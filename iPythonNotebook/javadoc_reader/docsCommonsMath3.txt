org.apache.commons.math4.Field: Interface representing a field.  Classes implementing this interface will often be singletons. 
org.apache.commons.math4.Field.getOne	(	): Get the multiplicative identity of the field.  The multiplicative identity is the element e1 of the field such that for all elements a of the field, the equalities a × e1 = e1 × a = a hold. 
org.apache.commons.math4.Field.getRuntimeClass	(	): Returns the runtime class of the FieldElement.
org.apache.commons.math4.Field.getZero	(	): Get the additive identity of the field.  The additive identity is the element e0 of the field such that for all elements a of the field, the equalities a + e0 = e0 + a = a hold. 
org.apache.commons.math4.FieldElement: Interface representing field elements.
org.apache.commons.math4.FieldElement.add	(	T	): Compute this + a.
org.apache.commons.math4.FieldElement.divide	(	T	): Compute this ÷ a.
org.apache.commons.math4.FieldElement.getField	(	): Get the Field to which the instance belongs.
org.apache.commons.math4.FieldElement.multiply	(	T	): Compute this × a.
org.apache.commons.math4.FieldElement.multiply	(	int	): Compute n × this. Multiplication by an integer number is defined as the following sum  n × this = ∑i=1n this. 
org.apache.commons.math4.FieldElement.negate	(	): Returns the additive inverse of this element.
org.apache.commons.math4.FieldElement.reciprocal	(	): Returns the multiplicative inverse of this element.
org.apache.commons.math4.FieldElement.subtract	(	T	): Compute this - a.
org.apache.commons.math4.PerfTestUtils: Simple benchmarking utilities.
org.apache.commons.math4.PerfTestUtils.RunTest: Utility class for storing a test label.
org.apache.commons.math4.PerfTestUtils.RunTest.RunTest	(	String	): 
org.apache.commons.math4.PerfTestUtils.RunTest.call	(	):  
org.apache.commons.math4.PerfTestUtils.RunTest.getName	(	): 
org.apache.commons.math4.PerfTestUtils.shorten	(	String	boolean	): Shortens a string. It will shorten package names and remove memory addresses that appear in an instance's name.
org.apache.commons.math4.PerfTestUtils.shortenPackageName	(	String	boolean	): Shortens package part of the name of a class.
org.apache.commons.math4.PerfTestUtils.time	(	int	int	boolean	Callable	): Timing.
org.apache.commons.math4.PerfTestUtils.timeAndReport	(	String	RunTest	): Timing and report (to standard output). This method calls timeAndReport() timeAndReport(title, 1000, 10000, false, methods).
org.apache.commons.math4.PerfTestUtils.timeAndReport	(	String	int	int	int	boolean	RunTest	): Timing and report (to standard output) the average time and standard deviation of a single call. The timing is performed by calling the time() method.
org.apache.commons.math4.PerfTestUtils.timesAndResults	(	int	int	boolean	Callable	): Timing.
org.apache.commons.math4.PerfTestUtils.truncate	(	String	int	String	): Truncates a string so that it will not be longer than the specified length.
org.apache.commons.math4.RealFieldElement: Interface representing a real field.
org.apache.commons.math4.RealFieldElement.abs	(	): absolute value.
org.apache.commons.math4.RealFieldElement.acos	(	): Arc cosine operation.
org.apache.commons.math4.RealFieldElement.acosh	(	): Inverse hyperbolic cosine operation.
org.apache.commons.math4.RealFieldElement.add	(	double	): '+' operator.
org.apache.commons.math4.RealFieldElement.asin	(	): Arc sine operation.
org.apache.commons.math4.RealFieldElement.asinh	(	): Inverse hyperbolic sine operation.
org.apache.commons.math4.RealFieldElement.atan	(	): Arc tangent operation.
org.apache.commons.math4.RealFieldElement.atan2	(	T	): Two arguments arc tangent operation.
org.apache.commons.math4.RealFieldElement.atanh	(	): Inverse hyperbolic tangent operation.
org.apache.commons.math4.RealFieldElement.cbrt	(	): Cubic root.
org.apache.commons.math4.RealFieldElement.ceil	(	): Get the smallest whole number larger than instance.
org.apache.commons.math4.RealFieldElement.copySign	(	T	): Returns the instance with the sign of the argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.RealFieldElement.copySign	(	double	): Returns the instance with the sign of the argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.RealFieldElement.cos	(	): Cosine operation.
org.apache.commons.math4.RealFieldElement.cosh	(	): Hyperbolic cosine operation.
org.apache.commons.math4.RealFieldElement.divide	(	double	): '÷' operator.
org.apache.commons.math4.RealFieldElement.exp	(	): Exponential.
org.apache.commons.math4.RealFieldElement.expm1	(	): Exponential minus 1.
org.apache.commons.math4.RealFieldElement.floor	(	): Get the largest whole number smaller than instance.
org.apache.commons.math4.RealFieldElement.getReal	(	): Get the real value of the number.
org.apache.commons.math4.RealFieldElement.hypot	(	T	): Returns the hypotenuse of a triangle with sides this and y - sqrt(this2 +y2) avoiding intermediate overflow or underflow.   If either argument is infinite, then the result is positive infinity.  else, if either argument is NaN then the result is NaN. 
org.apache.commons.math4.RealFieldElement.linearCombination	(	T	T	T	T	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	T	T	T	T	T	T	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	T	T	T	T	T	T	T	T	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	T[]	T[]	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	double	T	double	T	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	double	T	double	T	double	T	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	double	T	double	T	double	T	double	T	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.linearCombination	(	double[]	T[]	): Compute a linear combination.
org.apache.commons.math4.RealFieldElement.log	(	): Natural logarithm.
org.apache.commons.math4.RealFieldElement.log10	(	): Base 10 logarithm.
org.apache.commons.math4.RealFieldElement.log1p	(	): Shifted natural logarithm.
org.apache.commons.math4.RealFieldElement.multiply	(	double	): '×' operator.
org.apache.commons.math4.RealFieldElement.pow	(	T	): Power operation.
org.apache.commons.math4.RealFieldElement.pow	(	double	): Power operation.
org.apache.commons.math4.RealFieldElement.pow	(	int	): Integer power operation.
org.apache.commons.math4.RealFieldElement.reciprocal	(	): Returns the multiplicative inverse of this element. 
org.apache.commons.math4.RealFieldElement.remainder	(	T	): IEEE remainder operator.
org.apache.commons.math4.RealFieldElement.remainder	(	double	): IEEE remainder operator.
org.apache.commons.math4.RealFieldElement.rint	(	): Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.
org.apache.commons.math4.RealFieldElement.rootN	(	int	): Nth root.
org.apache.commons.math4.RealFieldElement.round	(	): Get the closest long to instance value.
org.apache.commons.math4.RealFieldElement.scalb	(	int	): Multiply the instance by a power of 2.
org.apache.commons.math4.RealFieldElement.signum	(	): Compute the signum of the instance. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
org.apache.commons.math4.RealFieldElement.sin	(	): Sine operation.
org.apache.commons.math4.RealFieldElement.sinh	(	): Hyperbolic sine operation.
org.apache.commons.math4.RealFieldElement.sqrt	(	): Square root.
org.apache.commons.math4.RealFieldElement.subtract	(	double	): '-' operator.
org.apache.commons.math4.RealFieldElement.tan	(	): Tangent operation.
org.apache.commons.math4.RealFieldElement.tanh	(	): Hyperbolic tangent operation.
org.apache.commons.math4.RetryRunner: A test runner that retries tests when assertions fail.
org.apache.commons.math4.RetryRunner.RetryRunner	(	Class	): Simple constructor.
org.apache.commons.math4.RetryRunnerTest: Test for the "Retry" functionality (retrying Junit test methods).
org.apache.commons.math4.RetryRunnerTest.testRetryFailAlways	(	): Shows that an always failing test will fail even if it is retried.
org.apache.commons.math4.RetryRunnerTest.testRetryFailSometimes	(	): Shows that a test that sometimes fail might succeed if it is retried. In this case the high number of retries makes it quite unlikely that the exception will be thrown by all of the calls.
org.apache.commons.math4.TestUtils.TestUtils	(	): Collection of static methods used in math unit tests.
org.apache.commons.math4.TestUtils.assertChiSquareAccept	(	String[]	double[]	long[]	double	): Asserts the null hypothesis for a ChiSquare test. Fails and dumps arguments and test statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%
org.apache.commons.math4.TestUtils.assertChiSquareAccept	(	double[]	long[]	double	): Asserts the null hypothesis for a ChiSquare test. Fails and dumps arguments and test statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%
org.apache.commons.math4.TestUtils.assertChiSquareAccept	(	int[]	double[]	long[]	double	): Asserts the null hypothesis for a ChiSquare test. Fails and dumps arguments and test statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%
org.apache.commons.math4.TestUtils.assertContains	(	Complex[]	Complex	double	): Fails iff values does not contain a number within epsilon of z.
org.apache.commons.math4.TestUtils.assertContains	(	String	Complex[]	Complex	double	): Fails iff values does not contain a number within epsilon of z.
org.apache.commons.math4.TestUtils.assertContains	(	String	double[]	double	double	): Fails iff values does not contain a number within epsilon of x.
org.apache.commons.math4.TestUtils.assertContains	(	double[]	double	double	): Fails iff values does not contain a number within epsilon of x.
org.apache.commons.math4.TestUtils.assertEquals	(	Complex	Complex	double	): Verifies that real and imaginary parts of the two complex arguments differ by at most delta. Also ensures that NaN / infinite components match.
org.apache.commons.math4.TestUtils.assertEquals	(	FieldMatrix	FieldMatrix	): verifies that two matrices are equal 
org.apache.commons.math4.TestUtils.assertEquals	(	String	Complex[]	Complex[]	double	): verifies that two arrays are close (sup norm) 
org.apache.commons.math4.TestUtils.assertEquals	(	String	RealMatrix	RealMatrix	double	): verifies that two matrices are close (1-norm) 
org.apache.commons.math4.TestUtils.assertEquals	(	String	RealVector	RealVector	double	): Asserts that all entries of the specified vectors are equal to within a positive delta.
org.apache.commons.math4.TestUtils.assertEquals	(	String	double	double	double	): Verifies that expected and actual are within delta, or are both NaN or infinities of the same sign.
org.apache.commons.math4.TestUtils.assertEquals	(	String	double[]	RealVector	double	): Asserts that all entries of the specified vectors are equal to within a positive delta.
org.apache.commons.math4.TestUtils.assertEquals	(	String	double[]	double[]	double	): verifies that two arrays are close (sup norm) 
org.apache.commons.math4.TestUtils.assertEquals	(	String	float[]	float[]	float	): verifies that two arrays are close (sup norm) 
org.apache.commons.math4.TestUtils.assertEquals	(	T[]	T[]	): verifies that two arrays are equal 
org.apache.commons.math4.TestUtils.assertEquals	(	double	double	double	): Verifies that two double arrays have equal entries, up to tolerance
org.apache.commons.math4.TestUtils.assertRelativelyEquals	(	String	double	double	double	): Verifies that the relative error in actual vs. expected is less than or equal to relativeError. If expected is infinite or NaN, actual must be the same (NaN or infinity of the same sign).
org.apache.commons.math4.TestUtils.assertRelativelyEquals	(	double	double	double	): Verifies that the relative error in actual vs. expected is less than or equal to relativeError. If expected is infinite or NaN, actual must be the same (NaN or infinity of the same sign).
org.apache.commons.math4.TestUtils.assertSame	(	Complex	Complex	): Verifies that real and imaginary parts of the two complex arguments are exactly the same. Also ensures that NaN / infinite components match.
org.apache.commons.math4.TestUtils.assertSame	(	double	double	): Verifies that the two arguments are exactly the same, either both NaN or infinities of same sign, or identical floating point values.
org.apache.commons.math4.TestUtils.checkSerializedEquality	(	Object	): Verifies that serialization preserves equals and hashCode. Serializes the object, then recovers it and checks equals and hash code.
org.apache.commons.math4.TestUtils.eliminateZeroMassPoints	(	int[]	double[]	): Eliminates points with zero mass from densityPoints and densityValues parallel arrays. Returns the number of positive mass points and collapses the arrays so that the first  elements of the input arrays represent the positive mass points.
org.apache.commons.math4.TestUtils.getDistributionQuartiles	(	RealDistribution	): Computes the 25th, 50th and 75th percentiles of the given distribution and returns these values in an array.
org.apache.commons.math4.TestUtils.serializeAndRecover	(	Object	): Serializes an object to a bytes array and then recovers the object from the bytes array. Returns the deserialized object.
org.apache.commons.math4.TestUtils.sumSquareDev	(	double[]	double	): Computes the sum of squared deviations of  from 
org.apache.commons.math4.TestUtils.updateCounts	(	double	long[]	double[]	): Updates observed counts of values in quartiles. counts[0] <-> 1st quartile ... counts[3] <-> top quartile
org.apache.commons.math4.analysis.BivariateFunction: An interface representing a bivariate real function.
org.apache.commons.math4.analysis.BivariateFunction.value	(	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.FunctionUtils: Utilities for manipulating function objects.
org.apache.commons.math4.analysis.FunctionUtils.FunctionUtils	(	): Class only contains static methods.
org.apache.commons.math4.analysis.FunctionUtils.add	(	UnivariateDifferentiableFunction	): Adds functions.
org.apache.commons.math4.analysis.FunctionUtils.add	(	UnivariateFunction	): Adds functions.
org.apache.commons.math4.analysis.FunctionUtils.collector	(	BivariateFunction	UnivariateFunction	double	): Returns a MultivariateFunction h(x[]) defined by   h(x[]) = combiner(...combiner(combiner(initialValue,f(x[0])),f(x[1]))...),f(x[x.length-1])) 
org.apache.commons.math4.analysis.FunctionUtils.collector	(	BivariateFunction	double	): Returns a MultivariateFunction h(x[]) defined by   h(x[]) = combiner(...combiner(combiner(initialValue,x[0]),x[1])...),x[x.length-1]) 
org.apache.commons.math4.analysis.FunctionUtils.combine	(	BivariateFunction	UnivariateFunction	UnivariateFunction	): Returns the univariate function h(x) = combiner(f(x), g(x)).
org.apache.commons.math4.analysis.FunctionUtils.compose	(	UnivariateDifferentiableFunction	): Composes functions.  The functions in the argument list are composed sequentially, in the given order. For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).
org.apache.commons.math4.analysis.FunctionUtils.compose	(	UnivariateFunction	): Composes functions.  The functions in the argument list are composed sequentially, in the given order. For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).
org.apache.commons.math4.analysis.FunctionUtils.derivative	(	MultivariateDifferentiableFunction	int[]	): Convert an MultivariateDifferentiableFunction to an MultivariateFunction computing nth order derivative.  This converter is only a convenience method. Beware computing only one derivative does not save any computation as the original function will really be called under the hood. The derivative will be extracted from the full DerivativeStructure result. 
org.apache.commons.math4.analysis.FunctionUtils.derivative	(	UnivariateDifferentiableFunction	int	): Convert an UnivariateDifferentiableFunction to an UnivariateFunction computing nth order derivative.  This converter is only a convenience method. Beware computing only one derivative does not save any computation as the original function will really be called under the hood. The derivative will be extracted from the full DerivativeStructure result. 
org.apache.commons.math4.analysis.FunctionUtils.fix1stArgument	(	BivariateFunction	double	): Creates a unary function by fixing the first argument of a binary function.
org.apache.commons.math4.analysis.FunctionUtils.fix2ndArgument	(	BivariateFunction	double	): Creates a unary function by fixing the second argument of a binary function.
org.apache.commons.math4.analysis.FunctionUtils.multiply	(	UnivariateDifferentiableFunction	): Multiplies functions.
org.apache.commons.math4.analysis.FunctionUtils.multiply	(	UnivariateFunction	): Multiplies functions.
org.apache.commons.math4.analysis.FunctionUtils.sample	(	UnivariateFunction	double	double	int	): Samples the specified univariate real function on the specified interval.  The interval is divided equally into n sections and sample points are taken from min to max - (max - min) / n; therefore f is not sampled at the upper bound max.
org.apache.commons.math4.analysis.FunctionUtils.toDifferentiable	(	MultivariateFunction	MultivariateVectorFunction	): Convert regular functions to MultivariateDifferentiableFunction.  This method handle the case with several free parameters and only first order derivatives. For the case with one free parameter and several derivatives, see toDifferentiable(). There are no direct support for intermediate cases, with several free parameters and order 2 or more derivatives, as is would be difficult to specify all the cross derivatives.   Note that the gradient is expected to be computed only with respect to the raw parameter x of the base function, i.e. it is df/dx1, df/dx2, ... Even if the built function is later used in a composition like f(sin(t), cos(t)), the provided gradient should not apply the composition with sine or cosine and their derivative by itself. The composition will be done automatically here and the result will properly contain f(sin(t), cos(t)), df(sin(t), cos(t))/dt despite the provided derivatives functions know nothing about the sine or cosine functions. 
org.apache.commons.math4.analysis.FunctionUtils.toDifferentiable	(	UnivariateFunction	UnivariateFunction	): Convert regular functions to UnivariateDifferentiableFunction.  This method handle the case with one free parameter and several derivatives. For the case with several free parameters and only first order derivatives, see toDifferentiable(). There are no direct support for intermediate cases, with several free parameters and order 2 or more derivatives, as is would be difficult to specify all the cross derivatives.   Note that the derivatives are expected to be computed only with respect to the raw parameter x of the base function, i.e. they are df/dx, df2/dx2, ... Even if the built function is later used in a composition like f(sin(t)), the provided derivatives should not apply the composition with sine and its derivatives by themselves. The composition will be done automatically here and the result will properly contain f(sin(t)), df(sin(t))/dt, df2(sin(t))/dt2 despite the provided derivatives functions know nothing about the sine function. 
org.apache.commons.math4.analysis.FunctionUtilsTest: Test for FunctionUtils.
org.apache.commons.math4.analysis.MonitoredFunction: Wrapper class for counting functions calls.
org.apache.commons.math4.analysis.MultivariateFunction: An interface representing a multivariate real function.
org.apache.commons.math4.analysis.MultivariateFunction.value	(	double[]	): Compute the value for the function at the given point.
org.apache.commons.math4.analysis.MultivariateMatrixFunction: An interface representing a multivariate matrix function.
org.apache.commons.math4.analysis.MultivariateMatrixFunction.value	(	double[]	): Compute the value for the function at the given point.
org.apache.commons.math4.analysis.MultivariateVectorFunction: An interface representing a multivariate vectorial function.
org.apache.commons.math4.analysis.MultivariateVectorFunction.value	(	double[]	): Compute the value for the function at the given point.
org.apache.commons.math4.analysis.ParametricUnivariateFunction: An interface representing a real function that depends on one independent variable plus some extra parameters.
org.apache.commons.math4.analysis.ParametricUnivariateFunction.gradient	(	double	double	): Compute the gradient of the function with respect to its parameters.
org.apache.commons.math4.analysis.ParametricUnivariateFunction.value	(	double	double	): Compute the value of the function.
org.apache.commons.math4.analysis.QuinticFunction: Auxiliary class for testing solvers.
org.apache.commons.math4.analysis.RealFieldUnivariateFunction: An interface representing a univariate real function.  When a user-defined function encounters an error during evaluation, the value() method should throw a user-defined unchecked exception.  The following code excerpt shows the recommended way to do that using a root solver as an example, but the same construct is applicable to ODE integrators or optimizers.  private static class LocalException extends RuntimeException { // The x value that caused the problem. private final SomeFieldType x; public LocalException(SomeFieldType x) { this.x = x; } public double getX() { return x; } } private static class MyFunction implements FieldUnivariateFunction<SomeFieldType> { public SomeFieldType value(SomeFieldType x) { SomeFieldType y = hugeFormula(x); if (somethingBadHappens) { throw new LocalException(x); } return y; } } public void compute() { try { solver.solve(maxEval, new MyFunction(a, b, c), min, max); } catch (LocalException le) { // Retrieve the x value. } }   As shown, the exception is local to the user's code and it is guaranteed that Apache Commons Math will not catch it.
org.apache.commons.math4.analysis.RealFieldUnivariateFunction.value	(	T	): Compute the value of the function.
org.apache.commons.math4.analysis.SumSincFunction: Auxiliary class for testing optimizers.
org.apache.commons.math4.analysis.SumSincFunction.SumSincFunction	(	double	): 
org.apache.commons.math4.analysis.SumSincFunction.value	(	double[]	): Compute the value for the function at the given point.
org.apache.commons.math4.analysis.TrivariateFunction: An interface representing a trivariate real function.
org.apache.commons.math4.analysis.TrivariateFunction.value	(	double	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.UnivariateFunction: An interface representing a univariate real function.  When a user-defined function encounters an error during evaluation, the value() method should throw a user-defined unchecked exception.  The following code excerpt shows the recommended way to do that using a root solver as an example, but the same construct is applicable to ODE integrators or optimizers.  private static class LocalException extends RuntimeException { // The x value that caused the problem. private final double x; public LocalException(double x) { this.x = x; } public double getX() { return x; } } private static class MyFunction implements UnivariateFunction { public double value(double x) { double y = hugeFormula(x); if (somethingBadHappens) { throw new LocalException(x); } return y; } } public void compute() { try { solver.solve(maxEval, new MyFunction(a, b, c), min, max); } catch (LocalException le) { // Retrieve the x value. } }  As shown, the exception is local to the user's code and it is guaranteed that Apache Commons Math will not catch it.
org.apache.commons.math4.analysis.UnivariateFunction.value	(	double	): Compute the value of the function.
org.apache.commons.math4.analysis.UnivariateMatrixFunction: An interface representing a univariate matrix function.
org.apache.commons.math4.analysis.UnivariateMatrixFunction.value	(	double	): Compute the value for the function.
org.apache.commons.math4.analysis.UnivariateVectorFunction: An interface representing a univariate vectorial function.
org.apache.commons.math4.analysis.UnivariateVectorFunction.value	(	double	): Compute the value for the function.
org.apache.commons.math4.analysis.XMinus5Function: Auxiliary class for testing solvers.
org.apache.commons.math4.analysis.differentiation.DSCompiler: Class holding "compiled" computation rules for derivative structures. This class implements the computation rules described in Dan Kalman's paper Doubly Recursive Multivariate Automatic Differentiation, Mathematics Magazine, vol. 75, no. 3, June 2002. However, in order to avoid performances bottlenecks, the recursive rules are "compiled" once in an unfold form. This class does this recursion unrolling and stores the computation rules as simple loops with pre-computed indirection arrays.  This class maps all derivative computation into single dimension arrays that hold the value and partial derivatives. The class does not hold these arrays, which remains under the responsibility of the caller. For each combination of number of free parameters and derivation order, only one compiler is necessary, and this compiler will be used to perform computations on all arrays provided to it, which can represent hundreds or thousands of different parameters kept together with all their partial derivatives.   The arrays on which compilers operate contain only the partial derivatives together with the 0th derivative, i.e. the value. The partial derivatives are stored in a compiler-specific order, which can be retrieved using methods getPartialDerivativeIndex() and getPartialDerivativeOrders(). The value is guaranteed to be stored as the first element (i.e. the getPartialDerivativeIndex() method returns 0 when called with 0 for all derivation orders and getPartialDerivativeOrders() returns an array filled with 0 when called with 0 as the index).   Note that the ordering changes with number of parameters and derivation order. For example given 2 parameters x and y, df/dy is stored at index 2 when derivation order is set to 1 (in this case the array has three elements: f, df/dx and df/dy). If derivation order is set to 2, then df/dy will be stored at index 3 (in this case the array has six elements: f, df/dx, df/dxdx, df/dy, df/dxdy and df/dydy).   Given this structure, users can perform some simple operations like adding, subtracting or multiplying constants and negating the elements by themselves, knowing if they want to mutate their array or create a new array. These simple operations are not provided by the compiler. The compiler provides only the more complex operations between several arrays.  This class is mainly used as the engine for scalar variable DerivativeStructure. It can also be used directly to hold several variables in arrays for more complex data structures. User can for example store a vector of n variables depending on three x, y and z free parameters in one array as follows:  // parameter 0 is x, parameter 1 is y, parameter 2 is z int parameters = 3; DSCompiler compiler = DSCompiler.getCompiler(parameters, order); int size = compiler.getSize(); // pack all elements in a single array double[] array = new double[n * size]; for (int i = 0; i < n; ++i) { // we know value is guaranteed to be the first element array[i * size] = v[i]; // we don't know where first derivatives are stored, so we ask the compiler array[i * size + compiler.getPartialDerivativeIndex(1, 0, 0) = dvOnDx[i][0]; array[i * size + compiler.getPartialDerivativeIndex(0, 1, 0) = dvOnDy[i][0]; array[i * size + compiler.getPartialDerivativeIndex(0, 0, 1) = dvOnDz[i][0]; // we let all higher order derivatives set to 0 }  Then in another function, user can perform some operations on all elements stored in the single array, such as a simple product of all variables:  // compute the product of all elements double[] product = new double[size]; prod[0] = 1.0; for (int i = 0; i < n; ++i) { double[] tmp = product.clone(); compiler.multiply(tmp, 0, array, i * size, product, 0); } // value double p = product[0]; // first derivatives double dPdX = product[compiler.getPartialDerivativeIndex(1, 0, 0)]; double dPdY = product[compiler.getPartialDerivativeIndex(0, 1, 0)]; double dPdZ = product[compiler.getPartialDerivativeIndex(0, 0, 1)]; // cross derivatives (assuming order was at least 2) double dPdXdX = product[compiler.getPartialDerivativeIndex(2, 0, 0)]; double dPdXdY = product[compiler.getPartialDerivativeIndex(1, 1, 0)]; double dPdXdZ = product[compiler.getPartialDerivativeIndex(1, 0, 1)]; double dPdYdY = product[compiler.getPartialDerivativeIndex(0, 2, 0)]; double dPdYdZ = product[compiler.getPartialDerivativeIndex(0, 1, 1)]; double dPdZdZ = product[compiler.getPartialDerivativeIndex(0, 0, 2)]; 
org.apache.commons.math4.analysis.differentiation.DSCompiler.DSCompiler	(	int	int	DSCompiler	DSCompiler	): Private constructor, reserved for the factory method getCompiler().
org.apache.commons.math4.analysis.differentiation.DSCompiler.acos	(	double[]	int	double[]	int	): Compute arc cosine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.acosh	(	double[]	int	double[]	int	): Compute inverse hyperbolic cosine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.add	(	double[]	int	double[]	int	double[]	int	): Perform addition of two derivative structures.
org.apache.commons.math4.analysis.differentiation.DSCompiler.asin	(	double[]	int	double[]	int	): Compute arc sine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.asinh	(	double[]	int	double[]	int	): Compute inverse hyperbolic sine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.atan	(	double[]	int	double[]	int	): Compute arc tangent of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.atan2	(	double[]	int	double[]	int	double[]	int	): Compute two arguments arc tangent of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.atanh	(	double[]	int	double[]	int	): Compute inverse hyperbolic tangent of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.checkCompatibility	(	DSCompiler	): Check rules set compatibility.
org.apache.commons.math4.analysis.differentiation.DSCompiler.compileCompositionIndirection	(	int	int	DSCompiler	DSCompiler	int[][]	int[][]	): Compile the function composition indirection array.  This indirection array contains the indices of all sets of elements involved when computing a composition. This allows a straightforward loop-based composition (see compose()). 
org.apache.commons.math4.analysis.differentiation.DSCompiler.compileDerivativesIndirection	(	int	int	DSCompiler	DSCompiler	): Compile the derivatives indirection array.
org.apache.commons.math4.analysis.differentiation.DSCompiler.compileLowerIndirection	(	int	int	DSCompiler	DSCompiler	): Compile the lower derivatives indirection array.  This indirection array contains the indices of all elements except derivatives for last derivation order. 
org.apache.commons.math4.analysis.differentiation.DSCompiler.compileMultiplicationIndirection	(	int	int	DSCompiler	DSCompiler	int[]	): Compile the multiplication indirection array.  This indirection array contains the indices of all pairs of elements involved when computing a multiplication. This allows a straightforward loop-based multiplication (see multiply()). 
org.apache.commons.math4.analysis.differentiation.DSCompiler.compileSizes	(	int	int	DSCompiler	): Compile the sizes array.
org.apache.commons.math4.analysis.differentiation.DSCompiler.compose	(	double[]	int	double[]	double[]	int	): Compute composition of a derivative structure by a function.
org.apache.commons.math4.analysis.differentiation.DSCompiler.convertIndex	(	int	int	int[][]	int	int	int[][]	): Convert an index from one (parameters, order) structure to another.
org.apache.commons.math4.analysis.differentiation.DSCompiler.cos	(	double[]	int	double[]	int	): Compute cosine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.cosh	(	double[]	int	double[]	int	): Compute hyperbolic cosine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.divide	(	double[]	int	double[]	int	double[]	int	): Perform division of two derivative structures.
org.apache.commons.math4.analysis.differentiation.DSCompiler.exp	(	double[]	int	double[]	int	): Compute exponential of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.expm1	(	double[]	int	double[]	int	): Compute exp(x) - 1 of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.getCompiler	(	int	int	): Get the compiler for number of free parameters and order.
org.apache.commons.math4.analysis.differentiation.DSCompiler.getFreeParameters	(	): Get the number of free parameters.
org.apache.commons.math4.analysis.differentiation.DSCompiler.getOrder	(	): Get the derivation order.
org.apache.commons.math4.analysis.differentiation.DSCompiler.getPartialDerivativeIndex	(	int	): Get the index of a partial derivative in the array.  If all orders are set to 0, then the 0th order derivative is returned, which is the value of the function.  The indices of derivatives are between 0 and getSize() getSize() - 1. Their specific order is fixed for a given compiler, but otherwise not publicly specified. There are however some simple cases which have guaranteed indices:   the index of 0th order derivative is always 0 if there is only 1 getFreeParameters() free parameter, then the derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp at index 1, d2f/dp2 at index 2 ... dkf/dpk at index k), if the getOrder() derivation order is 1, then the derivatives are sorted in increasing free parameter order (i.e. f at index 0, df/dx1 at index 1, df/dx2 at index 2 ... df/dxk at index k), all other cases are not publicly specified   This method is the inverse of method getPartialDerivativeOrders() 
org.apache.commons.math4.analysis.differentiation.DSCompiler.getPartialDerivativeIndex	(	int	int	int[][]	int	): Get the index of a partial derivative in an array.
org.apache.commons.math4.analysis.differentiation.DSCompiler.getPartialDerivativeOrders	(	int	): Get the derivation orders for a specific index in the array.  This method is the inverse of getPartialDerivativeIndex(). 
org.apache.commons.math4.analysis.differentiation.DSCompiler.getSize	(	): Get the array size required for holding partial derivatives data.  This number includes the single 0 order derivative element, which is guaranteed to be stored in the first element of the array. 
org.apache.commons.math4.analysis.differentiation.DSCompiler.linearCombination	(	double	double[]	int	double	double[]	int	double	double[]	int	double	double[]	int	double[]	int	): Compute linear combination. The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4
org.apache.commons.math4.analysis.differentiation.DSCompiler.linearCombination	(	double	double[]	int	double	double[]	int	double	double[]	int	double[]	int	): Compute linear combination. The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4
org.apache.commons.math4.analysis.differentiation.DSCompiler.linearCombination	(	double	double[]	int	double	double[]	int	double[]	int	): Compute linear combination. The derivative structure built will be a1 * ds1 + a2 * ds2
org.apache.commons.math4.analysis.differentiation.DSCompiler.log	(	double[]	int	double[]	int	): Compute natural logarithm of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.log10	(	double[]	int	double[]	int	): Computes base 10 logarithm of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.log1p	(	double[]	int	double[]	int	): Computes shifted logarithm of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.multiply	(	double[]	int	double[]	int	double[]	int	): Perform multiplication of two derivative structures.
org.apache.commons.math4.analysis.differentiation.DSCompiler.pow	(	double	double[]	int	double[]	int	): Compute power of a double to a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.pow	(	double[]	int	double	double[]	int	): Compute power of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.pow	(	double[]	int	double[]	int	double[]	int	): Compute power of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.pow	(	double[]	int	int	double[]	int	): Compute integer power of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.remainder	(	double[]	int	double[]	int	double[]	int	): Perform remainder of two derivative structures.
org.apache.commons.math4.analysis.differentiation.DSCompiler.rootN	(	double[]	int	int	double[]	int	): Compute nth root of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.sin	(	double[]	int	double[]	int	): Compute sine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.sinh	(	double[]	int	double[]	int	): Compute hyperbolic sine of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.subtract	(	double[]	int	double[]	int	double[]	int	): Perform subtraction of two derivative structures.
org.apache.commons.math4.analysis.differentiation.DSCompiler.tan	(	double[]	int	double[]	int	): Compute tangent of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.tanh	(	double[]	int	double[]	int	): Compute hyperbolic tangent of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompiler.taylor	(	double[]	int	double	): Evaluate Taylor expansion of a derivative structure.
org.apache.commons.math4.analysis.differentiation.DSCompilerTest: Test for class DSCompiler.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure: Class representing both the value and the differentials of a function. This class is the workhorse of the differentiation package. This class is an implementation of the extension to Rall's numbers described in Dan Kalman's paper Doubly Recursive Multivariate Automatic Differentiation, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers are an extension to the real numbers used throughout mathematical expressions; they hold the derivative together with the value of a function. Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and real numbers can be seen as derivative structures with zero order derivative and no free parameters. DerivativeStructure instances can be used directly thanks to the arithmetic operators to the mathematical functions provided as methods by this class (+, -, *, /, %, sin, cos ...). Implementing complex expressions by hand using these classes is a tedious and error-prone task but has the advantage of having no limitation on the derivation order despite not requiring users to compute the derivatives by themselves. Implementing complex expression can also be done by developing computation code using standard primitive double values and to use UnivariateFunctionDifferentiator differentiators to create the DerivativeStructure-based instances. This method is simpler but may be limited in the accuracy and derivation orders and may be computationally intensive (this is typically the case for FiniteDifferencesDifferentiator finite differences differentiator. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DataTransferObject: Internal class used only for serialization. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DataTransferObject.DataTransferObject	(	int	int	double[]	): Simple constructor.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DataTransferObject.readResolve	(	): Replace the deserialized data transfer object with a DerivativeStructure.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	DSCompiler	): Build an instance with all values and derivatives set to 0.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	DerivativeStructure	): Copy constructor.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	double	DerivativeStructure	double	DerivativeStructure	): Linear combination constructor. The derivative structure built will be a1 * ds1 + a2 * ds2
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	double	DerivativeStructure	double	DerivativeStructure	double	DerivativeStructure	): Linear combination constructor. The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	double	DerivativeStructure	double	DerivativeStructure	double	DerivativeStructure	double	DerivativeStructure	): Linear combination constructor. The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	int	int	): Build an instance with all values and derivatives set to 0.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	int	int	double	): Build an instance from all its derivatives.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.DerivativeStructure	(	int	int	int	double	): Build an instance representing a variable. Instances built using this constructor are considered to be the free variables with respect to which differentials are computed. As such, their differential with respect to themselves is +1.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.abs	(	): absolute value.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.acos	(	): Arc cosine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.acosh	(	): Inverse hyperbolic cosine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.add	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.add	(	double	): '+' operator.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.asin	(	): Arc sine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.asinh	(	): Inverse hyperbolic sine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.atan	(	): Arc tangent operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.atan2	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.atan2	(	DerivativeStructure	DerivativeStructure	): Two arguments arc tangent operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.atanh	(	): Inverse hyperbolic tangent operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.cbrt	(	): Cubic root.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.ceil	(	): Get the smallest whole number larger than instance.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.compose	(	double	): Compute composition of the instance by a univariate function.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.copySign	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.copySign	(	double	): Returns the instance with the sign of the argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.cos	(	): Cosine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.cosh	(	): Hyperbolic cosine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.createConstant	(	double	): Create a constant compatible with instance order and number of parameters.  This method is a convenience factory method, it simply calls new DerivativeStructure(getFreeParameters(), getOrder(), c) 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.divide	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.divide	(	double	): '÷' operator.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.equals	(	Object	): Test for the equality of two derivative structures.  Derivative structures are considered equal if they have the same number of free parameters, the same derivation order, and the same derivatives. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.exp	(	): Exponential.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.expm1	(	): Exponential minus 1.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.floor	(	): Get the largest whole number smaller than instance.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getAllDerivatives	(	): Get all partial derivatives.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getExponent	(	): Return the exponent of the instance value, removing the bias.  For double numbers of the form 2x, the unbiased exponent is exactly x. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getFreeParameters	(	): Get the number of free parameters.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getOrder	(	): Get the derivation order.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getPartialDerivative	(	int	): Get a partial derivative.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getReal	(	): Get the real value of the number.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.getValue	(	): Get the value part of the derivative structure.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.hashCode	(	): Get a hashCode for the derivative structure.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.hypot	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.hypot	(	DerivativeStructure	DerivativeStructure	): Returns the hypotenuse of a triangle with sides x and y - sqrt(x2 +y2) avoiding intermediate overflow or underflow.   If either argument is infinite, then the result is positive infinity.  else, if either argument is NaN then the result is NaN. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	DerivativeStructure[]	DerivativeStructure[]	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	double	DerivativeStructure	double	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	double	DerivativeStructure	double	DerivativeStructure	double	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	double	DerivativeStructure	double	DerivativeStructure	double	DerivativeStructure	double	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.linearCombination	(	double[]	DerivativeStructure[]	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.log	(	): Natural logarithm.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.log10	(	): Base 10 logarithm.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.log1p	(	): Shifted natural logarithm.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.multiply	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.multiply	(	double	): '×' operator.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.multiply	(	int	): Compute n × this. Multiplication by an integer number is defined as the following sum  n × this = ∑i=1n this.  
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.negate	(	): Returns the additive inverse of this element. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.pow	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.pow	(	double	): Power operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.pow	(	double	DerivativeStructure	): Compute ax where a is a double and x a DerivativeStructure
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.pow	(	int	): Integer power operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.reciprocal	(	): Returns the multiplicative inverse of this element.  
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.remainder	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.remainder	(	double	): IEEE remainder operator. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.rint	(	): Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.rootN	(	int	): Nth root.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.round	(	): Get the closest long to instance value. 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.scalb	(	int	): Multiply the instance by a power of 2.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.signum	(	): Compute the signum of the instance. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.sin	(	): Sine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.sinh	(	): Hyperbolic sine operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.sqrt	(	): Square root.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.subtract	(	DerivativeStructure	): 
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.subtract	(	double	): '-' operator.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.tan	(	): Tangent operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.tanh	(	): Hyperbolic tangent operation.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.taylor	(	double	): Evaluate Taylor expansion a derivative structure.
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.toDegrees	(	): Convert radians to degrees, with error of less than 0.5 ULP
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.toRadians	(	): Convert degrees to radians, with error of less than 0.5 ULP
org.apache.commons.math4.analysis.differentiation.DerivativeStructure.writeReplace	(	): Replace the instance with a data transfer object for serialization.
org.apache.commons.math4.analysis.differentiation.DerivativeStructureTest: Test for class DerivativeStructure.
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator: Univariate functions differentiator using finite differences.  This class creates some wrapper objects around regular UnivariateFunction univariate functions (or UnivariateVectorFunction univariate vector functions or UnivariateMatrixFunction univariate matrix functions). These wrapper objects compute derivatives in addition to function values.   The wrapper objects work by calling the underlying function on a sampling grid around the current point and performing polynomial interpolation. A finite differences scheme with n points is theoretically able to compute derivatives up to order n-1, but it is generally better to have a slight margin. The step size must also be small enough in order for the polynomial approximation to be good in the current point neighborhood, but it should not be too small because numerical instability appears quickly (there are several differences of close points). Choosing the number of points and the step size is highly problem dependent.   As an example of good and bad settings, lets consider the quintic polynomial function f(x) = (x-1)*(x-0.5)*x*(x+0.5)*(x+1). Since it is a polynomial, finite differences with at least 6 points should theoretically recover the exact same polynomial and hence compute accurate derivatives for any order. However, due to numerical errors, we get the following results for a 7 points finite differences for abscissae in the [-10, 10] range:  step size = 0.25, second order derivative error about 9.97e-10 step size = 0.25, fourth order derivative error about 5.43e-8 step size = 1.0e-6, second order derivative error about 148 step size = 1.0e-6, fourth order derivative error about 6.35e+14   This example shows that the small step size is really bad, even simply for second order derivative!
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.FiniteDifferencesDifferentiator	(	int	double	): Build a differentiator with number of points and step size when independent variable is unbounded.  Beware that wrong settings for the finite differences differentiator can lead to highly unstable and inaccurate results, especially for high derivation orders. Using very small step sizes is often a bad idea. 
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.FiniteDifferencesDifferentiator	(	int	double	double	double	): Build a differentiator with number of points and step size when independent variable is bounded.  When the independent variable is bounded (tLower < t < tUpper), the sampling points used for differentiation will be adapted to ensure the constraint holds even near the boundaries. This means the sample will not be centered anymore in these cases. At an extreme case, computing derivatives exactly at the lower bound will lead the sample to be entirely on the right side of the derivation point.   Note that the boundaries are considered to be excluded for function evaluation.   Beware that wrong settings for the finite differences differentiator can lead to highly unstable and inaccurate results, especially for high derivation orders. Using very small step sizes is often a bad idea. 
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.differentiate	(	UnivariateFunction	): Create an implementation of a UnivariateDifferentiableFunction differential from a regular UnivariateFunction function. The returned object cannot compute derivatives to arbitrary orders. The value function will throw a NumberIsTooLargeException if the requested derivation order is larger or equal to the number of points. 
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.differentiate	(	UnivariateMatrixFunction	): Create an implementation of a UnivariateDifferentiableMatrixFunction differential from a regular UnivariateMatrixFunction matrix function. The returned object cannot compute derivatives to arbitrary orders. The value function will throw a NumberIsTooLargeException if the requested derivation order is larger or equal to the number of points. 
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.differentiate	(	UnivariateVectorFunction	): Create an implementation of a UnivariateDifferentiableVectorFunction differential from a regular UnivariateVectorFunction vector function. The returned object cannot compute derivatives to arbitrary orders. The value function will throw a NumberIsTooLargeException if the requested derivation order is larger or equal to the number of points. 
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.evaluate	(	DerivativeStructure	double	double[]	): Evaluate derivatives from a sample.  Evaluation is done using divided differences. 
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.getNbPoints	(	): Get the number of points to use.
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiator.getStepSize	(	): Get the step size.
org.apache.commons.math4.analysis.differentiation.FiniteDifferencesDifferentiatorTest: Test for class FiniteDifferencesDifferentiator.
org.apache.commons.math4.analysis.differentiation.GradientFunction: Class representing the gradient of a multivariate function.  The vectorial components of the function represent the derivatives with respect to each function parameters. 
org.apache.commons.math4.analysis.differentiation.GradientFunction.GradientFunction	(	MultivariateDifferentiableFunction	): Simple constructor.
org.apache.commons.math4.analysis.differentiation.GradientFunction.value	(	double[]	): Compute the value for the function at the given point. 
org.apache.commons.math4.analysis.differentiation.GradientFunctionTest: Test for class GradientFunction.
org.apache.commons.math4.analysis.differentiation.JacobianFunction: Class representing the Jacobian of a multivariate vector function.  The rows iterate on the model functions while the columns iterate on the parameters; thus, the numbers of rows is equal to the dimension of the underlying function vector value and the number of columns is equal to the number of free parameters of the underlying function. 
org.apache.commons.math4.analysis.differentiation.JacobianFunction.JacobianFunction	(	MultivariateDifferentiableVectorFunction	): Simple constructor.
org.apache.commons.math4.analysis.differentiation.JacobianFunction.value	(	double[]	): Compute the value for the function at the given point. 
org.apache.commons.math4.analysis.differentiation.JacobianFunctionTest: Test for class JacobianFunction.
org.apache.commons.math4.analysis.differentiation.MultivariateDifferentiableFunction: Extension of MultivariateFunction representing a multivariate differentiable real function.
org.apache.commons.math4.analysis.differentiation.MultivariateDifferentiableFunction.value	(	DerivativeStructure[]	): Compute the value for the function at the given point.
org.apache.commons.math4.analysis.differentiation.MultivariateDifferentiableVectorFunction: Extension of MultivariateVectorFunction representing a multivariate differentiable vectorial function.
org.apache.commons.math4.analysis.differentiation.MultivariateDifferentiableVectorFunction.value	(	DerivativeStructure[]	): Compute the value for the function at the given point.
org.apache.commons.math4.analysis.differentiation.SparseGradient: First derivative computation with large number of variables.  This class plays a similar role to DerivativeStructure, with a focus on efficiency when dealing with large number of independent variables and most computation depend only on a few of them, and when only first derivative is desired. When these conditions are met, this class should be much faster than DerivativeStructure and use less memory. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.SparseGradient	(	double	Map	): Internal constructor.
org.apache.commons.math4.analysis.differentiation.SparseGradient.SparseGradient	(	double	double	Map	): Internal constructor.
org.apache.commons.math4.analysis.differentiation.SparseGradient.abs	(	): absolute value. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.acos	(	): Arc cosine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.acosh	(	): Inverse hyperbolic cosine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.add	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.add	(	double	): '+' operator. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.addInPlace	(	SparseGradient	): Add in place.  This method is designed to be faster when used multiple times in a loop.   The instance is changed here, in order to not change the instance the add() method should be used. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.asin	(	): Arc sine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.asinh	(	): Inverse hyperbolic sine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.atan	(	): Arc tangent operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.atan2	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.atan2	(	SparseGradient	SparseGradient	): Two arguments arc tangent operation.
org.apache.commons.math4.analysis.differentiation.SparseGradient.atanh	(	): Inverse hyperbolic tangent operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.cbrt	(	): Cubic root. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.ceil	(	): Get the smallest whole number larger than instance. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.compose	(	double	double	): Compute composition of the instance by a univariate function.
org.apache.commons.math4.analysis.differentiation.SparseGradient.copySign	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.copySign	(	double	): Returns the instance with the sign of the argument. A NaN sign argument is treated as positive. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.cos	(	): Cosine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.cosh	(	): Hyperbolic cosine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.createConstant	(	double	): Factory method creating a constant.
org.apache.commons.math4.analysis.differentiation.SparseGradient.createVariable	(	int	double	): Factory method creating an independent variable.
org.apache.commons.math4.analysis.differentiation.SparseGradient.divide	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.divide	(	double	): '÷' operator. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.equals	(	Object	): Test for the equality of two sparse gradients.  Sparse gradients are considered equal if they have the same value and the same derivatives. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.exp	(	): Exponential. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.expm1	(	): Exponential minus 1. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.floor	(	): Get the largest whole number smaller than instance. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.getDerivative	(	int	): Get the derivative with respect to a particular index variable.
org.apache.commons.math4.analysis.differentiation.SparseGradient.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.getReal	(	): Get the real value of the number. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.getValue	(	): Get the value of the function.
org.apache.commons.math4.analysis.differentiation.SparseGradient.hashCode	(	): Get a hashCode for the derivative structure.
org.apache.commons.math4.analysis.differentiation.SparseGradient.hypot	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.hypot	(	SparseGradient	SparseGradient	): Returns the hypotenuse of a triangle with sides x and y - sqrt(x2 +y2) avoiding intermediate overflow or underflow.   If either argument is infinite, then the result is positive infinity.  else, if either argument is NaN then the result is NaN. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	SparseGradient	SparseGradient	SparseGradient	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	SparseGradient	SparseGradient	SparseGradient	SparseGradient	SparseGradient	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	SparseGradient	SparseGradient	SparseGradient	SparseGradient	SparseGradient	SparseGradient	SparseGradient	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	SparseGradient[]	SparseGradient[]	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	double	SparseGradient	double	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	double	SparseGradient	double	SparseGradient	double	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	double	SparseGradient	double	SparseGradient	double	SparseGradient	double	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.linearCombination	(	double[]	SparseGradient[]	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.log	(	): Natural logarithm. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.log10	(	): Base 10 logarithm.
org.apache.commons.math4.analysis.differentiation.SparseGradient.log1p	(	): Shifted natural logarithm. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.multiply	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.multiply	(	double	): '×' operator. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.multiply	(	int	): Compute n × this. Multiplication by an integer number is defined as the following sum  n × this = ∑i=1n this.  
org.apache.commons.math4.analysis.differentiation.SparseGradient.multiplyInPlace	(	SparseGradient	): Multiply in place.  This method is designed to be faster when used multiple times in a loop.   The instance is changed here, in order to not change the instance the add() method should be used. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.negate	(	): Returns the additive inverse of this element. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.numVars	(	): Find the number of variables.
org.apache.commons.math4.analysis.differentiation.SparseGradient.pow	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.pow	(	double	): Power operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.pow	(	double	SparseGradient	): Compute ax where a is a double and x a SparseGradient
org.apache.commons.math4.analysis.differentiation.SparseGradient.pow	(	int	): Integer power operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.reciprocal	(	): Returns the multiplicative inverse of this element.  
org.apache.commons.math4.analysis.differentiation.SparseGradient.remainder	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.remainder	(	double	): IEEE remainder operator. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.rint	(	): Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.rootN	(	int	): Nth root. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.round	(	): Get the closest long to instance value. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.scalb	(	int	): Multiply the instance by a power of 2. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.signum	(	): Compute the signum of the instance. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise 
org.apache.commons.math4.analysis.differentiation.SparseGradient.sin	(	): Sine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.sinh	(	): Hyperbolic sine operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.sqrt	(	): Square root. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.subtract	(	SparseGradient	):  
org.apache.commons.math4.analysis.differentiation.SparseGradient.subtract	(	double	): '-' operator. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.tan	(	): Tangent operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.tanh	(	): Hyperbolic tangent operation. 
org.apache.commons.math4.analysis.differentiation.SparseGradient.taylor	(	double	): Evaluate Taylor expansion of a sparse gradient.
org.apache.commons.math4.analysis.differentiation.SparseGradient.toDegrees	(	): Convert radians to degrees, with error of less than 0.5 ULP
org.apache.commons.math4.analysis.differentiation.SparseGradient.toRadians	(	): Convert degrees to radians, with error of less than 0.5 ULP
org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction: Interface for univariate functions derivatives. This interface represents a simple function which computes both the value and the first derivative of a mathematical function. The derivative is computed with respect to the input variable.
org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableFunction.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableMatrixFunction: Extension of UnivariateMatrixFunction representing a univariate differentiable matrix function.
org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableMatrixFunction.value	(	DerivativeStructure	): Compute the value for the function.
org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableVectorFunction: Extension of UnivariateVectorFunction representing a univariate differentiable vectorial function.
org.apache.commons.math4.analysis.differentiation.UnivariateDifferentiableVectorFunction.value	(	DerivativeStructure	): Compute the value for the function.
org.apache.commons.math4.analysis.differentiation.UnivariateFunctionDifferentiator: Interface defining the function differentiation operation.
org.apache.commons.math4.analysis.differentiation.UnivariateFunctionDifferentiator.differentiate	(	UnivariateFunction	): Create an implementation of a UnivariateDifferentiableFunction differential from a regular UnivariateFunction function.
org.apache.commons.math4.analysis.differentiation.UnivariateMatrixFunctionDifferentiator: Interface defining the function differentiation operation.
org.apache.commons.math4.analysis.differentiation.UnivariateMatrixFunctionDifferentiator.differentiate	(	UnivariateMatrixFunction	): Create an implementation of a UnivariateDifferentiableMatrixFunction differential from a regular UnivariateMatrixFunction matrix function.
org.apache.commons.math4.analysis.differentiation.UnivariateVectorFunctionDifferentiator: Interface defining the function differentiation operation.
org.apache.commons.math4.analysis.differentiation.UnivariateVectorFunctionDifferentiator.differentiate	(	UnivariateVectorFunction	): Create an implementation of a UnivariateDifferentiableVectorFunction differential from a regular UnivariateVectorFunction vector function.
org.apache.commons.math4.analysis.function.Abs: Absolute value function.
org.apache.commons.math4.analysis.function.Abs.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Acos: Arc-cosine function.
org.apache.commons.math4.analysis.function.Acos.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Acos.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Acosh: Hyperbolic arc-cosine function.
org.apache.commons.math4.analysis.function.Acosh.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Acosh.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Add: Add the two operands.
org.apache.commons.math4.analysis.function.Add.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Asin: Arc-sine function.
org.apache.commons.math4.analysis.function.Asin.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Asin.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Asinh: Hyperbolic arc-sine function.
org.apache.commons.math4.analysis.function.Asinh.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Asinh.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Atan: Arc-tangent function.
org.apache.commons.math4.analysis.function.Atan.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Atan.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Atan2: Arc-tangent function.
org.apache.commons.math4.analysis.function.Atan2.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Atanh: Hyperbolic arc-tangent function.
org.apache.commons.math4.analysis.function.Atanh.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Atanh.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.BivariateFunctionTest: Test for all uncovered classes in org.apache.commons.math4.analysis.function that implement BivariateFunction explicitly.
org.apache.commons.math4.analysis.function.Cbrt: Cube root function.
org.apache.commons.math4.analysis.function.Cbrt.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Cbrt.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Ceil: ceil function.
org.apache.commons.math4.analysis.function.Ceil.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Constant: Constant function.
org.apache.commons.math4.analysis.function.Constant.Constant	(	double	): 
org.apache.commons.math4.analysis.function.Constant.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Constant.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Cos: Cosine function.
org.apache.commons.math4.analysis.function.Cos.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Cos.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Cosh: Hyperbolic cosine function.
org.apache.commons.math4.analysis.function.Cosh.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Cosh.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Divide: Divide the first operand by the second.
org.apache.commons.math4.analysis.function.Divide.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Exp: Exponential function.
org.apache.commons.math4.analysis.function.Exp.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Exp.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Expm1: ex-1 function.
org.apache.commons.math4.analysis.function.Expm1.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Expm1.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Floor: floor function.
org.apache.commons.math4.analysis.function.Floor.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Gaussian:  Gaussian function.
org.apache.commons.math4.analysis.function.Gaussian.Gaussian	(	): Normalized gaussian with zero mean and unit standard deviation.
org.apache.commons.math4.analysis.function.Gaussian.Gaussian	(	double	double	): Normalized gaussian with given mean and standard deviation.
org.apache.commons.math4.analysis.function.Gaussian.Gaussian	(	double	double	double	): Gaussian with given normalization factor, mean and standard deviation.
org.apache.commons.math4.analysis.function.Gaussian.Parametric: Parametric function where the input array contains the parameters of the Gaussian, ordered as follows:  Norm Mean Standard deviation 
org.apache.commons.math4.analysis.function.Gaussian.Parametric.gradient	(	double	double	): Computes the value of the gradient at x. The components of the gradient vector are the partial derivatives of the function with respect to each of the parameters (norm, mean and standard deviation).
org.apache.commons.math4.analysis.function.Gaussian.Parametric.validateParameters	(	double[]	): Validates parameters to ensure they are appropriate for the evaluation of the value() and gradient() methods.
org.apache.commons.math4.analysis.function.Gaussian.Parametric.value	(	double	double	): Computes the value of the Gaussian at x.
org.apache.commons.math4.analysis.function.Gaussian.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Gaussian.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Gaussian.value	(	double	double	double	): 
org.apache.commons.math4.analysis.function.GaussianTest: Test for class Gaussian.
org.apache.commons.math4.analysis.function.HarmonicOscillator:  simple harmonic oscillator function.
org.apache.commons.math4.analysis.function.HarmonicOscillator.HarmonicOscillator	(	double	double	double	): Harmonic oscillator function.
org.apache.commons.math4.analysis.function.HarmonicOscillator.Parametric: Parametric function where the input array contains the parameters of the harmonic oscillator function, ordered as follows:  Amplitude Angular frequency Phase 
org.apache.commons.math4.analysis.function.HarmonicOscillator.Parametric.gradient	(	double	double	): Computes the value of the gradient at x. The components of the gradient vector are the partial derivatives of the function with respect to each of the parameters (amplitude, angular frequency and phase).
org.apache.commons.math4.analysis.function.HarmonicOscillator.Parametric.validateParameters	(	double[]	): Validates parameters to ensure they are appropriate for the evaluation of the value() and gradient() methods.
org.apache.commons.math4.analysis.function.HarmonicOscillator.Parametric.value	(	double	double	): Computes the value of the harmonic oscillator at x.
org.apache.commons.math4.analysis.function.HarmonicOscillator.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.HarmonicOscillator.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.HarmonicOscillator.value	(	double	double	): 
org.apache.commons.math4.analysis.function.HarmonicOscillatorTest: Test for class HarmonicOscillator.
org.apache.commons.math4.analysis.function.Identity: Identity function.
org.apache.commons.math4.analysis.function.Identity.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Identity.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Inverse: Inverse function.
org.apache.commons.math4.analysis.function.Inverse.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Inverse.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Log: Natural logarithm function.
org.apache.commons.math4.analysis.function.Log.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Log.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Log10: Base 10 logarithm function.
org.apache.commons.math4.analysis.function.Log10.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Log10.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Log1p: log(1 + p) function.
org.apache.commons.math4.analysis.function.Log1p.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Log1p.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Logistic:  Generalised logistic function.
org.apache.commons.math4.analysis.function.Logistic.Logistic	(	double	double	double	double	double	double	): 
org.apache.commons.math4.analysis.function.Logistic.Parametric: Parametric function where the input array contains the parameters of the Logistic() logistic function, ordered as follows:  k m b q a n 
org.apache.commons.math4.analysis.function.Logistic.Parametric.gradient	(	double	double	): Computes the value of the gradient at x. The components of the gradient vector are the partial derivatives of the function with respect to each of the parameters.
org.apache.commons.math4.analysis.function.Logistic.Parametric.validateParameters	(	double[]	): Validates parameters to ensure they are appropriate for the evaluation of the value() and gradient() methods.
org.apache.commons.math4.analysis.function.Logistic.Parametric.value	(	double	double	): Computes the value of the sigmoid at x.
org.apache.commons.math4.analysis.function.Logistic.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Logistic.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Logistic.value	(	double	double	double	double	double	double	): 
org.apache.commons.math4.analysis.function.LogisticTest: Test for class Logistic.
org.apache.commons.math4.analysis.function.Logit:  Logit function. It is the inverse of the Sigmoid sigmoid function.
org.apache.commons.math4.analysis.function.Logit.Logit	(	): Usual logit function, where the lower bound is 0 and the higher bound is 1.
org.apache.commons.math4.analysis.function.Logit.Logit	(	double	double	): Logit function.
org.apache.commons.math4.analysis.function.Logit.Parametric: Parametric function where the input array contains the parameters of the logit function, ordered as follows:  Lower bound Higher bound 
org.apache.commons.math4.analysis.function.Logit.Parametric.gradient	(	double	double	): Computes the value of the gradient at x. The components of the gradient vector are the partial derivatives of the function with respect to each of the parameters (lower bound and higher bound).
org.apache.commons.math4.analysis.function.Logit.Parametric.validateParameters	(	double[]	): Validates parameters to ensure they are appropriate for the evaluation of the value() and gradient() methods.
org.apache.commons.math4.analysis.function.Logit.Parametric.value	(	double	double	): Computes the value of the logit at x.
org.apache.commons.math4.analysis.function.Logit.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Logit.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Logit.value	(	double	double	double	): 
org.apache.commons.math4.analysis.function.LogitTest: Test for class Logit.
org.apache.commons.math4.analysis.function.Max: Maximum function.
org.apache.commons.math4.analysis.function.Max.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Min: Minimum function.
org.apache.commons.math4.analysis.function.Min.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Minus: Minus function.
org.apache.commons.math4.analysis.function.Minus.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Minus.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Multiply: Multiply the two operands.
org.apache.commons.math4.analysis.function.Multiply.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Pow: Power function.
org.apache.commons.math4.analysis.function.Pow.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Power: Power function.
org.apache.commons.math4.analysis.function.Power.Power	(	double	): 
org.apache.commons.math4.analysis.function.Power.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Power.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Rint: rint function.
org.apache.commons.math4.analysis.function.Rint.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Sigmoid:  Sigmoid function. It is the inverse of the Logit logit function. A more flexible version, the generalised logistic, is implemented by the Logistic class.
org.apache.commons.math4.analysis.function.Sigmoid.Parametric: Parametric function where the input array contains the parameters of the Sigmoid() sigmoid function, ordered as follows:  Lower asymptote Higher asymptote 
org.apache.commons.math4.analysis.function.Sigmoid.Parametric.gradient	(	double	double	): Computes the value of the gradient at x. The components of the gradient vector are the partial derivatives of the function with respect to each of the parameters (lower asymptote and higher asymptote).
org.apache.commons.math4.analysis.function.Sigmoid.Parametric.validateParameters	(	double[]	): Validates parameters to ensure they are appropriate for the evaluation of the value() and gradient() methods.
org.apache.commons.math4.analysis.function.Sigmoid.Parametric.value	(	double	double	): Computes the value of the sigmoid at x.
org.apache.commons.math4.analysis.function.Sigmoid.Sigmoid	(	): Usual sigmoid function, where the lower asymptote is 0 and the higher asymptote is 1.
org.apache.commons.math4.analysis.function.Sigmoid.Sigmoid	(	double	double	): Sigmoid function.
org.apache.commons.math4.analysis.function.Sigmoid.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Sigmoid.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Sigmoid.value	(	double	double	double	): 
org.apache.commons.math4.analysis.function.SigmoidTest: Test for class Sigmoid.
org.apache.commons.math4.analysis.function.Signum: signum function.
org.apache.commons.math4.analysis.function.Signum.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Sin: Sine function.
org.apache.commons.math4.analysis.function.Sin.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Sin.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Sinc: Sinc function, defined by  sinc(x) = 1 if x = 0, sin(x) / x otherwise. 
org.apache.commons.math4.analysis.function.Sinc.Sinc	(	): The sinc function, sin(x) / x.
org.apache.commons.math4.analysis.function.Sinc.Sinc	(	boolean	): Instantiates the sinc function.
org.apache.commons.math4.analysis.function.Sinc.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Sinc.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Sinh: Hyperbolic sine function.
org.apache.commons.math4.analysis.function.Sinh.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Sinh.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Sqrt: Square-root function.
org.apache.commons.math4.analysis.function.Sqrt.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Sqrt.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.StepFunction:  Step function.
org.apache.commons.math4.analysis.function.StepFunction.StepFunction	(	double[]	double[]	): Builds a step function from a list of arguments and the corresponding values. Specifically, returns the function h(x) defined by  h(x) = y[0] for all x < x[1] y[1] for x[1] ≤ x < x[2] ... y[y.length - 1] for x ≥ x[x.length - 1]  The value of x[0] is ignored, but it must be strictly less than x[1].
org.apache.commons.math4.analysis.function.StepFunction.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.StepFunctionTest: Test for class StepFunction.
org.apache.commons.math4.analysis.function.Subtract: Subtract the second operand from the first.
org.apache.commons.math4.analysis.function.Subtract.value	(	double	double	): Compute the value for the function. 
org.apache.commons.math4.analysis.function.Tan: Tangent function.
org.apache.commons.math4.analysis.function.Tan.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Tan.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Tanh: Hyperbolic tangent function.
org.apache.commons.math4.analysis.function.Tanh.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.function.Tanh.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.Ulp: ulp function.
org.apache.commons.math4.analysis.function.Ulp.value	(	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.function.UnivariateDifferentiableFunctionTest: Test for all classes in org.apache.commons.math4.analysis.function that implement UnivariateDifferentiableFunction explicitly.
org.apache.commons.math4.analysis.function.UnivariateFunctionTest: Test for all classes in org.apache.commons.math4.analysis.function that implement UnivariateFunction explicitly.
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator: Provide a default implementation for several generic functions.
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.BaseAbstractUnivariateIntegrator	(	double	double	): Construct an integrator with given accuracies.
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.BaseAbstractUnivariateIntegrator	(	double	double	int	int	): Construct an integrator with given accuracies and iteration counts.  The meanings of the various parameters are:  relative accuracy: this is used to stop iterations if the absolute accuracy can't be achieved due to large values or short mantissa length. If this should be the primary criterion for convergence rather then a safety measure, set the absolute accuracy to a ridiculously small value, like SAFE_MIN Precision.SAFE_MIN. absolute accuracy: The default is usually chosen so that results in the interval -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the expected absolute value of your results is of much smaller magnitude, set this to a smaller value. minimum number of iterations: minimal iteration is needed to avoid false early convergence, e.g. the sample points happen to be zeroes of the function. Users can use the default value or choose one that they see as appropriate. maximum number of iterations: usually a high iteration count indicates convergence problems. However, the "reasonable value" varies widely for different algorithms. Users are advised to use the default value supplied by the algorithm. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.BaseAbstractUnivariateIntegrator	(	int	int	): Construct an integrator with given iteration counts.
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.computeObjectiveValue	(	double	): Compute the objective function value.
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.doIntegrate	(	): Method for implementing actual integration algorithms in derived classes.
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getAbsoluteAccuracy	(	): Get the absolute accuracy. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getEvaluations	(	): Get the number of function evaluations of the last run of the integrator. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getIterations	(	): Get the number of iterations of the last run of the integrator. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getMax	(	): 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getMaximalIterationCount	(	): Get the upper limit for the number of iterations. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getMin	(	): 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getMinimalIterationCount	(	): Get the min limit for the number of iterations. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.getRelativeAccuracy	(	): Get the relative accuracy. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.integrate	(	int	UnivariateFunction	double	double	): Integrate the function in the given interval. 
org.apache.commons.math4.analysis.integration.BaseAbstractUnivariateIntegrator.setup	(	int	UnivariateFunction	double	double	): Prepare for computation. Subclasses must call this method if they override any of the solve methods.
org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator: This algorithm divides the integration interval into equally-sized sub-interval and on each of them performs a  Legendre-Gauss quadrature. Because of its non-adaptive nature, this algorithm can converge to a wrong value for the integral (for example, if the function is significantly different from zero toward the ends of the integration interval). In particular, a change of variables aimed at estimating integrals over infinite intervals as proposed  here should be avoided when using this class.
org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator.IterativeLegendreGaussIntegrator	(	int	double	double	): Builds an integrator with given accuracies.
org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator.IterativeLegendreGaussIntegrator	(	int	double	double	int	int	): Builds an integrator with given accuracies and iterations counts.
org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator.IterativeLegendreGaussIntegrator	(	int	int	int	): Builds an integrator with given iteration counts.
org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator.doIntegrate	(	): Method for implementing actual integration algorithms in derived classes. 
org.apache.commons.math4.analysis.integration.IterativeLegendreGaussIntegrator.stage	(	int	): Compute the n-th stage integral.
org.apache.commons.math4.analysis.integration.MidPointIntegrator: Implements the  Midpoint Rule for integration of real univariate functions. For reference, see Numerical Mathematics, ISBN 0387989595, chapter 9.2.  The function should be integrable.
org.apache.commons.math4.analysis.integration.MidPointIntegrator.MidPointIntegrator	(	): Construct a midpoint integrator with default settings. (max iteration count set to MIDPOINT_MAX_ITERATIONS_COUNT)
org.apache.commons.math4.analysis.integration.MidPointIntegrator.MidPointIntegrator	(	double	double	int	int	): Build a midpoint integrator with given accuracies and iterations counts.
org.apache.commons.math4.analysis.integration.MidPointIntegrator.MidPointIntegrator	(	int	int	): Build a midpoint integrator with given iteration counts.
org.apache.commons.math4.analysis.integration.MidPointIntegrator.doIntegrate	(	): Method for implementing actual integration algorithms in derived classes. 
org.apache.commons.math4.analysis.integration.MidPointIntegrator.stage	(	int	double	double	double	): Compute the n-th stage integral of midpoint rule. This function should only be called by API integrate() in the package. To save time it does not verify arguments - caller does.  The interval is divided equally into 2^n sections rather than an arbitrary m sections because this configuration can best utilize the already computed values.
org.apache.commons.math4.analysis.integration.MidPointIntegratorTest: Test case for midpoint integrator.  Test runs show that for a default relative accuracy of 1E-6, it generally takes 10 to 15 iterations for the integral to converge.
org.apache.commons.math4.analysis.integration.MidPointIntegratorTest.testLowAccuracy	(	): Test of integrator for the sine function.
org.apache.commons.math4.analysis.integration.MidPointIntegratorTest.testParameters	(	): Test of parameters for the integrator.
org.apache.commons.math4.analysis.integration.MidPointIntegratorTest.testQuinticFunction	(	): Test of integrator for the quintic function.
org.apache.commons.math4.analysis.integration.MidPointIntegratorTest.testSinFunction	(	): Test of integrator for the sine function.
org.apache.commons.math4.analysis.integration.RombergIntegrator: Implements the  Romberg Algorithm for integration of real univariate functions. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 3.  Romberg integration employs k successive refinements of the trapezoid rule to remove error terms less than order O(N^(-2k)). Simpson's rule is a special case of k = 2.
org.apache.commons.math4.analysis.integration.RombergIntegrator.RombergIntegrator	(	): Construct a Romberg integrator with default settings (max iteration count set to ROMBERG_MAX_ITERATIONS_COUNT)
org.apache.commons.math4.analysis.integration.RombergIntegrator.RombergIntegrator	(	double	double	int	int	): Build a Romberg integrator with given accuracies and iterations counts.
org.apache.commons.math4.analysis.integration.RombergIntegrator.RombergIntegrator	(	int	int	): Build a Romberg integrator with given iteration counts.
org.apache.commons.math4.analysis.integration.RombergIntegrator.doIntegrate	(	): Method for implementing actual integration algorithms in derived classes. 
org.apache.commons.math4.analysis.integration.RombergIntegratorTest: Test case for Romberg integrator.  Romberg algorithm is very fast for good behavior integrand. Test runs show that for a default relative accuracy of 1E-6, it generally takes takes less than 5 iterations for the integral to converge.
org.apache.commons.math4.analysis.integration.RombergIntegratorTest.testParameters	(	): Test of parameters for the integrator.
org.apache.commons.math4.analysis.integration.RombergIntegratorTest.testQuinticFunction	(	): Test of integrator for the quintic function.
org.apache.commons.math4.analysis.integration.RombergIntegratorTest.testSinFunction	(	): Test of integrator for the sine function.
org.apache.commons.math4.analysis.integration.SimpsonIntegrator: Implements  Simpson's Rule for integration of real univariate functions. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 3.  This implementation employs the basic trapezoid rule to calculate Simpson's rule.
org.apache.commons.math4.analysis.integration.SimpsonIntegrator.SimpsonIntegrator	(	): Construct an integrator with default settings. (max iteration count set to SIMPSON_MAX_ITERATIONS_COUNT)
org.apache.commons.math4.analysis.integration.SimpsonIntegrator.SimpsonIntegrator	(	double	double	int	int	): Build a Simpson integrator with given accuracies and iterations counts.
org.apache.commons.math4.analysis.integration.SimpsonIntegrator.SimpsonIntegrator	(	int	int	): Build a Simpson integrator with given iteration counts.
org.apache.commons.math4.analysis.integration.SimpsonIntegrator.doIntegrate	(	): Method for implementing actual integration algorithms in derived classes. 
org.apache.commons.math4.analysis.integration.SimpsonIntegratorTest: Test case for Simpson integrator.  Test runs show that for a default relative accuracy of 1E-6, it generally takes 5 to 10 iterations for the integral to converge.
org.apache.commons.math4.analysis.integration.SimpsonIntegratorTest.testParameters	(	): Test of parameters for the integrator.
org.apache.commons.math4.analysis.integration.SimpsonIntegratorTest.testQuinticFunction	(	): Test of integrator for the quintic function.
org.apache.commons.math4.analysis.integration.SimpsonIntegratorTest.testSinFunction	(	): Test of integrator for the sine function.
org.apache.commons.math4.analysis.integration.TrapezoidIntegrator: Implements the  Trapezoid Rule for integration of real univariate functions. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 3.  The function should be integrable.
org.apache.commons.math4.analysis.integration.TrapezoidIntegrator.TrapezoidIntegrator	(	): Construct a trapezoid integrator with default settings. (max iteration count set to TRAPEZOID_MAX_ITERATIONS_COUNT)
org.apache.commons.math4.analysis.integration.TrapezoidIntegrator.TrapezoidIntegrator	(	double	double	int	int	): Build a trapezoid integrator with given accuracies and iterations counts.
org.apache.commons.math4.analysis.integration.TrapezoidIntegrator.TrapezoidIntegrator	(	int	int	): Build a trapezoid integrator with given iteration counts.
org.apache.commons.math4.analysis.integration.TrapezoidIntegrator.doIntegrate	(	): Method for implementing actual integration algorithms in derived classes. 
org.apache.commons.math4.analysis.integration.TrapezoidIntegrator.stage	(	BaseAbstractUnivariateIntegrator	int	): Compute the n-th stage integral of trapezoid rule. This function should only be called by API integrate() in the package. To save time it does not verify arguments - caller does.  The interval is divided equally into 2^n sections rather than an arbitrary m sections because this configuration can best utilize the already computed values.
org.apache.commons.math4.analysis.integration.TrapezoidIntegratorTest: Test case for trapezoid integrator.  Test runs show that for a default relative accuracy of 1E-6, it generally takes 10 to 15 iterations for the integral to converge.
org.apache.commons.math4.analysis.integration.TrapezoidIntegratorTest.testParameters	(	): Test of parameters for the integrator.
org.apache.commons.math4.analysis.integration.TrapezoidIntegratorTest.testQuinticFunction	(	): Test of integrator for the quintic function.
org.apache.commons.math4.analysis.integration.TrapezoidIntegratorTest.testSinFunction	(	): Test of integrator for the sine function.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator: Interface for univariate real integration algorithms.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.getAbsoluteAccuracy	(	): Get the absolute accuracy.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.getEvaluations	(	): Get the number of function evaluations of the last run of the integrator.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.getIterations	(	): Get the number of iterations of the last run of the integrator.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.getMaximalIterationCount	(	): Get the upper limit for the number of iterations.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.getMinimalIterationCount	(	): Get the min limit for the number of iterations.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.getRelativeAccuracy	(	): Get the relative accuracy.
org.apache.commons.math4.analysis.integration.UnivariateIntegrator.integrate	(	int	UnivariateFunction	double	double	): Integrate the function in the given interval.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactory: Base class for rules that determines the integration nodes and their weights. Subclasses must implement the computeRule() method.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactory.addRule	(	Pair	): Stores a rule.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactory.computeRule	(	int	): Computes the rule for the given order.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactory.convertToDouble	(	Pair	): Converts the from the actual Number type to double
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactory.getRule	(	int	): Gets a copy of the quadrature rule with the given number of integration points.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactory.getRuleInternal	(	int	): Gets a rule. Synchronization ensures that rules will be computed and added to the cache at most once. The returned rule is a reference into the cache.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactoryTest: Test for BaseRuleFactory.
org.apache.commons.math4.analysis.integration.gauss.BaseRuleFactoryTest.testConcurrentCreation	(	): Tests that a given rule rule will be computed and added once to the cache whatever the number of times this rule is called concurrently.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator: Class that implements the Gaussian rule for integrate() integrating a weighted function.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator.GaussIntegrator	(	Pair	): Creates an integrator from the given pair of points (first element of the pair) and weights (second element of the pair.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator.GaussIntegrator	(	double[]	double[]	): Creates an integrator from the given points and weights. The integration interval is defined by the first and last value of points which must be sorted in increasing order.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator.getNumberOfPoints	(	): 
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator.getPoint	(	int	): Gets the integration point at the given index. The index must be in the valid range but no check is performed.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator.getWeight	(	int	): Gets the weight of the integration point at the given index. The index must be in the valid range but no check is performed.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegrator.integrate	(	UnivariateFunction	): Returns an estimate of the integral of f(x) * w(x), where w is a weight function that depends on the actual flavor of the Gauss integration scheme. The algorithm uses the points and associated weights, as passed to the GaussIntegrator() constructor.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory: Class that provides different ways to compute the nodes and weights to be used by the GaussIntegrator Gaussian integration rule.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.getRule	(	BaseRuleFactory	int	): 
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.hermite	(	int	): Creates a Gauss-Hermite integrator of the given order. The call to the integrate() method will perform a weighted integration on the interval \([-\infty, +\infty]\): the computed value is the improper integral of \(e^{-x^2}f(x)\) where \(f(x)\) is the function passed to the integrate() method.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.laguerre	(	int	): Creates a Gauss-Laguerre integrator of the given order. The call to the integrate() method will perform an integration on the interval \([0, +\infty)\): the computed value is the improper integral of \(e^{-x} f(x)\) where \(f(x)\) is the function passed to the integrate() method.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.legendre	(	int	): Creates a Gauss-Legendre integrator of the given order. The call to the integrate() method will perform an integration on the natural interval [-1 , 1].
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.legendre	(	int	double	double	): Creates a Gauss-Legendre integrator of the given order. The call to the integrate() method will perform an integration on the given interval.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.legendreHighPrecision	(	int	): Creates a Gauss-Legendre integrator of the given order. The call to the integrate() method will perform an integration on the natural interval [-1 , 1].
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.legendreHighPrecision	(	int	double	double	): Creates an integrator of the given order, and whose call to the integrate() method will perform an integration on the given interval.
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorFactory.transform	(	Pair	double	double	): Performs a change of variable so that the integration can be performed on an arbitrary interval [a, b]. It is assumed that the natural interval is [-1, 1].
org.apache.commons.math4.analysis.integration.gauss.GaussIntegratorTest: Test for GaussIntegrator class.
org.apache.commons.math4.analysis.integration.gauss.GaussianQuadratureAbstractTest: Base class for standard testing of Gaussian quadrature rules, which are exact for polynomials up to a certain degree. In this test, each monomial in turn is tested against the specified quadrature rule.
org.apache.commons.math4.analysis.integration.gauss.GaussianQuadratureAbstractTest.GaussianQuadratureAbstractTest	(	GaussIntegrator	int	double	double	): Creates a new instance of this abstract test with the specified quadrature rule. If the expected value is non-zero, equality of actual and expected values is checked in the relative sense  |xact - xexp| ≤  n  Math.ulp(xexp),  where n is the maximum relative error (in ulps). If the expected value is zero, the test checks that  |xact| ≤ ε,  where ε is the maximum absolute error.
org.apache.commons.math4.analysis.integration.gauss.GaussianQuadratureAbstractTest.getExpectedValue	(	int	): Returns the expected value of the integral of the specified monomial. The integration is carried out on the natural interval of the quadrature rule under test.
org.apache.commons.math4.analysis.integration.gauss.GaussianQuadratureAbstractTest.testAllMonomials	(	): Checks that the value of the integral of each monomial x0, ... , xp returned by the quadrature rule under test conforms with the expected value. Here p denotes the degree of the highest polynomial for which exactness is to be expected.
org.apache.commons.math4.analysis.integration.gauss.HermiteParametricTest: Test of the HermiteRuleFactory. This parameterized test extends the standard test for Gaussian quadrature rule, where each monomial is tested in turn. Parametrization allows to test automatically 0, 1, ... , MAX_NUM_POINTS quadrature rules.
org.apache.commons.math4.analysis.integration.gauss.HermiteParametricTest.HermiteParametricTest	(	int	int	double	double	): Creates a new instance of this test, with the specified number of nodes for the Gauss-Hermite quadrature rule.
org.apache.commons.math4.analysis.integration.gauss.HermiteParametricTest.getParameters	(	): Returns the collection of parameters to be passed to the constructor of this class. Gauss-Hermite quadrature rules of order 1, ..., MAX_NUM_POINTS will be constructed.
org.apache.commons.math4.analysis.integration.gauss.HermiteRuleFactory: Factory that creates a  Gauss-type quadrature rule using Hermite polynomials of the first kind. Such a quadrature rule allows the calculation of improper integrals of a function  \(f(x) e^{-x^2}\)  Recurrence relation and weights computation follow  Abramowitz and Stegun, 1964.  The coefficients of the standard Hermite polynomials grow very rapidly. In order to avoid overflows, each Hermite polynomial is normalized with respect to the underlying scalar product. The initial interval for the application of the bisection method is based on the roots of the previous Hermite polynomial (interlacing). Upper and lower bounds of these roots are provided by   I. Krasikov, Nonnegative quadratic forms and bounds on orthogonal polynomials, Journal of Approximation theory 111, 31-49 
org.apache.commons.math4.analysis.integration.gauss.HermiteRuleFactory.computeRule	(	int	): Computes the rule for the given order. 
org.apache.commons.math4.analysis.integration.gauss.HermiteTest: Test of the HermiteRuleFactory.
org.apache.commons.math4.analysis.integration.gauss.LaguerreRuleFactory: Factory that creates Gauss-type quadrature rule using Laguerre polynomials.
org.apache.commons.math4.analysis.integration.gauss.LaguerreRuleFactory.companionMatrix	(	int	): 
org.apache.commons.math4.analysis.integration.gauss.LaguerreRuleFactory.computeRule	(	int	): Computes the rule for the given order. 
org.apache.commons.math4.analysis.integration.gauss.LaguerreTest: Test of the LaguerreRuleFactory.
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionParametricTest: Test of the LegendreHighPrecisionRuleFactory. This parameterized test extends the standard test for Gaussian quadrature rule, where each monomial is tested in turn. Parametrization allows to test automatically 0, 1, ... , MAX_NUM_POINTS quadrature rules.
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionParametricTest.LegendreHighPrecisionParametricTest	(	int	int	double	double	): Creates a new instance of this test, with the specified number of nodes for the Gauss-Legendre quadrature rule.
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionParametricTest.getParameters	(	): Returns the collection of parameters to be passed to the constructor of this class. Gauss-Legendre quadrature rules of order 1, ..., MAX_NUM_POINTS will be constructed.
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionRuleFactory: Factory that creates Gauss-type quadrature rule using Legendre polynomials. In this implementation, the lower and upper bounds of the natural interval of integration are -1 and 1, respectively. The Legendre polynomials are evaluated using the recurrence relation presented in  Abramowitz and Stegun, 1964.
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionRuleFactory.LegendreHighPrecisionRuleFactory	(	): Default precision is DECIMAL128.
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionRuleFactory.LegendreHighPrecisionRuleFactory	(	MathContext	): 
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionRuleFactory.computeRule	(	int	): Computes the rule for the given order. 
org.apache.commons.math4.analysis.integration.gauss.LegendreHighPrecisionTest: Test of the LegendreHighPrecisionRuleFactory.
org.apache.commons.math4.analysis.integration.gauss.LegendreParametricTest: Test of the LegendreRuleFactory. This parameterized test extends the standard test for Gaussian quadrature rule, where each monomial is tested in turn. Parametrization allows to test automatically 0, 1, ... , MAX_NUM_POINTS quadrature rules.
org.apache.commons.math4.analysis.integration.gauss.LegendreParametricTest.LegendreParametricTest	(	int	int	double	double	): Creates a new instance of this test, with the specified number of nodes for the Gauss-Legendre quadrature rule.
org.apache.commons.math4.analysis.integration.gauss.LegendreParametricTest.getParameters	(	): Returns the collection of parameters to be passed to the constructor of this class. Gauss-Legendre quadrature rules of order 1, ..., MAX_NUM_POINTS will be constructed.
org.apache.commons.math4.analysis.integration.gauss.LegendreRuleFactory: Factory that creates Gauss-type quadrature rule using Legendre polynomials. In this implementation, the lower and upper bounds of the natural interval of integration are -1 and 1, respectively. The Legendre polynomials are evaluated using the recurrence relation presented in  Abramowitz and Stegun, 1964.
org.apache.commons.math4.analysis.integration.gauss.LegendreRuleFactory.computeRule	(	int	): Computes the rule for the given order. 
org.apache.commons.math4.analysis.integration.gauss.LegendreTest: Test of the LegendreRuleFactory.
org.apache.commons.math4.analysis.integration.gauss.SymmetricGaussIntegrator: This class's implements integrate() method assuming that the integral is symmetric about 0. This allows to reduce numerical errors.
org.apache.commons.math4.analysis.integration.gauss.SymmetricGaussIntegrator.SymmetricGaussIntegrator	(	Pair	): Creates an integrator from the given pair of points (first element of the pair) and weights (second element of the pair.
org.apache.commons.math4.analysis.integration.gauss.SymmetricGaussIntegrator.SymmetricGaussIntegrator	(	double[]	double[]	): Creates an integrator from the given points and weights. The integration interval is defined by the first and last value of points which must be sorted in increasing order.
org.apache.commons.math4.analysis.integration.gauss.SymmetricGaussIntegrator.integrate	(	UnivariateFunction	): Returns an estimate of the integral of f(x) * w(x), where w is a weight function that depends on the actual flavor of the Gauss integration scheme. The algorithm uses the points and associated weights, as passed to the GaussIntegrator() constructor.
org.apache.commons.math4.analysis.interpolation.AkimaSplineInterpolator: Computes a cubic spline interpolation for the data set using the Akima algorithm, as originally formulated by Hiroshi Akima in his 1970 paper "A New Method of Interpolation and Smooth Curve Fitting Based on Local Procedures." J. ACM 17, 4 (October 1970), 589-602. DOI=10.1145/321607.321609 http://doi.acm.org/10.1145/321607.321609  This implementation is based on the Akima implementation in the CubicSpline class in the Math.NET Numerics library. The method referenced is CubicSpline.InterpolateAkimaSorted   The interpolate() method returns a PolynomialSplineFunction consisting of n cubic polynomials, defined over the subintervals determined by the x values, x[0] < x[i] ... < x[n]. The Akima algorithm requires that n >= 5. 
org.apache.commons.math4.analysis.interpolation.AkimaSplineInterpolator.differentiateThreePoint	(	double[]	double[]	int	int	int	int	): Three point differentiation helper, modeled off of the same method in the Math.NET CubicSpline class. This is used by both the Apache Math and the Math.NET Akima Cubic Spline algorithms
org.apache.commons.math4.analysis.interpolation.AkimaSplineInterpolator.interpolate	(	double[]	double[]	): Computes an interpolating function for the data set.
org.apache.commons.math4.analysis.interpolation.AkimaSplineInterpolator.interpolateHermiteSorted	(	double[]	double[]	double[]	): Creates a Hermite cubic spline interpolation from the set of (x,y) value pairs and their derivatives. This is modeled off of the InterpolateHermiteSorted method in the Math.NET CubicSpline class.
org.apache.commons.math4.analysis.interpolation.BicubicFunction: Bicubic function.
org.apache.commons.math4.analysis.interpolation.BicubicFunction.BicubicFunction	(	double[]	): Simple constructor.
org.apache.commons.math4.analysis.interpolation.BicubicFunction.apply	(	double[]	double[]	double[][]	): Compute the value of the bicubic polynomial.
org.apache.commons.math4.analysis.interpolation.BicubicFunction.value	(	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunction: Function that implements the  bicubic spline interpolation.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunction.BicubicInterpolatingFunction	(	double[]	double[]	double[][]	double[][]	double[][]	double[][]	): 
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunction.computeSplineCoefficients	(	double[]	): Compute the spline coefficients from the list of function values and function partial derivatives values at the four corners of a grid element. They must be specified in the following order:  f(0,0) f(1,0) f(0,1) f(1,1) fx(0,0) fx(1,0) fx(0,1) fx(1,1) fy(0,0) fy(1,0) fy(0,1) fy(1,1) fxy(0,0) fxy(1,0) fxy(0,1) fxy(1,1)  where the subscripts indicate the partial derivative with respect to the corresponding variable(s).
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunction.isValidPoint	(	double	double	): Indicates whether a point is within the interpolation range.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunction.searchIndex	(	double	double[]	): 
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunction.value	(	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunctionTest: Test case for the bicubic function.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunctionTest.testInterpolation	(	double	double	double	double	int	int	BivariateFunction	BivariateFunction	BivariateFunction	BivariateFunction	double	double	boolean	): 
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunctionTest.testParaboloid	(	): Interpolating a paraboloid.  z = 2 x2 - 3 y2 + 4 x y - 5
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunctionTest.testPlane	(	): Interpolating a plane.  z = 2 x - 3 y + 5
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatingFunctionTest.testPreconditions	(	): Test preconditions.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolator: Generates a BicubicInterpolatingFunction bicubic interpolating function.  Caveat: Because the interpolation scheme requires that derivatives be specified at the sample points, those are approximated with finite differences (using the 2-points symmetric formulae). Since their values are undefined at the borders of the provided interpolation ranges, the interpolated values will be wrong at the edges of the patch. The interpolate method will return a function that overrides isValidPoint() to indicate points where the interpolation will be inaccurate. 
org.apache.commons.math4.analysis.interpolation.BicubicInterpolator.interpolate	(	double[]	double[]	double[][]	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatorTest: Test case for the bicubic interpolator.
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatorTest.testInterpolation	(	int	double	BivariateFunction	boolean	): 
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatorTest.testParaboloid	(	): Interpolating a paraboloid.  z = 2 x2 - 3 y2 + 4 x y - 5
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatorTest.testPlane	(	): Interpolating a plane.  z = 2 x - 3 y + 5
org.apache.commons.math4.analysis.interpolation.BicubicInterpolatorTest.testPreconditions	(	): Test preconditions.
org.apache.commons.math4.analysis.interpolation.BivariateGridInterpolator: Interface representing a bivariate real interpolating function where the sample points must be specified on a regular grid.
org.apache.commons.math4.analysis.interpolation.BivariateGridInterpolator.interpolate	(	double[]	double[]	double[][]	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolator: Implements the  Divided Difference Algorithm for interpolation of real univariate functions. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 2.  The actual code of Neville's evaluation is in PolynomialFunctionLagrangeForm, this class provides an easy-to-use interface to it.
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolator.computeDividedDifference	(	double	double	): Return a copy of the divided difference array.  The divided difference array is defined recursively by  f[x0] = f(x0) f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)   The computational complexity is \(O(n^2)\) where \(n\) is the common length of x and y.
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolator.interpolate	(	double	double	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolatorTest: Test case for Divided Difference interpolator.  The error of polynomial interpolation is f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! where f^(n) is the n-th derivative of the approximated function and zeta is some point in the interval determined by x[] and z.  Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound it and use the absolute value upper bound for estimates. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 2.
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolatorTest.partialerror	(	double	double	): Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolatorTest.testExpm1Function	(	): Test of interpolator for the exponential function.  |expm1^(n)(zeta)| <= e, zeta in [-1, 1]
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolatorTest.testParameters	(	): Test of parameters for the interpolator.
org.apache.commons.math4.analysis.interpolation.DividedDifferenceInterpolatorTest.testSinFunction	(	): Test of interpolator for the sine function.  |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]
org.apache.commons.math4.analysis.interpolation.FieldHermiteInterpolator: Polynomial interpolator using both sample values and sample derivatives.  The interpolation polynomials match all sample points, including both values and provided derivatives. There is one polynomial for each component of the values vector. All polynomials have the same degree. The degree of the polynomials depends on the number of points and number of derivatives at each point. For example the interpolation polynomials for n sample points without any derivatives all have degree n-1. The interpolation polynomials for n sample points with the two extreme points having value and first derivative and the remaining points having value only all have degree n+1. The interpolation polynomial for n sample points with value, first and second derivative for all points all have degree 3n-1. 
org.apache.commons.math4.analysis.interpolation.FieldHermiteInterpolator.FieldHermiteInterpolator	(	): Create an empty interpolator.
org.apache.commons.math4.analysis.interpolation.FieldHermiteInterpolator.addSamplePoint	(	T	T[]	): Add a sample point.  This method must be called once for each sample point. It is allowed to mix some calls with values only with calls with values and first derivatives.   The point abscissae for all calls must be different. 
org.apache.commons.math4.analysis.interpolation.FieldHermiteInterpolator.derivatives	(	T	int	): Interpolate value and first derivatives at a specified abscissa.
org.apache.commons.math4.analysis.interpolation.FieldHermiteInterpolator.value	(	T	): Interpolate value at a specified abscissa.
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator: Polynomial interpolator using both sample values and sample derivatives.  The interpolation polynomials match all sample points, including both values and provided derivatives. There is one polynomial for each component of the values vector. All polynomials have the same degree. The degree of the polynomials depends on the number of points and number of derivatives at each point. For example the interpolation polynomials for n sample points without any derivatives all have degree n-1. The interpolation polynomials for n sample points with the two extreme points having value and first derivative and the remaining points having value only all have degree n+1. The interpolation polynomial for n sample points with value, first and second derivative for all points all have degree 3n-1. 
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.HermiteInterpolator	(	): Create an empty interpolator.
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.addSamplePoint	(	double	double[]	): Add a sample point.  This method must be called once for each sample point. It is allowed to mix some calls with values only with calls with values and first derivatives.   The point abscissae for all calls must be different. 
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.checkInterpolation	(	): Check interpolation can be performed.
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.getPolynomials	(	): Compute the interpolation polynomials.
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.polynomial	(	double	): Create a polynomial from its coefficients.
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.value	(	DerivativeStructure	): Interpolate value at a specified abscissa.  Calling this method is equivalent to call the value() methods of all polynomials returned by getPolynomials(), except it does not build the intermediate polynomials, so this method is faster and numerically more stable. 
org.apache.commons.math4.analysis.interpolation.HermiteInterpolator.value	(	double	): Interpolate value at a specified abscissa.  Calling this method is equivalent to call the value() methods of all polynomials returned by getPolynomials(), except it does not build the intermediate polynomials, so this method is faster and numerically more stable. 
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere: Utility class for the MicrosphereProjectionInterpolator algorithm.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.Facet: Microsphere "facet" (surface element).
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.Facet.Facet	(	double[]	): 
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.Facet.getNormal	(	): Return a reference to the vector normal to this facet.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.FacetData: Data associated with each Facet.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.FacetData.FacetData	(	double	double	): 
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.FacetData.illumination	(	): Get the illumination.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.FacetData.sample	(	): Get the data value.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.InterpolatingMicrosphere	(	InterpolatingMicrosphere	): Copy constructor.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.InterpolatingMicrosphere	(	int	int	double	double	double	): Create an unitialiazed sphere. Sub-classes are responsible for calling the add(double[]) add method in order to initialize all the sphere's facets.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.InterpolatingMicrosphere	(	int	int	double	double	double	UnitSphereRandomVectorGenerator	): Create a sphere from randomly sampled vectors.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.add	(	double[]	boolean	): Replace i-th facet of the microsphere. Method for initializing the microsphere facets.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.clear	(	): Reset the all the Facet facets data to zero.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.copy	(	): Perform a copy.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.getDimension	(	): Get the space dimensionality.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.getSize	(	): Get the size of the sphere.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.illuminate	(	double[]	double	double	): Illumination.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.interpolate	(	): Interpolation.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere.value	(	double[]	double[][]	double[]	double	double	): Estimate the value at the requested location. This microsphere is placed at the given point, contribution of the given samplePoints to each sphere facet is computed (illumination) and the interpolation is performed (integration of the illumination).
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere2D: Utility class for the MicrosphereProjectionInterpolator algorithm. For 2D interpolation, this class constructs the microsphere as a series of evenly spaced facets (rather than generating random normals as in the base implementation).
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere2D.InterpolatingMicrosphere2D	(	InterpolatingMicrosphere2D	): Copy constructor.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere2D.InterpolatingMicrosphere2D	(	int	double	double	double	): Create a sphere from vectors regularly sampled around a circle.
org.apache.commons.math4.analysis.interpolation.InterpolatingMicrosphere2D.copy	(	): Perform a copy.
org.apache.commons.math4.analysis.interpolation.LinearInterpolator: Implements a linear function for interpolation of real univariate functions.
org.apache.commons.math4.analysis.interpolation.LinearInterpolator.interpolate	(	double	double	): Computes a linear interpolating function for the data set.
org.apache.commons.math4.analysis.interpolation.LinearInterpolatorTest: Test the LinearInterpolator.
org.apache.commons.math4.analysis.interpolation.LinearInterpolatorTest.verifyInterpolation	(	UnivariateFunction	double	double	): verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator: Implements the  Local Regression Algorithm (also Loess, Lowess) for interpolation of real univariate functions.  For reference, see  William S. Cleveland - Robust Locally Weighted Regression and Smoothing Scatterplots  This class implements both the loess method and serves as an interpolation adapter to it, allowing one to build a spline on the obtained loess fit.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.LoessInterpolator	(	): Constructs a new LoessInterpolator with a bandwidth of DEFAULT_BANDWIDTH, DEFAULT_ROBUSTNESS_ITERS robustness iterations and an accuracy of {#link #DEFAULT_ACCURACY}. See LoessInterpolator() for an explanation of the parameters.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.LoessInterpolator	(	double	int	): Construct a new LoessInterpolator with given bandwidth and number of robustness iterations.  Calling this constructor is equivalent to calling {link LoessInterpolator() LoessInterpolator(bandwidth, robustnessIters, LoessInterpolator.DEFAULT_ACCURACY) 
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.LoessInterpolator	(	double	int	double	): Construct a new LoessInterpolator with given bandwidth, number of robustness iterations and accuracy.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.checkAllFiniteReal	(	double[]	): Check that all elements of an array are finite real numbers.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.interpolate	(	double[]	double[]	): Compute an interpolating function by performing a loess fit on the data at the original abscissae and then building a cubic spline with a org.apache.commons.math4.analysis.interpolation.SplineInterpolator on the resulting fit.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.nextNonzero	(	double[]	int	): Return the smallest index j such that j > i && (j == weights.length || weights[j] != 0).
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.smooth	(	double[]	double[]	): Compute a loess fit on the data at the original abscissae.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.smooth	(	double[]	double[]	double[]	): Compute a weighted loess fit on the data at the original abscissae.
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.tricube	(	double	): Compute the tricube weight function
org.apache.commons.math4.analysis.interpolation.LoessInterpolator.updateBandwidthInterval	(	double[]	double[]	int	int[]	): Given an index interval into xval that embraces a certain number of points closest to xval[i-1], update the interval so that it embraces the same number of points closest to xval[i], ignoring zero weights.
org.apache.commons.math4.analysis.interpolation.LoessInterpolatorTest: Test of the LoessInterpolator class.
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolator: Interpolator that implements the algorithm described in William Dudziak's MS thesis.
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolator.MicrosphereProjectionInterpolator	(	InterpolatingMicrosphere	double	boolean	double	): Create a microsphere interpolator.
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolator.MicrosphereProjectionInterpolator	(	int	int	double	double	double	double	boolean	double	): Create a microsphere interpolator.
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolator.interpolate	(	double[][]	double[]	): Computes an interpolating function for the data set.
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolatorTest: Test case for the MicrosphereProjectionInterpolator "microsphere projection" interpolator.
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolatorTest.testLinearFunction2D	(	): Test of interpolator for a plane.  y = 2 x1 - 3 x2 + 5
org.apache.commons.math4.analysis.interpolation.MicrosphereProjectionInterpolatorTest.toCoordinate	(	double	double	int	int	): 
org.apache.commons.math4.analysis.interpolation.MultivariateInterpolator: Interface representing a univariate real interpolating function.
org.apache.commons.math4.analysis.interpolation.MultivariateInterpolator.interpolate	(	double[][]	double[]	): Computes an interpolating function for the data set.
org.apache.commons.math4.analysis.interpolation.NevilleInterpolator: Implements the  Neville's Algorithm for interpolation of real univariate functions. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 2.  The actual code of Neville's algorithm is in PolynomialFunctionLagrangeForm, this class provides an easy-to-use interface to it.
org.apache.commons.math4.analysis.interpolation.NevilleInterpolator.interpolate	(	double	double	): Computes an interpolating function for the data set.
org.apache.commons.math4.analysis.interpolation.NevilleInterpolatorTest: Test case for Neville interpolator.  The error of polynomial interpolation is f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! where f^(n) is the n-th derivative of the approximated function and zeta is some point in the interval determined by x[] and z.  Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound it and use the absolute value upper bound for estimates. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 2.
org.apache.commons.math4.analysis.interpolation.NevilleInterpolatorTest.partialerror	(	double	double	): Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!
org.apache.commons.math4.analysis.interpolation.NevilleInterpolatorTest.testExpm1Function	(	): Test of interpolator for the exponential function.  |expm1^(n)(zeta)| <= e, zeta in [-1, 1]
org.apache.commons.math4.analysis.interpolation.NevilleInterpolatorTest.testParameters	(	): Test of parameters for the interpolator.
org.apache.commons.math4.analysis.interpolation.NevilleInterpolatorTest.testSinFunction	(	): Test of interpolator for the sine function.  |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunction: Function that implements the bicubic spline interpolation. This implementation currently uses AkimaSplineInterpolator as the underlying one-dimensional interpolator, which requires 5 sample points; insufficient data will raise an exception when the value() method is called.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunction.PiecewiseBicubicSplineInterpolatingFunction	(	double[]	double[]	double[][]	): 
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunction.isValidPoint	(	double	double	): Indicates whether a point is within the interpolation range.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunction.searchIndex	(	double	double[]	int	int	): 
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunction.value	(	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunctionTest: Test case for the piecewise bicubic function.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunctionTest.testInterpolation	(	double	double	double	double	int	int	BivariateFunction	double	double	): 
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunctionTest.testParabaloid	(	): Interpolating a paraboloid.  z = 2 x2 - 3 y2 + 4 x y - 5
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunctionTest.testPlane	(	): Interpolating a plane.  z = 2 x - 3 y + 5
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatingFunctionTest.testPreconditions	(	): Test preconditions.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolator: Generates a piecewise-bicubic interpolating function.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolator.interpolate	(	double[]	double[]	double[][]	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatorTest: Test case for the piecewise bicubic interpolator.
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatorTest.testInterpolation1	(	): Interpolating a plane.  z = 2 x - 3 y + 5
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatorTest.testInterpolation2	(	): Interpolating a paraboloid.  z = 2 x2 - 3 y2 + 4 x y - 5
org.apache.commons.math4.analysis.interpolation.PiecewiseBicubicSplineInterpolatorTest.testPreconditions	(	): Test preconditions.
org.apache.commons.math4.analysis.interpolation.SplineInterpolator: Computes a natural (also known as "free", "unclamped") cubic spline interpolation for the data set.  The interpolate() method returns a PolynomialSplineFunction consisting of n cubic polynomials, defined over the subintervals determined by the x values, x[0] < x[i] ... < x[n]. The x values are referred to as "knot points."  The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest knot point and strictly less than the largest knot point is computed by finding the subinterval to which x belongs and computing the value of the corresponding polynomial at x - x[i]  where i is the index of the subinterval. See PolynomialSplineFunction for more details.   The interpolating polynomials satisfy:  The value of the PolynomialSplineFunction at each of the input x values equals the corresponding y value. Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials "match up" at the knot points, as do their first and second derivatives).   The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires, Numerical Analysis, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131. 
org.apache.commons.math4.analysis.interpolation.SplineInterpolator.interpolate	(	double	double	): Computes an interpolating function for the data set.
org.apache.commons.math4.analysis.interpolation.SplineInterpolatorTest: Test the SplineInterpolator.
org.apache.commons.math4.analysis.interpolation.SplineInterpolatorTest.verifyConsistency	(	PolynomialSplineFunction	double	): Verifies that interpolating polynomials satisfy consistency requirement: adjacent polynomials must agree through two derivatives at knot points
org.apache.commons.math4.analysis.interpolation.SplineInterpolatorTest.verifyInterpolation	(	UnivariateFunction	double	double	): verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.
org.apache.commons.math4.analysis.interpolation.TricubicFunction: 3D-spline function.
org.apache.commons.math4.analysis.interpolation.TricubicFunction.TricubicFunction	(	double[]	): 
org.apache.commons.math4.analysis.interpolation.TricubicFunction.value	(	double	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunction: Function that implements the  tricubic spline interpolation, as proposed in  Tricubic interpolation in three dimensions F. Lekien and J. Marsden Int. J. Numer. Meth. Eng 2005; 63:455-471 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunction.TricubicInterpolatingFunction	(	double[]	double[]	double[]	double[][][]	double[][][]	double[][][]	double[][][]	double[][][]	double[][][]	double[][][]	double[][][]	): 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunction.computeCoefficients	(	double[]	): Compute the spline coefficients from the list of function values and function partial derivatives values at the four corners of a grid element. They must be specified in the following order:  f(0,0,0) f(1,0,0) f(0,1,0) f(1,1,0) f(0,0,1) f(1,0,1) f(0,1,1) f(1,1,1) fx(0,0,0) ... (same order as above) fx(1,1,1) fy(0,0,0) ... (same order as above) fy(1,1,1) fz(0,0,0) ... (same order as above) fz(1,1,1) fxy(0,0,0) ... (same order as above) fxy(1,1,1) fxz(0,0,0) ... (same order as above) fxz(1,1,1) fyz(0,0,0) ... (same order as above) fyz(1,1,1) fxyz(0,0,0) ... (same order as above) fxyz(1,1,1)  where the subscripts indicate the partial derivative with respect to the corresponding variable(s).
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunction.isValidPoint	(	double	double	double	): Indicates whether a point is within the interpolation range.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunction.searchIndex	(	double	double[]	): 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunction.value	(	double	double	double	): Compute the value for the function.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunctionTest: Test case for the bicubic function.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunctionTest.testInterpolation	(	double	double	double	double	double	double	int	int	TrivariateFunction	TrivariateFunction	TrivariateFunction	TrivariateFunction	TrivariateFunction	TrivariateFunction	TrivariateFunction	TrivariateFunction	double	double	double	boolean	): 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunctionTest.testPlane	(	): Test for a plane.  f(x, y, z) = 2 x - 3 y - 4 z + 5 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunctionTest.testPreconditions	(	): Test preconditions.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunctionTest.testQuadric	(	): Test for a quadric.  f(x, y, z) = 2 x2 - 3 y2 - 4 z2 + 5 x y + 6 x z - 2 y z + 3 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatingFunctionTest.testWave	(	): Wave.  f(x, y, z) = a cos (ω z - kx x - ky y)  with a = 5, ω = 0.3, kx = 0.8, ky = 1.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolator: Generates a tricubic interpolating function.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolator.interpolate	(	double[]	double[]	double[]	double[][][]	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatorTest: Test case for the TricubicInterpolator tricubic interpolator.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatorTest.testPlane	(	): Test for a plane.  f(x, y, z) = 2 x - 3 y - 4 z + 5 
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatorTest.testPreconditions	(	): Test preconditions.
org.apache.commons.math4.analysis.interpolation.TricubicInterpolatorTest.testWave	(	): Sine wave.  f(x, y, z) = a cos [ω z - ky x - ky y]  with A = 0.2, ω = 0.5, kx = 2, ky = 1.
org.apache.commons.math4.analysis.interpolation.TrivariateGridInterpolator: Interface representing a trivariate real interpolating function where the sample points must be specified on a regular grid.
org.apache.commons.math4.analysis.interpolation.TrivariateGridInterpolator.interpolate	(	double[]	double[]	double[]	double[][][]	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.UnivariateInterpolator: Interface representing a univariate real interpolating function.
org.apache.commons.math4.analysis.interpolation.UnivariateInterpolator.interpolate	(	double	double	): Compute an interpolating function for the dataset.
org.apache.commons.math4.analysis.interpolation.UnivariatePeriodicInterpolator: Adapter for classes implementing the UnivariateInterpolator interface. The data to be interpolated is assumed to be periodic. Thus values that are outside of the range can be passed to the interpolation function: They will be wrapped into the initial range before being passed to the class that actually computes the interpolation.
org.apache.commons.math4.analysis.interpolation.UnivariatePeriodicInterpolator.UnivariatePeriodicInterpolator	(	UnivariateInterpolator	double	): Builds an interpolator. Uses DEFAULT_EXTEND as the number of extension points on each side of the original abscissae range.
org.apache.commons.math4.analysis.interpolation.UnivariatePeriodicInterpolator.UnivariatePeriodicInterpolator	(	UnivariateInterpolator	double	int	): Builds an interpolator.
org.apache.commons.math4.analysis.interpolation.UnivariatePeriodicInterpolator.interpolate	(	double[]	double[]	): 
org.apache.commons.math4.analysis.interpolation.UnivariatePeriodicInterpolatorTest: Test for UnivariatePeriodicInterpolator.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction: Immutable representation of a real polynomial function with real coefficients.  Horner's Method is used to evaluate the function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.Parametric: Dedicated parametric polynomial class.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.Parametric.gradient	(	double	double	): Compute the gradient of the function with respect to its parameters. 
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.Parametric.value	(	double	double	): Compute the value of the function. 
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.PolynomialFunction	(	double	): Construct a polynomial with the given coefficients. The first element of the coefficients array is the constant term. Higher degree coefficients follow in sequence. The degree of the resulting polynomial is the index of the last non-null element of the array, or 0 if all elements are null.  The constructor makes a copy of the input array and assigns the copy to the coefficients property.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.add	(	PolynomialFunction	): Add a polynomial to the instance.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.degree	(	): Returns the degree of the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.differentiate	(	double[]	): Returns the coefficients of the derivative of the polynomial with the given coefficients.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.equals	(	Object	):  
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.evaluate	(	double[]	double	): Uses Horner's Method to evaluate the polynomial with the given coefficients at the argument.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.getCoefficients	(	): Returns a copy of the coefficients array.  Changes made to the returned copy will not affect the coefficients of the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.hashCode	(	):  
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.multiply	(	PolynomialFunction	): Multiply the instance by a polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.negate	(	): Negate the instance.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.polynomialDerivative	(	): Returns the derivative as a PolynomialFunction.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.subtract	(	PolynomialFunction	): Subtract a polynomial from the instance.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.toString	(	): Returns a string representation of the polynomial. The representation is user oriented. Terms are displayed lowest degrees first. The multiplications signs, coefficients equals to one and null terms are not displayed (except if the polynomial is 0, in which case the 0 constant term is displayed). Addition of terms with negative coefficients are replaced by subtraction of terms with positive coefficients except for the first displayed term (i.e. we display -3 for a constant negative polynomial, but 1 - 3 x + x^2 if the negative coefficient is not the first one displayed).
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.toString	(	double	): Creates a string representing a coefficient, removing ".0" endings.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunction.value	(	double	): Compute the value of the function for the given argument.  The value returned is  coefficients[n] * x^n + ... + coefficients[1] * x + coefficients[0] 
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm: Implements the representation of a real polynomial function in  Lagrange Form. For reference, see Introduction to Numerical Analysis, ISBN 038795452X, chapter 2.  The approximated function should be smooth enough for Lagrange polynomial to work well. Otherwise, consider using splines instead.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.PolynomialFunctionLagrangeForm	(	double	double	): Construct a Lagrange polynomial with the given abscissas and function values. The order of interpolating points are not important.  The constructor makes copy of the input arrays and assigns them.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.computeCoefficients	(	): Calculate the coefficients of Lagrange polynomial from the interpolation data. It takes O(n^2) time. Note that this computation can be ill-conditioned: Use with caution and only when it is necessary.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.degree	(	): Returns the degree of the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.evaluate	(	double	double	double	): Evaluate the Lagrange polynomial using  Neville's Algorithm. It takes O(n^2) time.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.evaluateInternal	(	double	double	double	): Evaluate the Lagrange polynomial using  Neville's Algorithm. It takes O(n^2) time.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.getCoefficients	(	): Returns a copy of the coefficients array.  Changes made to the returned copy will not affect the polynomial.  Note that coefficients computation can be ill-conditioned. Use with caution and only when it is necessary.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.getInterpolatingPoints	(	): Returns a copy of the interpolating points array.  Changes made to the returned copy will not affect the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.getInterpolatingValues	(	): Returns a copy of the interpolating values array.  Changes made to the returned copy will not affect the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.value	(	double	): Calculate the function value at the given point.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeForm.verifyInterpolationArray	(	double	double	boolean	): Check that the interpolation arrays are valid. The arrays features checked by this method are that both arrays have the same length and this length is at least 2.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeFormTest: Test case for Lagrange form of polynomial function.  We use n+1 points to interpolate a polynomial of degree n. This should give us the exact same polynomial as result. Thus we can use a very small tolerance to account only for round-off errors.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeFormTest.testLinearFunction	(	): Test of polynomial for the linear function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeFormTest.testParameters	(	): Test of parameters for the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeFormTest.testQuadraticFunction	(	): Test of polynomial for the quadratic function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionLagrangeFormTest.testQuinticFunction	(	): Test of polynomial for the quintic function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm: Implements the representation of a real polynomial function in Newton Form. For reference, see Elementary Numerical Analysis, ISBN 0070124477, chapter 2.  The formula of polynomial in Newton form is p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... + a[n](x-c[0])(x-c[1])...(x-c[n-1]) Note that the length of a[] is one more than the length of c[]
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.PolynomialFunctionNewtonForm	(	double	double	): Construct a Newton polynomial with the given a[] and c[]. The order of centers are important in that if c[] shuffle, then values of a[] would completely change, not just a permutation of old a[].  The constructor makes copy of the input arrays and assigns them.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.computeCoefficients	(	): Calculate the normal polynomial coefficients given the Newton form. It also uses nested multiplication but takes O(N^2) time.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.degree	(	): Returns the degree of the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.evaluate	(	double	double	double	): Evaluate the Newton polynomial using nested multiplication. It is also called  Horner's Rule and takes O(N) time.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.getCenters	(	): Returns a copy of the centers array.  Changes made to the returned copy will not affect the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.getCoefficients	(	): Returns a copy of the coefficients array.  Changes made to the returned copy will not affect the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.getNewtonCoefficients	(	): Returns a copy of coefficients in Newton form formula.  Changes made to the returned copy will not affect the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.value	(	double	): Calculate the function value at the given point.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonForm.verifyInputArray	(	double	double	): Verifies that the input arrays are valid.  The centers must be distinct for interpolation purposes, but not for general use. Thus it is not verified here.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonFormTest: Test case for Newton form of polynomial function.  The small tolerance number is used only to account for round-off errors.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonFormTest.testDerivative	(	): Test for derivatives.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonFormTest.testLinearFunction	(	): Test of polynomial for the linear function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonFormTest.testParameters	(	): Test of parameters for the polynomial.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonFormTest.testQuadraticFunction	(	): Test of polynomial for the quadratic function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionNewtonFormTest.testQuinticFunction	(	): Test of polynomial for the quintic function.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest: Tests the PolynomialFunction implementation of a UnivariateFunction.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest.testConstants	(	): tests the value of a constant polynomial. value of this is 2.5 everywhere.
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest.testLinear	(	): tests the value of a linear polynomial. This will test the function f(x) = 3*x - 1.5 This will have the values f(0) = -1.5, f(-1) = -4.5, f(-2.5) = -9, f(0.5) = 0, f(1.5) = 3 and f(3) = 7.5 
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest.testMath341	(	): tests the firstDerivative function by comparison This will test the functions f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6 and h(x) = 6x - 4
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest.testQuadratic	(	): Tests a second order polynomial.  This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest.testQuintic	(	): This will test the quintic function f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2
org.apache.commons.math4.analysis.polynomials.PolynomialFunctionTest.testfirstDerivativeComparison	(	): tests the firstDerivative function by comparison This will test the functions f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6 and h(x) = 6x - 4
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction: Represents a polynomial spline function.  A polynomial spline function consists of a set of interpolating polynomials and an ascending array of domain knot points, determining the intervals over which the spline function is defined by the constituent polynomials. The polynomials are assumed to have been computed to match the values of another function at the knot points. The value consistency constraints are not currently enforced by PolynomialSplineFunction itself, but are assumed to hold among the polynomials and knot points passed to the constructor.  N.B.: The polynomials in the polynomials property must be centered on the knot points to compute the spline function values. See below.  The domain of the polynomial spline function is [smallest knot, largest knot]. Attempts to evaluate the function at values outside of this range generate IllegalArgumentExceptions.   The value of the polynomial spline function for an argument x is computed as follows:  The knot array is searched to find the segment to which x belongs. If x is less than the smallest knot point or greater than the largest one, an IllegalArgumentException is thrown.  Let j be the index of the largest knot point that is less than or equal to x. The value returned is polynomials[j](x - knot[j])
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.PolynomialSplineFunction	(	double	PolynomialFunction	): Construct a polynomial spline function with the given segment delimiters and interpolating polynomials. The constructor copies both arrays and assigns the copies to the knots and polynomials properties, respectively.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.getKnots	(	): Get an array copy of the knot points. It returns a fresh copy of the array. Changes made to the copy will not affect the knots property.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.getN	(	): Get the number of spline segments. It is also the number of polynomials and the number of knot points - 1.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.getPolynomials	(	): Get a copy of the interpolating polynomials array. It returns a fresh copy of the array. Changes made to the copy will not affect the polynomials property.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.isValidPoint	(	double	): Indicates whether a point is within the interpolation range.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.polynomialSplineDerivative	(	): Get the derivative of the polynomial spline function.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.value	(	DerivativeStructure	): Simple mathematical function. UnivariateDifferentiableFunction classes compute both the value and the first derivative of the function.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunction.value	(	double	): Compute the value for the function. See PolynomialSplineFunction for details on the algorithm for computing the value of the function.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunctionTest: Tests the PolynomialSplineFunction implementation.
org.apache.commons.math4.analysis.polynomials.PolynomialSplineFunctionTest.findKnot	(	double[]	double	): Do linear search to find largest knot point less than or equal to x. Implementation does binary search.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils: A collection of static methods that operate on or return polynomials.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.JacobiKey: Inner class for Jacobi polynomials keys. 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.JacobiKey.JacobiKey	(	int	int	): Simple constructor.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.JacobiKey.equals	(	Object	): Check if the instance represent the same key as another instance.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.JacobiKey.hashCode	(	): Get hash code.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.PolynomialsUtils	(	): Private constructor, to prevent instantiation.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.RecurrenceCoefficientsGenerator: Interface for recurrence coefficients generation. 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.RecurrenceCoefficientsGenerator.generate	(	int	): Generate recurrence coefficients.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.buildPolynomial	(	int	List	RecurrenceCoefficientsGenerator	): Get the coefficients array for a given degree.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.computeUpToDegree	(	int	int	RecurrenceCoefficientsGenerator	List	): Compute polynomial coefficients up to a given degree.
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.createChebyshevPolynomial	(	int	): Create a Chebyshev polynomial of the first kind. Chebyshev polynomials of the first kind are orthogonal polynomials. They can be defined by the following recurrence relations: \( T_0(x) = 1 \\ T_1(x) = x \\ T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x) \) 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.createHermitePolynomial	(	int	): Create a Hermite polynomial. Hermite polynomials are orthogonal polynomials. They can be defined by the following recurrence relations: \( H_0(x) = 1 \\ H_1(x) = 2x \\ H_{k+1}(x) = 2x H_k(X) - 2k H_{k-1}(x) \) 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.createJacobiPolynomial	(	int	int	int	): Create a Jacobi polynomial. Jacobi polynomials are orthogonal polynomials. They can be defined by the following recurrence relations: \( P_0^{vw}(x) = 1 \\ P_{-1}^{vw}(x) = 0 \\ 2k(k + v + w)(2k + v + w - 2) P_k^{vw}(x) = \\ (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) x + v^2 - w^2] P_{k-1}^{vw}(x) \\ - 2(k + v - 1)(k + w - 1)(2k + v + w) P_{k-2}^{vw}(x) \) 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.createLaguerrePolynomial	(	int	): Create a Laguerre polynomial. Laguerre polynomials are orthogonal polynomials. They can be defined by the following recurrence relations: \( L_0(x) = 1 \\ L_1(x) = 1 - x \\ (k+1) L_{k+1}(x) = (2k + 1 - x) L_k(x) - k L_{k-1}(x) \) 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.createLegendrePolynomial	(	int	): Create a Legendre polynomial. Legendre polynomials are orthogonal polynomials. They can be defined by the following recurrence relations: \( P_0(x) = 1 \\ P_1(x) = x \\ (k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x) \) 
org.apache.commons.math4.analysis.polynomials.PolynomialsUtils.shift	(	double[]	double	): Compute the coefficients of the polynomial \(P_s(x)\) whose values at point x will be the same as the those from the original polynomial \(P(x)\) when computed at x + shift.  More precisely, let \(\Delta = \) shift and let \(P_s(x) = P(x + \Delta)\). The returned array consists of the coefficients of \(P_s\). So if \(a_0, ..., a_{n-1}\) are the coefficients of \(P\), then the returned array \(b_0, ..., b_{n-1}\) satisfies the identity \(\sum_{i=0}^{n-1} b_i x^i = \sum_{i=0}^{n-1} a_i (x + \Delta)^i\) for all \(x\).
org.apache.commons.math4.analysis.polynomials.PolynomialsUtilsTest: Tests the PolynomialsUtils class.
org.apache.commons.math4.analysis.solvers.AbstractPolynomialSolver: Base class for solvers.
org.apache.commons.math4.analysis.solvers.AbstractPolynomialSolver.AbstractPolynomialSolver	(	double	): Construct a solver with given absolute accuracy.
org.apache.commons.math4.analysis.solvers.AbstractPolynomialSolver.AbstractPolynomialSolver	(	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.AbstractPolynomialSolver.AbstractPolynomialSolver	(	double	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.AbstractPolynomialSolver.getCoefficients	(	): 
org.apache.commons.math4.analysis.solvers.AbstractPolynomialSolver.setup	(	int	PolynomialFunction	double	double	double	): 
org.apache.commons.math4.analysis.solvers.AbstractUnivariateDifferentiableSolver: Provide a default implementation for several functions useful to generic solvers.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateDifferentiableSolver.AbstractUnivariateDifferentiableSolver	(	double	): Construct a solver with given absolute accuracy.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateDifferentiableSolver.AbstractUnivariateDifferentiableSolver	(	double	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateDifferentiableSolver.computeObjectiveValueAndDerivative	(	double	): Compute the objective function value.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateDifferentiableSolver.setup	(	int	UnivariateDifferentiableFunction	double	double	double	): 
org.apache.commons.math4.analysis.solvers.AbstractUnivariateSolver: Base class for solvers.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateSolver.AbstractUnivariateSolver	(	double	): Construct a solver with given absolute accuracy.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateSolver.AbstractUnivariateSolver	(	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.AbstractUnivariateSolver.AbstractUnivariateSolver	(	double	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver: Provide a default implementation for several functions useful to generic solvers. The default values for relative and function tolerances are 1e-14 and 1e-15, respectively. It is however highly recommended to not rely on the default, but rather carefully consider values that match user's expectations, as well as the specifics of each implementation.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver	(	double	): Construct a solver with given absolute accuracy.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver	(	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver	(	double	double	double	): Construct a solver with given accuracies.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.computeObjectiveValue	(	double	): Compute the objective function value.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getAbsoluteAccuracy	(	): Get the absolute accuracy of the solver. Solutions returned by the solver should be accurate to this tolerance, i.e., if ε is the absolute accuracy of the solver and v is a value returned by one of the solve methods, then a root of the function should exist somewhere in the interval (v - ε, v + ε).
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getEvaluations	(	): Get the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet. 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getFunctionValueAccuracy	(	): Get the function value accuracy of the solver. If v is a value returned by the solver for a function f, then by contract, |f(v)| should be less than or equal to the function value accuracy configured for the solver.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getMax	(	): 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getMaxEvaluations	(	): Get the maximum number of function evaluations. 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getMin	(	): 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getRelativeAccuracy	(	): Get the relative accuracy of the solver. The contract for relative accuracy is the same as getAbsoluteAccuracy(), but using relative, rather than absolute error. If ρ is the relative accuracy configured for a solver and v is a value returned, then a root of the function should exist somewhere in the interval (v - ρ v, v + ρ v).
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.getStartValue	(	): 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.incrementEvaluationCount	(	): Increment the evaluation count by one. Method computeObjectiveValue() calls this method internally. It is provided for subclasses that do not exclusively use computeObjectiveValue to solve the function. See e.g. AbstractUnivariateDifferentiableSolver.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.isBracketing	(	double	double	): Check whether the function takes opposite signs at the endpoints.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.isSequence	(	double	double	double	): Check whether the arguments form a (strictly) increasing sequence.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.setup	(	int	FUNC	double	double	double	): Prepare for computation. Subclasses must call this method if they override any of the solve methods.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.solve	(	int	FUNC	double	): Solve for a zero in the vicinity of startValue. 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.solve	(	int	FUNC	double	double	): Solve for a zero root in the given interval. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root. 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.solve	(	int	FUNC	double	double	double	): Solve for a zero in the given interval, start at startValue. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root. 
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.verifyBracketing	(	double	double	): Check that the endpoints specify an interval and the function takes opposite signs at the endpoints.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.verifyInterval	(	double	double	): Check that the endpoints specify an interval.
org.apache.commons.math4.analysis.solvers.BaseAbstractUnivariateSolver.verifySequence	(	double	double	double	): Check that lower < initial < upper.
org.apache.commons.math4.analysis.solvers.BaseSecantSolver: Base class for all bracketing Secant-based methods for root-finding (approximating a zero of a univariate real function). Implementation of the RegulaFalsiSolver Regula Falsi and IllinoisSolver Illinois methods is based on the following article: M. Dowell and P. Jarratt, A modified regula falsi method for computing the root of an equation, BIT Numerical Mathematics, volume 11, number 2, pages 168-174, Springer, 1971. Implementation of the PegasusSolver Pegasus method is based on the following article: M. Dowell and P. Jarratt, The "Pegasus" method for computing the root of an equation, BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer, 1972. The SecantSolver Secant method is not a bracketing method, so it is not implemented here. It has a separate implementation.
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.BaseSecantSolver	(	double	Method	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.BaseSecantSolver	(	double	double	Method	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.BaseSecantSolver	(	double	double	double	Method	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.solve	(	int	UnivariateFunction	double	double	AllowedSolution	):  
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.solve	(	int	UnivariateFunction	double	double	double	):  
org.apache.commons.math4.analysis.solvers.BaseSecantSolver.solve	(	int	UnivariateFunction	double	double	double	AllowedSolution	):  
org.apache.commons.math4.analysis.solvers.BaseSecantSolverAbstractTest: Base class for root-finding algorithms tests derived from BaseSecantSolver.
org.apache.commons.math4.analysis.solvers.BaseSecantSolverAbstractTest.getQuinticEvalCounts	(	): Returns the expected number of evaluations for the testQuinticZero unit test. A value of -1 indicates that the test should be skipped for that solver.
org.apache.commons.math4.analysis.solvers.BaseSecantSolverAbstractTest.getSolver	(	): Returns the solver to use to perform the tests.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver: Interface for (univariate real) rootfinding algorithms. Implementations will search for only one zero in the given interval. This class is not intended for use outside of the Apache Commons Math library, regular user should rely on more specific interfaces like UnivariateSolver, PolynomialSolver or UnivariateDifferentiableSolver.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.getAbsoluteAccuracy	(	): Get the absolute accuracy of the solver. Solutions returned by the solver should be accurate to this tolerance, i.e., if ε is the absolute accuracy of the solver and v is a value returned by one of the solve methods, then a root of the function should exist somewhere in the interval (v - ε, v + ε).
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.getEvaluations	(	): Get the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.getFunctionValueAccuracy	(	): Get the function value accuracy of the solver. If v is a value returned by the solver for a function f, then by contract, |f(v)| should be less than or equal to the function value accuracy configured for the solver.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.getMaxEvaluations	(	): Get the maximum number of function evaluations.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.getRelativeAccuracy	(	): Get the relative accuracy of the solver. The contract for relative accuracy is the same as getAbsoluteAccuracy(), but using relative, rather than absolute error. If ρ is the relative accuracy configured for a solver and v is a value returned, then a root of the function should exist somewhere in the interval (v - ρ v, v + ρ v).
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.solve	(	int	FUNC	double	): Solve for a zero in the vicinity of startValue.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.solve	(	int	FUNC	double	double	): Solve for a zero root in the given interval. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.BaseUnivariateSolver.solve	(	int	FUNC	double	double	double	): Solve for a zero in the given interval, start at startValue. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.BisectionSolver: Implements the  bisection algorithm for finding zeros of univariate real functions.  The function should be continuous but not necessarily smooth.
org.apache.commons.math4.analysis.solvers.BisectionSolver.BisectionSolver	(	): Construct a solver with default accuracy (1e-6).
org.apache.commons.math4.analysis.solvers.BisectionSolver.BisectionSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BisectionSolver.BisectionSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BisectionSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver: Interface for UnivariateSolver (univariate real) root-finding algorithms that maintain a bracketed solution. There are several advantages to having such root-finding algorithms:  The bracketed solution guarantees that the root is kept within the interval. As such, these algorithms generally also guarantee convergence. The bracketed solution means that we have the opportunity to only return roots that are greater than or equal to the actual root, or are less than or equal to the actual root. That is, we can control whether under-approximations and over-approximations are AllowedSolution allowed solutions. Other root-finding algorithms can usually only guarantee that the solution (the root that was found) is around the actual root.  For backwards compatibility, all root-finding algorithms must have ANY_SIDE as default for the allowed solutions.
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.getAbsoluteAccuracy	(	): Get the absolute accuracy of the solver. Solutions returned by the solver should be accurate to this tolerance, i.e., if ε is the absolute accuracy of the solver and v is a value returned by one of the solve methods, then a root of the function should exist somewhere in the interval (v - ε, v + ε).
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.getEvaluations	(	): Get the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet.
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.getFunctionValueAccuracy	(	): Get the function value accuracy of the solver. If v is a value returned by the solver for a function f, then by contract, |f(v)| should be less than or equal to the function value accuracy configured for the solver.
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.getMaxEvaluations	(	): Get the maximum number of function evaluations.
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.getRelativeAccuracy	(	): Get the relative accuracy of the solver. The contract for relative accuracy is the same as getAbsoluteAccuracy(), but using relative, rather than absolute error. If ρ is the relative accuracy configured for a solver and v is a value returned, then a root of the function should exist somewhere in the interval (v - ρ v, v + ρ v).
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.solve	(	int	RealFieldUnivariateFunction	T	T	AllowedSolution	): Solve for a zero in the given interval. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.BracketedRealFieldUnivariateSolver.solve	(	int	RealFieldUnivariateFunction	T	T	T	AllowedSolution	): Solve for a zero in the given interval, start at startValue. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.BracketedUnivariateSolver: Interface for UnivariateSolver (univariate real) root-finding algorithms that maintain a bracketed solution. There are several advantages to having such root-finding algorithms:  The bracketed solution guarantees that the root is kept within the interval. As such, these algorithms generally also guarantee convergence. The bracketed solution means that we have the opportunity to only return roots that are greater than or equal to the actual root, or are less than or equal to the actual root. That is, we can control whether under-approximations and over-approximations are AllowedSolution allowed solutions. Other root-finding algorithms can usually only guarantee that the solution (the root that was found) is around the actual root.  For backwards compatibility, all root-finding algorithms must have ANY_SIDE as default for the allowed solutions.
org.apache.commons.math4.analysis.solvers.BracketedUnivariateSolver.solve	(	int	FUNC	double	double	AllowedSolution	): Solve for a zero in the given interval. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.BracketedUnivariateSolver.solve	(	int	FUNC	double	double	double	AllowedSolution	): Solve for a zero in the given interval, start at startValue. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver: This class implements a modification of the  Brent algorithm.  The changes with respect to the original Brent algorithm are:  the returned value is chosen in the current interval according to user specified AllowedSolution, the maximal order for the invert polynomial root search is user-specified instead of being invert quadratic only  The given interval must bracket the root.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver	(	): Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver	(	double	double	double	int	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver	(	double	double	int	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver	(	double	int	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.getMaximalOrder	(	): Get the maximal order.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.guessX	(	double	double[]	double[]	int	int	): Guess an x value by nth order inverse polynomial interpolation.  The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q is built such that for all considered points (xi, yi), Q(yi) = xi. 
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.solve	(	int	UnivariateFunction	double	double	AllowedSolution	):  
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolver.solve	(	int	UnivariateFunction	double	double	double	AllowedSolution	):  
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolverTest: Test case for BracketingNthOrderBrentSolver bracketing nth order Brent solver.
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolverTest.getQuinticEvalCounts	(	): Returns the expected number of evaluations for the testQuinticZero unit test. A value of -1 indicates that the test should be skipped for that solver. 
org.apache.commons.math4.analysis.solvers.BracketingNthOrderBrentSolverTest.getSolver	(	): Returns the solver to use to perform the tests. 
org.apache.commons.math4.analysis.solvers.BrentSolver: This class implements the  Brent algorithm for finding zeros of real univariate functions. The function should be continuous but not necessarily smooth. The solve method returns a zero x of the function f in the given interval [a, b] to within a tolerance 2 eps abs(x) + t where eps is the relative accuracy and t is the absolute accuracy. The given interval must bracket the root.  The reference implementation is given in chapter 4 of  Algorithms for Minimization Without Derivatives, Richard P. Brent, Dover, 2002 
org.apache.commons.math4.analysis.solvers.BrentSolver.BrentSolver	(	): Construct a solver with default absolute accuracy (1e-6).
org.apache.commons.math4.analysis.solvers.BrentSolver.BrentSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BrentSolver.BrentSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BrentSolver.BrentSolver	(	double	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.BrentSolver.brent	(	double	double	double	double	): Search for a zero inside the provided interval. This implementation is based on the algorithm described at page 58 of the book  Algorithms for Minimization Without Derivatives, Richard P. Brent, Dover 0-486-41998-3 
org.apache.commons.math4.analysis.solvers.BrentSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.BrentSolverTest: Test case for BrentSolver Brent solver. Because Brent-Dekker is guaranteed to converge in less than the default maximum iteration count due to bisection fallback, it is quite hard to debug. I include measured iteration counts plus one in order to detect regressions. On average Brent-Dekker should use 4..5 iterations for the default absolute accuracy of 10E-8 for sinus and the quintic function around zero, and 5..10 iterations for the other zeros.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver: This class implements a modification of the  Brent algorithm.  The changes with respect to the original Brent algorithm are:  the returned value is chosen in the current interval according to user specified AllowedSolution the maximal order for the invert polynomial root search is user-specified instead of being invert quadratic only  The given interval must bracket the root.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.FieldBracketingNthOrderBrentSolver	(	T	T	T	int	): Construct a solver.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.getAbsoluteAccuracy	(	): Get the absolute accuracy.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.getEvaluations	(	): Get the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.getFunctionValueAccuracy	(	): Get the function accuracy.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.getMaxEvaluations	(	): Get the maximal number of function evaluations.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.getMaximalOrder	(	): Get the maximal order.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.getRelativeAccuracy	(	): Get the relative accuracy.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.guessX	(	T	T[]	T[]	int	int	): Guess an x value by nth order inverse polynomial interpolation.  The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q is built such that for all considered points (xi, yi), Q(yi) = xi. 
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.solve	(	int	RealFieldUnivariateFunction	T	T	AllowedSolution	): Solve for a zero in the given interval. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.solve	(	int	RealFieldUnivariateFunction	T	T	T	AllowedSolution	): Solve for a zero in the given interval, start at startValue. A solver may require that the interval brackets a single zero root. Solvers that do require bracketing should be able to handle the case where one of the endpoints is itself a root.
org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolverTest: Test case for FieldBracketingNthOrderBrentSolver bracketing nth order Brent solver.
org.apache.commons.math4.analysis.solvers.IllinoisSolver: Implements the Illinois method for root-finding (approximating a zero of a univariate real function). It is a modified RegulaFalsiSolver Regula Falsi method. Like the Regula Falsi method, convergence is guaranteed by maintaining a bracketed solution. The Illinois method however, should converge much faster than the original Regula Falsi method. Furthermore, this implementation of the Illinois method should not suffer from the same implementation issues as the Regula Falsi method, which may fail to convergence in certain cases. The Illinois method assumes that the function is continuous, but not necessarily smooth. Implementation based on the following article: M. Dowell and P. Jarratt, A modified regula falsi method for computing the root of an equation, BIT Numerical Mathematics, volume 11, number 2, pages 168-174, Springer, 1971.
org.apache.commons.math4.analysis.solvers.IllinoisSolver.IllinoisSolver	(	): Construct a solver with default accuracy (1e-6). 
org.apache.commons.math4.analysis.solvers.IllinoisSolver.IllinoisSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.IllinoisSolver.IllinoisSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.IllinoisSolver.IllinoisSolver	(	double	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.IllinoisSolverTest: Test case for IllinoisSolver Illinois solver.
org.apache.commons.math4.analysis.solvers.IllinoisSolverTest.getQuinticEvalCounts	(	): Returns the expected number of evaluations for the testQuinticZero unit test. A value of -1 indicates that the test should be skipped for that solver. 
org.apache.commons.math4.analysis.solvers.IllinoisSolverTest.getSolver	(	): Returns the solver to use to perform the tests. 
org.apache.commons.math4.analysis.solvers.LaguerreSolver: Implements the  Laguerre's Method for root finding of real coefficient polynomials. For reference, see  A First Course in Numerical Analysis, ISBN 048641454X, chapter 8.  Laguerre's method is global in the sense that it can start with any initial approximation and be able to solve all roots from that point. The algorithm requires a bracketing condition.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.ComplexSolver: Class for searching all (complex) roots.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.ComplexSolver.isRoot	(	double	double	Complex	): Check whether the given complex root is actually a real zero in the given interval, within the solver tolerance level.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.ComplexSolver.solve	(	Complex	Complex	): Find a complex root for the polynomial with the given coefficients, starting from the given initial value.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.ComplexSolver.solveAll	(	Complex	Complex	): Find all complex roots for the polynomial with the given coefficients, starting from the given initial value.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.LaguerreSolver	(	): Construct a solver with default accuracy (1e-6).
org.apache.commons.math4.analysis.solvers.LaguerreSolver.LaguerreSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.LaguerreSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.LaguerreSolver	(	double	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.laguerre	(	double	double	): Find a real root in the given interval. Despite the bracketing condition, the root returned by solve() may not be a real zero inside [min, max]. For example,  p(x) = x3 + 1,  with min = -2, max = 2, initial = 0. When it occurs, this code calls solveAll() in order to obtain all roots and picks up one real root.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.solveAllComplex	(	double[]	double	): Find all complex roots for the polynomial with the given coefficients, starting from the given initial value.  Note: This method is not part of the API of BaseUnivariateSolver.
org.apache.commons.math4.analysis.solvers.LaguerreSolver.solveComplex	(	double[]	double	): Find a complex root for the polynomial with the given coefficients, starting from the given initial value.  Note: This method is not part of the API of BaseUnivariateSolver.
org.apache.commons.math4.analysis.solvers.LaguerreSolverTest: Test case for Laguerre solver.  Laguerre's method is very efficient in solving polynomials. Test runs show that for a default absolute accuracy of 1E-6, it generally takes less than 5 iterations to find one root, provided solveAll() is not invoked, and 15 to 20 iterations to find all roots for quintic function.
org.apache.commons.math4.analysis.solvers.LaguerreSolverTest.testLinearFunction	(	): Test of solver for the linear function.
org.apache.commons.math4.analysis.solvers.LaguerreSolverTest.testParameters	(	): Test of parameters for the solver.
org.apache.commons.math4.analysis.solvers.LaguerreSolverTest.testQuadraticFunction	(	): Test of solver for the quadratic function.
org.apache.commons.math4.analysis.solvers.LaguerreSolverTest.testQuinticFunction	(	): Test of solver for the quintic function.
org.apache.commons.math4.analysis.solvers.LaguerreSolverTest.testQuinticFunction2	(	): Test of solver for the quintic function using solveAllComplex().
org.apache.commons.math4.analysis.solvers.MullerSolver: This class implements the  Muller's Method for root finding of real univariate functions. For reference, see Elementary Numerical Analysis, ISBN 0070124477, chapter 3.  Muller's method applies to both real and complex functions, but here we restrict ourselves to real functions. This class differs from MullerSolver in the way it avoids complex operations. Muller's original method would have function evaluation at complex point. Since our f(x) is real, we have to find ways to avoid that. Bracketing condition is one way to go: by requiring bracketing in every iteration, the newly computed approximation is guaranteed to be real.  Normally Muller's method converges quadratically in the vicinity of a zero, however it may be very slow in regions far away from zeros. For example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use bisection as a safety backup if it performs very poorly.  The formulas here use divided differences directly.
org.apache.commons.math4.analysis.solvers.MullerSolver.MullerSolver	(	): Construct a solver with default accuracy (1e-6).
org.apache.commons.math4.analysis.solvers.MullerSolver.MullerSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.MullerSolver.MullerSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.MullerSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.MullerSolver.solve	(	double	double	double	double	): Find a real root in the given interval.
org.apache.commons.math4.analysis.solvers.MullerSolver2: This class implements the  Muller's Method for root finding of real univariate functions. For reference, see Elementary Numerical Analysis, ISBN 0070124477, chapter 3.  Muller's method applies to both real and complex functions, but here we restrict ourselves to real functions. This class differs from MullerSolver in the way it avoids complex operations. Except for the initial [min, max], it does not require bracketing condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If a complex number arises in the computation, we simply use its modulus as a real approximation.  Because the interval may not be bracketing, the bisection alternative is not applicable here. However in practice our treatment usually works well, especially near real zeroes where the imaginary part of the complex approximation is often negligible.  The formulas here do not use divided differences directly.
org.apache.commons.math4.analysis.solvers.MullerSolver2.MullerSolver2	(	): Construct a solver with default accuracy (1e-6).
org.apache.commons.math4.analysis.solvers.MullerSolver2.MullerSolver2	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.MullerSolver2.MullerSolver2	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.MullerSolver2.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.MullerSolver2Test: Test case for MullerSolver2 Muller solver.  Muller's method converges almost quadratically near roots, but it can be very slow in regions far away from zeros. Test runs show that for reasonably good initial values, for a default absolute accuracy of 1E-6, it generally takes 5 to 10 iterations for the solver to converge.  Tests for the exponential function illustrate the situations where Muller solver performs poorly.
org.apache.commons.math4.analysis.solvers.MullerSolver2Test.testExpm1Function	(	): Test of solver for the exponential function.  It takes 25 to 50 iterations for the last two tests to converge.
org.apache.commons.math4.analysis.solvers.MullerSolver2Test.testParameters	(	): Test of parameters for the solver.
org.apache.commons.math4.analysis.solvers.MullerSolver2Test.testQuinticFunction	(	): Test of solver for the quintic function.
org.apache.commons.math4.analysis.solvers.MullerSolver2Test.testSinFunction	(	): Test of solver for the sine function.
org.apache.commons.math4.analysis.solvers.MullerSolverTest: Test case for MullerSolver Muller solver.  Muller's method converges almost quadratically near roots, but it can be very slow in regions far away from zeros. Test runs show that for reasonably good initial values, for a default absolute accuracy of 1E-6, it generally takes 5 to 10 iterations for the solver to converge.  Tests for the exponential function illustrate the situations where Muller solver performs poorly.
org.apache.commons.math4.analysis.solvers.MullerSolverTest.testExpm1Function	(	): Test of solver for the exponential function.  It takes 10 to 15 iterations for the last two tests to converge. In fact, if not for the bisection alternative, the solver would exceed the default maximal iteration of 100.
org.apache.commons.math4.analysis.solvers.MullerSolverTest.testParameters	(	): Test of parameters for the solver.
org.apache.commons.math4.analysis.solvers.MullerSolverTest.testQuinticFunction	(	): Test of solver for the quintic function.
org.apache.commons.math4.analysis.solvers.MullerSolverTest.testSinFunction	(	): Test of solver for the sine function.
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolver: Implements  Newton's Method for finding zeros of real univariate differentiable functions.
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolver.NewtonRaphsonSolver	(	): Construct a solver.
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolver.NewtonRaphsonSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolver.solve	(	int	UnivariateDifferentiableFunction	double	double	): Find a zero near the midpoint of min and max.
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolverTest.testQuinticZero	(	): 
org.apache.commons.math4.analysis.solvers.NewtonRaphsonSolverTest.testSinZero	(	): 
org.apache.commons.math4.analysis.solvers.PegasusSolver: Implements the Pegasus method for root-finding (approximating a zero of a univariate real function). It is a modified RegulaFalsiSolver Regula Falsi method. Like the Regula Falsi method, convergence is guaranteed by maintaining a bracketed solution. The Pegasus method however, should converge much faster than the original Regula Falsi method. Furthermore, this implementation of the Pegasus method should not suffer from the same implementation issues as the Regula Falsi method, which may fail to convergence in certain cases. Also, the Pegasus method should converge faster than the IllinoisSolver Illinois method, another Regula Falsi-based method. The Pegasus method assumes that the function is continuous, but not necessarily smooth. Implementation based on the following article: M. Dowell and P. Jarratt, The "Pegasus" method for computing the root of an equation, BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer, 1972.
org.apache.commons.math4.analysis.solvers.PegasusSolver.PegasusSolver	(	): Construct a solver with default accuracy (1e-6). 
org.apache.commons.math4.analysis.solvers.PegasusSolver.PegasusSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.PegasusSolver.PegasusSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.PegasusSolver.PegasusSolver	(	double	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.PegasusSolverTest: Test case for PegasusSolver Pegasus solver.
org.apache.commons.math4.analysis.solvers.PegasusSolverTest.getQuinticEvalCounts	(	): Returns the expected number of evaluations for the testQuinticZero unit test. A value of -1 indicates that the test should be skipped for that solver. 
org.apache.commons.math4.analysis.solvers.PegasusSolverTest.getSolver	(	): Returns the solver to use to perform the tests. 
org.apache.commons.math4.analysis.solvers.PolynomialSolver: Interface for (polynomial) root-finding algorithms. Implementations will search for only one zero in the given interval.
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolver: Implements the Regula Falsi or False position method for root-finding (approximating a zero of a univariate real function). It is a modified SecantSolver Secant method. The Regula Falsi method is included for completeness, for testing purposes, for educational purposes, for comparison to other algorithms, etc. It is however not intended to be used for actual problems, as one of the bounds often remains fixed, resulting in very slow convergence. Instead, one of the well-known modified Regula Falsi algorithms can be used (IllinoisSolver Illinois or PegasusSolver Pegasus). These two algorithms solve the fundamental issues of the original Regula Falsi algorithm, and greatly out-performs it for most, if not all, (practical) functions. Unlike the Secant method, the Regula Falsi guarantees convergence, by maintaining a bracketed solution. Note however, that due to the finite/limited precision of Java's Double double type, which is used in this implementation, the algorithm may get stuck in a situation where it no longer makes any progress. Such cases are detected and result in a ConvergenceException exception being thrown. In other words, the algorithm theoretically guarantees convergence, but the implementation does not. The Regula Falsi method assumes that the function is continuous, but not necessarily smooth. Implementation based on the following article: M. Dowell and P. Jarratt, A modified regula falsi method for computing the root of an equation, BIT Numerical Mathematics, volume 11, number 2, pages 168-174, Springer, 1971.
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolver.RegulaFalsiSolver	(	): Construct a solver with default accuracy (1e-6). 
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolver.RegulaFalsiSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolver.RegulaFalsiSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolver.RegulaFalsiSolver	(	double	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolverTest: Test case for RegulaFalsiSolver Regula Falsi solver.
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolverTest.getQuinticEvalCounts	(	): Returns the expected number of evaluations for the testQuinticZero unit test. A value of -1 indicates that the test should be skipped for that solver. 
org.apache.commons.math4.analysis.solvers.RegulaFalsiSolverTest.getSolver	(	): Returns the solver to use to perform the tests. 
org.apache.commons.math4.analysis.solvers.RiddersSolver: Implements the  Ridders' Method for root finding of real univariate functions. For reference, see C. Ridders, A new algorithm for computing a single root of a real continuous function , IEEE Transactions on Circuits and Systems, 26 (1979), 979 - 980.  The function should be continuous but not necessarily smooth.
org.apache.commons.math4.analysis.solvers.RiddersSolver.RiddersSolver	(	): Construct a solver with default accuracy (1e-6).
org.apache.commons.math4.analysis.solvers.RiddersSolver.RiddersSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.RiddersSolver.RiddersSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.RiddersSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes.
org.apache.commons.math4.analysis.solvers.RiddersSolverTest: Test case for RiddersSolver Ridders solver.  Ridders' method converges superlinearly, more specific, its rate of convergence is sqrt(2). Test runs show that for a default absolute accuracy of 1E-6, it generally takes less than 5 iterations for close initial bracket and 5 to 10 iterations for distant initial bracket to converge.
org.apache.commons.math4.analysis.solvers.RiddersSolverTest.testExpm1Function	(	): Test of solver for the exponential function.
org.apache.commons.math4.analysis.solvers.RiddersSolverTest.testParameters	(	): Test of parameters for the solver.
org.apache.commons.math4.analysis.solvers.RiddersSolverTest.testQuinticFunction	(	): Test of solver for the quintic function.
org.apache.commons.math4.analysis.solvers.RiddersSolverTest.testSinFunction	(	): Test of solver for the sine function.
org.apache.commons.math4.analysis.solvers.SecantSolver: Implements the Secant method for root-finding (approximating a zero of a univariate real function). The solution that is maintained is not bracketed, and as such convergence is not guaranteed. Implementation based on the following article: M. Dowell and P. Jarratt, A modified regula falsi method for computing the root of an equation, BIT Numerical Mathematics, volume 11, number 2, pages 168-174, Springer, 1971. Note that since release 3.0 this class implements the actual Secant algorithm, and not a modified one. As such, the 3.0 version is not backwards compatible with previous versions. To use an algorithm similar to the pre-3.0 releases, use the IllinoisSolver Illinois algorithm or the PegasusSolver Pegasus algorithm.
org.apache.commons.math4.analysis.solvers.SecantSolver.SecantSolver	(	): Construct a solver with default accuracy (1e-6). 
org.apache.commons.math4.analysis.solvers.SecantSolver.SecantSolver	(	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.SecantSolver.SecantSolver	(	double	double	): Construct a solver.
org.apache.commons.math4.analysis.solvers.SecantSolver.doSolve	(	): Method for implementing actual optimization algorithms in derived classes. 
org.apache.commons.math4.analysis.solvers.SecantSolverTest: Test case for SecantSolver Secant solver.
org.apache.commons.math4.analysis.solvers.SecantSolverTest.getQuinticEvalCounts	(	): Returns the expected number of evaluations for the testQuinticZero unit test. A value of -1 indicates that the test should be skipped for that solver. 
org.apache.commons.math4.analysis.solvers.SecantSolverTest.getSolver	(	): Returns the solver to use to perform the tests. 
org.apache.commons.math4.analysis.solvers.UnivariateDifferentiableSolver: Interface for (univariate real) rootfinding algorithms. Implementations will search for only one zero in the given interval.
org.apache.commons.math4.analysis.solvers.UnivariateSolver: Interface for (univariate real) root-finding algorithms. Implementations will search for only one zero in the given interval.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils: Utility routines for UnivariateSolver objects.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.UnivariateSolverUtils	(	): Class contains only static methods.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.bracket	(	UnivariateFunction	double	double	double	): This method simply calls bracket() bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations) with q and r set to 1.0 and maximumIterations set to Integer.MAX_VALUE.  Note:  this method can take Integer.MAX_VALUE iterations to throw a ConvergenceException. Unless you are confident that there is a root between lowerBound and upperBound near initial, it is better to use bracket() bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations), explicitly specifying the maximum number of iterations.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.bracket	(	UnivariateFunction	double	double	double	double	double	int	): This method attempts to find two values a and b satisfying   lowerBound <= a < initial < b <= upperBound   f(a) * f(b) <= 0   If f is continuous on [a,b], this means that a and b bracket a root of f.  The algorithm checks the sign of \( f(l_k) \) and \( f(u_k) \) for increasing values of k, where \( l_k = max(lower, initial - \delta_k) \), \( u_k = min(upper, initial + \delta_k) \), using recurrence \( \delta_{k+1} = r \delta_k + q, \delta_0 = 0\) and starting search with \( k=1 \). The algorithm stops when one of the following happens:   at least one positive and one negative value have been found -- success!  both endpoints have reached their respective limits -- NoBracketingException   maximumIterations iterations elapse -- NoBracketingException   If different signs are found at first iteration (k=1), then the returned interval will be \( [a, b] = [l_1, u_1] \). If different signs are found at a later iteration k>1, then the returned interval will be either \( [a, b] = [l_{k+1}, l_{k}] \) or \( [a, b] = [u_{k}, u_{k+1}] \). A root solver called with these parameters will therefore start with the smallest bracketing interval known at this step.   Interval expansion rate is tuned by changing the recurrence parameters r and q. When the multiplicative factor r is set to 1, the sequence is a simple arithmetic sequence with linear increase. When the multiplicative factor r is larger than 1, the sequence has an asymptotically exponential rate. Note than the additive parameter q should never be set to zero, otherwise the interval would degenerate to the single initial point for all values of k.   As a rule of thumb, when the location of the root is expected to be approximately known within some error margin, r should be set to 1 and q should be set to the order of magnitude of the error margin. When the location of the root is really a wild guess, then r should be set to a value larger than 1 (typically 2 to double the interval length at each iteration) and q should be set according to half the initial search interval length.   As an example, if we consider the trivial function f(x) = 1 - x and use initial = 4, r = 1, q = 2, the algorithm will compute f(4-2) = f(2) = -1 and f(4+2) = f(6) = -5 for k = 1, then f(4-4) = f(0) = +1 and f(4+4) = f(8) = -7 for k = 2. Then it will return the interval [0, 2] as the smallest one known to be bracketing the root. As shown by this example, the initial value (here 4) may lie outside of the returned bracketing interval. 
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.bracket	(	UnivariateFunction	double	double	double	int	): This method simply calls bracket() bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations) with q and r set to 1.0.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.forceSide	(	int	UnivariateFunction	BracketedUnivariateSolver	double	double	double	AllowedSolution	): Force a root found by a non-bracketing solver to lie on a specified side, as if the solver were a bracketing one.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.isBracketing	(	UnivariateFunction	double	double	): Check whether the interval bounds bracket a root. That is, if the values at the endpoints are not equal to zero, then the function takes opposite signs at the endpoints.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.isSequence	(	double	double	double	): Check whether the arguments form a (strictly) increasing sequence.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.midpoint	(	double	double	): Compute the midpoint of two values.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.solve	(	UnivariateFunction	double	double	): Convenience method to find a zero of a univariate real function. A default solver is used.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.solve	(	UnivariateFunction	double	double	double	): Convenience method to find a zero of a univariate real function. A default solver is used.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.verifyBracketing	(	UnivariateFunction	double	double	): Check that the endpoints specify an interval and the end points bracket a root.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.verifyInterval	(	double	double	): Check that the endpoints specify an interval.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtils.verifySequence	(	double	double	double	): Check that lower < initial < upper.
org.apache.commons.math4.analysis.solvers.UnivariateSolverUtilsTest.testBracketLoopConditionForB	(	): check the search continues when a = lowerBound and b < upperBound. 
org.apache.commons.math4.complex.Complex: Representation of a Complex number, i.e. a number which has both a real and imaginary part.  Implementations of arithmetic operations handle NaN and infinite values according to the rules for java.lang.Double, i.e. equals is an equivalence relation for all instances that have a NaN in either real or imaginary part, e.g. the following are considered equal:  1 + NaNi NaN + i NaN + NaNi  Note that this contradicts the IEEE-754 standard for floating point numbers (according to which the test x == x must fail if x is NaN). The method equals() equals for primitive double in org.apache.commons.numbers.core.Precision conforms with IEEE-754 while this class conforms with the standard behavior for Java object types.
org.apache.commons.math4.complex.Complex.Complex	(	double	): Create a complex number given only the real part.
org.apache.commons.math4.complex.Complex.Complex	(	double	double	): Create a complex number given the real and imaginary parts.
org.apache.commons.math4.complex.Complex.abs	(	): Return the absolute value of this complex number. Returns NaN if either real or imaginary part is NaN and Double.POSITIVE_INFINITY if neither part is NaN, but at least one part is infinite.
org.apache.commons.math4.complex.Complex.acos	(	): Compute the  inverse cosine of this complex number. Implements the formula:  acos(z) = -i (log(z + i (sqrt(1 - z2))))  Returns NaN if either real or imaginary part of the input argument is NaN or infinite.
org.apache.commons.math4.complex.Complex.add	(	Complex	): Returns a Complex whose value is (this + addend). Uses the definitional formula  (a + bi) + (c + di) = (a+c) + (b+d)i  If either this or addend has a NaN value in either part, NaN is returned; otherwise Infinite and NaN values are returned in the parts of the result according to the rules for java.lang.Double arithmetic.
org.apache.commons.math4.complex.Complex.add	(	double	): Returns a Complex whose value is (this + addend), with addend interpreted as a real number.
org.apache.commons.math4.complex.Complex.asin	(	): Compute the  inverse sine of this complex number. Implements the formula:  asin(z) = -i (log(sqrt(1 - z2) + iz))  Returns NaN if either real or imaginary part of the input argument is NaN or infinite.
org.apache.commons.math4.complex.Complex.atan	(	): Compute the  inverse tangent of this complex number. Implements the formula:  atan(z) = (i/2) log((i + z)/(i - z))  Returns NaN if either real or imaginary part of the input argument is NaN or infinite.
org.apache.commons.math4.complex.Complex.conjugate	(	): Returns the conjugate of this complex number. The conjugate of a + bi is a - bi.  NaN is returned if either the real or imaginary part of this Complex number equals Double.NaN.  If the imaginary part is infinite, and the real part is not NaN, the returned value has infinite imaginary part of the opposite sign, e.g. the conjugate of 1 + POSITIVE_INFINITY i is 1 - NEGATIVE_INFINITY i. 
org.apache.commons.math4.complex.Complex.cos	(	): Compute the  cosine of this complex number. Implements the formula:  cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i  where the (real) functions on the right-hand side are sin, cos, cosh and sinh.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  cos(1 ± INFINITY i) = 1 \u2213 INFINITY i cos(±INFINITY + i) = NaN + NaN i cos(±INFINITY ± INFINITY i) = NaN + NaN i  
org.apache.commons.math4.complex.Complex.cosh	(	): Compute the  hyperbolic cosine of this complex number. Implements the formula:   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i   where the (real) functions on the right-hand side are sin, cos, cosh and sinh.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  cosh(1 ± INFINITY i) = NaN + NaN i cosh(±INFINITY + i) = INFINITY ± INFINITY i cosh(±INFINITY ± INFINITY i) = NaN + NaN i  
org.apache.commons.math4.complex.Complex.createComplex	(	double	double	): Create a complex number given the real and imaginary parts.
org.apache.commons.math4.complex.Complex.divide	(	Complex	): Returns a Complex whose value is (this / divisor). Implements the definitional formula   a + bi ac + bd + (bc - ad)i ----------- = ------------------------- c + di c2 + d2   but uses  prescaling of operands to limit the effects of overflows and underflows in the computation.  Infinite and NaN values are handled according to the following rules, applied in the order presented:  If either this or divisor has a NaN value in either part, NaN is returned.  If divisor equals ZERO, NaN is returned.  If this and divisor are both infinite, NaN is returned.  If this is finite (i.e., has no Infinite or NaN parts) and divisor is infinite (one or both parts infinite), ZERO is returned.  If this is infinite and divisor is finite, NaN values are returned in the parts of the result if the java.lang.Double rules applied to the definitional formula force NaN results.  
org.apache.commons.math4.complex.Complex.divide	(	double	): Returns a Complex whose value is (this / divisor), with divisor interpreted as a real number.
org.apache.commons.math4.complex.Complex.equals	(	Complex	Complex	): Returns true iff the values are equal as defined by equals() equals(x, y, 1).
org.apache.commons.math4.complex.Complex.equals	(	Complex	Complex	double	): Returns true if, both for the real part and for the imaginary part, there is no double value strictly between the arguments or the difference between them is within the range of allowed error (inclusive). Returns false if either of the arguments is NaN.
org.apache.commons.math4.complex.Complex.equals	(	Complex	Complex	int	): Test for the floating-point equality between Complex objects. It returns true if both arguments are equal or within the range of allowed error (inclusive).
org.apache.commons.math4.complex.Complex.equals	(	Object	): Test for equality with another object. If both the real and imaginary parts of two complex numbers are exactly the same, and neither is Double.NaN, the two Complex objects are considered to be equal. The behavior is the same as for JDK's equals() Double:  All NaN values are considered to be equal, i.e, if either (or both) real and imaginary parts of the complex number are equal to Double.NaN, the complex number is equal to NaN.   Instances constructed with different representations of zero (i.e. either "0" or "-0") are not considered to be equal.  
org.apache.commons.math4.complex.Complex.equalsWithRelativeTolerance	(	Complex	Complex	double	): Returns true if, both for the real part and for the imaginary part, there is no double value strictly between the arguments or the relative difference between them is smaller or equal to the given tolerance. Returns false if either of the arguments is NaN.
org.apache.commons.math4.complex.Complex.exp	(	): Compute the  exponential function of this complex number. Implements the formula:   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i   where the (real) functions on the right-hand side are exp, cos, and sin.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  exp(1 ± INFINITY i) = NaN + NaN i exp(INFINITY + i) = INFINITY + INFINITY i exp(-INFINITY + i) = 0 + 0i exp(±INFINITY ± INFINITY i) = NaN + NaN i  
org.apache.commons.math4.complex.Complex.getArgument	(	): Compute the argument of this complex number. The argument is the angle phi between the positive real axis and the point representing this number in the complex plane. The value returned is between -PI (not inclusive) and PI (inclusive), with negative values returned for numbers with negative imaginary parts.  If either real or imaginary part (or both) is NaN, NaN is returned. Infinite parts are handled as Math.atan2 handles them, essentially treating finite parts as zero in the presence of an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite parts. See the javadoc for Math.atan2 for full details.
org.apache.commons.math4.complex.Complex.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.complex.Complex.getImaginary	(	): Access the imaginary part.
org.apache.commons.math4.complex.Complex.getReal	(	): Access the real part.
org.apache.commons.math4.complex.Complex.hashCode	(	): Get a hashCode for the complex number. Any Double.NaN value in real or imaginary part produces the same hash code 7.
org.apache.commons.math4.complex.Complex.isInfinite	(	): Checks whether either the real or imaginary part of this complex number takes an infinite value (either Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY) and neither part is NaN.
org.apache.commons.math4.complex.Complex.isNaN	(	): Checks whether either or both parts of this complex number is NaN.
org.apache.commons.math4.complex.Complex.log	(	): Compute the  natural logarithm of this complex number. Implements the formula:   log(a + bi) = ln(|a + bi|) + arg(a + bi)i   where ln on the right hand side is log, |a + bi| is the modulus, abs, and arg(a + bi) = atan2(b, a).  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite (or critical) values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  log(1 ± INFINITY i) = INFINITY ± (π/2)i log(INFINITY + i) = INFINITY + 0i log(-INFINITY + i) = INFINITY + πi log(INFINITY ± INFINITY i) = INFINITY ± (π/4)i log(-INFINITY ± INFINITY i) = INFINITY ± (3π/4)i log(0 + 0i) = -INFINITY + 0i  
org.apache.commons.math4.complex.Complex.multiply	(	Complex	): Returns a Complex whose value is this * factor. Implements preliminary checks for NaN and infinity followed by the definitional formula:  (a + bi)(c + di) = (ac - bd) + (ad + bc)i  Returns NaN if either this or factor has one or more NaN parts.  Returns INF if neither this nor factor has one or more NaN parts and if either this or factor has one or more infinite parts (same result is returned regardless of the sign of the components).  Returns finite values in components of the result per the definitional formula in all remaining cases.
org.apache.commons.math4.complex.Complex.multiply	(	double	): Returns a Complex whose value is this * factor, with factor interpreted as a real number.
org.apache.commons.math4.complex.Complex.multiply	(	int	): Returns a Complex whose value is this * factor, with factor interpreted as a integer number.
org.apache.commons.math4.complex.Complex.negate	(	): Returns a Complex whose value is (-this). Returns NaN if either real or imaginary part of this Complex number is Double.NaN.
org.apache.commons.math4.complex.Complex.nthRoot	(	int	): Computes the n-th roots of this complex number. The nth roots are defined by the formula:   zk = abs1/n (cos(phi + 2πk/n) + i (sin(phi + 2πk/n))   for k=0, 1, ..., n-1, where abs and phi are respectively the abs() modulus and getArgument() argument of this complex number.  If one or both parts of this complex number is NaN, a list with just one element, NaN is returned. if neither part is NaN, but at least one part is infinite, the result is a one-element list containing INF.
org.apache.commons.math4.complex.Complex.pow	(	Complex	): Returns of value of this complex number raised to the power of x. Implements the formula:   yx = exp(x·log(y))   where exp and log are exp and log, respectively.  Returns NaN if either real or imaginary part of the input argument is NaN or infinite, or if y equals ZERO.
org.apache.commons.math4.complex.Complex.pow	(	double	): Returns of value of this complex number raised to the power of x.
org.apache.commons.math4.complex.Complex.readResolve	(	): Resolve the transient fields in a deserialized Complex Object. Subclasses will need to override createComplex to deserialize properly.
org.apache.commons.math4.complex.Complex.reciprocal	(	): Returns the multiplicative inverse of this element. 
org.apache.commons.math4.complex.Complex.sin	(	): Compute the  sine of this complex number. Implements the formula:   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i   where the (real) functions on the right-hand side are sin, cos, cosh and sinh.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  sin(1 ± INFINITY i) = 1 ± INFINITY i sin(±INFINITY + i) = NaN + NaN i sin(±INFINITY ± INFINITY i) = NaN + NaN i  
org.apache.commons.math4.complex.Complex.sinh	(	): Compute the  hyperbolic sine of this complex number. Implements the formula:   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i   where the (real) functions on the right-hand side are sin, cos, cosh and sinh.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  sinh(1 ± INFINITY i) = NaN + NaN i sinh(±INFINITY + i) = ± INFINITY + INFINITY i sinh(±INFINITY ± INFINITY i) = NaN + NaN i  
org.apache.commons.math4.complex.Complex.sqrt	(	): Compute the  square root of this complex number. Implements the following algorithm to compute sqrt(a + bi): Let t = sqrt((|a| + |a + bi|) / 2) if a ≥ 0 return t + (b/2t)i else return |b|/2t + sign(b)t i   where  |a| = abs(a) |a + bi| = abs(a + bi) sign(b) = copySign() copySign(1d, b)   Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  sqrt(1 ± INFINITY i) = INFINITY + NaN i sqrt(INFINITY + i) = INFINITY + 0i sqrt(-INFINITY + i) = 0 + INFINITY i sqrt(INFINITY ± INFINITY i) = INFINITY + NaN i sqrt(-INFINITY ± INFINITY i) = NaN ± INFINITY i  
org.apache.commons.math4.complex.Complex.sqrt1z	(	): Compute the  square root of 1 - this2 for this complex number. Computes the result directly as sqrt(ONE.subtract(z.multiply(z))).  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.
org.apache.commons.math4.complex.Complex.subtract	(	Complex	): Returns a Complex whose value is (this - subtrahend). Uses the definitional formula  (a + bi) - (c + di) = (a-c) + (b-d)i  If either this or subtrahend has a NaN] value in either part, NaN is returned; otherwise infinite and NaN values are returned in the parts of the result according to the rules for java.lang.Double arithmetic.
org.apache.commons.math4.complex.Complex.subtract	(	double	): Returns a Complex whose value is (this - subtrahend).
org.apache.commons.math4.complex.Complex.tan	(	): Compute the  tangent of this complex number. Implements the formula:   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i   where the (real) functions on the right-hand side are sin, cos, cosh and sinh.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite (or critical) values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  tan(a ± INFINITY i) = 0 ± i tan(±INFINITY + bi) = NaN + NaN i tan(±INFINITY ± INFINITY i) = NaN + NaN i tan(±π/2 + 0 i) = ±INFINITY + NaN i  
org.apache.commons.math4.complex.Complex.tanh	(	): Compute the  hyperbolic tangent of this complex number. Implements the formula:   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i   where the (real) functions on the right-hand side are sin, cos, cosh and sinh.  Returns NaN if either real or imaginary part of the input argument is NaN.  Infinite values in real or imaginary parts of the input may result in infinite or NaN values returned in parts of the result.  Examples:  tanh(a ± INFINITY i) = NaN + NaN i tanh(±INFINITY + bi) = ±1 + 0 i tanh(±INFINITY ± INFINITY i) = NaN + NaN i tanh(0 + (π/2)i) = NaN + INFINITY i  
org.apache.commons.math4.complex.Complex.toString	(	):  
org.apache.commons.math4.complex.Complex.valueOf	(	double	): Create a complex number given only the real part.
org.apache.commons.math4.complex.Complex.valueOf	(	double	double	): Create a complex number given the real and imaginary parts.
org.apache.commons.math4.complex.ComplexField: Representation of the complex numbers field.  This class is a singleton. 
org.apache.commons.math4.complex.ComplexField.ComplexField	(	): Private constructor for the singleton.
org.apache.commons.math4.complex.ComplexField.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.complex.ComplexField.getInstance	(	): Get the unique instance.
org.apache.commons.math4.complex.ComplexField.getOne	(	): Get the multiplicative identity of the field.  The multiplicative identity is the element e1 of the field such that for all elements a of the field, the equalities a × e1 = e1 × a = a hold.  
org.apache.commons.math4.complex.ComplexField.getRuntimeClass	(	): Returns the runtime class of the FieldElement. 
org.apache.commons.math4.complex.ComplexField.getZero	(	): Get the additive identity of the field.  The additive identity is the element e0 of the field such that for all elements a of the field, the equalities a + e0 = e0 + a = a hold.  
org.apache.commons.math4.complex.ComplexField.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.complex.ComplexFormat: Formats a Complex number in cartesian format "Re(c) + Im(c)i". 'i' can be replaced with 'j' (or anything else), and the number format for both real and imaginary parts can be configured.
org.apache.commons.math4.complex.ComplexFormat.ComplexFormat	(	): Create an instance with the default imaginary character, 'i', and the default number format for both real and imaginary parts.
org.apache.commons.math4.complex.ComplexFormat.ComplexFormat	(	NumberFormat	): Create an instance with a custom number format for both real and imaginary parts.
org.apache.commons.math4.complex.ComplexFormat.ComplexFormat	(	NumberFormat	NumberFormat	): Create an instance with a custom number format for the real part and a custom number format for the imaginary part.
org.apache.commons.math4.complex.ComplexFormat.ComplexFormat	(	String	): Create an instance with a custom imaginary character, and the default number format for both real and imaginary parts.
org.apache.commons.math4.complex.ComplexFormat.ComplexFormat	(	String	NumberFormat	): Create an instance with a custom imaginary character, and a custom number format for both real and imaginary parts.
org.apache.commons.math4.complex.ComplexFormat.ComplexFormat	(	String	NumberFormat	NumberFormat	): Create an instance with a custom imaginary character, a custom number format for the real part, and a custom number format for the imaginary part.
org.apache.commons.math4.complex.ComplexFormat.format	(	Complex	): This method calls format().
org.apache.commons.math4.complex.ComplexFormat.format	(	Complex	StringBuffer	FieldPosition	): Formats a Complex object to produce a string.
org.apache.commons.math4.complex.ComplexFormat.format	(	Double	): This method calls format().
org.apache.commons.math4.complex.ComplexFormat.format	(	Object	StringBuffer	FieldPosition	): Formats a object to produce a string. obj must be either a Complex object or a Number object. Any other type of object will result in an IllegalArgumentException being thrown.
org.apache.commons.math4.complex.ComplexFormat.formatImaginary	(	double	StringBuffer	FieldPosition	): Format the absolute value of the imaginary part.
org.apache.commons.math4.complex.ComplexFormat.getAvailableLocales	(	): Get the set of locales for which complex formats are available. This is the same set as the NumberFormat set.
org.apache.commons.math4.complex.ComplexFormat.getImaginaryCharacter	(	): Access the imaginaryCharacter.
org.apache.commons.math4.complex.ComplexFormat.getImaginaryFormat	(	): Access the imaginaryFormat.
org.apache.commons.math4.complex.ComplexFormat.getInstance	(	): Returns the default complex format for the current locale.
org.apache.commons.math4.complex.ComplexFormat.getInstance	(	Locale	): Returns the default complex format for the given locale.
org.apache.commons.math4.complex.ComplexFormat.getInstance	(	String	Locale	): Returns the default complex format for the given locale.
org.apache.commons.math4.complex.ComplexFormat.getRealFormat	(	): Access the realFormat.
org.apache.commons.math4.complex.ComplexFormat.parse	(	String	): Parses a string to produce a Complex object.
org.apache.commons.math4.complex.ComplexFormat.parse	(	String	ParsePosition	): Parses a string to produce a Complex object.
org.apache.commons.math4.complex.ComplexTest.TestComplex: Class to test extending Complex
org.apache.commons.math4.complex.ComplexTest.testGetArgument	(	): Test standard values
org.apache.commons.math4.complex.ComplexTest.testGetArgumentInf	(	): Verify atan2-style handling of infinite parts
org.apache.commons.math4.complex.ComplexTest.testGetArgumentNaN	(	): Verify that either part NaN results in NaN
org.apache.commons.math4.complex.ComplexTest.testMath221	(	): test issue MATH-221 
org.apache.commons.math4.complex.ComplexTest.testNthRoot_cornercase_NAN_Inf	(	): Test cornercases with NaN and Infinity.
org.apache.commons.math4.complex.ComplexTest.testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty	(	): Test: computing third roots of z.   z = 8 => z_0 = 2 => z_1 = -1 + 1.73205 * i => z_2 = -1 - 1.73205 * i  
org.apache.commons.math4.complex.ComplexTest.testNthRoot_cornercase_thirdRoot_realPartZero	(	): Test: computing third roots of z with real part 0.   z = 2 * i => z_0 = 1.0911 + 0.6299 * i => z_1 = -1.0911 + 0.6299 * i => z_2 = -2.3144 - 1.2599 * i  
org.apache.commons.math4.complex.ComplexTest.testNthRoot_normal_fourthRoot	(	): Test: computing fourth roots of z.   z = 5 - 2 * i => z_0 = 1.5164 - 0.1446 * i => z_1 = 0.1446 + 1.5164 * i => z_2 = -1.5164 + 0.1446 * i => z_3 = -1.5164 - 0.1446 * i  
org.apache.commons.math4.complex.ComplexTest.testNthRoot_normal_thirdRoot	(	): Test: computing third roots of z.   z = -2 + 2 * i => z_0 = 1 + i => z_1 = -1.3660 + 0.3660 * i => z_2 = 0.3660 - 1.3660 * i  
org.apache.commons.math4.complex.ComplexUtils: Static implementations of common Complex utilities functions.
org.apache.commons.math4.complex.ComplexUtils.ComplexUtils	(	): Utility class.
org.apache.commons.math4.complex.ComplexUtils.abs	(	Complex[]	): Returns double[] containing absolute values (magnitudes) of a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.arg	(	Complex[]	): Returns double[] containing arguments (phase angles) of a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Imaginary	(	Complex[]	): Converts imaginary part of a Complex[] array to a double[] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Imaginary	(	Complex[]	Range	): Converts imaginary part of a Complex[] array to a double[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.complex2Imaginary	(	Complex[]	int	int	): Converts imaginary part of Complex[] array to a double[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.complex2Imaginary	(	Complex[]	int	int	int	): Converts imaginary part of a Complex[] array to a double[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.complex2Imaginary	(	Complex[][]	): Converts imaginary component of a 2D Complex[][] array to a 2D double[][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Imaginary	(	Complex[][][]	): Converts imaginary component of a 3D Complex[][][] array to a 3D double[][][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2ImaginaryFloat	(	Complex[]	): Converts imaginary component of a Complex[] array to a float[] array.
org.apache.commons.math4.complex.ComplexUtils.complex2ImaginaryFloat	(	Complex[]	Range	): Converts imaginary part of a Complex[] array to a float[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.complex2ImaginaryFloat	(	Complex[]	int	int	): Converts imaginary part of a Complex[] array to a float[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.complex2ImaginaryFloat	(	Complex[]	int	int	int	): Converts imaginary part of a Complex[] array to a float[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.complex2ImaginaryFloat	(	Complex[][]	): Converts imaginary component of a 2D Complex[][] array to a 2D float[][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2ImaginaryFloat	(	Complex[][][]	): Converts imaginary component of a 3D Complex[][][] array to a 3D float[][][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[]	): Converts a Complex[] array to an interleaved complex double[] array
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[]	Range	): Converts a Complex[] array to an interleaved complex double[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[]	int	int	): Converts a Complex[] array to an interleaved complex double[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[]	int	int	int	): Converts a Complex[] array to an interleaved complex double[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[][]	): Converts a 2D Complex[][] array to an interleaved complex double[][] array. The second depth level of the array is assumed to be interleaved.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[][]	int	): Converts a 2D Complex[][] array to an interleaved complex double[][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[][][]	): Converts a 3D Complex[][][] array to an interleaved complex double[][][] array. The third depth level of the array is interleaved.
org.apache.commons.math4.complex.ComplexUtils.complex2Interleaved	(	Complex[][][]	int	): Converts a 3D Complex[][][] array to an interleaved complex double[][][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[]	): Converts a Complex[] array to an interleaved complex float[] array
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[]	Range	): Converts a Complex[] array to an interleaved complex float[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[]	int	int	): Converts a Complex[] array to an interleaved complex float[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[]	int	int	int	): Converts a Complex[] array to an interleaved complex float[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[][]	): Converts a 2D Complex[][] array to an interleaved complex float[][] array. The second depth level of the array is assumed to be interleaved.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[][]	int	): Converts a 2D Complex[][] array to an interleaved complex float[][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[][][]	): Converts a 3D Complex[][][] array to an interleaved complex float[][][] array. The third depth level of the array is interleaved.
org.apache.commons.math4.complex.ComplexUtils.complex2InterleavedFloat	(	Complex[][][]	int	): Converts a 3D Complex[][][] array to an interleaved complex float[][][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Real	(	Complex[]	): Converts real component of Complex[] array to a double[] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Real	(	Complex[]	Range	): Converts a Complex[] array to a double[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.complex2Real	(	Complex[]	int	int	): Converts a Complex[] array to a double[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.complex2Real	(	Complex[]	int	int	int	): Converts a Complex[] array to a double[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.complex2Real	(	Complex[][]	): Converts real component of a 2D Complex[][] array to a 2D double[][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2Real	(	Complex[][][]	): Converts real component of a 3D Complex[][][] array to a 3D double[][][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2RealFloat	(	Complex[]	): Converts real component of Complex[] array to a float[] array.
org.apache.commons.math4.complex.ComplexUtils.complex2RealFloat	(	Complex[]	Range	): Converts a Complex[] array to a float[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.complex2RealFloat	(	Complex[]	int	int	): Converts a Complex[] array to a float[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.complex2RealFloat	(	Complex[]	int	int	int	): Converts a Complex[] array to a float[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.complex2RealFloat	(	Complex[][]	): Converts real component of a 2D Complex[][] array to a 2D float[][] array.
org.apache.commons.math4.complex.ComplexUtils.complex2RealFloat	(	Complex[][][]	): Converts real component of a 3D Complex[][][] array to a 3D float[][][] array.
org.apache.commons.math4.complex.ComplexUtils.extractComplexFromImaginaryArray	(	double[]	int	): Returns double from array imaginary[] at entry index as a Complex.
org.apache.commons.math4.complex.ComplexUtils.extractComplexFromImaginaryArray	(	float[]	int	): Returns float from array imaginary[] at entry index as a Complex.
org.apache.commons.math4.complex.ComplexUtils.extractComplexFromInterleavedArray	(	double[]	int	): Returns a Complex object from interleaved double[] array at entry index.
org.apache.commons.math4.complex.ComplexUtils.extractComplexFromInterleavedArray	(	float[]	int	): Returns a Complex object from interleaved float[] array at entry index.
org.apache.commons.math4.complex.ComplexUtils.extractComplexFromRealArray	(	double[]	int	): Returns double from array real[] at entry index as a Complex.
org.apache.commons.math4.complex.ComplexUtils.extractComplexFromRealArray	(	float[]	int	): Returns float from array real[] at entry index as a Complex.
org.apache.commons.math4.complex.ComplexUtils.extractImaginaryFloatFromComplexArray	(	Complex[]	int	): Returns imaginary component of array Complex[] at entry index as a float.
org.apache.commons.math4.complex.ComplexUtils.extractImaginaryFromComplexArray	(	Complex[]	int	): Returns imaginary component of Complex from array Complex[] at entry index as a double.
org.apache.commons.math4.complex.ComplexUtils.extractInterleavedFloatFromComplexArray	(	Complex[]	int	): Returns Complex object from array Complex[] at entry index as a size 2 float of the form {real, imag}.
org.apache.commons.math4.complex.ComplexUtils.extractInterleavedFromComplexArray	(	Complex[]	int	): Returns values of Complex object from array Complex[] at entry index as a size 2 double of the form {real, imag}.
org.apache.commons.math4.complex.ComplexUtils.extractRealFloatFromComplexArray	(	Complex[]	int	): Returns real component of array Complex[] at entry index as a float.
org.apache.commons.math4.complex.ComplexUtils.extractRealFromComplexArray	(	Complex[]	int	): Returns real component of Complex from array Complex[] at entry index as a double.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	double[]	): Converts a double[] array to an imaginary Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	double[]	Range	): Converts a double[] array to an imaginary Complex[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	double[]	int	int	): Converts a double[] array to an imaginary Complex[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	double[]	int	int	int	): Converts a double[] array to an imaginary Complex[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	double[][]	): Converts a 2D imaginary array double[][] to a 2D Complex[][] array.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	double[][][]	): Converts a 3D imaginary array double[][][] to a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	float[]	): Converts a float[] array to an imaginary Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	float[]	Range	): Converts a float[] array to an imaginary Complex[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	float[]	int	int	): Converts a float[] array to an imaginary Complex[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.imaginary2Complex	(	float[]	int	int	int	): Converts a float[] array to an imaginary Complex[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.initialize	(	Complex[]	): Initializes a Complex[] array to zero, to avoid NullPointerExceptions.
org.apache.commons.math4.complex.ComplexUtils.initialize	(	Complex[][]	): Initializes a Complex[][] array to zero, to avoid NullPointerExceptions.
org.apache.commons.math4.complex.ComplexUtils.initialize	(	Complex[][][]	): Initializes a Complex[][][] array to zero, to avoid NullPointerExceptions.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[]	): Converts a complex interleaved double[] array to a Complex[] array
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[]	Range	): Converts a complex interleaved double[] array to a Complex[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[]	int	int	): Converts a complex interleaved double[] array to a Complex[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[]	int	int	int	): Converts a complex interleaved double[] array to a Complex[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[][]	): Converts a 2D interleaved complex double[][] array to a Complex[][] array. The second depth level of the array is assumed to be interleaved.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[][]	int	): Converts a 2D interleaved complex double[][] array to a Complex[][] array.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[][][]	): Converts a 3D interleaved complex double[][][] array to a Complex[][][] array. The third depth level is assumed to be interleaved.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	double[][][]	int	): Converts a 3D interleaved complex double[][][] array to a Complex[][][] array.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[]	): Converts a complex interleaved float[] array to a Complex[] array
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[]	Range	): Converts a complex interleaved float[] array to a Complex[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[]	int	int	): Converts a complex interleaved float[] array to a Complex[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[]	int	int	int	): Converts a complex interleaved float[] array to a Complex[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[][]	): Converts a 2D interleaved complex float[][] array to a Complex[][] array. The second depth level of the array is assumed to be interleaved.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[][]	int	): Converts a 2D interleaved complex float[][] array to a Complex[][] array.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[][][]	): Converts a 3D interleaved complex float[][][] array to a Complex[] array. The third depth level of the array is assumed to be interleaved.
org.apache.commons.math4.complex.ComplexUtils.interleaved2Complex	(	float[][][]	int	): Converts a 3D interleaved complex float[][][] array to a Complex[][][] array.
org.apache.commons.math4.complex.ComplexUtils.polar2Complex	(	double	double	): Creates a complex number from the given polar representation.  If either r or theta is NaN, or theta is infinite, NaN is returned.  If r is infinite and theta is finite, infinite or NaN values may be returned in parts of the result, following the rules for double arithmetic.  Examples: polar2Complex(INFINITY, \(\pi\)) = INFINITY + INFINITY i polar2Complex(INFINITY, 0) = INFINITY + NaN i polar2Complex(INFINITY, \(-\frac \pi}{4}\)) = INFINITY - INFINITY i polar2Complex(INFINITY, \(5\frac{\pi}{4}\)) = -INFINITY - INFINITY i } 
org.apache.commons.math4.complex.ComplexUtils.polar2Complex	(	double[]	double[]	): Creates Complex[] array given double[] arrays of r and theta.
org.apache.commons.math4.complex.ComplexUtils.polar2Complex	(	double[][]	double[][]	): Creates Complex[][] array given double[][] arrays of r and theta.
org.apache.commons.math4.complex.ComplexUtils.polar2Complex	(	double[][][]	double[][][]	): Creates Complex[][][] array given double[][][] arrays of r and theta.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	double[]	): Converts a double[] array to a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	double[]	Range	): Converts a double[] array to a Complex[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	double[]	int	int	): Converts a double[] array to a Complex[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	double[]	int	int	int	): Converts a double[] array to a Complex[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	double[][]	): Converts a 2D real double[][] array to a 2D Complex[][] array.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	double[][][]	): Converts a 3D real double[][][] array to a Complex [][][] array.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	float[]	): Converts a float[] array to a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	float[]	Range	): Converts a float[] array to a Complex[] array for the IntegerSequence range.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	float[]	int	int	): Converts a float[] array to a Complex[] array for the range start - end.
org.apache.commons.math4.complex.ComplexUtils.real2Complex	(	float[]	int	int	int	): Converts a float[] array to a Complex[] array for the range start - end by increment.
org.apache.commons.math4.complex.ComplexUtils.split2Complex	(	double[]	double[]	): Converts a split complex array double[] r, double[] i to a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.split2Complex	(	double[][]	double[][]	): Converts a 2D split complex array double[][] r, double[][] i to a 2D Complex[][] array.
org.apache.commons.math4.complex.ComplexUtils.split2Complex	(	double[][][]	double[][][]	): Converts a 3D split complex array double[][][] r, double[][][] i to a 3D Complex[][][] array.
org.apache.commons.math4.complex.ComplexUtils.split2Complex	(	float[]	float[]	): Converts a split complex array float[] r, float[] i to a Complex[] array.
org.apache.commons.math4.complex.ComplexUtils.split2Complex	(	float[][]	float[][]	): Converts a 2D split complex array float[][] r, float[][] i to a 2D Complex[][] array.
org.apache.commons.math4.complex.ComplexUtils.split2Complex	(	float[][][]	float[][][]	): Converts a 3D split complex array float[][][] r, float[][][] i to a 3D Complex[][][] array.
org.apache.commons.math4.complex.Quaternion: This class implements  quaternions (Hamilton's hypercomplex numbers).  Instance of this class are guaranteed to be immutable.
org.apache.commons.math4.complex.Quaternion.Quaternion	(	double	double	double	double	): Builds a quaternion from its components.
org.apache.commons.math4.complex.Quaternion.Quaternion	(	double	double[]	): Builds a quaternion from scalar and vector parts.
org.apache.commons.math4.complex.Quaternion.Quaternion	(	double[]	): Builds a pure quaternion from a vector (assuming that the scalar part is zero).
org.apache.commons.math4.complex.Quaternion.add	(	Quaternion	): Computes the sum of the instance and another quaternion.
org.apache.commons.math4.complex.Quaternion.add	(	Quaternion	Quaternion	): Computes the sum of two quaternions.
org.apache.commons.math4.complex.Quaternion.dotProduct	(	Quaternion	): Computes the dot-product of the instance by a quaternion.
org.apache.commons.math4.complex.Quaternion.dotProduct	(	Quaternion	Quaternion	): Computes the dot-product of two quaternions.
org.apache.commons.math4.complex.Quaternion.equals	(	Object	): 
org.apache.commons.math4.complex.Quaternion.equals	(	Quaternion	double	): Checks whether this instance is equal to another quaternion within a given tolerance.
org.apache.commons.math4.complex.Quaternion.getConjugate	(	): Returns the conjugate quaternion of the instance.
org.apache.commons.math4.complex.Quaternion.getInverse	(	): Returns the inverse of this instance. The norm of the quaternion must not be zero.
org.apache.commons.math4.complex.Quaternion.getNorm	(	): Computes the norm of the quaternion.
org.apache.commons.math4.complex.Quaternion.getPositivePolarForm	(	): Returns the polar form of the quaternion.
org.apache.commons.math4.complex.Quaternion.getQ0	(	): Gets the first component of the quaternion (scalar part).
org.apache.commons.math4.complex.Quaternion.getQ1	(	): Gets the second component of the quaternion (first component of the vector part).
org.apache.commons.math4.complex.Quaternion.getQ2	(	): Gets the third component of the quaternion (second component of the vector part).
org.apache.commons.math4.complex.Quaternion.getQ3	(	): Gets the fourth component of the quaternion (third component of the vector part).
org.apache.commons.math4.complex.Quaternion.getScalarPart	(	): Gets the scalar part of the quaternion.
org.apache.commons.math4.complex.Quaternion.getVectorPart	(	): Gets the three components of the vector part of the quaternion.
org.apache.commons.math4.complex.Quaternion.hashCode	(	): 
org.apache.commons.math4.complex.Quaternion.isPureQuaternion	(	double	): Checks whether the instance is a pure quaternion within a given tolerance.
org.apache.commons.math4.complex.Quaternion.isUnitQuaternion	(	double	): Checks whether the instance is a unit quaternion within a given tolerance.
org.apache.commons.math4.complex.Quaternion.multiply	(	Quaternion	): Returns the Hamilton product of the instance by a quaternion.
org.apache.commons.math4.complex.Quaternion.multiply	(	Quaternion	Quaternion	): Returns the Hamilton product of two quaternions.
org.apache.commons.math4.complex.Quaternion.multiply	(	double	): Multiplies the instance by a scalar.
org.apache.commons.math4.complex.Quaternion.normalize	(	): Computes the normalized quaternion (the versor of the instance). The norm of the quaternion must not be zero.
org.apache.commons.math4.complex.Quaternion.subtract	(	Quaternion	): Subtracts a quaternion from the instance.
org.apache.commons.math4.complex.Quaternion.subtract	(	Quaternion	Quaternion	): Subtracts two quaternions.
org.apache.commons.math4.complex.Quaternion.toString	(	): 
org.apache.commons.math4.complex.RootsOfUnity: A helper class for the computation and caching of the n-th roots of unity.
org.apache.commons.math4.complex.RootsOfUnity.RootsOfUnity	(	): Build an engine for computing the n-th roots of unity.
org.apache.commons.math4.complex.RootsOfUnity.computeRoots	(	int	):  Computes the n-th roots of unity. The roots are stored in omega[], such that omega[k] = w ^ k, where k = 0, ..., n - 1, w = exp(2 * pi * i / n) and i = sqrt(-1).   Note that n can be positive of negative   abs(n) is always the number of roots of unity. If n > 0, then the roots are stored in counter-clockwise order. If n < 0, then the roots are stored in clockwise order. 
org.apache.commons.math4.complex.RootsOfUnity.getImaginary	(	int	): Get the imaginary part of the k-th n-th root of unity.
org.apache.commons.math4.complex.RootsOfUnity.getNumberOfRoots	(	): Returns the number of roots of unity currently stored. If computeRoots() was called with n, then this method returns abs(n). If no roots of unity have been computed yet, this method returns 0.
org.apache.commons.math4.complex.RootsOfUnity.getReal	(	int	): Get the real part of the k-th n-th root of unity.
org.apache.commons.math4.complex.RootsOfUnity.isCounterClockWise	(	): Returns true if computeRoots() was called with a positive value of its argument n. If true, then counter-clockwise ordering of the roots of unity should be used.
org.apache.commons.math4.complex.RootsOfUnityTest: Unit tests for the RootsOfUnity class.
org.apache.commons.math4.dfp.Dfp: Decimal floating point library for Java Another floating point class. This one is built using radix 10000 which is 104, so its almost decimal. The design goals here are:  Decimal math, or close to it Settable precision (but no mix between numbers using different settings) Portability. Code should be kept as portable as possible. Performance Accuracy - Results should always be +/- 1 ULP for basic algebraic operation Comply with IEEE 854-1987 as much as possible. (See IEEE 854-1987 notes below)  Trade offs:  Memory foot print. I'm using more memory than necessary to represent numbers to get better performance. Digits are bigger, so rounding is a greater loss. So, if you really need 12 decimal digits, better use 4 base 10000 digits there can be one partially filled.  Numbers are represented in the following form:  n = sign × mant × (radix)exp;  where sign is ±1, mantissa represents a fractional number between zero and one. mant[0] is the least significant digit. exp is in the range of -32767 to 32768 IEEE 854-1987 Notes and differences IEEE 854 requires the radix to be either 2 or 10. The radix here is 10000, so that requirement is not met, but it is possible that a subclassed can be made to make it behave as a radix 10 number. It is my opinion that if it looks and behaves as a radix 10 number then it is one and that requirement would be met. The radix of 10000 was chosen because it should be faster to operate on 4 decimal digits at once instead of one at a time. Radix 10 behavior can be realized by adding an additional rounding step to ensure that the number of decimal digits represented is constant. The IEEE standard specifically leaves out internal data encoding, so it is reasonable to conclude that such a subclass of this radix 10000 system is merely an encoding of a radix 10 system. IEEE 854 also specifies the existence of "sub-normal" numbers. This class does not contain any such entities. The most significant radix 10000 digit is always non-zero. Instead, we support "gradual underflow" by raising the underflow flag for numbers less with exponent less than expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits. Thus the smallest number we can represent would be: 1E(-(MIN_EXP-digits-1)*4), eg, for digits=5, MIN_EXP=-32767, that would be 1e-131092. IEEE 854 defines that the implied radix point lies just to the right of the most significant digit and to the left of the remaining digits. This implementation puts the implied radix point to the left of all digits including the most significant one. The most significant digit here is the one just to the right of the radix point. This is a fine detail and is really only a matter of definition. Any side effects of this can be rendered invisible by a subclass.
org.apache.commons.math4.dfp.Dfp.Dfp	(	Dfp	): Copy constructor.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	): Makes an instance with a value of zero.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	String	): Create an instance from a String representation.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	byte	): Create an instance from a byte value.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	byte	byte	): Creates an instance with a non-finite value.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	double	): Create an instance from a double value.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	int	): Create an instance from an int value.
org.apache.commons.math4.dfp.Dfp.Dfp	(	DfpField	long	): Create an instance from a long value.
org.apache.commons.math4.dfp.Dfp.abs	(	): Get the absolute value of instance.
org.apache.commons.math4.dfp.Dfp.acos	(	): Arc cosine operation.
org.apache.commons.math4.dfp.Dfp.acosh	(	): Inverse hyperbolic cosine operation.
org.apache.commons.math4.dfp.Dfp.add	(	Dfp	): Add x to this.
org.apache.commons.math4.dfp.Dfp.add	(	double	): '+' operator.
org.apache.commons.math4.dfp.Dfp.align	(	int	): Make our exp equal to the supplied one, this may cause rounding. Also causes de-normalized numbers. These numbers are generally dangerous because most routines assume normalized numbers. Align doesn't round, so it will return the last digit destroyed by shifting right.
org.apache.commons.math4.dfp.Dfp.asin	(	): Arc sine operation.
org.apache.commons.math4.dfp.Dfp.asinh	(	): Inverse hyperbolic sine operation.
org.apache.commons.math4.dfp.Dfp.atan	(	): Arc tangent operation.
org.apache.commons.math4.dfp.Dfp.atan2	(	Dfp	): 
org.apache.commons.math4.dfp.Dfp.atanh	(	): Inverse hyperbolic tangent operation.
org.apache.commons.math4.dfp.Dfp.cbrt	(	): Cubic root.
org.apache.commons.math4.dfp.Dfp.ceil	(	): Round to an integer using the round ceil mode. That is, round toward +Infinity
org.apache.commons.math4.dfp.Dfp.classify	(	): Returns the type - one of FINITE, INFINITE, SNAN, QNAN.
org.apache.commons.math4.dfp.Dfp.compare	(	Dfp	Dfp	): Compare two instances.
org.apache.commons.math4.dfp.Dfp.complement	(	int	): Negate the mantissa of this by computing the complement. Leaves the sign bit unchanged, used internally by add. Denormalized numbers are handled properly here.
org.apache.commons.math4.dfp.Dfp.copySign	(	Dfp	): 
org.apache.commons.math4.dfp.Dfp.copySign	(	double	): Returns the instance with the sign of the argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.dfp.Dfp.copysign	(	Dfp	Dfp	): Creates an instance that is the same as x except that it has the sign of y. abs(x) = dfp.copysign(x, dfp.one)
org.apache.commons.math4.dfp.Dfp.cos	(	): Cosine operation.
org.apache.commons.math4.dfp.Dfp.cosh	(	): Hyperbolic cosine operation.
org.apache.commons.math4.dfp.Dfp.dfp2sci	(	): Convert an instance to a string using scientific notation.
org.apache.commons.math4.dfp.Dfp.dfp2string	(	): Convert an instance to a string using normal notation.
org.apache.commons.math4.dfp.Dfp.divide	(	Dfp	): Divide this by divisor.
org.apache.commons.math4.dfp.Dfp.divide	(	double	): '÷' operator.
org.apache.commons.math4.dfp.Dfp.divide	(	int	): Divide by a single digit less than radix. Special case, so there are speed advantages. 0 <= divisor < radix
org.apache.commons.math4.dfp.Dfp.dotrap	(	int	String	Dfp	Dfp	): Raises a trap. This does not set the corresponding flag however.
org.apache.commons.math4.dfp.Dfp.equals	(	Object	): Check if instance is equal to x.
org.apache.commons.math4.dfp.Dfp.exp	(	): Exponential.
org.apache.commons.math4.dfp.Dfp.expm1	(	): Exponential minus 1.
org.apache.commons.math4.dfp.Dfp.floor	(	): Round to an integer using the round floor mode. That is, round toward -Infinity
org.apache.commons.math4.dfp.Dfp.getField	(	): Get the org.apache.commons.math4.Field Field (really a DfpField) to which the instance belongs.  The field is linked to the number of digits and acts as a factory for Dfp instances. 
org.apache.commons.math4.dfp.Dfp.getOne	(	): Get the constant 1.
org.apache.commons.math4.dfp.Dfp.getRadixDigits	(	): Get the number of radix digits of the instance.
org.apache.commons.math4.dfp.Dfp.getReal	(	): Get the real value of the number.
org.apache.commons.math4.dfp.Dfp.getTwo	(	): Get the constant 2.
org.apache.commons.math4.dfp.Dfp.getZero	(	): Get the constant 0.
org.apache.commons.math4.dfp.Dfp.greaterThan	(	Dfp	): Check if instance is greater than x.
org.apache.commons.math4.dfp.Dfp.hashCode	(	): Gets a hashCode for the instance.
org.apache.commons.math4.dfp.Dfp.hypot	(	Dfp	): 
org.apache.commons.math4.dfp.Dfp.intLog10	(	): Get the exponent of the greatest power of 10 that is less than or equal to abs(this).
org.apache.commons.math4.dfp.Dfp.intValue	(	): Convert this to an integer. If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.
org.apache.commons.math4.dfp.Dfp.isInfinite	(	): Check if instance is infinite.
org.apache.commons.math4.dfp.Dfp.isNaN	(	): Check if instance is not a number.
org.apache.commons.math4.dfp.Dfp.isZero	(	): Check if instance is equal to zero.
org.apache.commons.math4.dfp.Dfp.lessThan	(	Dfp	): Check if instance is less than x.
org.apache.commons.math4.dfp.Dfp.linearCombination	(	Dfp	Dfp	Dfp	Dfp	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	Dfp	Dfp	Dfp	Dfp	Dfp	Dfp	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	Dfp	Dfp	Dfp	Dfp	Dfp	Dfp	Dfp	Dfp	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	Dfp[]	Dfp[]	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	double	Dfp	double	Dfp	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	double	Dfp	double	Dfp	double	Dfp	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	double	Dfp	double	Dfp	double	Dfp	double	Dfp	): 
org.apache.commons.math4.dfp.Dfp.linearCombination	(	double[]	Dfp[]	): 
org.apache.commons.math4.dfp.Dfp.log	(	): Natural logarithm.
org.apache.commons.math4.dfp.Dfp.log10	(	): Base 10 logarithm.
org.apache.commons.math4.dfp.Dfp.log10K	(	): Get the exponent of the greatest power of 10000 that is less than or equal to the absolute value of this. I.E. if this is 106 then log10K would return 1.
org.apache.commons.math4.dfp.Dfp.log1p	(	): Shifted natural logarithm.
org.apache.commons.math4.dfp.Dfp.multiply	(	Dfp	): Multiply this by x.
org.apache.commons.math4.dfp.Dfp.multiply	(	double	): '×' operator.
org.apache.commons.math4.dfp.Dfp.multiply	(	int	): Multiply this by a single digit x.
org.apache.commons.math4.dfp.Dfp.multiplyFast	(	int	): Multiply this by a single digit 0<=x<radix. There are speed advantages in this special case.
org.apache.commons.math4.dfp.Dfp.negate	(	): Returns a number that is this number with the sign bit reversed.
org.apache.commons.math4.dfp.Dfp.negativeOrNull	(	): Check if instance is less than or equal to 0.
org.apache.commons.math4.dfp.Dfp.newInstance	(	): Create an instance with a value of 0. Use this internally in preference to constructors to facilitate subclasses
org.apache.commons.math4.dfp.Dfp.newInstance	(	Dfp	): Create an instance by copying an existing one. Use this internally in preference to constructors to facilitate subclasses.
org.apache.commons.math4.dfp.Dfp.newInstance	(	String	): Create an instance from a String representation. Use this internally in preference to constructors to facilitate subclasses.
org.apache.commons.math4.dfp.Dfp.newInstance	(	byte	): Create an instance from a byte value.
org.apache.commons.math4.dfp.Dfp.newInstance	(	byte	byte	): Creates an instance with a non-finite value.
org.apache.commons.math4.dfp.Dfp.newInstance	(	double	): Create an instance from a double value.
org.apache.commons.math4.dfp.Dfp.newInstance	(	int	): Create an instance from an int value.
org.apache.commons.math4.dfp.Dfp.newInstance	(	long	): Create an instance from a long value.
org.apache.commons.math4.dfp.Dfp.nextAfter	(	Dfp	): Returns the next number greater than this one in the direction of x. If this==x then simply returns this.
org.apache.commons.math4.dfp.Dfp.positiveOrNull	(	): Check if instance is greater than or equal to 0.
org.apache.commons.math4.dfp.Dfp.pow	(	Dfp	): 
org.apache.commons.math4.dfp.Dfp.pow	(	double	): Power operation.
org.apache.commons.math4.dfp.Dfp.pow	(	int	): Integer power operation.
org.apache.commons.math4.dfp.Dfp.power10	(	int	): Return the specified power of 10.
org.apache.commons.math4.dfp.Dfp.power10K	(	int	): Get the specified power of 10000.
org.apache.commons.math4.dfp.Dfp.reciprocal	(	): Returns the multiplicative inverse of this element.  
org.apache.commons.math4.dfp.Dfp.remainder	(	Dfp	): Returns the IEEE remainder.
org.apache.commons.math4.dfp.Dfp.remainder	(	double	): IEEE remainder operator.
org.apache.commons.math4.dfp.Dfp.rint	(	): Round to nearest integer using the round-half-even method. That is round to nearest integer unless both are equidistant. In which case round to the even one.
org.apache.commons.math4.dfp.Dfp.rootN	(	int	): Nth root.
org.apache.commons.math4.dfp.Dfp.round	(	): Get the closest long to instance value.
org.apache.commons.math4.dfp.Dfp.round	(	int	): Round this given the next digit n using the current rounding mode.
org.apache.commons.math4.dfp.Dfp.scalb	(	int	): Multiply the instance by a power of 2.
org.apache.commons.math4.dfp.Dfp.shiftLeft	(	): Shift the mantissa left, and adjust the exponent to compensate.
org.apache.commons.math4.dfp.Dfp.shiftRight	(	): Shift the mantissa right, and adjust the exponent to compensate.
org.apache.commons.math4.dfp.Dfp.signum	(	): Compute the signum of the instance. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
org.apache.commons.math4.dfp.Dfp.sin	(	): Sine operation.
org.apache.commons.math4.dfp.Dfp.sinh	(	): Hyperbolic sine operation.
org.apache.commons.math4.dfp.Dfp.sqrt	(	): Compute the square root.
org.apache.commons.math4.dfp.Dfp.strictlyNegative	(	): Check if instance is strictly less than 0.
org.apache.commons.math4.dfp.Dfp.strictlyPositive	(	): Check if instance is strictly greater than 0.
org.apache.commons.math4.dfp.Dfp.subtract	(	Dfp	): Subtract x from this.
org.apache.commons.math4.dfp.Dfp.subtract	(	double	): '-' operator.
org.apache.commons.math4.dfp.Dfp.tan	(	): Tangent operation.
org.apache.commons.math4.dfp.Dfp.tanh	(	): Hyperbolic tangent operation.
org.apache.commons.math4.dfp.Dfp.toDouble	(	): Convert the instance into a double.
org.apache.commons.math4.dfp.Dfp.toSplitDouble	(	): Convert the instance into a split double.
org.apache.commons.math4.dfp.Dfp.toString	(	): Get a string representation of the instance.
org.apache.commons.math4.dfp.Dfp.trap	(	int	String	Dfp	Dfp	Dfp	): Trap handler. Subclasses may override this to provide trap functionality per IEEE 854-1987.
org.apache.commons.math4.dfp.Dfp.trunc	(	DfpField.RoundingMode	): Does the integer conversions with the specified rounding.
org.apache.commons.math4.dfp.Dfp.unequal	(	Dfp	): Check if instance is not equal to x.
org.apache.commons.math4.dfp.DfpDec: Subclass of Dfp which hides the radix-10000 artifacts of the superclass. This should give outward appearances of being a decimal number with DIGITS*4-3 decimal digits. This class can be subclassed to appear to be an arbitrary number of decimal digits less than DIGITS*4-3.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	Dfp	): Copy constructor.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	): Makes an instance with a value of zero.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	String	): Create an instance from a String representation.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	byte	): Create an instance from a byte value.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	byte	byte	): Creates an instance with a non-finite value.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	double	): Create an instance from a double value.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	int	): Create an instance from an int value.
org.apache.commons.math4.dfp.DfpDec.DfpDec	(	DfpField	long	): Create an instance from a long value.
org.apache.commons.math4.dfp.DfpDec.getDecimalDigits	(	): Get the number of decimal digits this class is going to represent. Default implementation returns getRadixDigits()*4-3. Subclasses can override this to return something less.
org.apache.commons.math4.dfp.DfpDec.newInstance	(	): Create an instance with a value of 0. Use this internally in preference to constructors to facilitate subclasses 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	Dfp	): Create an instance by copying an existing one. Use this internally in preference to constructors to facilitate subclasses. 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	String	): Create an instance from a String representation. Use this internally in preference to constructors to facilitate subclasses. 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	byte	): Create an instance from a byte value. 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	byte	byte	): Creates an instance with a non-finite value. 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	double	): Create an instance from a double value. 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	int	): Create an instance from an int value. 
org.apache.commons.math4.dfp.DfpDec.newInstance	(	long	): Create an instance from a long value. 
org.apache.commons.math4.dfp.DfpDec.nextAfter	(	Dfp	): Returns the next number greater than this one in the direction of x. If this==x then simply returns this. 
org.apache.commons.math4.dfp.DfpDec.round	(	int	): Round this given the next digit n using the current rounding mode. 
org.apache.commons.math4.dfp.DfpField: Field for Decimal floating point instances.
org.apache.commons.math4.dfp.DfpField.DfpField	(	int	): Create a factory for the specified number of radix digits.  Note that since the Dfp class uses 10000 as its radix, each radix digit is equivalent to 4 decimal digits. This implies that asking for 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in all cases. 
org.apache.commons.math4.dfp.DfpField.DfpField	(	int	boolean	): Create a factory for the specified number of radix digits.  Note that since the Dfp class uses 10000 as its radix, each radix digit is equivalent to 4 decimal digits. This implies that asking for 13, 14, 15 or 16 decimal digits will really lead to a 4 radix 10000 digits in all cases. 
org.apache.commons.math4.dfp.DfpField.clearIEEEFlags	(	): Clears the IEEE 854 status flags.
org.apache.commons.math4.dfp.DfpField.computeExp	(	Dfp	Dfp	): Compute exp(a).
org.apache.commons.math4.dfp.DfpField.computeLn	(	Dfp	Dfp	Dfp	): Compute ln(a). Let f(x) = ln(x), We know that f'(x) = 1/x, thus from Taylor's theorem we have: ----- n+1 n f(x) = \ (-1) (x - 1) / ---------------- for 1 <= n <= infinity ----- n or 2 3 4 (x-1) (x-1) (x-1) ln(x) = (x-1) - ----- + ------ - ------ + ... 2 3 4 alternatively, 2 3 4 x x x ln(x+1) = x - - + - - - + ... 2 3 4 This series can be used to compute ln(x), but it converges too slowly. If we substitute -x for x above, we get 2 3 4 x x x ln(1-x) = -x - - - - - - + ... 2 3 4 Note that all terms are now negative. Because the even powered ones absorbed the sign. Now, subtract the series above from the previous one to get ln(x+1) - ln(1-x). Note the even terms cancel out leaving only the odd ones 3 5 7 2x 2x 2x ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ... 3 5 7 By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have: 3 5 7 x+1 / x x x \ ln ----- = 2 * | x + ---- + ---- + ---- + ... | x-1 \ 3 5 7 / But now we want to find ln(a), so we need to find the value of x such that a = (x+1)/(x-1). This is easily solved to find that x = (a-1)/(a+1).
org.apache.commons.math4.dfp.DfpField.computePi	(	Dfp	Dfp	Dfp	): Compute π using Jonathan and Peter Borwein quartic formula.
org.apache.commons.math4.dfp.DfpField.computeStringConstants	(	int	): Recompute the high precision string constants.
org.apache.commons.math4.dfp.DfpField.getE	(	): Get the constant e.
org.apache.commons.math4.dfp.DfpField.getESplit	(	): Get the constant e split in two pieces.
org.apache.commons.math4.dfp.DfpField.getIEEEFlags	(	): Get the IEEE 854 status flags.
org.apache.commons.math4.dfp.DfpField.getLn10	(	): Get the constant ln(10).
org.apache.commons.math4.dfp.DfpField.getLn2	(	): Get the constant ln(2).
org.apache.commons.math4.dfp.DfpField.getLn2Split	(	): Get the constant ln(2) split in two pieces.
org.apache.commons.math4.dfp.DfpField.getLn5	(	): Get the constant ln(5).
org.apache.commons.math4.dfp.DfpField.getLn5Split	(	): Get the constant ln(5) split in two pieces.
org.apache.commons.math4.dfp.DfpField.getOne	(	): Get the constant 1.
org.apache.commons.math4.dfp.DfpField.getPi	(	): Get the constant π.
org.apache.commons.math4.dfp.DfpField.getPiSplit	(	): Get the constant π split in two pieces.
org.apache.commons.math4.dfp.DfpField.getRadixDigits	(	): Get the number of radix digits of the Dfp instances built by this factory.
org.apache.commons.math4.dfp.DfpField.getRoundingMode	(	): Get the current rounding mode.
org.apache.commons.math4.dfp.DfpField.getRuntimeClass	(	): Returns the runtime class of the FieldElement. 
org.apache.commons.math4.dfp.DfpField.getSqr2	(	): Get the constant √2.
org.apache.commons.math4.dfp.DfpField.getSqr2Reciprocal	(	): Get the constant √2 / 2.
org.apache.commons.math4.dfp.DfpField.getSqr2Split	(	): Get the constant √2 split in two pieces.
org.apache.commons.math4.dfp.DfpField.getSqr3	(	): Get the constant √3.
org.apache.commons.math4.dfp.DfpField.getSqr3Reciprocal	(	): Get the constant √3 / 3.
org.apache.commons.math4.dfp.DfpField.getTwo	(	): Get the constant 2.
org.apache.commons.math4.dfp.DfpField.getZero	(	): Get the constant 0.
org.apache.commons.math4.dfp.DfpField.newDfp	(	): Makes a Dfp with a value of 0.
org.apache.commons.math4.dfp.DfpField.newDfp	(	Dfp	): Copy constructor.
org.apache.commons.math4.dfp.DfpField.newDfp	(	String	): Create a Dfp given a String representation.
org.apache.commons.math4.dfp.DfpField.newDfp	(	byte	): Create an instance from a byte value.
org.apache.commons.math4.dfp.DfpField.newDfp	(	byte	byte	): Creates a Dfp with a non-finite value.
org.apache.commons.math4.dfp.DfpField.newDfp	(	double	): Create an instance from a double value.
org.apache.commons.math4.dfp.DfpField.newDfp	(	int	): Create an instance from an int value.
org.apache.commons.math4.dfp.DfpField.newDfp	(	long	): Create an instance from a long value.
org.apache.commons.math4.dfp.DfpField.setIEEEFlags	(	int	): Sets the IEEE 854 status flags.
org.apache.commons.math4.dfp.DfpField.setIEEEFlagsBits	(	int	): Sets some bits in the IEEE 854 status flags, without changing the already set bits.  Calling this method is equivalent to call setIEEEFlags(getIEEEFlags() | bits) 
org.apache.commons.math4.dfp.DfpField.setRoundingMode	(	RoundingMode	): Set the rounding mode. If not set, the default value is ROUND_HALF_EVEN.
org.apache.commons.math4.dfp.DfpField.split	(	String	): Breaks a string representation up into two Dfp's. The split is such that the sum of them is equivalent to the input string, but has higher precision than using a single Dfp.
org.apache.commons.math4.dfp.DfpMath: Mathematical routines for use with Dfp. The constants are defined in DfpField
org.apache.commons.math4.dfp.DfpMath.DfpMath	(	): Private Constructor.
org.apache.commons.math4.dfp.DfpMath.acos	(	Dfp	): computes the arc-cosine of the argument.
org.apache.commons.math4.dfp.DfpMath.asin	(	Dfp	): computes the arc-sine of the argument.
org.apache.commons.math4.dfp.DfpMath.atan	(	Dfp	): computes the arc tangent of the argument Uses the typical taylor series but may reduce arguments using the following identity tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y)) since tan(PI/8) = sqrt(2)-1, atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0
org.apache.commons.math4.dfp.DfpMath.atanInternal	(	Dfp	): computes the arc-tangent of the argument.
org.apache.commons.math4.dfp.DfpMath.cos	(	Dfp	): computes the cosine of the argument.
org.apache.commons.math4.dfp.DfpMath.cosInternal	(	Dfp	): Computes cos(a) Used when 0 < a < pi/4. Uses the classic Taylor series for cosine. 1 - x**2/2! + x**4/4! ...
org.apache.commons.math4.dfp.DfpMath.exp	(	Dfp	): Computes e to the given power. a is broken into two parts, such that a = n+m where n is an integer. We use pow() to compute en and a Taylor series to compute em. We return e*n × em
org.apache.commons.math4.dfp.DfpMath.expInternal	(	Dfp	): Computes e to the given power. Where -1 < a < 1. Use the classic Taylor series. 1 + x**2/2! + x**3/3! + x**4/4! ... 
org.apache.commons.math4.dfp.DfpMath.log	(	Dfp	): Returns the natural logarithm of a. a is first split into three parts such that a = (10000^h)(2^j)k. ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k). k is in the range 2/3 < k <4/3 and is passed on to a series expansion.
org.apache.commons.math4.dfp.DfpMath.logInternal	(	Dfp	): Computes the natural log of a number between 0 and 2. Let f(x) = ln(x), We know that f'(x) = 1/x, thus from Taylor's theorum we have: ----- n+1 n f(x) = \ (-1) (x - 1) / ---------------- for 1 <= n <= infinity ----- n or 2 3 4 (x-1) (x-1) (x-1) ln(x) = (x-1) - ----- + ------ - ------ + ... 2 3 4 alternatively, 2 3 4 x x x ln(x+1) = x - - + - - - + ... 2 3 4 This series can be used to compute ln(x), but it converges too slowly. If we substitute -x for x above, we get 2 3 4 x x x ln(1-x) = -x - - - - - - + ... 2 3 4 Note that all terms are now negative. Because the even powered ones absorbed the sign. Now, subtract the series above from the previous one to get ln(x+1) - ln(1-x). Note the even terms cancel out leaving only the odd ones 3 5 7 2x 2x 2x ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ... 3 5 7 By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have: 3 5 7 x+1 / x x x \ ln ----- = 2 * | x + ---- + ---- + ---- + ... | x-1 \ 3 5 7 / But now we want to find ln(a), so we need to find the value of x such that a = (x+1)/(x-1). This is easily solved to find that x = (a-1)/(a+1).
org.apache.commons.math4.dfp.DfpMath.pow	(	Dfp	Dfp	): Computes x to the y power. Uses the following method:   Set u = rint(y), v = y-u  Compute a = v * ln(x)  Compute b = rint( a/ln(2) )  Compute c = a - b*ln(2)  xy = xu * 2b * ec  if |y| > 1e8, then we compute by exp(y*ln(x)) Special Cases   if y is 0.0 or -0.0 then result is 1.0  if y is 1.0 then result is x  if y is NaN then result is NaN  if x is NaN and y is not zero then result is NaN  if |x| > 1.0 and y is +Infinity then result is +Infinity  if |x| < 1.0 and y is -Infinity then result is +Infinity  if |x| > 1.0 and y is -Infinity then result is +0  if |x| < 1.0 and y is +Infinity then result is +0  if |x| = 1.0 and y is +/-Infinity then result is NaN  if x = +0 and y > 0 then result is +0  if x = +Inf and y < 0 then result is +0  if x = +0 and y < 0 then result is +Inf  if x = +Inf and y > 0 then result is +Inf  if x = -0 and y > 0, finite, not odd integer then result is +0  if x = -0 and y < 0, finite, and odd integer then result is -Inf  if x = -Inf and y > 0, finite, and odd integer then result is -Inf  if x = -0 and y < 0, not finite odd integer then result is +Inf  if x = -Inf and y > 0, not finite odd integer then result is +Inf  if x < 0 and y > 0, finite, and odd integer then result is -(|x|y)  if x < 0 and y > 0, finite, and not integer then result is NaN 
org.apache.commons.math4.dfp.DfpMath.pow	(	Dfp	int	): Raises base to the power a by successive squaring.
org.apache.commons.math4.dfp.DfpMath.sin	(	Dfp	): computes the sine of the argument.
org.apache.commons.math4.dfp.DfpMath.sinInternal	(	Dfp	): Computes sin(a) Used when 0 < a < pi/4}. Uses the classic Taylor series. x - x**3/3! + x**5/5! ... 
org.apache.commons.math4.dfp.DfpMath.split	(	Dfp	): Splits a Dfp into 2 Dfp's such that their sum is equal to the input Dfp.
org.apache.commons.math4.dfp.DfpMath.split	(	DfpField	String	): Breaks a string representation up into two dfp's. The two dfp are such that the sum of them is equivalent to the input string, but has higher precision than using a single dfp. This is useful for improving accuracy of exponentiation and critical multiplies.
org.apache.commons.math4.dfp.DfpMath.splitDiv	(	Dfp[]	Dfp[]	): Divide two numbers that are split in to two pieces that are meant to be added together. Inverse of split multiply above: (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )
org.apache.commons.math4.dfp.DfpMath.splitMult	(	Dfp[]	Dfp[]	): Multiply two numbers that are split in to two pieces that are meant to be added together. Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1 Store the first term in result0, the rest in result1
org.apache.commons.math4.dfp.DfpMath.splitPow	(	Dfp[]	int	): Raise a split base to the a power.
org.apache.commons.math4.dfp.DfpMath.tan	(	Dfp	): computes the tangent of the argument.
org.apache.commons.math4.distribution.AbstractIntegerDistribution: Base class for integer-valued discrete distributions. Default implementations are provided for some of the methods that do not vary from distribution to distribution.
org.apache.commons.math4.distribution.AbstractIntegerDistribution.checkedCumulativeProbability	(	int	): Computes the cumulative probability function and checks for NaN values returned. Throws MathInternalError if the value is NaN. Rethrows any exception encountered evaluating the cumulative probability function. Throws MathInternalError if the cumulative probability function returns NaN.
org.apache.commons.math4.distribution.AbstractIntegerDistribution.createICPF	(	): 
org.apache.commons.math4.distribution.AbstractIntegerDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.AbstractIntegerDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in Z | P(X<=x) >= p} for 0 < p <= 1, inf{x in Z | P(X<=x) > 0} for p = 0.  If the result exceeds the range of the data type int, then Integer.MIN_VALUE or Integer.MAX_VALUE is returned. The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1, and solveInverseCumulativeProbability() for 0 < p < 1. 
org.apache.commons.math4.distribution.AbstractIntegerDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x).
org.apache.commons.math4.distribution.AbstractIntegerDistribution.probability	(	int	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(x0 < X <= x1). The default implementation uses the identity P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)
org.apache.commons.math4.distribution.AbstractIntegerDistribution.sample	(	int	IntegerDistribution.Sampler	): Utility function for allocating an array and filling it with n samples generated by the given sampler.
org.apache.commons.math4.distribution.AbstractIntegerDistribution.solveInverseCumulativeProbability	(	double	int	int	): This is a utility function used by inverseCumulativeProbability(). It assumes 0 < p < 1 and that the inverse cumulative probability lies in the bracket (lower, upper]. The implementation does simple bisection to find the smallest p-quantile inf{x in Z | P(X<=x) >= p}.
org.apache.commons.math4.distribution.AbstractIntegerDistributionTest: Test cases for AbstractIntegerDistribution default implementations.
org.apache.commons.math4.distribution.AbstractIntegerDistributionTest.DiceDistribution: Simple distribution modeling a 6-sided die
org.apache.commons.math4.distribution.AbstractMultivariateRealDistribution: Base class for multivariate probability distributions.
org.apache.commons.math4.distribution.AbstractMultivariateRealDistribution.AbstractMultivariateRealDistribution	(	int	): 
org.apache.commons.math4.distribution.AbstractMultivariateRealDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.AbstractMultivariateRealDistribution.getDimension	(	): Gets the number of random variables of the distribution. It is the size of the array returned by the sample() method. 
org.apache.commons.math4.distribution.AbstractMultivariateRealDistribution.sample	(	int	MultivariateRealDistribution.Sampler	): Utility function for creating n vectors generated by the given sampler.
org.apache.commons.math4.distribution.AbstractRealDistribution: Base class for probability distributions on the reals. Default implementations are provided for some of the methods that do not vary from distribution to distribution.  This base class provides a default factory method for creating a RealDistribution.Sampler sampler instance that uses the  inversion method for generating random samples that follow the distribution. 
org.apache.commons.math4.distribution.AbstractRealDistribution.createICPF	(	): 
org.apache.commons.math4.distribution.AbstractRealDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.AbstractRealDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default.
org.apache.commons.math4.distribution.AbstractRealDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1. 
org.apache.commons.math4.distribution.AbstractRealDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x).
org.apache.commons.math4.distribution.AbstractRealDistribution.probability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.AbstractRealDistribution.probability	(	double	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(x0 < X <= x1).
org.apache.commons.math4.distribution.AbstractRealDistribution.sample	(	int	RealDistribution.Sampler	): Utility function for allocating an array and filling it with n samples generated by the given sampler.
org.apache.commons.math4.distribution.AbstractRealDistributionTest: Various tests related to MATH-699. 
org.apache.commons.math4.distribution.BetaDistribution: Implements the Beta distribution.
org.apache.commons.math4.distribution.BetaDistribution.BetaDistribution	(	double	double	): Creates a new instance.
org.apache.commons.math4.distribution.BetaDistribution.BetaDistribution	(	double	double	double	): Creates a new instance.
org.apache.commons.math4.distribution.BetaDistribution.createSampler	(	UniformRandomProvider	):  Sampling is performed using Cheng's algorithm:   R. C. H. Cheng, "Generating beta variates with nonintegral shape parameters", Communications of the ACM, 21, 317-322, 1978.  
org.apache.commons.math4.distribution.BetaDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.BetaDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.BetaDistribution.getAlpha	(	): Access the first shape parameter, alpha.
org.apache.commons.math4.distribution.BetaDistribution.getBeta	(	): Access the second shape parameter, beta.
org.apache.commons.math4.distribution.BetaDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For first shape parameter alpha and second shape parameter beta, the mean is alpha / (alpha + beta).
org.apache.commons.math4.distribution.BetaDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For first shape parameter alpha and second shape parameter beta, the variance is (alpha * beta) / [(alpha + beta)^2 * (alpha + beta + 1)].
org.apache.commons.math4.distribution.BetaDistribution.getSolverAbsoluteAccuracy	(	): Return the absolute accuracy setting of the solver used to estimate inverse cumulative probabilities.
org.apache.commons.math4.distribution.BetaDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the parameters.
org.apache.commons.math4.distribution.BetaDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always 1 no matter the parameters.
org.apache.commons.math4.distribution.BetaDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.BetaDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.BinomialDistribution: Implementation of the binomial distribution.
org.apache.commons.math4.distribution.BinomialDistribution.BinomialDistribution	(	int	double	): Creates a binomial distribution.
org.apache.commons.math4.distribution.BinomialDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.BinomialDistribution.getNumberOfTrials	(	): Access the number of trials for this distribution.
org.apache.commons.math4.distribution.BinomialDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For n trials and probability parameter p, the mean is n * p.
org.apache.commons.math4.distribution.BinomialDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For n trials and probability parameter p, the variance is n * p * (1 - p).
org.apache.commons.math4.distribution.BinomialDistribution.getProbabilityOfSuccess	(	): Access the probability of success for this distribution.
org.apache.commons.math4.distribution.BinomialDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. The lower bound of the support is always 0 except for the probability parameter p = 1.
org.apache.commons.math4.distribution.BinomialDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is the number of trials except for the probability parameter p = 0.
org.apache.commons.math4.distribution.BinomialDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.BinomialDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x). 
org.apache.commons.math4.distribution.BinomialDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.BinomialDistributionTest: Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest. See class javadoc for IntegerDistributionAbstractTest for details.
org.apache.commons.math4.distribution.BinomialDistributionTest.BinomialDistributionTest	(	): Constructor to override default tolerance.
org.apache.commons.math4.distribution.BinomialDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values 
org.apache.commons.math4.distribution.BinomialDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values. Reference values are from R, version 2.15.3.
org.apache.commons.math4.distribution.BinomialDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values. 
org.apache.commons.math4.distribution.BinomialDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values. Reference values are from R, version 2.15.3.
org.apache.commons.math4.distribution.BinomialDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.BinomialDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.BinomialDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values
org.apache.commons.math4.distribution.BinomialDistributionTest.testDegenerate0	(	): Test degenerate case p = 0 
org.apache.commons.math4.distribution.BinomialDistributionTest.testDegenerate1	(	): Test degenerate case p = 1 
org.apache.commons.math4.distribution.BinomialDistributionTest.testDegenerate2	(	): Test degenerate case n = 0 
org.apache.commons.math4.distribution.CauchyDistribution: Implementation of the Cauchy distribution.
org.apache.commons.math4.distribution.CauchyDistribution.CauchyDistribution	(	): Creates a Cauchy distribution with the median equal to zero and scale equal to one.
org.apache.commons.math4.distribution.CauchyDistribution.CauchyDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.CauchyDistribution.CauchyDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.CauchyDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.CauchyDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.CauchyDistribution.getMedian	(	): Access the median.
org.apache.commons.math4.distribution.CauchyDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. The mean is always undefined no matter the parameters.
org.apache.commons.math4.distribution.CauchyDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. The variance is always undefined no matter the parameters.
org.apache.commons.math4.distribution.CauchyDistribution.getScale	(	): Access the scale parameter.
org.apache.commons.math4.distribution.CauchyDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.CauchyDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always negative infinity no matter the parameters.
org.apache.commons.math4.distribution.CauchyDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.CauchyDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  Returns Double.NEGATIVE_INFINITY when p == 0 and Double.POSITIVE_INFINITY when p == 1.
org.apache.commons.math4.distribution.CauchyDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.CauchyDistributionTest: Test cases for CauchyDistribution. Extends ContinuousDistributionAbstractTest. See class javadoc for ContinuousDistributionAbstractTest for details.
org.apache.commons.math4.distribution.CauchyDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.CauchyDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.CauchyDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.CauchyDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.ChiSquaredDistribution: Implementation of the chi-squared distribution.
org.apache.commons.math4.distribution.ChiSquaredDistribution.ChiSquaredDistribution	(	double	): Creates distribution with the given degrees of freedom.
org.apache.commons.math4.distribution.ChiSquaredDistribution.ChiSquaredDistribution	(	double	double	): Creates a distribution with the given degrees of freedom and inverse cumulative probability accuracy.
org.apache.commons.math4.distribution.ChiSquaredDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.ChiSquaredDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.ChiSquaredDistribution.getDegreesOfFreedom	(	): Access the number of degrees of freedom.
org.apache.commons.math4.distribution.ChiSquaredDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For k degrees of freedom, the mean is k.
org.apache.commons.math4.distribution.ChiSquaredDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.ChiSquaredDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.ChiSquaredDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the degrees of freedom.
org.apache.commons.math4.distribution.ChiSquaredDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the degrees of freedom.
org.apache.commons.math4.distribution.ChiSquaredDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.ChiSquaredDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.ChiSquaredDistributionTest: Test cases for ChiSquaredDistribution.
org.apache.commons.math4.distribution.ChiSquaredDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.ChiSquaredDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.ChiSquaredDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.ChiSquaredDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.ChiSquaredDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.ChiSquaredDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.ConstantRealDistribution: Implementation of the constant real distribution.
org.apache.commons.math4.distribution.ConstantRealDistribution.ConstantRealDistribution	(	double	): Create a constant real distribution with the given value.
org.apache.commons.math4.distribution.ConstantRealDistribution.createSampler	(	UniformRandomProvider	): 
org.apache.commons.math4.distribution.ConstantRealDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.ConstantRealDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.ConstantRealDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.
org.apache.commons.math4.distribution.ConstantRealDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.ConstantRealDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}.
org.apache.commons.math4.distribution.ConstantRealDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}.
org.apache.commons.math4.distribution.ConstantRealDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.ConstantRealDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support.
org.apache.commons.math4.distribution.ConstantRealDistributionTest: Test cases for ConstantRealDistribution.
org.apache.commons.math4.distribution.ConstantRealDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.ConstantRealDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability distribution test expected values 
org.apache.commons.math4.distribution.ConstantRealDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.ConstantRealDistributionTest.makeDistribution	(	): Creates the default uniform real distribution instance to use in tests. 
org.apache.commons.math4.distribution.ConstantRealDistributionTest.testInverseCumulativeProbabilities	(	): Override default test, verifying that inverse cum is constant 
org.apache.commons.math4.distribution.EmpiricalDistribution: Represents an  empirical probability distribution -- a probability distribution derived from observed data without making any assumptions about the functional form of the population distribution that the data come from. An EmpiricalDistribution maintains data structures, called distribution digests, that describe empirical distributions and support the following operations:  loading the distribution from a file of observed data values dividing the input data into "bin ranges" and reporting bin frequency counts (data for histogram) reporting univariate statistics describing the full set of data values as well as the observations within each bin generating random values from the distribution  Applications can use EmpiricalDistribution to build grouped frequency histograms representing the input data or to generate random values "like" those in the input file -- i.e., the values generated will follow the distribution of the values in the file. The implementation uses what amounts to the  Variable Kernel Method with Gaussian smoothing: Digesting the input file Pass the file once to compute min and max. Divide the range from min-max into binCount "bins." Pass the data file again, computing bin counts and univariate statistics (mean, std dev.) for each of the bins  Divide the interval (0,1) into subintervals associated with the bins, with the length of a bin's subinterval proportional to its count. Generating random values from the distribution Generate a uniformly distributed value in (0,1)  Select the subinterval to which the value belongs. Generate a random Gaussian value with mean = mean of the associated bin and std dev = std dev of associated bin. EmpiricalDistribution implements the RealDistribution interface as follows. Given x within the range of values in the dataset, let B be the bin containing x and let K be the within-bin kernel for B. Let P(B-) be the sum of the probabilities of the bins below B and let K(B) be the mass of B under K (i.e., the integral of the kernel density over B). Then set P(X < x) = P(B-) + P(B) * K(x) / K(B) where K(x) is the kernel distribution evaluated at x. This results in a cdf that matches the grouped frequency distribution at the bin endpoints and interpolates within bins using within-bin kernels. USAGE NOTES: The binCount is set by default to 1000. A good rule of thumb is to set the bin count to approximately the length of the input file divided by 10.  The input file must be a plain text file containing one valid numeric entry per line. 
org.apache.commons.math4.distribution.EmpiricalDistribution.ArrayDataAdapter: DataAdapter for data provided as array of doubles.
org.apache.commons.math4.distribution.EmpiricalDistribution.ArrayDataAdapter.ArrayDataAdapter	(	double[]	): Construct an ArrayDataAdapter from a double[] array
org.apache.commons.math4.distribution.EmpiricalDistribution.ArrayDataAdapter.computeBinStats	(	): Compute bin stats. 
org.apache.commons.math4.distribution.EmpiricalDistribution.ArrayDataAdapter.computeStats	(	): Compute sample statistics. 
org.apache.commons.math4.distribution.EmpiricalDistribution.DataAdapter: Provides methods for computing sampleStats and beanStats abstracting the source of data.
org.apache.commons.math4.distribution.EmpiricalDistribution.DataAdapter.computeBinStats	(	): Compute bin stats.
org.apache.commons.math4.distribution.EmpiricalDistribution.DataAdapter.computeStats	(	): Compute sample statistics.
org.apache.commons.math4.distribution.EmpiricalDistribution.EmpiricalDistribution	(	): Creates a new EmpiricalDistribution with the default bin count.
org.apache.commons.math4.distribution.EmpiricalDistribution.EmpiricalDistribution	(	int	): Creates a new EmpiricalDistribution with the specified bin count.
org.apache.commons.math4.distribution.EmpiricalDistribution.StreamDataAdapter: DataAdapter for data provided through some input stream
org.apache.commons.math4.distribution.EmpiricalDistribution.StreamDataAdapter.StreamDataAdapter	(	BufferedReader	): Create a StreamDataAdapter from a BufferedReader
org.apache.commons.math4.distribution.EmpiricalDistribution.StreamDataAdapter.computeBinStats	(	): Compute bin stats. 
org.apache.commons.math4.distribution.EmpiricalDistribution.StreamDataAdapter.computeStats	(	): Compute sample statistics. 
org.apache.commons.math4.distribution.EmpiricalDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.EmpiricalDistribution.cumBinP	(	int	): The combined probability of the bins up to and including binIndex.
org.apache.commons.math4.distribution.EmpiricalDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. Algorithm description: Find the bin B that x belongs to. Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B. Compute K(B) = the probability mass of B with respect to the within-bin kernel and K(B-) = the kernel distribution evaluated at the lower endpoint of B Return P(B-) + P(B) * [K(x) - K(B-)] / K(B) where K(x) is the within-bin kernel distribution function evaluated at x. If K is a constant distribution, we return P(B-) + P(B) (counting the full mass of B).
org.apache.commons.math4.distribution.EmpiricalDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Returns the kernel density normalized so that its integral over each bin equals the bin mass. Algorithm description:  Find the bin B that x belongs to. Compute K(B) = the mass of B with respect to the within-bin kernel (i.e., the integral of the kernel density over B). Return k(x) * P(B) / K(B), where k is the within-bin kernel density and P(B) is the mass of B.
org.apache.commons.math4.distribution.EmpiricalDistribution.fillBinStats	(	DataAdapter	): Fills binStats array (second pass through data file).
org.apache.commons.math4.distribution.EmpiricalDistribution.findBin	(	double	): Returns the index of the bin to which the given value belongs
org.apache.commons.math4.distribution.EmpiricalDistribution.getBinCount	(	): Returns the number of bins.
org.apache.commons.math4.distribution.EmpiricalDistribution.getBinStats	(	): Returns a List of SummaryStatistics instances containing statistics describing the values in each of the bins. The list is indexed on the bin number.
org.apache.commons.math4.distribution.EmpiricalDistribution.getGeneratorUpperBounds	(	): Returns a fresh copy of the array of upper bounds of the subintervals of [0,1] used in generating data from the empirical distribution. Subintervals correspond to bins with lengths proportional to bin counts. Preconditions: the distribution must be loaded before invoking this method In versions 1.0-2.0 of commons-math, this array was (incorrectly) returned by getUpperBounds().
org.apache.commons.math4.distribution.EmpiricalDistribution.getKernel	(	SummaryStatistics	): The within-bin smoothing kernel. Returns a Gaussian distribution parameterized by bStats, unless the bin contains only one observation, in which case a constant distribution is returned.
org.apache.commons.math4.distribution.EmpiricalDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.
org.apache.commons.math4.distribution.EmpiricalDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.EmpiricalDistribution.getSampleStats	(	): Returns a StatisticalSummary describing this distribution. Preconditions: the distribution must be loaded before invoking this method
org.apache.commons.math4.distribution.EmpiricalDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}.
org.apache.commons.math4.distribution.EmpiricalDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}.
org.apache.commons.math4.distribution.EmpiricalDistribution.getUpperBounds	(	): Returns a fresh copy of the array of upper bounds for the bins. Bins are:  [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],..., (upperBounds[binCount-2], upperBounds[binCount-1] = max]. Note: In versions 1.0-2.0 of commons-math, this method incorrectly returned the array of probability generator upper bounds now returned by getGeneratorUpperBounds().
org.apache.commons.math4.distribution.EmpiricalDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  Algorithm description: Find the smallest i such that the sum of the masses of the bins through i is at least p.  Let K be the within-bin kernel distribution for bin i. Let K(B) be the mass of B under K.  Let K(B-) be K evaluated at the lower endpoint of B (the combined mass of the bins below B under K). Let P(B) be the probability of bin i. Let P(B-) be the sum of the bin masses below bin i.  Let pCrit = p - P(B-) Return the inverse of K evaluated at  K(B-) + pCrit * K(B) / P(B)  
org.apache.commons.math4.distribution.EmpiricalDistribution.isLoaded	(	): Property indicating whether or not the distribution has been loaded.
org.apache.commons.math4.distribution.EmpiricalDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support.
org.apache.commons.math4.distribution.EmpiricalDistribution.k	(	double	): The within-bin kernel of the bin that x belongs to.
org.apache.commons.math4.distribution.EmpiricalDistribution.kB	(	int	): Mass of bin i under the within-bin kernel of the bin.
org.apache.commons.math4.distribution.EmpiricalDistribution.load	(	File	): Computes the empirical distribution from the input file. The input file must be an ASCII text file containing one valid numeric entry per line.
org.apache.commons.math4.distribution.EmpiricalDistribution.load	(	URL	): Computes the empirical distribution using data read from a URL. The input file must be an ASCII text file containing one valid numeric entry per line.
org.apache.commons.math4.distribution.EmpiricalDistribution.load	(	double[]	): Computes the empirical distribution from the provided array of numbers.
org.apache.commons.math4.distribution.EmpiricalDistribution.pB	(	int	): The probability of bin i.
org.apache.commons.math4.distribution.EmpiricalDistribution.pBminus	(	int	): The combined probability of the bins up to but not including bin i.
org.apache.commons.math4.distribution.EmpiricalDistribution.probability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.EmpiricalDistributionTest: Test cases for the EmpiricalDistribution class.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.ConstantKernelEmpiricalDistribution: Empirical distribution using a constant smoothing kernel.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.UniformKernelEmpiricalDistribution: Empirical distribution using a uniform smoothing kernel.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.findBin	(	double	): Find the bin that x belongs (relative to makeDistribution()).
org.apache.commons.math4.distribution.EmpiricalDistributionTest.findKernel	(	double	double	): Find the within-bin kernel for the bin with lower bound lower and upper bound upper. All bins other than the first contain 10 points exclusive of the lower bound and are centered at (lower + upper + 1) / 2. The first bin includes its lower bound, 0, so has different mean and standard deviation.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testBinIndexOverflow	(	): Test bin index overflow problem (BZ 36450)
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testDensityIntegrals	(	): Modify test integration bounds from the default. Because the distribution has discontinuities at bin boundaries, integrals spanning multiple bins will face convergence problems. Only test within-bin integrals and spans across no more than 3 bin boundaries.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testDoubleLoad	(	): Test EmpiricalDistrbution.load(double[]) using data taken from sample data file. Check that the sampleCount, mu and sigma match data in the sample data file.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testGetBinUpperBounds	(	): MATH-298
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testGridTooFat	(	): How about too fat?
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testGridTooFine	(	): Make sure we can handle a grid size that is too fine
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testLoad	(	): Test EmpiricalDistrbution.load() using sample data file. Check that the sampleCount, mu and sigma match data in the sample data file. Also verify that load is idempotent.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testNext	(	): Generate 1000 random values and make sure they look OK. Note that there is a non-zero (but very small) probability that these tests will fail even if the code is working as designed.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testNextFail1	(	): Make sure exception thrown if sampling is attempted before loading empiricalDistribution.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testNextFail2	(	): Make sure exception thrown if sampling is attempted before loading empiricalDistribution.
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testNoBinVariance	(	): MATH-1203, MATH-1208
org.apache.commons.math4.distribution.EmpiricalDistributionTest.testSampleValuesRange	(	): MATH-984 Verify that sampled values do not go outside of the range of the data.
org.apache.commons.math4.distribution.EnumeratedDistribution: A generic implementation of a  discrete probability distribution (Wikipedia) over a finite sample space, based on an enumerated list of <value, probability> pairs. Input probabilities must all be non-negative, but zero values are allowed and their sum does not have to equal one. Constructors will normalize input probabilities to make them sum to one. The list of <value, probability> pairs does not, strictly speaking, have to be a function and it can contain null values. The pmf created by the constructor will combine probabilities of equal values and will treat null values as equal. For example, if the list of pairs <"dog", 0.2>, <null, 0.1>, <"pig", 0.2>, <"dog", 0.1>, <null, 0.4> is provided to the constructor, the resulting pmf will assign mass of 0.5 to null, 0.3 to "dog" and 0.2 to null.
org.apache.commons.math4.distribution.EnumeratedDistribution.EnumeratedDistribution	(	List	): Create an enumerated distribution using the given random number generator and probability mass function enumeration.
org.apache.commons.math4.distribution.EnumeratedDistribution.Sampler: Sampler functionality.
org.apache.commons.math4.distribution.EnumeratedDistribution.Sampler.Sampler	(	UniformRandomProvider	): 
org.apache.commons.math4.distribution.EnumeratedDistribution.Sampler.sample	(	): Generates a random value sampled from this distribution.
org.apache.commons.math4.distribution.EnumeratedDistribution.Sampler.sample	(	int	): Generates a random sample from the distribution.
org.apache.commons.math4.distribution.EnumeratedDistribution.Sampler.sample	(	int	T[]	): Generates a random sample from the distribution.  If the requested samples fit in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection.
org.apache.commons.math4.distribution.EnumeratedDistribution.createSampler	(	UniformRandomProvider	): Creates a Sampler.
org.apache.commons.math4.distribution.EnumeratedDistribution.getPmf	(	): Return the probability mass function as a list of <value, probability> pairs. Note that if duplicate and / or null values were provided to the constructor when creating this EnumeratedDistribution, the returned list will contain these values. If duplicates values exist, what is returned will not represent a pmf (i.e., it is up to the caller to consolidate duplicate mass points).
org.apache.commons.math4.distribution.EnumeratedDistribution.probability	(	T	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. Note that if x1 and x2 satisfy x1.equals(x2), or both are null, then probability(x1) = probability(x2).
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution: Implementation of an integer-valued EnumeratedDistribution. Values with zero-probability are allowed but they do not extend the support. Duplicate values are allowed. Probabilities of duplicate values are combined when computing cumulative probabilities and statistics.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.EnumeratedIntegerDistribution	(	int[]	): Create a discrete integer-valued distribution from the input data. Values are assigned mass based on their frequency.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.EnumeratedIntegerDistribution	(	int[]	double[]	): Create a discrete distribution.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.createDistribution	(	int[]	double[]	): Create the list of Pairs representing the distribution from singletons and probabilities.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. Returns the lowest value with non-zero probability.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. Returns the highest value with non-zero probability.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.EnumeratedIntegerDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest: Test class for EnumeratedIntegerDistribution.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.EnumeratedIntegerDistributionTest	(	): Creates the default distribution object used for testing.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testCumulativeProbability	(	): Tests if the distribution returns proper cumulative probability values.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testExceptions	(	): Tests if the EnumeratedIntegerDistribution constructor throws exceptions for invalid data.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testGetNumericalMean	(	): Tests if the distribution returns proper mean value.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testGetNumericalVariance	(	): Tests if the distribution returns proper variance.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testGetSupportLowerBound	(	): Tests if the distribution returns proper lower bound.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testGetSupportUpperBound	(	): Tests if the distribution returns proper upper bound.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testIsSupportConnected	(	): Tests if the distribution returns properly that the support is connected.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testProbability	(	): Tests if the distribution returns proper probability values.
org.apache.commons.math4.distribution.EnumeratedIntegerDistributionTest.testSample	(	): Tests sampling.
org.apache.commons.math4.distribution.EnumeratedRealDistribution: Implementation of a real-valued EnumeratedDistribution. Values with zero-probability are allowed but they do not extend the support. Duplicate values are allowed. Probabilities of duplicate values are combined when computing cumulative probabilities and statistics.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.EnumeratedRealDistribution	(	double[]	): Creates a discrete real-valued distribution from the input data. Values are assigned mass based on their frequency.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.EnumeratedRealDistribution	(	double[]	double[]	): Create a discrete real-valued distribution using the given random number generator and probability mass function enumeration.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.createDistribution	(	double[]	double[]	): Create the list of Pairs representing the distribution from singletons and probabilities.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.EnumeratedRealDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.density	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. Returns the lowest value with non-zero probability.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. Returns the highest value with non-zero probability.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1. 
org.apache.commons.math4.distribution.EnumeratedRealDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.EnumeratedRealDistribution.probability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest: Test class for EnumeratedRealDistribution.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.EnumeratedRealDistributionTest	(	): Creates the default distribution object used for testing.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testCumulativeProbability	(	): Tests if the distribution returns proper cumulative probability values.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testDensity	(	): Tests if the distribution returns proper density values.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testExceptions	(	): Tests if the EnumeratedRealDistribution constructor throws exceptions for invalid data.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testGetNumericalMean	(	): Tests if the distribution returns proper mean value.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testGetNumericalVariance	(	): Tests if the distribution returns proper variance.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testGetSupportLowerBound	(	): Tests if the distribution returns proper lower bound.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testGetSupportUpperBound	(	): Tests if the distribution returns proper upper bound.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testIsSupportConnected	(	): Tests if the distribution returns properly that the support is connected.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testProbability	(	): Tests if the distribution returns proper probability values.
org.apache.commons.math4.distribution.EnumeratedRealDistributionTest.testSample	(	): Tests sampling.
org.apache.commons.math4.distribution.ExponentialDistribution: Implementation of the exponential distribution.
org.apache.commons.math4.distribution.ExponentialDistribution.ExponentialDistribution	(	double	): Creates a distribution.
org.apache.commons.math4.distribution.ExponentialDistribution.ExponentialDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.ExponentialDistribution.createSampler	(	UniformRandomProvider	):  Sampling algorithm uses the  inversion method to generate exponentially distributed random values from uniform deviates. 
org.apache.commons.math4.distribution.ExponentialDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. The implementation of this method is based on:    Exponential Distribution, equation (1). 
org.apache.commons.math4.distribution.ExponentialDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.ExponentialDistribution.getMean	(	): Access the mean.
org.apache.commons.math4.distribution.ExponentialDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For mean parameter k, the mean is k.
org.apache.commons.math4.distribution.ExponentialDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For mean parameter k, the variance is k^2.
org.apache.commons.math4.distribution.ExponentialDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.ExponentialDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the mean parameter.
org.apache.commons.math4.distribution.ExponentialDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the mean parameter.
org.apache.commons.math4.distribution.ExponentialDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  Returns 0 when p= = 0 and Double.POSITIVE_INFINITY when p == 1.
org.apache.commons.math4.distribution.ExponentialDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.ExponentialDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.ExponentialDistributionTest: Test cases for ExponentialDistribution. Extends ContinuousDistributionAbstractTest. See class javadoc for ContinuousDistributionAbstractTest for details.
org.apache.commons.math4.distribution.ExponentialDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.ExponentialDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.ExponentialDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.ExponentialDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.FDistribution: Implementation of the F-distribution.
org.apache.commons.math4.distribution.FDistribution.FDistribution	(	double	double	): Creates a using the given degrees of freedom.
org.apache.commons.math4.distribution.FDistribution.FDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.FDistribution.calculateNumericalVariance	(	): used by getNumericalVariance()
org.apache.commons.math4.distribution.FDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. The implementation of this method is based on    F-Distribution, equation (4).  
org.apache.commons.math4.distribution.FDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient.
org.apache.commons.math4.distribution.FDistribution.getDenominatorDegreesOfFreedom	(	): Access the denominator degrees of freedom.
org.apache.commons.math4.distribution.FDistribution.getNumeratorDegreesOfFreedom	(	): Access the numerator degrees of freedom.
org.apache.commons.math4.distribution.FDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For denominator degrees of freedom parameter b, the mean is  if b > 2 then b / (b - 2), else undefined (Double.NaN). 
org.apache.commons.math4.distribution.FDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For numerator degrees of freedom parameter a and denominator degrees of freedom parameter b, the variance is   if b > 4 then [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)],  else undefined (Double.NaN). 
org.apache.commons.math4.distribution.FDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.FDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the parameters.
org.apache.commons.math4.distribution.FDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.FDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.FDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.FDistributionTest: Test cases for FDistribution. Extends ContinuousDistributionAbstractTest. See class javadoc for ContinuousDistributionAbstractTest for details.
org.apache.commons.math4.distribution.FDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.FDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.FDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.FDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.GammaDistribution: Implementation of the Gamma distribution.
org.apache.commons.math4.distribution.GammaDistribution.GammaDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.GammaDistribution.GammaDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.GammaDistribution.createSampler	(	UniformRandomProvider	):   Sampling algorithms:   For 0 < shape < 1:  Ahrens, J. H. and Dieter, U., Computer methods for sampling from gamma, beta, Poisson and binomial distributions, Computing, 12, 223-246, 1974.    For shape >= 1:  Marsaglia and Tsang, A Simple Method for Generating Gamma Variables. ACM Transactions on Mathematical Software, Volume 26 Issue 3, September, 2000.   
org.apache.commons.math4.distribution.GammaDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. The implementation of this method is based on:    Chi-Squared Distribution, equation (9).  Casella, G., & Berger, R. (1990). Statistical Inference. Belmont, CA: Duxbury Press.  
org.apache.commons.math4.distribution.GammaDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.GammaDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For shape parameter alpha and scale parameter beta, the mean is alpha * beta.
org.apache.commons.math4.distribution.GammaDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For shape parameter alpha and scale parameter beta, the variance is alpha * beta^2.
org.apache.commons.math4.distribution.GammaDistribution.getScale	(	): Returns the scale parameter of this distribution.
org.apache.commons.math4.distribution.GammaDistribution.getShape	(	): Returns the shape parameter of this distribution.
org.apache.commons.math4.distribution.GammaDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.GammaDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the parameters.
org.apache.commons.math4.distribution.GammaDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.GammaDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.GammaDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.GammaDistributionTest: Test cases for GammaDistribution. Extends ContinuousDistributionAbstractTest. See class javadoc for ContinuousDistributionAbstractTest for details.
org.apache.commons.math4.distribution.GammaDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.GammaDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.GammaDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.GammaDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.GeometricDistribution: Implementation of the geometric distribution.
org.apache.commons.math4.distribution.GeometricDistribution.GeometricDistribution	(	double	): Creates a geometric distribution.
org.apache.commons.math4.distribution.GeometricDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.GeometricDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For probability parameter p, the mean is (1 - p) / p.
org.apache.commons.math4.distribution.GeometricDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For probability parameter p, the variance is (1 - p) / (p * p).
org.apache.commons.math4.distribution.GeometricDistribution.getProbabilityOfSuccess	(	): Access the probability of success for this distribution.
org.apache.commons.math4.distribution.GeometricDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. The lower bound of the support is always 0.
org.apache.commons.math4.distribution.GeometricDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is infinite (which we approximate as Integer.MAX_VALUE).
org.apache.commons.math4.distribution.GeometricDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in Z | P(X<=x) >= p} for 0 < p <= 1, inf{x in Z | P(X<=x) > 0} for p = 0.  If the result exceeds the range of the data type int, then Integer.MIN_VALUE or Integer.MAX_VALUE is returned. The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1, and solveInverseCumulativeProbability() for 0 < p < 1. 
org.apache.commons.math4.distribution.GeometricDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.GeometricDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x). 
org.apache.commons.math4.distribution.GeometricDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.GeometricDistributionTest: Test cases for GeometricDistribution.  See class javadoc for IntegerDistributionAbstractTest for details.
org.apache.commons.math4.distribution.GeometricDistributionTest.GeometricDistributionTest	(	): Constructor to override default tolerance.
org.apache.commons.math4.distribution.GeometricDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values 
org.apache.commons.math4.distribution.GeometricDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.GeometricDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values 
org.apache.commons.math4.distribution.GeometricDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values. Reference values are from R, version version 2.15.3.
org.apache.commons.math4.distribution.GeometricDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.GeometricDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.GeometricDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values
org.apache.commons.math4.distribution.GeometricDistributionTest.makeLogDensityTestValues	(	): Creates the default log probability density test expected values. Reference values are from R, version version 2.14.1.
org.apache.commons.math4.distribution.GumbelDistribution: This class implements the Gumbel distribution.
org.apache.commons.math4.distribution.GumbelDistribution.GumbelDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.GumbelDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.GumbelDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.GumbelDistribution.getLocation	(	): Access the location parameter, mu.
org.apache.commons.math4.distribution.GumbelDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. 
org.apache.commons.math4.distribution.GumbelDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. 
org.apache.commons.math4.distribution.GumbelDistribution.getScale	(	): Access the scale parameter, beta.
org.apache.commons.math4.distribution.GumbelDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. 
org.apache.commons.math4.distribution.GumbelDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. 
org.apache.commons.math4.distribution.GumbelDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.GumbelDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. 
org.apache.commons.math4.distribution.GumbelDistributionTest: Test cases for GumbelDistribution.
org.apache.commons.math4.distribution.HypergeometricDistribution: Implementation of the hypergeometric distribution.
org.apache.commons.math4.distribution.HypergeometricDistribution.HypergeometricDistribution	(	int	int	int	): Creates a new hypergeometric distribution.
org.apache.commons.math4.distribution.HypergeometricDistribution.calculateNumericalVariance	(	): Used by getNumericalVariance().
org.apache.commons.math4.distribution.HypergeometricDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.HypergeometricDistribution.getDomain	(	int	int	int	): Return the domain for the given hypergeometric distribution parameters.
org.apache.commons.math4.distribution.HypergeometricDistribution.getLowerDomain	(	int	int	int	): Return the lowest domain value for the given hypergeometric distribution parameters.
org.apache.commons.math4.distribution.HypergeometricDistribution.getNumberOfSuccesses	(	): Access the number of successes.
org.apache.commons.math4.distribution.HypergeometricDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For population size N, number of successes m, and sample size n, the mean is n * m / N.
org.apache.commons.math4.distribution.HypergeometricDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For population size N, number of successes m, and sample size n, the variance is [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)].
org.apache.commons.math4.distribution.HypergeometricDistribution.getPopulationSize	(	): Access the population size.
org.apache.commons.math4.distribution.HypergeometricDistribution.getSampleSize	(	): Access the sample size.
org.apache.commons.math4.distribution.HypergeometricDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. For population size N, number of successes m, and sample size n, the lower bound of the support is max(0, n + m - N).
org.apache.commons.math4.distribution.HypergeometricDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. For number of successes m and sample size n, the upper bound of the support is min(m, n).
org.apache.commons.math4.distribution.HypergeometricDistribution.getUpperDomain	(	int	int	): Return the highest domain value for the given hypergeometric distribution parameters.
org.apache.commons.math4.distribution.HypergeometricDistribution.innerCumulativeProbability	(	int	int	int	): For this distribution, X, this method returns P(x0 <= X <= x1). This probability is computed by summing the point probabilities for the values x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx.
org.apache.commons.math4.distribution.HypergeometricDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.HypergeometricDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x). 
org.apache.commons.math4.distribution.HypergeometricDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.HypergeometricDistribution.upperCumulativeProbability	(	int	): For this distribution, X, this method returns P(X >= x).
org.apache.commons.math4.distribution.HypergeometricDistributionTest: Test cases for HyperGeometriclDistribution. Extends IntegerDistributionAbstractTest. See class javadoc for IntegerDistributionAbstractTest for details.
org.apache.commons.math4.distribution.HypergeometricDistributionTest.HypergeometricDistributionTest	(	): Constructor to override default tolerance.
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values Reference values are from R, version 2.15.3.
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values Reference values are from R, version 2.15.3.
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.makeLogDensityTestValues	(	): Creates the default probability log density test expected values Reference values are from R, version 2.14.1.
org.apache.commons.math4.distribution.HypergeometricDistributionTest.testDegenerateFullSample	(	): Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.testDegenerateNoFailures	(	): Verify that if there are no failures, mass is concentrated on sampleSize 
org.apache.commons.math4.distribution.HypergeometricDistributionTest.testDegenerateNoSuccesses	(	): Verify that if there are no successes, mass is concentrated on 0 
org.apache.commons.math4.distribution.IntegerDistribution: Interface for distributions on the integers.
org.apache.commons.math4.distribution.IntegerDistribution.Sampler: Sampling functionality.
org.apache.commons.math4.distribution.IntegerDistribution.Sampler.sample	(	): Generates a random value sampled from this distribution.
org.apache.commons.math4.distribution.IntegerDistribution.createSampler	(	UniformRandomProvider	): Creates a sampler.
org.apache.commons.math4.distribution.IntegerDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution.
org.apache.commons.math4.distribution.IntegerDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.
org.apache.commons.math4.distribution.IntegerDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.IntegerDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}.
org.apache.commons.math4.distribution.IntegerDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}.
org.apache.commons.math4.distribution.IntegerDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in Z | P(X<=x) >= p} for 0 < p <= 1, inf{x in Z | P(X<=x) > 0} for p = 0.  If the result exceeds the range of the data type int, then Integer.MIN_VALUE or Integer.MAX_VALUE is returned.
org.apache.commons.math4.distribution.IntegerDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support.
org.apache.commons.math4.distribution.IntegerDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().
org.apache.commons.math4.distribution.IntegerDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.IntegerDistribution.probability	(	int	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(x0 < X <= x1).
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest: Abstract base class for IntegerDistribution tests.  To create a concrete test class for an integer distribution implementation, implement makeDistribution() to return a distribution instance to use in tests and each of the test data generation methods below. In each case, the test points and test values arrays returned represent parallel arrays of inputs and expected values for the distribution returned by makeDistribution().  makeDensityTestPoints() -- arguments used to test probability density calculation makeDensityTestValues() -- expected probability densities makeCumulativeTestPoints() -- arguments used to test cumulative probabilities makeCumulativeTestValues() -- expected cumulative probabilites makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation makeInverseCumulativeTestValues() -- expected inverse cdf values  To implement additional test cases with different distribution instances and test data, use the setXxx methods for the instance data in test cases and call the verifyXxx methods to verify results.
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getCumulativeTestPoints	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getCumulativeTestValues	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getDensityTestPoints	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getDensityTestValues	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getDistribution	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getInverseCumulativeTestPoints	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getInverseCumulativeTestValues	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.getTolerance	(	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeDensityTestPoints	(	): Creates the default probability density test input values 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.makeLogDensityTestValues	(	): Creates the default logarithmic probability density test expected values. The default implementation simply computes the logarithm of all the values in makeDensityTestValues().
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setCumulativeTestPoints	(	int[]	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setCumulativeTestValues	(	double[]	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setDensityTestPoints	(	int[]	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setDensityTestValues	(	double[]	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setDistribution	(	IntegerDistribution	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setInverseCumulativeTestPoints	(	double[]	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setInverseCumulativeTestValues	(	int[]	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setTolerance	(	double	): 
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.setUp	(	): Setup sets all test instance data to default values
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.tearDown	(	): Cleans up test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.testCumulativeProbabilities	(	): Verifies that cumulative probability density calculations match expected values using default test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.testDensities	(	): Verifies that probability density calculations match expected values using default test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.testIllegalArguments	(	): Verifies that illegal arguments are correctly handled
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.testInverseCumulativeProbabilities	(	): Verifies that inverse cumulative probability density calculations match expected values using default test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.testLogDensities	(	): Verifies that logarithmic probability density calculations match expected values using default test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.testSampling	(	): Test sampling
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.verifyCumulativeProbabilities	(	): Verifies that cumulative probability density calculations match expected values using current test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.verifyDensities	(	): Verifies that probability density calculations match expected values using current test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.verifyInverseCumulativeProbabilities	(	): Verifies that inverse cumulative probability density calculations match expected values using current test instance data
org.apache.commons.math4.distribution.IntegerDistributionAbstractTest.verifyLogDensities	(	): Verifies that logarithmic probability density calculations match expected values using current test instance data.
org.apache.commons.math4.distribution.LaplaceDistribution: This class implements the Laplace distribution.
org.apache.commons.math4.distribution.LaplaceDistribution.LaplaceDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.LaplaceDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.LaplaceDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.LaplaceDistribution.getLocation	(	): Access the location parameter, mu.
org.apache.commons.math4.distribution.LaplaceDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. 
org.apache.commons.math4.distribution.LaplaceDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. 
org.apache.commons.math4.distribution.LaplaceDistribution.getScale	(	): Access the scale parameter, beta.
org.apache.commons.math4.distribution.LaplaceDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. 
org.apache.commons.math4.distribution.LaplaceDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. 
org.apache.commons.math4.distribution.LaplaceDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.LaplaceDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. 
org.apache.commons.math4.distribution.LaplaceDistributionTest: Test cases for LaplaceDistribution.
org.apache.commons.math4.distribution.LevyDistribution: This class implements the  Lévy distribution.
org.apache.commons.math4.distribution.LevyDistribution.LevyDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.LevyDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution.  From Wikipedia: the cumulative distribution function is   f(x; u, c) = erfc (√ (c / 2 (x - u ))) 
org.apache.commons.math4.distribution.LevyDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient.  From Wikipedia: The probability density function of the Lévy distribution over the domain is   f(x; μ, c) = √(c / 2π) * e-c / 2 (x - μ) / (x - μ)3/2   For this distribution, X, this method returns P(X < x). If x is less than location parameter μ, Double.NaN is returned, as in these cases the distribution is not defined. 
org.apache.commons.math4.distribution.LevyDistribution.getLocation	(	): Get the location parameter of the distribution.
org.apache.commons.math4.distribution.LevyDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. 
org.apache.commons.math4.distribution.LevyDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. 
org.apache.commons.math4.distribution.LevyDistribution.getScale	(	): Get the scale parameter of the distribution.
org.apache.commons.math4.distribution.LevyDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. 
org.apache.commons.math4.distribution.LevyDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. 
org.apache.commons.math4.distribution.LevyDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.LevyDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. 
org.apache.commons.math4.distribution.LevyDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). See documentation of density() for computation details.
org.apache.commons.math4.distribution.LevyDistributionTest.makeLogDensityTestValues	(	): Creates the default logarithmic probability density test expected values. Reference values are from R, version 2.14.1.
org.apache.commons.math4.distribution.LogNormalDistribution: Implementation of the log-normal (gaussian) distribution.  Parameters: X is log-normally distributed if its natural logarithm log(X) is normally distributed. The probability distribution function of X is given by (for x > 0)   exp(-0.5 * ((ln(x) - m) / s)^2) / (s * sqrt(2 * pi) * x)   m is the scale parameter: this is the mean of the normally distributed natural logarithm of this distribution, s is the shape parameter: this is the standard deviation of the normally distributed natural logarithm of this distribution. 
org.apache.commons.math4.distribution.LogNormalDistribution.LogNormalDistribution	(	): Creates a log-normal distribution, where the mean and standard deviation of the NormalDistribution normally distributed natural logarithm of the log-normal distribution are equal to zero and one respectively. In other words, the scale of the returned distribution is 0, while its shape is 1.
org.apache.commons.math4.distribution.LogNormalDistribution.LogNormalDistribution	(	double	double	): Creates a log-normal distribution.
org.apache.commons.math4.distribution.LogNormalDistribution.LogNormalDistribution	(	double	double	double	): Creates a log-normal distribution.
org.apache.commons.math4.distribution.LogNormalDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.LogNormalDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. For scale m, and shape s of this distribution, the CDF is given by  0 if x <= 0, 0 if ln(x) - m < 0 and m - ln(x) > 40 * s, as in these cases the actual value is within Double.MIN_VALUE of 0, 1 if ln(x) - m >= 0 and ln(x) - m > 40 * s, as in these cases the actual value is within Double.MIN_VALUE of 1, 0.5 + 0.5 * erf((ln(x) - m) / (s * sqrt(2)) otherwise. 
org.apache.commons.math4.distribution.LogNormalDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. For scale m, and shape s of this distribution, the PDF is given by  0 if x <= 0, exp(-0.5 * ((ln(x) - m) / s)^2) / (s * sqrt(2 * pi) * x) otherwise. 
org.apache.commons.math4.distribution.LogNormalDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For scale m and shape s, the mean is exp(m + s^2 / 2).
org.apache.commons.math4.distribution.LogNormalDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For scale m and shape s, the variance is (exp(s^2) - 1) * exp(2 * m + s^2).
org.apache.commons.math4.distribution.LogNormalDistribution.getScale	(	): Returns the scale parameter of this distribution.
org.apache.commons.math4.distribution.LogNormalDistribution.getShape	(	): Returns the shape parameter of this distribution.
org.apache.commons.math4.distribution.LogNormalDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.LogNormalDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the parameters.
org.apache.commons.math4.distribution.LogNormalDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.LogNormalDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.LogNormalDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). See documentation of density() for computation details.
org.apache.commons.math4.distribution.LogNormalDistribution.probability	(	double	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(x0 < X <= x1). 
org.apache.commons.math4.distribution.LogNormalDistributionTest: Test cases for LogNormalDistribution. Extends RealDistributionAbstractTest. See class javadoc of that class for details.
org.apache.commons.math4.distribution.LogNormalDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.LogNormalDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.LogNormalDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.LogNormalDistributionTest.makeDistribution	(	): Creates the default real distribution instance to use in tests. 
org.apache.commons.math4.distribution.LogNormalDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability distribution test input values.
org.apache.commons.math4.distribution.LogNormalDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability test expected values.
org.apache.commons.math4.distribution.LogNormalDistributionTest.testExtremeValues	(	): Check to make sure top-coding of extreme values works correctly. Verifies fixes for JIRA MATH-167, MATH-414
org.apache.commons.math4.distribution.LogisticDistribution: This class implements the Logistic distribution.
org.apache.commons.math4.distribution.LogisticDistribution.LogisticDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.LogisticDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.LogisticDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.LogisticDistribution.getLocation	(	): Access the location parameter, mu.
org.apache.commons.math4.distribution.LogisticDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. 
org.apache.commons.math4.distribution.LogisticDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. 
org.apache.commons.math4.distribution.LogisticDistribution.getScale	(	): Access the scale parameter, s.
org.apache.commons.math4.distribution.LogisticDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. 
org.apache.commons.math4.distribution.LogisticDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. 
org.apache.commons.math4.distribution.LogisticDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.LogisticDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. 
org.apache.commons.math4.distribution.LogisticsDistributionTest: Test cases for LogisticsDistribution.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistribution: Multivariate normal mixture distribution. This class is mainly syntactic sugar.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistribution.MixtureMultivariateNormalDistribution	(	List	): Creates a mixture model from a list of distributions and their associated weights.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistribution.MixtureMultivariateNormalDistribution	(	double[]	double[][]	double[][][]	): Creates a multivariate normal mixture distribution.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistribution.createComponents	(	double[]	double[][]	double[][][]	): Creates components of the mixture model.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistributionTest: Test case MixtureMultivariateNormalDistribution.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistributionTest.getCorrectSamples	(	): Values used in testSampling().
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistributionTest.testDensities	(	): Test the accuracy of the density calculation.
org.apache.commons.math4.distribution.MixtureMultivariateNormalDistributionTest.testSampling	(	): Test the accuracy of sampling from the distribution.
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution: Class for representing  mixture model distributions.
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.MixtureMultivariateRealDistribution	(	List	): Creates a mixture model from a list of distributions and their associated weights.
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.MixtureSampler: Sampler.
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.MixtureSampler.MixtureSampler	(	UniformRandomProvider	): 
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.MixtureSampler.sample	(	): Generates a random value vector sampled from this distribution. 
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.density	(	double[]	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulative distribution function. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.MixtureMultivariateRealDistribution.getComponents	(	): Gets the distributions that make up the mixture model.
org.apache.commons.math4.distribution.MultivariateNormalDistribution: Implementation of the multivariate normal (Gaussian) distribution.
org.apache.commons.math4.distribution.MultivariateNormalDistribution.MultivariateNormalDistribution	(	double[]	double[][]	): Creates a multivariate normal distribution with the given mean vector and covariance matrix.  The number of dimensions is equal to the length of the mean vector and to the number of rows and columns of the covariance matrix. It is frequently written as "p" in formulae. 
org.apache.commons.math4.distribution.MultivariateNormalDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.MultivariateNormalDistribution.density	(	double[]	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulative distribution function. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.MultivariateNormalDistribution.getCovariances	(	): Gets the covariance matrix.
org.apache.commons.math4.distribution.MultivariateNormalDistribution.getExponentTerm	(	double[]	): Computes the term used in the exponent (see definition of the distribution).
org.apache.commons.math4.distribution.MultivariateNormalDistribution.getMeans	(	): Gets the mean vector.
org.apache.commons.math4.distribution.MultivariateNormalDistribution.getStandardDeviations	(	): Gets the square root of each element on the diagonal of the covariance matrix.
org.apache.commons.math4.distribution.MultivariateNormalDistributionTest: Test cases for MultivariateNormalDistribution.
org.apache.commons.math4.distribution.MultivariateNormalDistributionTest.testDensities	(	): Test the accuracy of the distribution when calculating densities.
org.apache.commons.math4.distribution.MultivariateNormalDistributionTest.testGetCovarianceMatrix	(	): Test the ability of the distribution to report its covariance matrix parameter.
org.apache.commons.math4.distribution.MultivariateNormalDistributionTest.testGetMean	(	): Test the ability of the distribution to report its mean value parameter.
org.apache.commons.math4.distribution.MultivariateNormalDistributionTest.testSampling	(	): Test the accuracy of sampling from the distribution.
org.apache.commons.math4.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution	(	): Test the accuracy of the distribution when calculating densities.
org.apache.commons.math4.distribution.MultivariateRealDistribution: Base interface for multivariate distributions on the reals. This is based largely on the RealDistribution interface, but cumulative distribution functions are not required because they are often quite difficult to compute for multivariate distributions.
org.apache.commons.math4.distribution.MultivariateRealDistribution.Sampler: Sampling functionality.
org.apache.commons.math4.distribution.MultivariateRealDistribution.Sampler.sample	(	): Generates a random value vector sampled from this distribution.
org.apache.commons.math4.distribution.MultivariateRealDistribution.createSampler	(	UniformRandomProvider	): Creates a sampler.
org.apache.commons.math4.distribution.MultivariateRealDistribution.density	(	double[]	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulative distribution function. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient.
org.apache.commons.math4.distribution.MultivariateRealDistribution.getDimension	(	): Gets the number of random variables of the distribution. It is the size of the array returned by the sample() method.
org.apache.commons.math4.distribution.NakagamiDistribution: This class implements the Nakagami distribution.
org.apache.commons.math4.distribution.NakagamiDistribution.NakagamiDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.NakagamiDistribution.NakagamiDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.NakagamiDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.NakagamiDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.NakagamiDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. 
org.apache.commons.math4.distribution.NakagamiDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. 
org.apache.commons.math4.distribution.NakagamiDistribution.getScale	(	): Access the scale parameter, omega.
org.apache.commons.math4.distribution.NakagamiDistribution.getShape	(	): Access the shape parameter, mu.
org.apache.commons.math4.distribution.NakagamiDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.NakagamiDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. 
org.apache.commons.math4.distribution.NakagamiDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. 
org.apache.commons.math4.distribution.NakagamiDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. 
org.apache.commons.math4.distribution.NakagamiDistributionTest: Test cases for NakagamiDistribution.
org.apache.commons.math4.distribution.NormalDistribution: Implementation of the normal (gaussian) distribution.
org.apache.commons.math4.distribution.NormalDistribution.NormalDistribution	(	): Create a normal distribution with mean equal to zero and standard deviation equal to one.
org.apache.commons.math4.distribution.NormalDistribution.NormalDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.NormalDistribution.NormalDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.NormalDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.NormalDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. If x is more than 40 standard deviations from the mean, 0 or 1 is returned, as in these cases the actual value is within Double.MIN_VALUE of 0 or 1.
org.apache.commons.math4.distribution.NormalDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.NormalDistribution.getMean	(	): Access the mean.
org.apache.commons.math4.distribution.NormalDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For mean parameter mu, the mean is mu.
org.apache.commons.math4.distribution.NormalDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For standard deviation parameter s, the variance is s^2.
org.apache.commons.math4.distribution.NormalDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.NormalDistribution.getStandardDeviation	(	): Access the standard deviation.
org.apache.commons.math4.distribution.NormalDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always negative infinity no matter the parameters.
org.apache.commons.math4.distribution.NormalDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.NormalDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1. 
org.apache.commons.math4.distribution.NormalDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.NormalDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.NormalDistribution.probability	(	double	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(x0 < X <= x1). 
org.apache.commons.math4.distribution.NormalDistributionTest: Test cases for NormalDistribution. Extends RealDistributionAbstractTest. See class javadoc of that class for details.
org.apache.commons.math4.distribution.NormalDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.NormalDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.NormalDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.NormalDistributionTest.makeDistribution	(	): Creates the default real distribution instance to use in tests. 
org.apache.commons.math4.distribution.NormalDistributionTest.testExtremeValues	(	): Check to make sure top-coding of extreme values works correctly. Verifies fixes for JIRA MATH-167, MATH-414
org.apache.commons.math4.distribution.ParetoDistribution: Implementation of the Pareto distribution.  Parameters: The probability distribution function of X is given by (for x >= k):  α * k^α / x^(α + 1)   k is the scale parameter: this is the minimum possible value of X, α is the shape parameter: this is the Pareto index 
org.apache.commons.math4.distribution.ParetoDistribution.ParetoDistribution	(	): Creates a Pareto distribution with a scale of 1 and a shape of 1.
org.apache.commons.math4.distribution.ParetoDistribution.ParetoDistribution	(	double	double	): Creates a Pareto distribution.
org.apache.commons.math4.distribution.ParetoDistribution.ParetoDistribution	(	double	double	double	): Creates a Pareto distribution.
org.apache.commons.math4.distribution.ParetoDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.ParetoDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution.  For scale k, and shape α of this distribution, the CDF is given by  0 if x < k, 1 - (k / x)^α otherwise. 
org.apache.commons.math4.distribution.ParetoDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient.  For scale k, and shape α of this distribution, the PDF is given by  0 if x < k, α * k^α / x^(α + 1) otherwise. 
org.apache.commons.math4.distribution.ParetoDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.  For scale k and shape α, the mean is given by  ∞ if α <= 1, α * k / (α - 1) otherwise. 
org.apache.commons.math4.distribution.ParetoDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.  For scale k and shape α, the variance is given by  ∞ if 1 < α <= 2, k^2 * α / ((α - 1)^2 * (α - 2)) otherwise. 
org.apache.commons.math4.distribution.ParetoDistribution.getScale	(	): Returns the scale parameter of this distribution.
org.apache.commons.math4.distribution.ParetoDistribution.getShape	(	): Returns the shape parameter of this distribution.
org.apache.commons.math4.distribution.ParetoDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.ParetoDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}.  The lower bound of the support is equal to the scale parameter k.
org.apache.commons.math4.distribution.ParetoDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}.  The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.ParetoDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support.  The support of this distribution is connected.
org.apache.commons.math4.distribution.ParetoDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). See documentation of density() for computation details.
org.apache.commons.math4.distribution.ParetoDistributionTest: Test cases for ParetoDistribution.  Extends RealDistributionAbstractTest. See class javadoc of that class for details.
org.apache.commons.math4.distribution.ParetoDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.ParetoDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.ParetoDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.ParetoDistributionTest.makeDistribution	(	): Creates the default real distribution instance to use in tests. 
org.apache.commons.math4.distribution.ParetoDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability distribution test input values.
org.apache.commons.math4.distribution.ParetoDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability test expected values.
org.apache.commons.math4.distribution.ParetoDistributionTest.testExtremeValues	(	): Check to make sure top-coding of extreme values works correctly.
org.apache.commons.math4.distribution.PascalDistribution:  Implementation of the Pascal distribution. The Pascal distribution is a special case of the Negative Binomial distribution where the number of successes parameter is an integer.   There are various ways to express the probability mass and distribution functions for the Pascal distribution. The present implementation represents the distribution of the number of failures before r successes occur. This is the convention adopted in e.g. MathWorld, but not in Wikipedia.   For a random variable X whose values are distributed according to this distribution, the probability mass function is given by P(X = k) = C(k + r - 1, r - 1) * p^r * (1 - p)^k, where r is the number of successes, p is the probability of success, and X is the total number of failures. C(n, k) is the binomial coefficient (n choose k). The mean and variance of X are E(X) = (1 - p) * r / p, var(X) = (1 - p) * r / p^2. Finally, the cumulative distribution function is given by P(X <= k) = I(p, r, k + 1), where I is the regularized incomplete Beta function. 
org.apache.commons.math4.distribution.PascalDistribution.PascalDistribution	(	int	double	): Create a Pascal distribution with the given number of successes and probability of success.
org.apache.commons.math4.distribution.PascalDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.PascalDistribution.getNumberOfSuccesses	(	): Access the number of successes for this distribution.
org.apache.commons.math4.distribution.PascalDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For number of successes r and probability of success p, the mean is r * (1 - p) / p.
org.apache.commons.math4.distribution.PascalDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For number of successes r and probability of success p, the variance is r * (1 - p) / p^2.
org.apache.commons.math4.distribution.PascalDistribution.getProbabilityOfSuccess	(	): Access the probability of success for this distribution.
org.apache.commons.math4.distribution.PascalDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the parameters.
org.apache.commons.math4.distribution.PascalDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters. Positive infinity is symbolized by Integer.MAX_VALUE.
org.apache.commons.math4.distribution.PascalDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.PascalDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x). 
org.apache.commons.math4.distribution.PascalDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.PascalDistributionTest: Test cases for PascalDistribution. Extends IntegerDistributionAbstractTest. See class javadoc for IntegerDistributionAbstractTest for details.
org.apache.commons.math4.distribution.PascalDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values 
org.apache.commons.math4.distribution.PascalDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.PascalDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values 
org.apache.commons.math4.distribution.PascalDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.PascalDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.PascalDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.PascalDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.PascalDistributionTest.testDegenerate0	(	): Test degenerate case p = 0 
org.apache.commons.math4.distribution.PascalDistributionTest.testDegenerate1	(	): Test degenerate case p = 1 
org.apache.commons.math4.distribution.PoissonDistribution: Implementation of the Poisson distribution.
org.apache.commons.math4.distribution.PoissonDistribution.PoissonDistribution	(	double	): Creates a new Poisson distribution with specified mean.
org.apache.commons.math4.distribution.PoissonDistribution.PoissonDistribution	(	double	double	): Creates a new Poisson distribution with the specified mean and convergence criterion.
org.apache.commons.math4.distribution.PoissonDistribution.PoissonDistribution	(	double	double	int	): Creates a new Poisson distribution with specified mean, convergence criterion and maximum number of iterations.
org.apache.commons.math4.distribution.PoissonDistribution.PoissonDistribution	(	double	int	): Creates a new Poisson distribution with the specified mean and maximum number of iterations.
org.apache.commons.math4.distribution.PoissonDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.PoissonDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.PoissonDistribution.getMean	(	): Get the mean for the distribution.
org.apache.commons.math4.distribution.PoissonDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For mean parameter p, the mean is p.
org.apache.commons.math4.distribution.PoissonDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For mean parameter p, the variance is p.
org.apache.commons.math4.distribution.PoissonDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the mean parameter.
org.apache.commons.math4.distribution.PoissonDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is positive infinity, regardless of the parameter values. There is no integer infinity, so this method returns Integer.MAX_VALUE.
org.apache.commons.math4.distribution.PoissonDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.PoissonDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x). 
org.apache.commons.math4.distribution.PoissonDistribution.normalApproximateProbability	(	int	): Calculates the Poisson distribution function using a normal approximation. The N(mean, sqrt(mean)) distribution is used to approximate the Poisson distribution. The computation uses "half-correction" (evaluating the normal distribution function at x + 0.5).
org.apache.commons.math4.distribution.PoissonDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.PoissonDistributionTest: PoissonDistributionTest
org.apache.commons.math4.distribution.PoissonDistributionTest.PoissonDistributionTest	(	): Constructor.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values. These and all other test values are generated by R, version 1.8.1
org.apache.commons.math4.distribution.PoissonDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values.
org.apache.commons.math4.distribution.PoissonDistributionTest.makeLogDensityTestValues	(	): Creates the default logarithmic probability density test expected values. Reference values are from R, version 2.14.1.
org.apache.commons.math4.distribution.PoissonDistributionTest.testCumulativeProbabilitySpecial	(	): JIRA: MATH-282
org.apache.commons.math4.distribution.PoissonDistributionTest.testDegenerateInverseCumulativeProbability	(	): Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.
org.apache.commons.math4.distribution.PoissonDistributionTest.testNormalApproximateProbability	(	): Test the normal approximation of the Poisson distribution by calculating P(90 ≤ X ≤ 110) for X = Po(100) and P(9900 ≤ X ≤ 10200) for X = Po(10000)
org.apache.commons.math4.distribution.RealDistribution: Base interface for distributions on the reals.
org.apache.commons.math4.distribution.RealDistribution.Sampler: Sampling functionality.
org.apache.commons.math4.distribution.RealDistribution.Sampler.sample	(	): Generates a random value sampled from this distribution.
org.apache.commons.math4.distribution.RealDistribution.createSampler	(	UniformRandomProvider	): Creates a sampler.
org.apache.commons.math4.distribution.RealDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution.
org.apache.commons.math4.distribution.RealDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient.
org.apache.commons.math4.distribution.RealDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution.
org.apache.commons.math4.distribution.RealDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution.
org.apache.commons.math4.distribution.RealDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}.
org.apache.commons.math4.distribution.RealDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}.
org.apache.commons.math4.distribution.RealDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0. 
org.apache.commons.math4.distribution.RealDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support.
org.apache.commons.math4.distribution.RealDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().
org.apache.commons.math4.distribution.RealDistribution.probability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution.
org.apache.commons.math4.distribution.RealDistribution.probability	(	double	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(x0 < X <= x1).
org.apache.commons.math4.distribution.RealDistributionAbstractTest: Abstract base class for RealDistribution tests.  To create a concrete test class for a continuous distribution implementation, first implement makeDistribution() to return a distribution instance to use in tests. Then implement each of the test data generation methods below. In each case, the test points and test values arrays returned represent parallel arrays of inputs and expected values for the distribution returned by makeDistribution(). Default implementations are provided for the makeInverseXxx methods that just invert the mapping defined by the arrays returned by the makeCumulativeXxx methods.  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities makeCumulativeTestValues() -- expected cumulative probabilities makeDensityTestValues() -- expected density values at cumulativeTestPoints makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf makeInverseCumulativeTestValues() -- expected inverse cdf values  To implement additional test cases with different distribution instances and test data, use the setXxx methods for the instance data in test cases and call the verifyXxx methods to verify results.  Error tolerance can be overridden by implementing getTolerance().  Test data should be validated against reference tables or other packages where possible, and the source of the reference data and/or validation should be documented in the test cases. A framework for validating distribution data against R is included in the /src/test/R source tree.  See NormalDistributionTest and ChiSquaredDistributionTest for examples.
org.apache.commons.math4.distribution.RealDistributionAbstractTest.deepClone	(	): Serialization and deserialization loop of the distribution.
org.apache.commons.math4.distribution.RealDistributionAbstractTest.getCumulativeTestPoints	(	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.getCumulativeTestValues	(	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.getDistribution	(	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.getInverseCumulativeTestPoints	(	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.getInverseCumulativeTestValues	(	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.getTolerance	(	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability test input values 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeCumulativeTestValues	(	): Creates the default cumulative probability test expected values 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeDensityTestValues	(	): Creates the default density test expected values 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.makeLogDensityTestValues	(	): Creates the default logarithmic density test expected values. The default implementation simply computes the logarithm of each value returned by makeDensityTestValues().
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setCumulativeTestPoints	(	double[]	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setCumulativeTestValues	(	double[]	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setDistribution	(	RealDistribution	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setInverseCumulativeTestPoints	(	double[]	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setInverseCumulativeTestValues	(	double[]	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setTolerance	(	double	): 
org.apache.commons.math4.distribution.RealDistributionAbstractTest.setUp	(	): Setup sets all test instance data to default values
org.apache.commons.math4.distribution.RealDistributionAbstractTest.tearDown	(	): Cleans up test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testConsistency	(	): Verifies that probability computations are consistent
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testCumulativeProbabilities	(	): Verifies that cumulative probability density calculations match expected values using default test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testDensities	(	): Verifies that density calculations return expected values for default test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testDensityIntegrals	(	): Verify that density integrals match the distribution. The (filtered, sorted) cumulativeTestPoints array is used to source integration limits. The integral of the density (estimated using a Legendre-Gauss integrator) is compared with the cdf over the same interval. Test points outside of the domain of the density function are discarded.
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testIllegalArguments	(	): Verifies that illegal arguments are correctly handled
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testInverseCumulativeProbabilities	(	): Verifies that inverse cumulative probability density calculations match expected values using default test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testLogDensities	(	): Verifies that logarithmic density calculations return expected values for default test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.testSampler	(	): Test sampling
org.apache.commons.math4.distribution.RealDistributionAbstractTest.verifyCumulativeProbabilities	(	): Verifies that cumulative probability density calculations match expected values using current test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.verifyDensities	(	): Verifies that density calculations match expected values
org.apache.commons.math4.distribution.RealDistributionAbstractTest.verifyInverseCumulativeProbabilities	(	): Verifies that inverse cumulative probability density calculations match expected values using current test instance data
org.apache.commons.math4.distribution.RealDistributionAbstractTest.verifyLogDensities	(	): Verifies that logarithmic density calculations match expected values
org.apache.commons.math4.distribution.SaddlePointExpansion:  Utility class used by various distributions to accurately compute their respective probability mass functions. The implementation for this class is based on the Catherine Loader's dbinom routines.   This class is not intended to be called directly.   References:  Catherine Loader (2000). "Fast and Accurate Computation of Binomial Probabilities.".  http://www.herine.net/stat/papers/dbinom.pdf  
org.apache.commons.math4.distribution.SaddlePointExpansion.SaddlePointExpansion	(	): Default constructor.
org.apache.commons.math4.distribution.SaddlePointExpansion.getDeviancePart	(	double	double	): A part of the deviance portion of the saddle point approximation.  References:  Catherine Loader (2000). "Fast and Accurate Computation of Binomial Probabilities.".  http://www.herine.net/stat/papers/dbinom.pdf  
org.apache.commons.math4.distribution.SaddlePointExpansion.getStirlingError	(	double	): Compute the error of Stirling's series at the given value.  References:  Eric W. Weisstein. "Stirling's Series." From MathWorld--A Wolfram Web Resource.  http://mathworld.wolfram.com/StirlingsSeries.html  
org.apache.commons.math4.distribution.SaddlePointExpansion.logBinomialProbability	(	int	int	double	double	): Compute the logarithm of the PMF for a binomial distribution using the saddle point expansion.
org.apache.commons.math4.distribution.TDistribution: Implementation of Student's t-distribution.
org.apache.commons.math4.distribution.TDistribution.TDistribution	(	double	): Creates a distribution.
org.apache.commons.math4.distribution.TDistribution.TDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.TDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.TDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.TDistribution.getDegreesOfFreedom	(	): Access the degrees of freedom.
org.apache.commons.math4.distribution.TDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For degrees of freedom parameter df, the mean is  if df > 1 then 0, else undefined (Double.NaN). 
org.apache.commons.math4.distribution.TDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For degrees of freedom parameter df, the variance is  if df > 2 then df / (df - 2), if 1 < df <= 2 then positive infinity (Double.POSITIVE_INFINITY), else undefined (Double.NaN). 
org.apache.commons.math4.distribution.TDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default. 
org.apache.commons.math4.distribution.TDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always negative infinity no matter the parameters.
org.apache.commons.math4.distribution.TDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.TDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.TDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.TDistributionTest: Test cases for TDistribution. Extends ContinuousDistributionAbstractTest. See class javadoc for ContinuousDistributionAbstractTest for details.
org.apache.commons.math4.distribution.TDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.TDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.TDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.TDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.TDistributionTest.testCumulativeProbabilityAgainstStackOverflow	(	): 
org.apache.commons.math4.distribution.TriangularDistribution: Implementation of the triangular real distribution.
org.apache.commons.math4.distribution.TriangularDistribution.TriangularDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.TriangularDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. For lower limit a, upper limit b and mode c, the CDF is given by  0 if x < a, (x - a)^2 / [(b - a) * (c - a)] if a <= x < c, (c - a) / (b - a) if x = c, 1 - (b - x)^2 / [(b - a) * (b - c)] if c < x <= b, 1 if x > b. 
org.apache.commons.math4.distribution.TriangularDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. For lower limit a, upper limit b and mode c, the PDF is given by  2 * (x - a) / [(b - a) * (c - a)] if a <= x < c, 2 / (b - a) if x = c, 2 * (b - x) / [(b - a) * (b - c)] if c < x <= b, 0 otherwise. 
org.apache.commons.math4.distribution.TriangularDistribution.getMode	(	): Returns the mode c of this distribution.
org.apache.commons.math4.distribution.TriangularDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For lower limit a, upper limit b, and mode c, the mean is (a + b + c) / 3.
org.apache.commons.math4.distribution.TriangularDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For lower limit a, upper limit b, and mode c, the variance is (a^2 + b^2 + c^2 - a * b - a * c - b * c) / 18.
org.apache.commons.math4.distribution.TriangularDistribution.getSolverAbsoluteAccuracy	(	): Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default.  For this distribution, the returned value is not really meaningful, since exact formulas are implemented for the computation of the inverseCumulativeProbability() (no solver is invoked).   For lower limit a and upper limit b, the current implementation returns max(ulp(a), ulp(b). 
org.apache.commons.math4.distribution.TriangularDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is equal to the lower limit parameter a of the distribution.
org.apache.commons.math4.distribution.TriangularDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is equal to the upper limit parameter b of the distribution.
org.apache.commons.math4.distribution.TriangularDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.TriangularDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.TriangularDistributionTest: Test cases for TriangularDistribution. See class javadoc for RealDistributionAbstractTest for further details.
org.apache.commons.math4.distribution.TriangularDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values.
org.apache.commons.math4.distribution.TriangularDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values.
org.apache.commons.math4.distribution.TriangularDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values. 
org.apache.commons.math4.distribution.TriangularDistributionTest.makeDistribution	(	): Creates the default triangular distribution instance to use in tests.
org.apache.commons.math4.distribution.TriangularDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability distribution test input values.
org.apache.commons.math4.distribution.TriangularDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values.
org.apache.commons.math4.distribution.TriangularDistributionTest.testGetLowerBound	(	): Test lower bound getter. 
org.apache.commons.math4.distribution.TriangularDistributionTest.testGetUpperBound	(	): Test upper bound getter. 
org.apache.commons.math4.distribution.TriangularDistributionTest.testMeanVariance	(	): Test mean/variance. 
org.apache.commons.math4.distribution.TriangularDistributionTest.testPreconditions1	(	): Test pre-condition for equal lower/upper limit. 
org.apache.commons.math4.distribution.TriangularDistributionTest.testPreconditions2	(	): Test pre-condition for lower limit larger than upper limit. 
org.apache.commons.math4.distribution.TriangularDistributionTest.testPreconditions3	(	): Test pre-condition for mode larger than upper limit. 
org.apache.commons.math4.distribution.TriangularDistributionTest.testPreconditions4	(	): Test pre-condition for mode smaller than lower limit. 
org.apache.commons.math4.distribution.UniformIntegerDistribution: Implementation of the  uniform integer distribution.
org.apache.commons.math4.distribution.UniformIntegerDistribution.UniformIntegerDistribution	(	int	int	): Creates a new uniform integer distribution using the given lower and upper bounds (both inclusive).
org.apache.commons.math4.distribution.UniformIntegerDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.UniformIntegerDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.UniformIntegerDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For lower bound lower and upper bound upper, the mean is 0.5 * (lower + upper).
org.apache.commons.math4.distribution.UniformIntegerDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For lower bound lower and upper bound upper, and n = upper - lower + 1, the variance is (n^2 - 1) / 12.
org.apache.commons.math4.distribution.UniformIntegerDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. The lower bound of the support is equal to the lower bound parameter of the distribution.
org.apache.commons.math4.distribution.UniformIntegerDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is equal to the upper bound parameter of the distribution.
org.apache.commons.math4.distribution.UniformIntegerDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.UniformIntegerDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest: Test cases for UniformIntegerDistribution. See class javadoc for IntegerDistributionAbstractTest for further details.
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values. 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values. 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values. 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values. 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.UniformIntegerDistributionTest.testMoments	(	): Test mean/variance. 
org.apache.commons.math4.distribution.UniformRealDistribution: Implementation of the uniform real distribution.
org.apache.commons.math4.distribution.UniformRealDistribution.UniformRealDistribution	(	): Create a standard uniform real distribution with lower bound (inclusive) equal to zero and upper bound (exclusive) equal to one.
org.apache.commons.math4.distribution.UniformRealDistribution.UniformRealDistribution	(	double	double	): Creates a uniform distribution.
org.apache.commons.math4.distribution.UniformRealDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.UniformRealDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.UniformRealDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.UniformRealDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For lower bound lower and upper bound upper, the mean is 0.5 * (lower + upper).
org.apache.commons.math4.distribution.UniformRealDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For lower bound lower and upper bound upper, the variance is (upper - lower)^2 / 12.
org.apache.commons.math4.distribution.UniformRealDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is equal to the lower bound parameter of the distribution.
org.apache.commons.math4.distribution.UniformRealDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is equal to the upper bound parameter of the distribution.
org.apache.commons.math4.distribution.UniformRealDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  
org.apache.commons.math4.distribution.UniformRealDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.UniformRealDistributionTest: Test cases for UniformRealDistribution. See class javadoc for RealDistributionAbstractTest for further details.
org.apache.commons.math4.distribution.UniformRealDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.UniformRealDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.UniformRealDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.UniformRealDistributionTest.makeDistribution	(	): Creates the default uniform real distribution instance to use in tests. 
org.apache.commons.math4.distribution.UniformRealDistributionTest.testGetLowerBound	(	): Test lower bound getter. 
org.apache.commons.math4.distribution.UniformRealDistributionTest.testGetUpperBound	(	): Test upper bound getter. 
org.apache.commons.math4.distribution.UniformRealDistributionTest.testInverseCumulativeDistribution	(	): Check accuracy of analytical inverse CDF. Fails if a solver is used with the default accuracy.
org.apache.commons.math4.distribution.UniformRealDistributionTest.testMeanVariance	(	): Test mean/variance. 
org.apache.commons.math4.distribution.UniformRealDistributionTest.testPreconditions1	(	): Test pre-condition for equal lower/upper bound. 
org.apache.commons.math4.distribution.UniformRealDistributionTest.testPreconditions2	(	): Test pre-condition for lower bound larger than upper bound. 
org.apache.commons.math4.distribution.WeibullDistribution: Implementation of the Weibull distribution. This implementation uses the two parameter form of the distribution defined by  Weibull Distribution, equations (1) and (2).
org.apache.commons.math4.distribution.WeibullDistribution.WeibullDistribution	(	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.WeibullDistribution.WeibullDistribution	(	double	double	double	): Creates a distribution.
org.apache.commons.math4.distribution.WeibullDistribution.calculateNumericalMean	(	): used by getNumericalMean()
org.apache.commons.math4.distribution.WeibullDistribution.calculateNumericalVariance	(	): used by getNumericalVariance()
org.apache.commons.math4.distribution.WeibullDistribution.cumulativeProbability	(	double	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.WeibullDistribution.density	(	double	): Returns the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. 
org.apache.commons.math4.distribution.WeibullDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. The mean is scale * Gamma(1 + (1 / shape)), where Gamma() is the Gamma-function.
org.apache.commons.math4.distribution.WeibullDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. The variance is scale^2 * Gamma(1 + (2 / shape)) - mean^2 where Gamma() is the Gamma-function.
org.apache.commons.math4.distribution.WeibullDistribution.getScale	(	): Access the scale parameter, beta.
org.apache.commons.math4.distribution.WeibullDistribution.getShape	(	): Access the shape parameter, alpha.
org.apache.commons.math4.distribution.WeibullDistribution.getSolverAbsoluteAccuracy	(	): Return the absolute accuracy setting of the solver used to estimate inverse cumulative probabilities.
org.apache.commons.math4.distribution.WeibullDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in R | P(X <= x) > 0}. The lower bound of the support is always 0 no matter the parameters.
org.apache.commons.math4.distribution.WeibullDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is always positive infinity no matter the parameters.
org.apache.commons.math4.distribution.WeibullDistribution.inverseCumulativeProbability	(	double	): Computes the quantile function of this distribution. For a random variable X distributed according to this distribution, the returned value is  inf{x in R | P(X<=x) >= p} for 0 < p <= 1, inf{x in R | P(X<=x) > 0} for p = 0.  The default implementation returns  getSupportLowerBound() for p = 0, getSupportUpperBound() for p = 1.  Returns 0 when p == 0 and Double.POSITIVE_INFINITY when p == 1.
org.apache.commons.math4.distribution.WeibullDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all values between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.WeibullDistribution.logDensity	(	double	): Returns the natural logarithm of the probability density function (PDF) of this distribution evaluated at the specified point x. In general, the PDF is the derivative of the cumulativeProbability() CDF. If the derivative does not exist at x, then an appropriate replacement should be returned, e.g. Double.POSITIVE_INFINITY, Double.NaN, or the limit inferior or limit superior of the difference quotient. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of density().  The default implementation simply computes the logarithm of density(x). 
org.apache.commons.math4.distribution.WeibullDistributionTest: Test cases for WeibullDistribution. Extends ContinuousDistributionAbstractTest. See class javadoc for ContinuousDistributionAbstractTest for details.
org.apache.commons.math4.distribution.WeibullDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability distribution test input values 
org.apache.commons.math4.distribution.WeibullDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.WeibullDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values 
org.apache.commons.math4.distribution.WeibullDistributionTest.makeDistribution	(	): Creates the default continuous distribution instance to use in tests. 
org.apache.commons.math4.distribution.ZipfDistribution: Implementation of the Zipf distribution.  Parameters: For a random variable X whose values are distributed according to this distribution, the probability mass function is given by  P(X = k) = H(N,s) * 1 / k^s for k = 1,2,...,N.  H(N,s) is the normalizing constant which corresponds to the generalized harmonic number of order N of s.  N is the number of elements s is the exponent 
org.apache.commons.math4.distribution.ZipfDistribution.ZipfDistribution	(	int	double	): Creates a distribution.
org.apache.commons.math4.distribution.ZipfDistribution.calculateNumericalMean	(	): Used by getNumericalMean().
org.apache.commons.math4.distribution.ZipfDistribution.calculateNumericalVariance	(	): Used by getNumericalVariance().
org.apache.commons.math4.distribution.ZipfDistribution.createSampler	(	UniformRandomProvider	):  
org.apache.commons.math4.distribution.ZipfDistribution.cumulativeProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X <= x). In other words, this method represents the (cumulative) distribution function (CDF) for this distribution. 
org.apache.commons.math4.distribution.ZipfDistribution.generalizedHarmonic	(	int	double	): Calculates the Nth generalized harmonic number. See Harmonic Series.
org.apache.commons.math4.distribution.ZipfDistribution.getExponent	(	): Get the exponent characterizing the distribution.
org.apache.commons.math4.distribution.ZipfDistribution.getNumberOfElements	(	): Get the number of elements (e.g. corpus size) for the distribution.
org.apache.commons.math4.distribution.ZipfDistribution.getNumericalMean	(	): Use this method to get the numerical value of the mean of this distribution. For number of elements N and exponent s, the mean is Hs1 / Hs, where  Hs1 = generalizedHarmonic(N, s - 1), Hs = generalizedHarmonic(N, s). 
org.apache.commons.math4.distribution.ZipfDistribution.getNumericalVariance	(	): Use this method to get the numerical value of the variance of this distribution. For number of elements N and exponent s, the mean is (Hs2 / Hs) - (Hs1^2 / Hs^2), where  Hs2 = generalizedHarmonic(N, s - 2), Hs1 = generalizedHarmonic(N, s - 1), Hs = generalizedHarmonic(N, s). 
org.apache.commons.math4.distribution.ZipfDistribution.getSupportLowerBound	(	): Access the lower bound of the support. This method must return the same value as inverseCumulativeProbability(0). In other words, this method must return inf {x in Z | P(X <= x) > 0}. The lower bound of the support is always 1 no matter the parameters.
org.apache.commons.math4.distribution.ZipfDistribution.getSupportUpperBound	(	): Access the upper bound of the support. This method must return the same value as inverseCumulativeProbability(1). In other words, this method must return inf {x in R | P(X <= x) = 1}. The upper bound of the support is the number of elements.
org.apache.commons.math4.distribution.ZipfDistribution.isSupportConnected	(	): Use this method to get information about whether the support is connected, i.e. whether all integers between the lower and upper bound of the support are included in the support. The support of this distribution is connected.
org.apache.commons.math4.distribution.ZipfDistribution.logProbability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns log(P(X = x)), where log is the natural logarithm. In other words, this method represents the logarithm of the probability mass function (PMF) for the distribution. Note that due to the floating point precision and under/overflow issues, this method will for some distributions be more precise and faster than computing the logarithm of probability().  The default implementation simply computes the logarithm of probability(x). 
org.apache.commons.math4.distribution.ZipfDistribution.probability	(	int	): For a random variable X whose values are distributed according to this distribution, this method returns P(X = x). In other words, this method represents the probability mass function (PMF) for the distribution. 
org.apache.commons.math4.distribution.ZipfDistributionTest: Test cases for ZipfDistribution. Extends IntegerDistributionAbstractTest. See class javadoc for IntegerDistributionAbstractTest for details.
org.apache.commons.math4.distribution.ZipfDistributionTest.ZipfDistributionTest	(	): Constructor to override default tolerance.
org.apache.commons.math4.distribution.ZipfDistributionTest.makeCumulativeTestPoints	(	): Creates the default cumulative probability density test input values 
org.apache.commons.math4.distribution.ZipfDistributionTest.makeCumulativeTestValues	(	): Creates the default cumulative probability density test expected values 
org.apache.commons.math4.distribution.ZipfDistributionTest.makeDensityTestPoints	(	): Creates the default probability density test input values 
org.apache.commons.math4.distribution.ZipfDistributionTest.makeDensityTestValues	(	): Creates the default probability density test expected values. Reference values are from R, version 2.15.3 (VGAM package 0.9-0).
org.apache.commons.math4.distribution.ZipfDistributionTest.makeDistribution	(	): Creates the default discrete distribution instance to use in tests. 
org.apache.commons.math4.distribution.ZipfDistributionTest.makeInverseCumulativeTestPoints	(	): Creates the default inverse cumulative probability test input values 
org.apache.commons.math4.distribution.ZipfDistributionTest.makeInverseCumulativeTestValues	(	): Creates the default inverse cumulative probability density test expected values 
org.apache.commons.math4.distribution.ZipfDistributionTest.makeLogDensityTestValues	(	): Creates the default logarithmic probability density test expected values. Reference values are from R, version 2.14.1.
org.apache.commons.math4.distribution.ZipfDistributionTest.testSamplingExtended	(	): Test sampling for various number of points and exponents.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization: Expectation-Maximization algorithm for fitting the parameters of multivariate normal mixture model distributions. This implementation is pure original code based on  EM Demystified: An Expectation-Maximization Tutorial by Yihua Chen and Maya R. Gupta, Department of Electrical Engineering, University of Washington, Seattle, WA 98195. It was verified using external tools like CRAN Mixtools (see the JUnit test cases) but it is not based on Mixtools code at all. The discussion of the origin of this class can be seen in the comments of the MATH-817 JIRA issue.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.DataRow: Class used for sorting user-supplied data.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.DataRow.DataRow	(	double[]	): Create a data row.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.DataRow.compareTo	(	DataRow	): Compare two data rows.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.DataRow.equals	(	Object	):  
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.DataRow.getRow	(	): Get a data row.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.DataRow.hashCode	(	):  
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.MultivariateNormalMixtureExpectationMaximization	(	double[][]	): Creates an object to fit a multivariate normal mixture model to data.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.estimate	(	double[][]	int	): Helper method to create a multivariate normal mixture model which can be used to initialize fit(). This method uses the data supplied to the constructor to try to determine a good mixture model at which to start the fit, but it is not guaranteed to supply a model which will find the optimal solution or even converge.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.fit	(	MixtureMultivariateNormalDistribution	): Fit a mixture model to the data supplied to the constructor. The quality of the fit depends on the concavity of the data provided to the constructor and the initial mixture provided to this function. If the data has many local optima, multiple runs of the fitting function with different initial mixtures may be required to find the optimal solution. If a SingularMatrixException is encountered, it is possible that another initialization would work.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.fit	(	MixtureMultivariateNormalDistribution	int	double	): Fit a mixture model to the data supplied to the constructor. The quality of the fit depends on the concavity of the data provided to the constructor and the initial mixture provided to this function. If the data has many local optima, multiple runs of the fitting function with different initial mixtures may be required to find the optimal solution. If a SingularMatrixException is encountered, it is possible that another initialization would work.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.getFittedModel	(	): Gets the fitted model.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximization.getLogLikelihood	(	): Gets the log likelihood of the data under the fitted model.
org.apache.commons.math4.distribution.fitting.MultivariateNormalMixtureExpectationMaximizationTest: Test that demonstrates the use of MultivariateNormalMixtureExpectationMaximization.
org.apache.commons.math4.exception.ConvergenceException: Error thrown when a numerical computation can not be performed because the numerical result failed to converge to a finite value.
org.apache.commons.math4.exception.ConvergenceException.ConvergenceException	(	): Construct the exception.
org.apache.commons.math4.exception.ConvergenceException.ConvergenceException	(	Localizable	Object	): Construct the exception with a specific context and arguments.
org.apache.commons.math4.exception.DimensionMismatchException: Exception to be thrown when two dimensions differ.
org.apache.commons.math4.exception.DimensionMismatchException.DimensionMismatchException	(	Localizable	int	int	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.exception.DimensionMismatchException.DimensionMismatchException	(	int	int	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.exception.DimensionMismatchException.getDimension	(	): 
org.apache.commons.math4.exception.DimensionMismatchExceptionTest: Test for DimensionMismatchException.
org.apache.commons.math4.exception.InsufficientDataException: Exception to be thrown when there is insufficient data to perform a computation.
org.apache.commons.math4.exception.InsufficientDataException.InsufficientDataException	(	): Construct the exception.
org.apache.commons.math4.exception.InsufficientDataException.InsufficientDataException	(	Localizable	Object	): Construct the exception with a specific context.
org.apache.commons.math4.exception.MathArithmeticException: Base class for arithmetic exceptions. It is used for all the exceptions that have the semantics of the standard ArithmeticException, but must also provide a localized message.
org.apache.commons.math4.exception.MathArithmeticException.MathArithmeticException	(	): Default constructor.
org.apache.commons.math4.exception.MathArithmeticException.MathArithmeticException	(	Localizable	Object	): Constructor with a specific message.
org.apache.commons.math4.exception.MathIllegalArgumentException: Base class for all preconditions violation exceptions. In most cases, this class should not be instantiated directly: it should serve as a base class to create all the exceptions that have the semantics of the standard IllegalArgumentException.
org.apache.commons.math4.exception.MathIllegalArgumentException.MathIllegalArgumentException	(	Localizable	Object	): 
org.apache.commons.math4.exception.MathIllegalNumberException: Base class for exceptions raised by a wrong number. This class is not intended to be instantiated directly: it should serve as a base class to create all the exceptions that are raised because some precondition is violated by a number argument.
org.apache.commons.math4.exception.MathIllegalNumberException.MathIllegalNumberException	(	Localizable	Number	Object	): Construct an exception.
org.apache.commons.math4.exception.MathIllegalNumberException.getArgument	(	): 
org.apache.commons.math4.exception.MathIllegalStateException: Base class for all exceptions that signal that the process throwing the exception is in a state that does not comply with the set of states that it is designed to be in.
org.apache.commons.math4.exception.MathIllegalStateException.MathIllegalStateException	(	): Default constructor.
org.apache.commons.math4.exception.MathIllegalStateException.MathIllegalStateException	(	Localizable	Object	): Simple constructor.
org.apache.commons.math4.exception.MathIllegalStateException.MathIllegalStateException	(	Throwable	Localizable	Object	): Simple constructor.
org.apache.commons.math4.exception.MathInternalError: Exception triggered when something that shouldn't happen does happen.
org.apache.commons.math4.exception.MathInternalError.MathInternalError	(	): Simple constructor.
org.apache.commons.math4.exception.MathInternalError.MathInternalError	(	Localizable	Object	): Constructor accepting a localized message.
org.apache.commons.math4.exception.MathInternalError.MathInternalError	(	Throwable	): Simple constructor.
org.apache.commons.math4.exception.MathParseException: Class to signal parse failures.
org.apache.commons.math4.exception.MathParseException.MathParseException	(	String	int	): 
org.apache.commons.math4.exception.MathParseException.MathParseException	(	String	int	Class	): 
org.apache.commons.math4.exception.MathRuntimeException: As of release 4.0, all exceptions thrown by the Commons Math code (except NullArgumentException) inherit from this class. In most cases, this class should not be instantiated directly: it should serve as a base class for implementing exception classes that describe a specific "problem".
org.apache.commons.math4.exception.MathRuntimeException.MathRuntimeException	(	Localizable	Object	): 
org.apache.commons.math4.exception.MathRuntimeException.MathRuntimeException	(	Throwable	Localizable	Object	): 
org.apache.commons.math4.exception.MathRuntimeException.getContext	(	): Gets a reference to the "rich context" data structure that allows to customize error messages and store key, value pairs in exceptions. 
org.apache.commons.math4.exception.MathRuntimeException.getLocalizedMessage	(	):  
org.apache.commons.math4.exception.MathRuntimeException.getMessage	(	):  
org.apache.commons.math4.exception.MathUnsupportedOperationException: Base class for all unsupported features. It is used for all the exceptions that have the semantics of the standard UnsupportedOperationException, but must also provide a localized message.
org.apache.commons.math4.exception.MathUnsupportedOperationException.MathUnsupportedOperationException	(	): Default constructor.
org.apache.commons.math4.exception.MathUnsupportedOperationException.MathUnsupportedOperationException	(	Localizable	Object	): 
org.apache.commons.math4.exception.MaxCountExceededException: Exception to be thrown when some counter maximum value is exceeded.
org.apache.commons.math4.exception.MaxCountExceededException.MaxCountExceededException	(	Localizable	Number	Object	): Construct the exception with a specific context.
org.apache.commons.math4.exception.MaxCountExceededException.MaxCountExceededException	(	Number	): Construct the exception.
org.apache.commons.math4.exception.MaxCountExceededException.getMax	(	): 
org.apache.commons.math4.exception.MaxCountExceededExceptionTest: Test for MaxCountExceededException.
org.apache.commons.math4.exception.MultiDimensionMismatchException: Exception to be thrown when two sets of dimensions differ.
org.apache.commons.math4.exception.MultiDimensionMismatchException.MultiDimensionMismatchException	(	Integer[]	Integer[]	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.exception.MultiDimensionMismatchException.MultiDimensionMismatchException	(	Localizable	Integer[]	Integer[]	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.exception.MultiDimensionMismatchException.getExpectedDimension	(	int	): 
org.apache.commons.math4.exception.MultiDimensionMismatchException.getExpectedDimensions	(	): 
org.apache.commons.math4.exception.MultiDimensionMismatchException.getWrongDimension	(	int	): 
org.apache.commons.math4.exception.MultiDimensionMismatchException.getWrongDimensions	(	): 
org.apache.commons.math4.exception.NoBracketingException: Exception to be thrown when function values have the same sign at both ends of an interval.
org.apache.commons.math4.exception.NoBracketingException.NoBracketingException	(	Localizable	double	double	double	double	Object	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NoBracketingException.NoBracketingException	(	double	double	double	double	): Construct the exception.
org.apache.commons.math4.exception.NoBracketingException.getFHi	(	): Get the value at the higher end of the interval.
org.apache.commons.math4.exception.NoBracketingException.getFLo	(	): Get the value at the lower end of the interval.
org.apache.commons.math4.exception.NoBracketingException.getHi	(	): Get the higher end of the interval.
org.apache.commons.math4.exception.NoBracketingException.getLo	(	): Get the lower end of the interval.
org.apache.commons.math4.exception.NoDataException: Exception to be thrown when the required data is missing.
org.apache.commons.math4.exception.NoDataException.NoDataException	(	): Construct the exception.
org.apache.commons.math4.exception.NoDataException.NoDataException	(	Localizable	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NonMonotonicSequenceException: Exception to be thrown when the a sequence of values is not monotonically increasing or decreasing.
org.apache.commons.math4.exception.NonMonotonicSequenceException.NonMonotonicSequenceException	(	Number	Number	int	): Construct the exception. This constructor uses default values assuming that the sequence should have been strictly increasing.
org.apache.commons.math4.exception.NonMonotonicSequenceException.NonMonotonicSequenceException	(	Number	Number	int	MathArrays.OrderDirection	boolean	): Construct the exception.
org.apache.commons.math4.exception.NonMonotonicSequenceException.getDirection	(	): 
org.apache.commons.math4.exception.NonMonotonicSequenceException.getIndex	(	): Get the index of the wrong value.
org.apache.commons.math4.exception.NonMonotonicSequenceException.getPrevious	(	): 
org.apache.commons.math4.exception.NonMonotonicSequenceException.getStrict	(	): 
org.apache.commons.math4.exception.NonMonotonicSequenceExceptionTest: Test for NonMonotonicSequenceException.
org.apache.commons.math4.exception.NotANumberException: Exception to be thrown when a number is not a number.
org.apache.commons.math4.exception.NotANumberException.NotANumberException	(	): Construct the exception.
org.apache.commons.math4.exception.NotFiniteNumberException: Exception to be thrown when a number is not finite.
org.apache.commons.math4.exception.NotFiniteNumberException.NotFiniteNumberException	(	Localizable	Number	Object	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NotFiniteNumberException.NotFiniteNumberException	(	Number	Object	): Construct the exception.
org.apache.commons.math4.exception.NotPositiveException: Exception to be thrown when the argument is negative.
org.apache.commons.math4.exception.NotPositiveException.NotPositiveException	(	Localizable	Number	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NotPositiveException.NotPositiveException	(	Number	): Construct the exception.
org.apache.commons.math4.exception.NotPositiveExceptionTest: Test for NotPositiveException.
org.apache.commons.math4.exception.NotStrictlyPositiveException: Exception to be thrown when the argument is not greater than 0.
org.apache.commons.math4.exception.NotStrictlyPositiveException.NotStrictlyPositiveException	(	Localizable	Number	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NotStrictlyPositiveException.NotStrictlyPositiveException	(	Number	): Construct the exception.
org.apache.commons.math4.exception.NotStrictlyPositiveExceptionTest: Test for NotStrictlyPositiveException.
org.apache.commons.math4.exception.NullArgumentException: All conditions checks that fail due to a null argument must throw this exception. This class is meant to signal a precondition violation ("null is an illegal argument") and so does not extend the standard NullPointerException. Propagation of NullPointerException from within Commons-Math is construed to be a bug.  Note: from 4.0 onwards, this class extends NullPointerException instead of MathIllegalArgumentException.
org.apache.commons.math4.exception.NullArgumentException.NullArgumentException	(	): Default constructor.
org.apache.commons.math4.exception.NullArgumentException.NullArgumentException	(	Localizable	Object	): 
org.apache.commons.math4.exception.NullArgumentException.getContext	(	): Gets a reference to the "rich context" data structure that allows to customize error messages and store key, value pairs in exceptions.
org.apache.commons.math4.exception.NullArgumentException.getLocalizedMessage	(	):  
org.apache.commons.math4.exception.NullArgumentException.getMessage	(	):  
org.apache.commons.math4.exception.NumberIsTooLargeException: Exception to be thrown when a number is too large.
org.apache.commons.math4.exception.NumberIsTooLargeException.NumberIsTooLargeException	(	Localizable	Number	Number	boolean	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NumberIsTooLargeException.NumberIsTooLargeException	(	Number	Number	boolean	): Construct the exception.
org.apache.commons.math4.exception.NumberIsTooLargeException.getBoundIsAllowed	(	): 
org.apache.commons.math4.exception.NumberIsTooLargeException.getMax	(	): 
org.apache.commons.math4.exception.NumberIsTooLargeExceptionTest: Test for NumberIsTooLargeException.
org.apache.commons.math4.exception.NumberIsTooSmallException: Exception to be thrown when a number is too small.
org.apache.commons.math4.exception.NumberIsTooSmallException.NumberIsTooSmallException	(	Localizable	Number	Number	boolean	): Construct the exception with a specific context.
org.apache.commons.math4.exception.NumberIsTooSmallException.NumberIsTooSmallException	(	Number	Number	boolean	): Construct the exception.
org.apache.commons.math4.exception.NumberIsTooSmallException.getBoundIsAllowed	(	): 
org.apache.commons.math4.exception.NumberIsTooSmallException.getMin	(	): 
org.apache.commons.math4.exception.NumberIsTooSmallExceptionTest: Test for NumberIsTooSmallException.
org.apache.commons.math4.exception.OutOfRangeException: Exception to be thrown when some argument is out of range.
org.apache.commons.math4.exception.OutOfRangeException.OutOfRangeException	(	Localizable	Number	Number	Number	): Construct an exception from the mismatched dimensions with a specific context information.
org.apache.commons.math4.exception.OutOfRangeException.OutOfRangeException	(	Number	Number	Number	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.exception.OutOfRangeException.getHi	(	): 
org.apache.commons.math4.exception.OutOfRangeException.getLo	(	): 
org.apache.commons.math4.exception.OutOfRangeExceptionTest: Test for OutOfRangeException.
org.apache.commons.math4.exception.TooManyEvaluationsException: Exception to be thrown when the maximal number of evaluations is exceeded.
org.apache.commons.math4.exception.TooManyEvaluationsException.TooManyEvaluationsException	(	Number	): Construct the exception.
org.apache.commons.math4.exception.TooManyEvaluationsExceptionTest: Test for TooManyEvaluationsException.
org.apache.commons.math4.exception.TooManyIterationsException: Exception to be thrown when the maximal number of iterations is exceeded.
org.apache.commons.math4.exception.TooManyIterationsException.TooManyIterationsException	(	Number	): Construct the exception.
org.apache.commons.math4.exception.ZeroException: Exception to be thrown when zero is provided where it is not allowed.
org.apache.commons.math4.exception.ZeroException.ZeroException	(	): Construct the exception.
org.apache.commons.math4.exception.ZeroException.ZeroException	(	Localizable	Object	): Construct the exception with a specific context.
org.apache.commons.math4.exception.util.ArgUtils: Utility class for transforming the list of arguments passed to constructors of exceptions.
org.apache.commons.math4.exception.util.ArgUtils.ArgUtils	(	): Class contains only static methods.
org.apache.commons.math4.exception.util.ArgUtils.flatten	(	Object[]	): Transform a multidimensional array into a one-dimensional list.
org.apache.commons.math4.exception.util.ArgUtilsTest: Test for ArgUtils.
org.apache.commons.math4.exception.util.ArgUtilsTest.create	(	List	): Create and store an Object.
org.apache.commons.math4.exception.util.DummyLocalizable: Dummy implementation of the Localizable interface, without localization.
org.apache.commons.math4.exception.util.DummyLocalizable.DummyLocalizable	(	String	): Simple constructor.
org.apache.commons.math4.exception.util.DummyLocalizable.getLocalizedString	(	Locale	): Gets the localized string. 
org.apache.commons.math4.exception.util.DummyLocalizable.getSourceString	(	): Gets the source (non-localized) string. 
org.apache.commons.math4.exception.util.DummyLocalizable.toString	(	):  
org.apache.commons.math4.exception.util.ExceptionContext: Class that contains the actual implementation of the functionality mandated by the ExceptionContext interface. All Commons Math exceptions delegate the interface's methods to this class.
org.apache.commons.math4.exception.util.ExceptionContext.ExceptionContext	(	Throwable	): Simple constructor.
org.apache.commons.math4.exception.util.ExceptionContext.addMessage	(	Localizable	Object	): Adds a message.
org.apache.commons.math4.exception.util.ExceptionContext.buildMessage	(	Locale	String	): Builds a message string.
org.apache.commons.math4.exception.util.ExceptionContext.deSerializeContext	(	ObjectInputStream	): Deserialize context.
org.apache.commons.math4.exception.util.ExceptionContext.deSerializeMessages	(	ObjectInputStream	): Deserialize msgPatterns and msgArguments.
org.apache.commons.math4.exception.util.ExceptionContext.getKeys	(	): Gets all the keys stored in the exception
org.apache.commons.math4.exception.util.ExceptionContext.getLocalizedMessage	(	): Gets the message in the default locale.
org.apache.commons.math4.exception.util.ExceptionContext.getMessage	(	): Gets the default message.
org.apache.commons.math4.exception.util.ExceptionContext.getMessage	(	Locale	): Gets the message in a specified locale.
org.apache.commons.math4.exception.util.ExceptionContext.getMessage	(	Locale	String	): Gets the message in a specified locale.
org.apache.commons.math4.exception.util.ExceptionContext.getThrowable	(	): Get a reference to the exception to which the context relates.
org.apache.commons.math4.exception.util.ExceptionContext.getValue	(	String	): Gets the value associated to the given context key.
org.apache.commons.math4.exception.util.ExceptionContext.nonSerializableReplacement	(	Object	): Replaces a non-serializable object with an error message string.
org.apache.commons.math4.exception.util.ExceptionContext.readObject	(	ObjectInputStream	): Deserialize this object from the given stream.
org.apache.commons.math4.exception.util.ExceptionContext.serializeContext	(	ObjectOutputStream	): Serialize context.
org.apache.commons.math4.exception.util.ExceptionContext.serializeMessages	(	ObjectOutputStream	): Serialize msgPatterns and msgArguments.
org.apache.commons.math4.exception.util.ExceptionContext.setValue	(	String	Object	): Sets the context (key, value) pair. Keys are assumed to be unique within an instance. If the same key is assigned a new value, the previous one will be lost.
org.apache.commons.math4.exception.util.ExceptionContext.writeObject	(	ObjectOutputStream	): Serialize this object to the given stream.
org.apache.commons.math4.exception.util.ExceptionContextProvider: Interface for accessing the context data structure stored in Commons Math exceptions.
org.apache.commons.math4.exception.util.ExceptionContextProvider.getContext	(	): Gets a reference to the "rich context" data structure that allows to customize error messages and store key, value pairs in exceptions.
org.apache.commons.math4.exception.util.ExceptionContextTest: Test for ExceptionContext.
org.apache.commons.math4.exception.util.ExceptionContextTest.Unserializable: Class used by testSerializeUnserializable().
org.apache.commons.math4.exception.util.Localizable: Interface for localizable strings.
org.apache.commons.math4.exception.util.Localizable.getLocalizedString	(	Locale	): Gets the localized string.
org.apache.commons.math4.exception.util.Localizable.getSourceString	(	): Gets the source (non-localized) string.
org.apache.commons.math4.filter.DefaultMeasurementModel: Default implementation of a MeasurementModel for the use with a KalmanFilter.
org.apache.commons.math4.filter.DefaultMeasurementModel.DefaultMeasurementModel	(	RealMatrix	RealMatrix	): Create a new MeasurementModel, taking RealMatrix objects as input parameters for the respective measurement matrix and noise.
org.apache.commons.math4.filter.DefaultMeasurementModel.DefaultMeasurementModel	(	double[][]	double[][]	): Create a new MeasurementModel, taking double arrays as input parameters for the respective measurement matrix and noise.
org.apache.commons.math4.filter.DefaultMeasurementModel.getMeasurementMatrix	(	): Returns the measurement matrix. 
org.apache.commons.math4.filter.DefaultMeasurementModel.getMeasurementNoise	(	): Returns the measurement noise matrix. This method is called by the KalmanFilter every correction step, so implementations of this interface may return a modified measurement noise depending on the current iteration step. 
org.apache.commons.math4.filter.DefaultProcessModel: Default implementation of a ProcessModel for the use with a KalmanFilter.
org.apache.commons.math4.filter.DefaultProcessModel.DefaultProcessModel	(	RealMatrix	RealMatrix	RealMatrix	RealVector	RealMatrix	): Create a new ProcessModel, taking double arrays as input parameters.
org.apache.commons.math4.filter.DefaultProcessModel.DefaultProcessModel	(	double[][]	double[][]	double[][]	): Create a new ProcessModel, taking double arrays as input parameters.  The initial state estimate and error covariance are omitted and will be initialized by the KalmanFilter to default values.
org.apache.commons.math4.filter.DefaultProcessModel.DefaultProcessModel	(	double[][]	double[][]	double[][]	double[]	double[][]	): Create a new ProcessModel, taking double arrays as input parameters.
org.apache.commons.math4.filter.DefaultProcessModel.getControlMatrix	(	): Returns the control matrix. 
org.apache.commons.math4.filter.DefaultProcessModel.getInitialErrorCovariance	(	): Returns the initial error covariance matrix.  Note: if the return value is zero, the Kalman filter will initialize the error covariance with the process noise matrix. 
org.apache.commons.math4.filter.DefaultProcessModel.getInitialStateEstimate	(	): Returns the initial state estimation vector.  Note: if the return value is zero, the Kalman filter will initialize the state estimation with a zero vector. 
org.apache.commons.math4.filter.DefaultProcessModel.getProcessNoise	(	): Returns the process noise matrix. This method is called by the KalmanFilter every prediction step, so implementations of this interface may return a modified process noise depending on the current iteration step. 
org.apache.commons.math4.filter.DefaultProcessModel.getStateTransitionMatrix	(	): Returns the state transition matrix. 
org.apache.commons.math4.filter.KalmanFilter: Implementation of a Kalman filter to estimate the state xk of a discrete-time controlled process that is governed by the linear stochastic difference equation:  xk = Axk-1 + Buk-1 + wk-1  with a measurement xk that is  zk = Hxk + vk.   The random variables wk and vk represent the process and measurement noise and are assumed to be independent of each other and distributed with normal probability (white noise).  The Kalman filter cycle involves the following steps:  predict: project the current state estimate ahead in time correct: adjust the projected estimate by an actual measurement   The Kalman filter is initialized with a ProcessModel and a MeasurementModel, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature:  A - state transition matrix B - control input matrix H - measurement matrix Q - process noise covariance matrix R - measurement noise covariance matrix P - error covariance matrix 
org.apache.commons.math4.filter.KalmanFilter.KalmanFilter	(	ProcessModel	MeasurementModel	): Creates a new Kalman filter with the given process and measurement models.
org.apache.commons.math4.filter.KalmanFilter.correct	(	RealVector	): Correct the current state estimate with an actual measurement.
org.apache.commons.math4.filter.KalmanFilter.correct	(	double[]	): Correct the current state estimate with an actual measurement.
org.apache.commons.math4.filter.KalmanFilter.getErrorCovariance	(	): Returns the current error covariance matrix.
org.apache.commons.math4.filter.KalmanFilter.getErrorCovarianceMatrix	(	): Returns a copy of the current error covariance matrix.
org.apache.commons.math4.filter.KalmanFilter.getMeasurementDimension	(	): Returns the dimension of the measurement vector.
org.apache.commons.math4.filter.KalmanFilter.getStateDimension	(	): Returns the dimension of the state estimation vector.
org.apache.commons.math4.filter.KalmanFilter.getStateEstimation	(	): Returns the current state estimation vector.
org.apache.commons.math4.filter.KalmanFilter.getStateEstimationVector	(	): Returns a copy of the current state estimation vector.
org.apache.commons.math4.filter.KalmanFilter.predict	(	): Predict the internal state estimation one time step ahead.
org.apache.commons.math4.filter.KalmanFilter.predict	(	RealVector	): Predict the internal state estimation one time step ahead.
org.apache.commons.math4.filter.KalmanFilter.predict	(	double[]	): Predict the internal state estimation one time step ahead.
org.apache.commons.math4.filter.KalmanFilterTest: Tests for KalmanFilter.
org.apache.commons.math4.filter.KalmanFilterTest.Cannonball: Represents an idealized Cannonball only taking into account gravity.
org.apache.commons.math4.filter.MeasurementModel: Defines the measurement model for the use with a KalmanFilter.
org.apache.commons.math4.filter.MeasurementModel.getMeasurementMatrix	(	): Returns the measurement matrix.
org.apache.commons.math4.filter.MeasurementModel.getMeasurementNoise	(	): Returns the measurement noise matrix. This method is called by the KalmanFilter every correction step, so implementations of this interface may return a modified measurement noise depending on the current iteration step.
org.apache.commons.math4.filter.ProcessModel: Defines the process dynamics model for the use with a KalmanFilter.
org.apache.commons.math4.filter.ProcessModel.getControlMatrix	(	): Returns the control matrix.
org.apache.commons.math4.filter.ProcessModel.getInitialErrorCovariance	(	): Returns the initial error covariance matrix.  Note: if the return value is zero, the Kalman filter will initialize the error covariance with the process noise matrix.
org.apache.commons.math4.filter.ProcessModel.getInitialStateEstimate	(	): Returns the initial state estimation vector.  Note: if the return value is zero, the Kalman filter will initialize the state estimation with a zero vector.
org.apache.commons.math4.filter.ProcessModel.getProcessNoise	(	): Returns the process noise matrix. This method is called by the KalmanFilter every prediction step, so implementations of this interface may return a modified process noise depending on the current iteration step.
org.apache.commons.math4.filter.ProcessModel.getStateTransitionMatrix	(	): Returns the state transition matrix.
org.apache.commons.math4.fitting.AbstractCurveFitter: Base class that contains common code for fitting parametric univariate real functions y = f(pi;x), where x is the independent variable and the pi are the parameters.  A fitter will find the optimal values of the parameters by fitting the curve so it remains very close to a set of N observed points (xk, yk), 0 <= k < N.  An algorithm usually performs the fit by finding the parameter values that minimizes the objective function  ∑yk - f(xk)2,  which is actually a least-squares problem. This class contains boilerplate code for calling the fit() method for obtaining the parameters. The problem setup, such as the choice of optimization algorithm for fitting a specific function is delegated to subclasses.
org.apache.commons.math4.fitting.AbstractCurveFitter.TheoreticalValuesFunction: Vector function for computing function theoretical values.
org.apache.commons.math4.fitting.AbstractCurveFitter.TheoreticalValuesFunction.TheoreticalValuesFunction	(	ParametricUnivariateFunction	Collection	): 
org.apache.commons.math4.fitting.AbstractCurveFitter.TheoreticalValuesFunction.getModelFunction	(	): 
org.apache.commons.math4.fitting.AbstractCurveFitter.TheoreticalValuesFunction.getModelFunctionJacobian	(	): 
org.apache.commons.math4.fitting.AbstractCurveFitter.fit	(	Collection	): Fits a curve. This method computes the coefficients of the curve that best fit the sample of observed points.
org.apache.commons.math4.fitting.AbstractCurveFitter.getOptimizer	(	): Creates an optimizer set up to fit the appropriate curve.  The default implementation uses a LevenbergMarquardtOptimizer Levenberg-Marquardt optimizer. 
org.apache.commons.math4.fitting.AbstractCurveFitter.getProblem	(	Collection	): Creates a least squares problem corresponding to the appropriate curve.
org.apache.commons.math4.fitting.GaussianCurveFitter: Fits points to a org.apache.commons.math4.analysis.function.Gaussian.Parametric Gaussian function.  The withStartPoint() initial guess values must be passed in the following order:  Normalization Mean Sigma  The optimal values will be returned in the same order.  Usage example:  WeightedObservedPoints obs = new WeightedObservedPoints(); obs.add(4.0254623, 531026.0); obs.add(4.03128248, 984167.0); obs.add(4.03839603, 1887233.0); obs.add(4.04421621, 2687152.0); obs.add(4.05132976, 3461228.0); obs.add(4.05326982, 3580526.0); obs.add(4.05779662, 3439750.0); obs.add(4.0636168, 2877648.0); obs.add(4.06943698, 2175960.0); obs.add(4.07525716, 1447024.0); obs.add(4.08237071, 717104.0); obs.add(4.08366408, 620014.0); double[] parameters = GaussianCurveFitter.create().fit(obs.toList()); 
org.apache.commons.math4.fitting.GaussianCurveFitter.GaussianCurveFitter	(	double[]	int	): Contructor used by the factory methods.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser: Guesses the parameters norm, mean, and sigma of a org.apache.commons.math4.analysis.function.Gaussian.Parametric based on the specified observed points.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.ParameterGuesser	(	Collection	): Constructs instance with the specified observed points.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.basicGuess	(	WeightedObservedPoint[]	): Guesses the parameters based on the specified observed points.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.findMaxY	(	WeightedObservedPoint[]	): Finds index of point in specified points with the largest Y.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.getInterpolationPointsForY	(	WeightedObservedPoint[]	int	int	double	): Gets the two bounding interpolation points from the specified points suitable for determining X at the specified Y.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.guess	(	): Gets an estimation of the parameters.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.interpolateXAtY	(	WeightedObservedPoint[]	int	int	double	): Interpolates using the specified points to determine X at the specified Y.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.isBetween	(	double	double	double	): Determines whether a value is between two other values.
org.apache.commons.math4.fitting.GaussianCurveFitter.ParameterGuesser.sortObservations	(	Collection	): Sort the observations.
org.apache.commons.math4.fitting.GaussianCurveFitter.create	(	): Creates a default curve fitter. The initial guess for the parameters will be ParameterGuesser computed automatically, and the maximum number of iterations of the optimization algorithm is set to MAX_VALUE.
org.apache.commons.math4.fitting.GaussianCurveFitter.getProblem	(	Collection	): Creates a least squares problem corresponding to the appropriate curve. 
org.apache.commons.math4.fitting.GaussianCurveFitter.withMaxIterations	(	int	): Configure the maximum number of iterations.
org.apache.commons.math4.fitting.GaussianCurveFitter.withStartPoint	(	double[]	): Configure the start point (initial guess).
org.apache.commons.math4.fitting.GaussianCurveFitterTest: Tests GaussianCurveFitter.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.createDataset	(	double[][]	): Adds the specified points to specified GaussianCurveFitter instance.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit01	(	): Basic.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit02	(	): Zero points is not enough observed points.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit03	(	): Two points is not enough observed points.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit04	(	): Poor data: right of peak not symmetric with left of peak.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit05	(	): Poor data: long tails.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit06	(	): Poor data: right of peak is missing.
org.apache.commons.math4.fitting.GaussianCurveFitterTest.testFit07	(	): Basic with smaller dataset.
org.apache.commons.math4.fitting.HarmonicCurveFitter: Fits points to a org.apache.commons.math4.analysis.function.HarmonicOscillator.Parametric harmonic oscillator function.  The withStartPoint() initial guess values must be passed in the following order:  Amplitude Angular frequency phase  The optimal values will be returned in the same order.
org.apache.commons.math4.fitting.HarmonicCurveFitter.HarmonicCurveFitter	(	double[]	int	): Contructor used by the factory methods.
org.apache.commons.math4.fitting.HarmonicCurveFitter.ParameterGuesser: This class guesses harmonic coefficients from a sample. The algorithm used to guess the coefficients is as follows: We know \( f(t) \) at some sampling points \( t_i \) and want to find \( a \), \( \omega \) and \( \phi \) such that \( f(t) = a \cos (\omega t + \phi) \).  From the analytical expression, we can compute two primitives : \[ If2(t) = \int f^2 dt = a^2 (t + S(t)) / 2 \] \[ If'2(t) = \int f'^2 dt = a^2 \omega^2 (t - S(t)) / 2 \] where \(S(t) = \frac{\sin(2 (\omega t + \phi))}{2\omega}\)  We can remove \(S\) between these expressions : \[ If'2(t) = a^2 \omega^2 t - \omega^2 If2(t) \]  The preceding expression shows that \(If'2 (t)\) is a linear combination of both \(t\) and \(If2(t)\): \[ If'2(t) = A t + B If2(t) \]  From the primitive, we can deduce the same form for definite integrals between \(t_1\) and \(t_i\) for each \(t_i\) : \[ If2(t_i) - If2(t_1) = A (t_i - t_1) + B (If2 (t_i) - If2(t_1)) \]  We can find the coefficients \(A\) and \(B\) that best fit the sample to this linear expression by computing the definite integrals for each sample points.  For a bilinear expression \(z(x_i, y_i) = A x_i + B y_i\), the coefficients \(A\) and \(B\) that minimize a least-squares criterion \(\sum (z_i - z(x_i, y_i))^2\) are given by these expressions: \[ A = \frac{\sum y_i y_i \sum x_i z_i - \sum x_i y_i \sum y_i z_i} {\sum x_i x_i \sum y_i y_i - \sum x_i y_i \sum x_i y_i} \] \[ B = \frac{\sum x_i x_i \sum y_i z_i - \sum x_i y_i \sum x_i z_i} {\sum x_i x_i \sum y_i y_i - \sum x_i y_i \sum x_i y_i} \] In fact, we can assume that both \(a\) and \(\omega\) are positive and compute them directly, knowing that \(A = a^2 \omega^2\) and that \(B = -\omega^2\). The complete algorithm is therefore: For each \(t_i\) from \(t_1\) to \(t_{n-1}\), compute: \[ f(t_i) \] \[ f'(t_i) = \frac{f (t_{i+1}) - f(t_{i-1})}{t_{i+1} - t_{i-1}} \] \[ x_i = t_i - t_1 \] \[ y_i = \int_{t_1}^{t_i} f^2(t) dt \] \[ z_i = \int_{t_1}^{t_i} f'^2(t) dt \] and update the sums: \[ \sum x_i x_i, \sum y_i y_i, \sum x_i y_i, \sum x_i z_i, \sum y_i z_i \] Then: \[ a = \sqrt{\frac{\sum y_i y_i \sum x_i z_i - \sum x_i y_i \sum y_i z_i } {\sum x_i y_i \sum x_i z_i - \sum x_i x_i \sum y_i z_i }} \] \[ \omega = \sqrt{\frac{\sum x_i y_i \sum x_i z_i - \sum x_i x_i \sum y_i z_i} {\sum x_i x_i \sum y_i y_i - \sum x_i y_i \sum x_i y_i}} \] Once we know \(\omega\) we can compute: \[ fc = \omega f(t) \cos(\omega t) - f'(t) \sin(\omega t) \] \[ fs = \omega f(t) \sin(\omega t) + f'(t) \cos(\omega t) \]  It appears that \(fc = a \omega \cos(\phi)\) and \(fs = -a \omega \sin(\phi)\), so we can use these expressions to compute \(\phi\). The best estimate over the sample is given by averaging these expressions.  Since integrals and means are involved in the preceding estimations, these operations run in \(O(n)\) time, where \(n\) is the number of measurements.
org.apache.commons.math4.fitting.HarmonicCurveFitter.ParameterGuesser.ParameterGuesser	(	Collection	): Simple constructor.
org.apache.commons.math4.fitting.HarmonicCurveFitter.ParameterGuesser.guess	(	): Gets an estimation of the parameters.
org.apache.commons.math4.fitting.HarmonicCurveFitter.ParameterGuesser.guessAOmega	(	WeightedObservedPoint[]	): Estimate a first guess of the amplitude and angular frequency.
org.apache.commons.math4.fitting.HarmonicCurveFitter.ParameterGuesser.guessPhi	(	WeightedObservedPoint[]	): Estimate a first guess of the phase.
org.apache.commons.math4.fitting.HarmonicCurveFitter.ParameterGuesser.sortObservations	(	Collection	): Sort the observations with respect to the abscissa.
org.apache.commons.math4.fitting.HarmonicCurveFitter.create	(	): Creates a default curve fitter. The initial guess for the parameters will be ParameterGuesser computed automatically, and the maximum number of iterations of the optimization algorithm is set to MAX_VALUE.
org.apache.commons.math4.fitting.HarmonicCurveFitter.getProblem	(	Collection	): Creates a least squares problem corresponding to the appropriate curve. 
org.apache.commons.math4.fitting.HarmonicCurveFitter.withMaxIterations	(	int	): Configure the maximum number of iterations.
org.apache.commons.math4.fitting.HarmonicCurveFitter.withStartPoint	(	double[]	): Configure the start point (initial guess).
org.apache.commons.math4.fitting.HarmonicCurveFitterTest.testPreconditions1	(	): Zero points is not enough observed points.
org.apache.commons.math4.fitting.PolynomialCurveFitter: Fits points to a org.apache.commons.math4.analysis.polynomials.PolynomialFunction.Parametric polynomial function.  The size of the withStartPoint() initial guess array defines the degree of the polynomial to be fitted. They must be sorted in increasing order of the polynomial's degree. The optimal values of the coefficients will be returned in the same order.
org.apache.commons.math4.fitting.PolynomialCurveFitter.PolynomialCurveFitter	(	double[]	int	): Contructor used by the factory methods.
org.apache.commons.math4.fitting.PolynomialCurveFitter.create	(	int	): Creates a default curve fitter. Zero will be used as initial guess for the coefficients, and the maximum number of iterations of the optimization algorithm is set to MAX_VALUE.
org.apache.commons.math4.fitting.PolynomialCurveFitter.getProblem	(	Collection	): Creates a least squares problem corresponding to the appropriate curve. 
org.apache.commons.math4.fitting.PolynomialCurveFitter.withMaxIterations	(	int	): Configure the maximum number of iterations.
org.apache.commons.math4.fitting.PolynomialCurveFitter.withStartPoint	(	double[]	): Configure the start point (initial guess).
org.apache.commons.math4.fitting.PolynomialCurveFitterTest: Test for class PolynomialCurveFitter.
org.apache.commons.math4.fitting.SimpleCurveFitter: Fits points to a user-defined ParametricUnivariateFunction function.
org.apache.commons.math4.fitting.SimpleCurveFitter.SimpleCurveFitter	(	ParametricUnivariateFunction	double[]	int	): Contructor used by the factory methods.
org.apache.commons.math4.fitting.SimpleCurveFitter.create	(	ParametricUnivariateFunction	double[]	): Creates a curve fitter. The maximum number of iterations of the optimization algorithm is set to MAX_VALUE.
org.apache.commons.math4.fitting.SimpleCurveFitter.getProblem	(	Collection	): Creates a least squares problem corresponding to the appropriate curve. 
org.apache.commons.math4.fitting.SimpleCurveFitter.withMaxIterations	(	int	): Configure the maximum number of iterations.
org.apache.commons.math4.fitting.SimpleCurveFitter.withStartPoint	(	double[]	): Configure the start point (initial guess).
org.apache.commons.math4.fitting.SimpleCurveFitterTest: Test for class SimpleCurveFitter.
org.apache.commons.math4.fitting.WeightedObservedPoint: This class is a simple container for weighted observed point in AbstractCurveFitter curve fitting. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.fitting.WeightedObservedPoint.WeightedObservedPoint	(	double	double	double	): Simple constructor.
org.apache.commons.math4.fitting.WeightedObservedPoint.getWeight	(	): Gets the weight of the measurement in the fitting process.
org.apache.commons.math4.fitting.WeightedObservedPoint.getX	(	): Gets the abscissa of the point.
org.apache.commons.math4.fitting.WeightedObservedPoint.getY	(	): Gets the observed value of the function at x.
org.apache.commons.math4.fitting.WeightedObservedPoints: Simple container for weighted observed points used in AbstractCurveFitter curve fitting algorithms.
org.apache.commons.math4.fitting.WeightedObservedPoints.add	(	WeightedObservedPoint	): Adds a point to the sample.
org.apache.commons.math4.fitting.WeightedObservedPoints.add	(	double	double	): Adds a point to the sample. Calling this method is equivalent to calling add(1.0, x, y).
org.apache.commons.math4.fitting.WeightedObservedPoints.add	(	double	double	double	): Adds a point to the sample.
org.apache.commons.math4.fitting.WeightedObservedPoints.clear	(	): Removes all observations from this container.
org.apache.commons.math4.fitting.WeightedObservedPoints.toList	(	): Gets a snapshot of the observed points. The list of stored points is copied in order to ensure that modification of the returned instance does not affect this container. Conversely, further modification of this container (through the add or clear methods) will not affect the returned list.
org.apache.commons.math4.fitting.WeightedObservedPointsTest: Tests WeightedObservedPoints.
org.apache.commons.math4.fitting.WeightedObservedPointsTest.lastElementIsSame	(	WeightedObservedPoints	WeightedObservedPoint	): Checks that the contents of the last element is equal to the contents of p.
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation: An implementation of Evaluation that is designed for extension. All of the methods implemented here use the methods that are left unimplemented.  TODO cache results?
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.AbstractEvaluation	(	int	): Constructor.
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.getChiSquare	(	): Get the sum of the squares of the residuals. 
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.getCost	(	): Get the cost. It is the square-root of the getChiSquare() objective function. 
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.getCovariances	(	double	): Get the covariance matrix of the optimized parameters.  Note that this operation involves the inversion of the JTJ matrix, where J is the Jacobian matrix. The threshold parameter is a way for the caller to specify that the result of this computation should be considered meaningless, and thus trigger an exception. 
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.getRMS	(	): Get the normalized cost. It is the square-root of the sum of squared of the residuals, divided by the number of measurements. 
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.getReducedChiSquare	(	int	): Get the reduced chi-square. 
org.apache.commons.math4.fitting.leastsquares.AbstractEvaluation.getSigma	(	double	): Get an estimate of the standard deviation of the parameters. The returned values are the square root of the diagonal coefficients of the covariance matrix, sd(a[i]) ~= sqrt(C[i][i]), where a[i] is the optimized value of the i-th parameter, and C is the covariance matrix. 
org.apache.commons.math4.fitting.leastsquares.AbstractLeastSquaresOptimizerAbstractTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here.   Concrete implementation of an optimizer.
org.apache.commons.math4.fitting.leastsquares.AbstractLeastSquaresOptimizerAbstractTest.assertEquals	(	double	RealVector	double	): Check the value of a vector.
org.apache.commons.math4.fitting.leastsquares.AbstractLeastSquaresOptimizerAbstractTest.getMaxIterations	(	): 
org.apache.commons.math4.fitting.leastsquares.AbstractLeastSquaresOptimizerAbstractTest.getOptimizer	(	): Get an instance of the optimizer under test.
org.apache.commons.math4.fitting.leastsquares.CircleProblem: Class that models a circle. The parameters of problem are:  the x-coordinate of the circle center, the y-coordinate of the circle center, the radius of the circle.  The model functions are:  for each triplet (cx, cy, r), the (x, y) coordinates of a point on the corresponding circle. 
org.apache.commons.math4.fitting.leastsquares.CircleProblem.CircleProblem	(	double	double	): 
org.apache.commons.math4.fitting.leastsquares.CircleProblem.CircleProblem	(	double	double	int	): 
org.apache.commons.math4.fitting.leastsquares.CircleVectorial: Class used in the tests.
org.apache.commons.math4.fitting.leastsquares.DenseWeightedEvaluation: Applies a dense weight matrix to an evaluation.
org.apache.commons.math4.fitting.leastsquares.DenseWeightedEvaluation.DenseWeightedEvaluation	(	Evaluation	RealMatrix	): Create a weighted evaluation from an unweighted one.
org.apache.commons.math4.fitting.leastsquares.DenseWeightedEvaluation.getJacobian	(	): Get the weighted Jacobian matrix. 
org.apache.commons.math4.fitting.leastsquares.DenseWeightedEvaluation.getPoint	(	): Get the abscissa (independent variables) of this evaluation. 
org.apache.commons.math4.fitting.leastsquares.DenseWeightedEvaluation.getResiduals	(	): Get the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix. 
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsChecker: Check if an optimization has converged based on the change in computed RMS.
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsChecker.EvaluationRmsChecker	(	double	): Create a convergence checker for the RMS with the same relative and absolute tolerance. Convenience constructor for when the relative and absolute tolerances are the same. Same as new EvaluationRmsChecker(tol, tol).
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsChecker.EvaluationRmsChecker	(	double	double	): Create a convergence checker for the RMS with a relative and absolute tolerance. The optimization has converged when the RMS of consecutive evaluations are equal to within the given relative tolerance or absolute tolerance.
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsChecker.converged	(	int	Evaluation	Evaluation	):  
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsCheckerTest: Unit tests for EvaluationRmsChecker. 
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsCheckerTest.mockEvaluation	(	double	): Create a mock Evaluation.
org.apache.commons.math4.fitting.leastsquares.EvaluationRmsCheckerTest.testConverged	(	): check converged(). 
org.apache.commons.math4.fitting.leastsquares.EvaluationTest: The only features tested here are utility methods defined in LeastSquaresProblem.Evaluation that compute the chi-square and parameters standard-deviations.
org.apache.commons.math4.fitting.leastsquares.EvaluationTest.builder	(	StatisticalReferenceDataset	): Create a LeastSquaresBuilder from a StatisticalReferenceDataset.
org.apache.commons.math4.fitting.leastsquares.EvaluationTest.dummyJacobian	(	): Used for testing direct vs lazy evaluation. 
org.apache.commons.math4.fitting.leastsquares.EvaluationTest.dummyModel	(	): Used for testing direct vs lazy evaluation. 
org.apache.commons.math4.fitting.leastsquares.EvaluationTestValidation: This class demonstrates the main functionality of the LeastSquaresProblem.Evaluation, common to the optimizer implementations in package org.apache.commons.math4.fitting.leastsquares.  Not enabled by default, as the class name does not end with "Test".  Invoke by running  mvn test -Dtest=EvaluationTestValidation  or by running  mvn test -Dtest=EvaluationTestValidation -DargLine="-DmcRuns=1234 -server" 
org.apache.commons.math4.fitting.leastsquares.EvaluationTestValidation.getChi2N	(	LeastSquaresProblem	RealVector	): 
org.apache.commons.math4.fitting.leastsquares.EvaluationTestValidation.testParametersErrorMonteCarloObservations	(	): Using a Monte-Carlo procedure, this test checks the error estimations as provided by the square-root of the diagonal elements of the covariance matrix.  The test generates sets of observations, each sampled from a Gaussian distribution.  The optimization problem solved is defined in class StraightLineProblem.  The output (on stdout) will be a table summarizing the distribution of parameters generated by the Monte-Carlo process and by the direct estimation provided by the diagonal elements of the covariance matrix.
org.apache.commons.math4.fitting.leastsquares.EvaluationTestValidation.testParametersErrorMonteCarloParameters	(	): In this test, the set of observations is fixed. Using a Monte-Carlo procedure, it generates sets of parameters, and determine the parameter change that will result in the normalized chi-square becoming larger by one than the value from the best fit solution.  The optimization problem solved is defined in class StraightLineProblem.  The output (on stdout) will be a list of lines containing:  slope of the straight line, intercept of the straight line, chi-square of the solution defined by the above two values.  The output is separated into two blocks (with a blank line between them); the first block will contain all parameter sets for which chi2 < chi2_b + 1 and the second block, all sets for which chi2 >= chi2_b + 1 where chi2_b is the lowest chi-square (corresponding to the best solution).
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer: Gauss-Newton least-squares solver.  This class solve a least-square problem by solving the normal equations of the linearized problem at each iteration. Either LU decomposition or Cholesky decomposition can be used to solve the normal equations, or QR decomposition or SVD decomposition can be used to solve the linear system. LU decomposition is faster but QR decomposition is more robust for difficult problems, and SVD can compute a solution for rank-deficient problems. 
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.GaussNewtonOptimizer	(	): Creates a Gauss Newton optimizer.  The default for the algorithm is to solve the normal equations using QR decomposition.
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.GaussNewtonOptimizer	(	Decomposition	): Create a Gauss Newton optimizer that uses the given decomposition algorithm to solve the normal equations.
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.computeNormalMatrix	(	RealMatrix	RealVector	): Compute the normal matrix, JTJ.
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.getDecomposition	(	): Get the matrix decomposition algorithm used to solve the normal equations.
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.optimize	(	LeastSquaresProblem	): Solve the non-linear least squares problem. 
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.toString	(	):  
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizer.withDecomposition	(	Decomposition	): Configure the decomposition algorithm.
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizerWithCholeskyTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here/
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizerWithLUTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here/
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizerWithQRTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here/
org.apache.commons.math4.fitting.leastsquares.GaussNewtonOptimizerWithSVDTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here/
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter: An adapter that delegates to another implementation of LeastSquaresProblem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.LeastSquaresAdapter	(	LeastSquaresProblem	): Delegate the LeastSquaresProblem interface to the given implementation.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.evaluate	(	RealVector	): Evaluate the model at the specified point.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.getConvergenceChecker	(	): Gets the convergence checker. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.getEvaluationCounter	(	): Get a independent Incrementor that counts up to the maximum number of evaluations and then throws an exception. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.getIterationCounter	(	): Get a independent Incrementor that counts up to the maximum number of iterations and then throws an exception. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.getObservationSize	(	): Get the number of observations (rows in the Jacobian) in this problem. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.getParameterSize	(	): Get the number of parameters (columns in the Jacobian) in this problem. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresAdapter.getStart	(	): Gets the initial guess. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder: A mutable builder for LeastSquaresProblems.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.build	(	): Construct a LeastSquaresProblem from the data in this builder.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.checker	(	ConvergenceChecker	): Configure the convergence checker.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.checkerPair	(	ConvergenceChecker	): Configure the convergence checker.  This function is an overloaded version of checker().
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.lazyEvaluation	(	boolean	): Configure whether evaluation will be lazy or not.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.maxEvaluations	(	int	): Configure the max evaluations.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.maxIterations	(	int	): Configure the max iterations.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.model	(	MultivariateJacobianFunction	): Configure the model function.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.model	(	MultivariateVectorFunction	MultivariateMatrixFunction	): Configure the model function.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.parameterValidator	(	ParameterValidator	): Configure the validator of the model parameters.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.start	(	RealVector	): Configure the initial guess.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.start	(	double[]	): Configure the initial guess.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.target	(	RealVector	): Configure the observed data.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.target	(	double[]	): Configure the observed data.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder.weight	(	RealMatrix	): Configure the weight matrix.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory: A Factory for creating LeastSquaresProblems.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LeastSquaresFactory	(	): Prevent instantiation. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem: A private, "field" immutable (not "real" immutable) implementation of LeastSquaresProblem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.LazyUnweightedEvaluation: Container with the model lazy evaluation at a particular point.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.LazyUnweightedEvaluation.LazyUnweightedEvaluation	(	ValueAndJacobianFunction	RealVector	RealVector	): Create an Evaluation with no weights.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.LazyUnweightedEvaluation.getJacobian	(	): Get the weighted Jacobian matrix. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.LazyUnweightedEvaluation.getPoint	(	): Get the abscissa (independent variables) of this evaluation. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.LazyUnweightedEvaluation.getResiduals	(	): Get the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.LocalLeastSquaresProblem	(	MultivariateJacobianFunction	RealVector	RealVector	ConvergenceChecker	int	int	boolean	ParameterValidator	): Create a LeastSquaresProblem from the given data.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.UnweightedEvaluation: Container with the model evaluation at a particular point.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.UnweightedEvaluation.UnweightedEvaluation	(	RealVector	RealMatrix	RealVector	RealVector	): Create an Evaluation with no weights.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.UnweightedEvaluation.getJacobian	(	): Get the weighted Jacobian matrix. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.UnweightedEvaluation.getPoint	(	): Get the abscissa (independent variables) of this evaluation. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.UnweightedEvaluation.getResiduals	(	): Get the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.evaluate	(	RealVector	): Evaluate the model at the specified point. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.getObservationSize	(	): Get the number of observations (rows in the Jacobian) in this problem. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.getParameterSize	(	): Get the number of parameters (columns in the Jacobian) in this problem. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalLeastSquaresProblem.getStart	(	): Gets the initial guess. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalValueAndJacobianFunction: Combine a MultivariateVectorFunction with a MultivariateMatrixFunction to produce a MultivariateJacobianFunction.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalValueAndJacobianFunction.LocalValueAndJacobianFunction	(	MultivariateVectorFunction	MultivariateMatrixFunction	): 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalValueAndJacobianFunction.computeJacobian	(	double[]	): Compute the Jacobian. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalValueAndJacobianFunction.computeValue	(	double[]	): Compute the value. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.LocalValueAndJacobianFunction.value	(	RealVector	): Compute the function value and its Jacobian. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.countEvaluations	(	LeastSquaresProblem	Incrementor	): Count the evaluations of a particular problem. The counter will be incremented every time evaluate() is called on the returned problem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.create	(	MultivariateJacobianFunction	RealVector	RealVector	ConvergenceChecker	int	int	): Create a org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem from the given elements. There will be no weights applied (unit weights).
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.create	(	MultivariateJacobianFunction	RealVector	RealVector	RealMatrix	ConvergenceChecker	int	int	): Create a org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem from the given elements.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.create	(	MultivariateJacobianFunction	RealVector	RealVector	RealMatrix	ConvergenceChecker	int	int	boolean	ParameterValidator	): Create a org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem from the given elements. There will be no weights applied (unit weights).
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.create	(	MultivariateVectorFunction	MultivariateMatrixFunction	double[]	double[]	RealMatrix	ConvergenceChecker	int	int	): Create a org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem from the given elements.  This factory method is provided for continuity with previous interfaces. Newer applications should use create(), or create().
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.evaluationChecker	(	ConvergenceChecker	): View a convergence checker specified for a PointVectorValuePair as one specified for an Evaluation.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.model	(	MultivariateVectorFunction	MultivariateMatrixFunction	): Combine a MultivariateVectorFunction with a MultivariateMatrixFunction to produce a MultivariateJacobianFunction.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.squareRoot	(	RealMatrix	): Computes the square-root of the weight matrix.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.weightDiagonal	(	LeastSquaresProblem	RealVector	): Apply a diagonal weight matrix to the LeastSquaresProblem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresFactory.weightMatrix	(	LeastSquaresProblem	RealMatrix	): Apply a dense weight matrix to the LeastSquaresProblem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer: An algorithm that can be applied to a non-linear least squares problem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum: The optimum found by the optimizer. This object contains the point, its value, and some metadata.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum.getEvaluations	(	): Get the number of times the model was evaluated in order to produce this optimum.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum.getIterations	(	): Get the number of times the algorithm iterated in order to produce this optimum. In general least squares it is common to have one getEvaluations() evaluation per iterations.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.optimize	(	LeastSquaresProblem	): Solve the non-linear least squares problem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem: The data necessary to define a non-linear least squares problem.  Includes the observed values, computed model function, and convergence/divergence criteria. Weights are implicit in getResiduals() and getJacobian().   Instances are typically either created progressively using a LeastSquaresBuilder builder or created at once using a LeastSquaresFactory factory. 
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation: An evaluation of a LeastSquaresProblem at a particular point. This class also computes several quantities derived from the value and its Jacobian.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getChiSquare	(	): Get the sum of the squares of the residuals.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getCost	(	): Get the cost. It is the square-root of the getChiSquare() objective function.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getCovariances	(	double	): Get the covariance matrix of the optimized parameters.  Note that this operation involves the inversion of the JTJ matrix, where J is the Jacobian matrix. The threshold parameter is a way for the caller to specify that the result of this computation should be considered meaningless, and thus trigger an exception.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getJacobian	(	): Get the weighted Jacobian matrix.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getPoint	(	): Get the abscissa (independent variables) of this evaluation.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getRMS	(	): Get the normalized cost. It is the square-root of the sum of squared of the residuals, divided by the number of measurements.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getReducedChiSquare	(	int	): Get the reduced chi-square.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getResiduals	(	): Get the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.Evaluation.getSigma	(	double	): Get an estimate of the standard deviation of the parameters. The returned values are the square root of the diagonal coefficients of the covariance matrix, sd(a[i]) ~= sqrt(C[i][i]), where a[i] is the optimized value of the i-th parameter, and C is the covariance matrix.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.evaluate	(	RealVector	): Evaluate the model at the specified point.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.getObservationSize	(	): Get the number of observations (rows in the Jacobian) in this problem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.getParameterSize	(	): Get the number of parameters (columns in the Jacobian) in this problem.
org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem.getStart	(	): Gets the initial guess.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer: This class solves a least-squares problem using the Levenberg-Marquardt algorithm. This implementation should work even for over-determined systems (i.e. systems having more point than equations). Over-determined systems are solved by ignoring the point which have the smallest impact according to their jacobian column norm. Only the rank of the matrix and some loop bounds are changed to implement this. The resolution engine is a simple translation of the MINPACK lmder routine with minor changes. The changes include the over-determined resolution, the use of inherited convergence checker and the Q.R. decomposition which has been rewritten following the algorithm described in the P. Lascaux and R. Theodor book Analyse numérique matricielle appliquée à l'art de l'ingénieur, Masson 1986. The authors of the original fortran version are:  Argonne National Laboratory. MINPACK project. March 1980 Burton S. Garbow Kenneth E. Hillstrom Jorge J. More  The redistribution policy for MINPACK is available here, for convenience, it is reproduced below.   Minpack Copyright Notice (1999) University of Chicago. All rights reserved   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. The end-user documentation included with the redistribution, if any, must include the following acknowledgment: This product includes software developed by the University of Chicago, as Operator of Argonne National Laboratory. Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES.  
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.InternalData: Holds internal data. This structure was created so that all optimizer fields can be "final". Code should be further refactored in order to not pass around arguments that will modified in-place (cf. "work" arrays).
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.InternalData.InternalData	(	double[][]	int[]	int	double[]	double[]	double[]	): 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer	(	): Default constructor.  The default values for the algorithm settings are:  Initial step bound factor: 100 Cost relative tolerance: 1e-10 Parameters relative tolerance: 1e-10 Orthogonality tolerance: 1e-10 QR ranking threshold: SAFE_MIN 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer	(	double	double	double	double	double	): Construct an instance with all parameters specified.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.determineLMDirection	(	double[]	double[]	double[]	InternalData	int	double[]	double[]	): Solve a*x = b and d*x = 0 in the least squares sense. This implementation is a translation in Java of the MINPACK qrsolv routine. This method sets the lmDir and lmDiag attributes. The authors of the original fortran function are:  Argonne National Laboratory. MINPACK project. March 1980 Burton S. Garbow Kenneth E. Hillstrom Jorge J. More  Luc Maisonobe did the Java translation.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.determineLMParameter	(	double[]	double	double[]	InternalData	int	double[]	double[]	double[]	double[]	double	): Determines the Levenberg-Marquardt parameter. This implementation is a translation in Java of the MINPACK lmpar routine. This method sets the lmPar and lmDir attributes. The authors of the original fortran function are:  Argonne National Laboratory. MINPACK project. March 1980 Burton S. Garbow Kenneth E. Hillstrom Jorge J. More  Luc Maisonobe did the Java translation.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.getCostRelativeTolerance	(	): Gets the value of a tuning parameter.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.getInitialStepBoundFactor	(	): Gets the value of a tuning parameter.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.getOrthoTolerance	(	): Gets the value of a tuning parameter.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.getParameterRelativeTolerance	(	): Gets the value of a tuning parameter.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.getRankingThreshold	(	): Gets the value of a tuning parameter.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.optimize	(	LeastSquaresProblem	): Solve the non-linear least squares problem. 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.qTy	(	double[]	InternalData	): Compute the product Qt.y for some Q.R. decomposition.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.qrDecomposition	(	RealMatrix	int	): Decompose a matrix A as A.P = Q.R using Householder transforms. As suggested in the P. Lascaux and R. Theodor book Analyse numérique matricielle appliquée à l'art de l'ingénieur (Masson, 1986), instead of representing the Householder transforms with uk unit vectors such that:  Hk = I - 2uk.ukt  we use k non-unit vectors such that:  Hk = I - betakvk.vkt  where vk = ak - alphak ek. The betak coefficients are provided upon exit as recomputing them from the vk vectors would be costly. This decomposition handles rank deficient cases since the tranformations are performed in non-increasing columns norms order thanks to columns pivoting. The diagonal elements of the R matrix are therefore also in non-increasing absolute values order.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.withCostRelativeTolerance	(	double	): 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.withInitialStepBoundFactor	(	double	): 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.withOrthoTolerance	(	double	): Modifies the given parameter.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.withParameterRelativeTolerance	(	double	): 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer.withRankingThreshold	(	double	): 
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizerTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here.
org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizerTest.testBevington	(	): Non-linear test case: fitting of decay curve (from Chapter 8 of Bevington's textbook, "Data reduction and analysis for the physical sciences"). XXX The expected ("reference") values may not be accurate and the tolerance too relaxed for this test to be currently really useful (the issue is under investigation).
org.apache.commons.math4.fitting.leastsquares.MinpackTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here, for convenience, it is reproduced below.   Minpack Copyright Notice (1999) University of Chicago. All rights reserved   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. The end-user documentation included with the redistribution, if any, must include the following acknowledgment: This product includes software developed by the University of Chicago, as Operator of Argonne National Laboratory. Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES.  
org.apache.commons.math4.fitting.leastsquares.MultivariateJacobianFunction: A interface for functions that compute a vector of values and can compute their derivatives (Jacobian).
org.apache.commons.math4.fitting.leastsquares.MultivariateJacobianFunction.value	(	RealVector	): Compute the function value and its Jacobian.
org.apache.commons.math4.fitting.leastsquares.OptimumImpl: A pedantic implementation of Optimum.
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.OptimumImpl	(	Evaluation	int	int	): Construct an optimum from an evaluation and the values of the counters.
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getChiSquare	(	): Get the sum of the squares of the residuals. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getCost	(	): Get the cost. It is the square-root of the getChiSquare() objective function. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getCovariances	(	double	): Get the covariance matrix of the optimized parameters.  Note that this operation involves the inversion of the JTJ matrix, where J is the Jacobian matrix. The threshold parameter is a way for the caller to specify that the result of this computation should be considered meaningless, and thus trigger an exception. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getEvaluations	(	): Get the number of times the model was evaluated in order to produce this optimum. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getIterations	(	): Get the number of times the algorithm iterated in order to produce this optimum. In general least squares it is common to have one getEvaluations() evaluation per iterations. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getJacobian	(	): Get the weighted Jacobian matrix. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getPoint	(	): Get the abscissa (independent variables) of this evaluation. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getRMS	(	): Get the normalized cost. It is the square-root of the sum of squared of the residuals, divided by the number of measurements. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getReducedChiSquare	(	int	): Get the reduced chi-square. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getResiduals	(	): Get the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix. 
org.apache.commons.math4.fitting.leastsquares.OptimumImpl.getSigma	(	double	): Get an estimate of the standard deviation of the parameters. The returned values are the square root of the diagonal coefficients of the covariance matrix, sd(a[i]) ~= sqrt(C[i][i]), where a[i] is the optimized value of the i-th parameter, and C is the covariance matrix. 
org.apache.commons.math4.fitting.leastsquares.ParameterValidator: Interface for validating a set of model parameters.
org.apache.commons.math4.fitting.leastsquares.ParameterValidator.validate	(	RealVector	): Validates the set of parameters.
org.apache.commons.math4.fitting.leastsquares.RandomCirclePointGenerator: Factory for generating a cloud of points that approximate a circle.
org.apache.commons.math4.fitting.leastsquares.RandomCirclePointGenerator.RandomCirclePointGenerator	(	double	double	double	double	double	long	): 
org.apache.commons.math4.fitting.leastsquares.RandomCirclePointGenerator.create	(	): Create one point.
org.apache.commons.math4.fitting.leastsquares.RandomCirclePointGenerator.generate	(	int	): Point generator.
org.apache.commons.math4.fitting.leastsquares.RandomStraightLinePointGenerator: Factory for generating a cloud of points that approximate a straight line.
org.apache.commons.math4.fitting.leastsquares.RandomStraightLinePointGenerator.RandomStraightLinePointGenerator	(	double	double	double	double	double	long	): The generator will create a cloud of points whose x-coordinates will be randomly sampled between xLo and xHi, and the corresponding y-coordinates will be computed as  y = a x + b + N(0, error)  where N(mean, sigma) is a Gaussian distribution with the given mean and standard deviation.
org.apache.commons.math4.fitting.leastsquares.RandomStraightLinePointGenerator.create	(	): Create one point.
org.apache.commons.math4.fitting.leastsquares.RandomStraightLinePointGenerator.generate	(	int	): Point generator.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset: This class gives access to the statistical reference datasets provided by the NIST (available here). Instances of this class can be created by invocation of the StatisticalReferenceDatasetFactory.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.StatisticalReferenceDataset	(	BufferedReader	): Creates a new instance of this class from the specified data file. The file must follow the StRD format.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.findLineNumbers	(	String	Iterable	):  Parses the specified text lines, and extracts the indices of the first and last lines of the data defined by the specified key. This key must be one of   "Starting Values", "Certified Values", "Data".   In the NIST data files, the line indices are separated by the keywords "lines" and "to". 
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getData	(	): Returns a copy of the data arrays. The data is laid out as follows  data[0][i] = x[i], data[1][i] = y[i],
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getLeastSquaresProblem	(	): Returns the least-squares problem corresponding to fitting the model to the specified data.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getModelDerivatives	(	double	double[]	): Returns the values of the partial derivatives of the model with respect to the parameters.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getModelValue	(	double	double[]	): Returns the value of the model for the specified values of the predictor variable and the parameters.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getName	(	): Returns the name of this dataset.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getNumObservations	(	): Returns the total number of observations (data points).
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getNumParameters	(	): Returns the total number of parameters.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getNumStartingPoints	(	): Returns the total number of starting points (initial guesses for the optimization process).
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getParameter	(	int	): Returns the certified value of the i-th parameter.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getParameterStandardDeviation	(	int	): Returns the certified value of the standard deviation of the i-th parameter.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getParameters	(	): Returns the certified values of the paramters.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getParametersStandardDeviations	(	): Reurns the certified values of the standard deviations of the parameters.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getResidualSumOfSquares	(	): Returns the certified value of the residual sum of squares.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getStartingPoint	(	int	): Returns the i-th set of initial values of the parameters.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getX	(	int	): Returns the x-value of the i-th data point.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDataset.getY	(	int	): Returns the y-value of the i-th data point.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDatasetFactory: A factory to create instances of StatisticalReferenceDataset from available resources.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDatasetFactory.createAll	(	): Returns an array with all available reference datasets.
org.apache.commons.math4.fitting.leastsquares.StatisticalReferenceDatasetFactory.createBufferedReaderFromResource	(	String	): Creates a new buffered reader from the specified resource name.
org.apache.commons.math4.fitting.leastsquares.StraightLineProblem: Class that models a straight line defined as y = a x + b. The parameters of problem are:  a b  The model functions are:  for each pair (a, b), the y-coordinate of the line. 
org.apache.commons.math4.fitting.leastsquares.StraightLineProblem.Model: Linear function.
org.apache.commons.math4.fitting.leastsquares.StraightLineProblem.StraightLineProblem	(	double	): 
org.apache.commons.math4.fitting.leastsquares.StraightLineProblem.solve	(	): Directly solve the linear problem, using the SimpleRegression class.
org.apache.commons.math4.fitting.leastsquares.StraightLineProblem.x	(	): 
org.apache.commons.math4.fitting.leastsquares.StraightLineProblem.y	(	): 
org.apache.commons.math4.fitting.leastsquares.ValueAndJacobianFunction: A interface for functions that compute a vector of values and can compute their derivatives (Jacobian).
org.apache.commons.math4.fitting.leastsquares.ValueAndJacobianFunction.computeJacobian	(	double[]	): Compute the Jacobian.
org.apache.commons.math4.fitting.leastsquares.ValueAndJacobianFunction.computeValue	(	double[]	): Compute the value.
org.apache.commons.math4.fraction.AbstractFormat: Common part shared by both FractionFormat and BigFractionFormat.
org.apache.commons.math4.fraction.AbstractFormat.AbstractFormat	(	): Create an improper formatting instance with the default number format for the numerator and denominator.
org.apache.commons.math4.fraction.AbstractFormat.AbstractFormat	(	NumberFormat	): Create an improper formatting instance with a custom number format for both the numerator and denominator.
org.apache.commons.math4.fraction.AbstractFormat.AbstractFormat	(	NumberFormat	NumberFormat	): Create an improper formatting instance with a custom number format for the numerator and a custom number format for the denominator.
org.apache.commons.math4.fraction.AbstractFormat.format	(	double	StringBuffer	FieldPosition	): Formats a double value as a fraction and appends the result to a StringBuffer.
org.apache.commons.math4.fraction.AbstractFormat.format	(	long	StringBuffer	FieldPosition	): Formats a long value as a fraction and appends the result to a StringBuffer.
org.apache.commons.math4.fraction.AbstractFormat.getDefaultNumberFormat	(	): Create a default number format. The default number format is based on getNumberInstance(). The only customization is the maximum number of BigFraction digits, which is set to 0.
org.apache.commons.math4.fraction.AbstractFormat.getDefaultNumberFormat	(	Locale	): Create a default number format. The default number format is based on getNumberInstance(). The only customization is the maximum number of BigFraction digits, which is set to 0.
org.apache.commons.math4.fraction.AbstractFormat.getDenominatorFormat	(	): Access the denominator format.
org.apache.commons.math4.fraction.AbstractFormat.getNumeratorFormat	(	): Access the numerator format.
org.apache.commons.math4.fraction.AbstractFormat.parseAndIgnoreWhitespace	(	String	ParsePosition	): Parses source until a non-whitespace character is found.
org.apache.commons.math4.fraction.AbstractFormat.parseNextCharacter	(	String	ParsePosition	): Parses source until a non-whitespace character is found.
org.apache.commons.math4.fraction.AbstractFormat.setDenominatorFormat	(	NumberFormat	): Modify the denominator format.
org.apache.commons.math4.fraction.AbstractFormat.setNumeratorFormat	(	NumberFormat	): Modify the numerator format.
org.apache.commons.math4.fraction.BigFraction: Representation of a rational number without any overflow. This class is immutable.
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	BigInteger	):  Create a BigFraction equivalent to the passed BigInteger, ie "num / 1". 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	BigInteger	BigInteger	): Create a BigFraction given the numerator and denominator as BigInteger. The BigFraction is reduced to lowest terms.
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	double	): Create a fraction given the double value.  This constructor behaves differently from BigFraction(). It converts the double value exactly, considering its internal bits representation. This works for all values except NaN and infinities and does not requires any loop or convergence threshold.   Since this conversion is exact and since double numbers are sometimes approximated, the fraction created may seem strange in some cases. For example, calling new BigFraction(1.0 / 3.0) does not create the fraction 1/3, but the fraction 6004799503160661 / 18014398509481984 because the double number passed to the constructor is not exactly 1/3 (this number cannot be stored exactly in IEEE754). 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	double	double	int	): Create a fraction given the double value and maximum error allowed.  References:   Continued Fraction equations (11) and (22)-(26) 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	double	double	int	int	): Create a fraction given the double value and either the maximum error allowed or the maximum number of denominator digits.  NOTE: This constructor is called with EITHER - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator has no effect). OR - a valid maxDenominator value and the epsilon value set to zero (that way epsilon only has effect if there is an exact match before the maxDenominator value is reached).   It has been done this way so that the same code can be (re)used for both scenarios. However this could be confusing to users if it were part of the public API and this constructor should therefore remain PRIVATE.  See JIRA issue ticket MATH-181 for more details: https://issues.apache.org/jira/browse/MATH-181
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	double	int	): Create a fraction given the double value and maximum denominator.  References:   Continued Fraction equations (11) and (22)-(26) 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	int	):  Create a BigFraction equivalent to the passed int, ie "num / 1". 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	int	int	):  Create a BigFraction given the numerator and denominator as simple int. The BigFraction is reduced to lowest terms. 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	long	):  Create a BigFraction equivalent to the passed long, ie "num / 1". 
org.apache.commons.math4.fraction.BigFraction.BigFraction	(	long	long	):  Create a BigFraction given the numerator and denominator as simple long. The BigFraction is reduced to lowest terms. 
org.apache.commons.math4.fraction.BigFraction.abs	(	):  Returns the absolute value of this BigFraction. 
org.apache.commons.math4.fraction.BigFraction.add	(	BigFraction	):  Adds the value of this fraction to another, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.add	(	BigInteger	):  Adds the value of this fraction to the passed BigInteger, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.add	(	int	):  Adds the value of this fraction to the passed integer, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.add	(	long	):  Adds the value of this fraction to the passed long, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.bigDecimalValue	(	):  Gets the fraction as a BigDecimal. This calculates the fraction as the numerator divided by denominator. 
org.apache.commons.math4.fraction.BigFraction.bigDecimalValue	(	int	):  Gets the fraction as a BigDecimal following the passed rounding mode. This calculates the fraction as the numerator divided by denominator. 
org.apache.commons.math4.fraction.BigFraction.bigDecimalValue	(	int	int	):  Gets the fraction as a BigDecimal following the passed scale and rounding mode. This calculates the fraction as the numerator divided by denominator. 
org.apache.commons.math4.fraction.BigFraction.compareTo	(	BigFraction	):  Compares this object to another based on size. 
org.apache.commons.math4.fraction.BigFraction.divide	(	BigFraction	):  Divide the value of this fraction by another, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.divide	(	BigInteger	):  Divide the value of this fraction by the passed BigInteger, ie this * 1 / bg, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.divide	(	int	):  Divide the value of this fraction by the passed int, ie this * 1 / i, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.divide	(	long	):  Divide the value of this fraction by the passed long, ie this * 1 / l, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.doubleValue	(	):  Gets the fraction as a double. This calculates the fraction as the numerator divided by denominator. 
org.apache.commons.math4.fraction.BigFraction.equals	(	Object	):  Test for the equality of two fractions. If the lowest term numerator and denominators are the same for both fractions, the two fractions are considered to be equal. 
org.apache.commons.math4.fraction.BigFraction.floatValue	(	):  Gets the fraction as a float. This calculates the fraction as the numerator divided by denominator. 
org.apache.commons.math4.fraction.BigFraction.getDenominator	(	):  Access the denominator as a BigInteger. 
org.apache.commons.math4.fraction.BigFraction.getDenominatorAsInt	(	):  Access the denominator as a int. 
org.apache.commons.math4.fraction.BigFraction.getDenominatorAsLong	(	):  Access the denominator as a long. 
org.apache.commons.math4.fraction.BigFraction.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.fraction.BigFraction.getNumerator	(	):  Access the numerator as a BigInteger. 
org.apache.commons.math4.fraction.BigFraction.getNumeratorAsInt	(	):  Access the numerator as a int. 
org.apache.commons.math4.fraction.BigFraction.getNumeratorAsLong	(	):  Access the numerator as a long. 
org.apache.commons.math4.fraction.BigFraction.getReducedFraction	(	int	int	):  Creates a BigFraction instance with the 2 parts of a fraction Y/Z.   Any negative signs are resolved to be on the numerator. 
org.apache.commons.math4.fraction.BigFraction.hashCode	(	):  Gets a hashCode for the fraction. 
org.apache.commons.math4.fraction.BigFraction.intValue	(	):  Gets the fraction as an int. This returns the whole number part of the fraction. 
org.apache.commons.math4.fraction.BigFraction.longValue	(	):  Gets the fraction as a long. This returns the whole number part of the fraction. 
org.apache.commons.math4.fraction.BigFraction.multiply	(	BigFraction	):  Multiplies the value of this fraction by another, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.multiply	(	BigInteger	):  Multiplies the value of this fraction by the passed BigInteger, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.multiply	(	int	):  Multiply the value of this fraction by the passed int, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.multiply	(	long	):  Multiply the value of this fraction by the passed long, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.negate	(	):  Return the additive inverse of this fraction, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.percentageValue	(	):  Gets the fraction percentage as a double. This calculates the fraction as the numerator divided by denominator multiplied by 100. 
org.apache.commons.math4.fraction.BigFraction.pow	(	BigInteger	):  Returns a BigFraction whose value is (thisexponent), returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.pow	(	double	):  Returns a double whose value is (thisexponent), returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.pow	(	int	):  Returns a BigFraction whose value is (thisexponent), returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.pow	(	long	):  Returns a BigFraction whose value is (thisexponent), returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.reciprocal	(	):  Return the multiplicative inverse of this fraction. 
org.apache.commons.math4.fraction.BigFraction.reduce	(	):  Reduce this BigFraction to its lowest terms. 
org.apache.commons.math4.fraction.BigFraction.subtract	(	BigFraction	):  Subtracts the value of another fraction from the value of this one, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.subtract	(	BigInteger	):  Subtracts the value of an BigInteger from the value of this BigFraction, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.subtract	(	int	):  Subtracts the value of an integer from the value of this BigFraction, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.subtract	(	long	):  Subtracts the value of a long from the value of this BigFraction, returning the result in reduced form. 
org.apache.commons.math4.fraction.BigFraction.toString	(	):  Returns the String representing this fraction, ie "num / dem" or just "num" if the denominator is one. 
org.apache.commons.math4.fraction.BigFractionField: Representation of the fractional numbers without any overflow field.  This class is a singleton. 
org.apache.commons.math4.fraction.BigFractionField.BigFractionField	(	): Private constructor for the singleton.
org.apache.commons.math4.fraction.BigFractionField.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.fraction.BigFractionField.getInstance	(	): Get the unique instance.
org.apache.commons.math4.fraction.BigFractionField.getOne	(	): Get the multiplicative identity of the field.  The multiplicative identity is the element e1 of the field such that for all elements a of the field, the equalities a × e1 = e1 × a = a hold.  
org.apache.commons.math4.fraction.BigFractionField.getRuntimeClass	(	): Returns the runtime class of the FieldElement. 
org.apache.commons.math4.fraction.BigFractionField.getZero	(	): Get the additive identity of the field.  The additive identity is the element e0 of the field such that for all elements a of the field, the equalities a + e0 = e0 + a = a hold.  
org.apache.commons.math4.fraction.BigFractionField.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.fraction.BigFractionFormat: Formats a BigFraction number in proper format or improper format.  The number format for each of the whole number, numerator and, denominator can be configured. 
org.apache.commons.math4.fraction.BigFractionFormat.BigFractionFormat	(	): Create an improper formatting instance with the default number format for the numerator and denominator.
org.apache.commons.math4.fraction.BigFractionFormat.BigFractionFormat	(	NumberFormat	): Create an improper formatting instance with a custom number format for both the numerator and denominator.
org.apache.commons.math4.fraction.BigFractionFormat.BigFractionFormat	(	NumberFormat	NumberFormat	): Create an improper formatting instance with a custom number format for the numerator and a custom number format for the denominator.
org.apache.commons.math4.fraction.BigFractionFormat.format	(	BigFraction	StringBuffer	FieldPosition	): Formats a BigFraction object to produce a string. The BigFraction is output in improper format.
org.apache.commons.math4.fraction.BigFractionFormat.format	(	Object	StringBuffer	FieldPosition	): Formats an object and appends the result to a StringBuffer. obj must be either a BigFraction object or a BigInteger object or a Number object. Any other type of object will result in an IllegalArgumentException being thrown.
org.apache.commons.math4.fraction.BigFractionFormat.formatBigFraction	(	BigFraction	): This static method calls formatBigFraction() on a default instance of BigFractionFormat.
org.apache.commons.math4.fraction.BigFractionFormat.getAvailableLocales	(	): Get the set of locales for which complex formats are available. This is the same set as the NumberFormat set.
org.apache.commons.math4.fraction.BigFractionFormat.getImproperInstance	(	): Returns the default complex format for the current locale.
org.apache.commons.math4.fraction.BigFractionFormat.getImproperInstance	(	Locale	): Returns the default complex format for the given locale.
org.apache.commons.math4.fraction.BigFractionFormat.getProperInstance	(	): Returns the default complex format for the current locale.
org.apache.commons.math4.fraction.BigFractionFormat.getProperInstance	(	Locale	): Returns the default complex format for the given locale.
org.apache.commons.math4.fraction.BigFractionFormat.parse	(	String	): Parses a string to produce a BigFraction object.
org.apache.commons.math4.fraction.BigFractionFormat.parse	(	String	ParsePosition	): Parses a string to produce a BigFraction object. This method expects the string to be formatted as an improper BigFraction.
org.apache.commons.math4.fraction.BigFractionFormat.parseNextBigInteger	(	String	ParsePosition	): Parses a string to produce a BigInteger.
org.apache.commons.math4.fraction.Fraction: Representation of a rational number. implements Serializable since 2.0
org.apache.commons.math4.fraction.Fraction.Fraction	(	double	): Create a fraction given the double value.
org.apache.commons.math4.fraction.Fraction.Fraction	(	double	double	int	): Create a fraction given the double value and maximum error allowed.  References:   Continued Fraction equations (11) and (22)-(26) 
org.apache.commons.math4.fraction.Fraction.Fraction	(	double	double	int	int	): Create a fraction given the double value and either the maximum error allowed or the maximum number of denominator digits.  NOTE: This constructor is called with EITHER - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator has no effect). OR - a valid maxDenominator value and the epsilon value set to zero (that way epsilon only has effect if there is an exact match before the maxDenominator value is reached).  It has been done this way so that the same code can be (re)used for both scenarios. However this could be confusing to users if it were part of the public API and this constructor should therefore remain PRIVATE.  See JIRA issue ticket MATH-181 for more details: https://issues.apache.org/jira/browse/MATH-181
org.apache.commons.math4.fraction.Fraction.Fraction	(	double	int	): Create a fraction given the double value and maximum denominator.  References:   Continued Fraction equations (11) and (22)-(26) 
org.apache.commons.math4.fraction.Fraction.Fraction	(	int	): Create a fraction from an int. The fraction is num / 1.
org.apache.commons.math4.fraction.Fraction.Fraction	(	int	int	): Create a fraction given the numerator and denominator. The fraction is reduced to lowest terms.
org.apache.commons.math4.fraction.Fraction.abs	(	): Returns the absolute value of this fraction.
org.apache.commons.math4.fraction.Fraction.add	(	Fraction	): Adds the value of this fraction to another, returning the result in reduced form. The algorithm follows Knuth, 4.5.1.
org.apache.commons.math4.fraction.Fraction.add	(	int	): Add an integer to the fraction.
org.apache.commons.math4.fraction.Fraction.addSub	(	Fraction	boolean	): Implement add and subtract using algorithm described in Knuth 4.5.1.
org.apache.commons.math4.fraction.Fraction.compareTo	(	Fraction	): Compares this object to another based on size.
org.apache.commons.math4.fraction.Fraction.divide	(	Fraction	): Divide the value of this fraction by another.
org.apache.commons.math4.fraction.Fraction.divide	(	int	): Divide the fraction by an integer.
org.apache.commons.math4.fraction.Fraction.doubleValue	(	): Gets the fraction as a double. This calculates the fraction as the numerator divided by denominator.
org.apache.commons.math4.fraction.Fraction.equals	(	Object	): Test for the equality of two fractions. If the lowest term numerator and denominators are the same for both fractions, the two fractions are considered to be equal.
org.apache.commons.math4.fraction.Fraction.floatValue	(	): Gets the fraction as a float. This calculates the fraction as the numerator divided by denominator.
org.apache.commons.math4.fraction.Fraction.getDenominator	(	): Access the denominator.
org.apache.commons.math4.fraction.Fraction.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.fraction.Fraction.getNumerator	(	): Access the numerator.
org.apache.commons.math4.fraction.Fraction.getReducedFraction	(	int	int	): Creates a Fraction instance with the 2 parts of a fraction Y/Z. Any negative signs are resolved to be on the numerator.
org.apache.commons.math4.fraction.Fraction.hashCode	(	): Gets a hashCode for the fraction.
org.apache.commons.math4.fraction.Fraction.intValue	(	): Gets the fraction as an int. This returns the whole number part of the fraction.
org.apache.commons.math4.fraction.Fraction.longValue	(	): Gets the fraction as a long. This returns the whole number part of the fraction.
org.apache.commons.math4.fraction.Fraction.multiply	(	Fraction	): Multiplies the value of this fraction by another, returning the result in reduced form.
org.apache.commons.math4.fraction.Fraction.multiply	(	int	): Multiply the fraction by an integer.
org.apache.commons.math4.fraction.Fraction.negate	(	): Return the additive inverse of this fraction.
org.apache.commons.math4.fraction.Fraction.percentageValue	(	):  Gets the fraction percentage as a double. This calculates the fraction as the numerator divided by denominator multiplied by 100. 
org.apache.commons.math4.fraction.Fraction.reciprocal	(	): Return the multiplicative inverse of this fraction.
org.apache.commons.math4.fraction.Fraction.subtract	(	Fraction	): Subtracts the value of another fraction from the value of this one, returning the result in reduced form.
org.apache.commons.math4.fraction.Fraction.subtract	(	int	): Subtract an integer from the fraction.
org.apache.commons.math4.fraction.Fraction.toString	(	):  Returns the String representing this fraction, ie "num / dem" or just "num" if the denominator is one. 
org.apache.commons.math4.fraction.FractionConversionException: Error thrown when a double value cannot be converted to a fraction in the allowed number of iterations.
org.apache.commons.math4.fraction.FractionConversionException.FractionConversionException	(	double	int	): Constructs an exception with specified formatted detail message. Message formatting is delegated to java.text.MessageFormat.
org.apache.commons.math4.fraction.FractionConversionException.FractionConversionException	(	double	long	long	): Constructs an exception with specified formatted detail message. Message formatting is delegated to java.text.MessageFormat.
org.apache.commons.math4.fraction.FractionField: Representation of the fractional numbers field.  This class is a singleton. 
org.apache.commons.math4.fraction.FractionField.FractionField	(	): Private constructor for the singleton.
org.apache.commons.math4.fraction.FractionField.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.fraction.FractionField.getInstance	(	): Get the unique instance.
org.apache.commons.math4.fraction.FractionField.getOne	(	): Get the multiplicative identity of the field.  The multiplicative identity is the element e1 of the field such that for all elements a of the field, the equalities a × e1 = e1 × a = a hold.  
org.apache.commons.math4.fraction.FractionField.getRuntimeClass	(	): Returns the runtime class of the FieldElement. 
org.apache.commons.math4.fraction.FractionField.getZero	(	): Get the additive identity of the field.  The additive identity is the element e0 of the field such that for all elements a of the field, the equalities a + e0 = e0 + a = a hold.  
org.apache.commons.math4.fraction.FractionField.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.fraction.FractionFormat: Formats a Fraction number in proper format or improper format. The number format for each of the whole number, numerator and, denominator can be configured.
org.apache.commons.math4.fraction.FractionFormat.FractionFormat	(	): Create an improper formatting instance with the default number format for the numerator and denominator.
org.apache.commons.math4.fraction.FractionFormat.FractionFormat	(	NumberFormat	): Create an improper formatting instance with a custom number format for both the numerator and denominator.
org.apache.commons.math4.fraction.FractionFormat.FractionFormat	(	NumberFormat	NumberFormat	): Create an improper formatting instance with a custom number format for the numerator and a custom number format for the denominator.
org.apache.commons.math4.fraction.FractionFormat.format	(	Fraction	StringBuffer	FieldPosition	): Formats a Fraction object to produce a string. The fraction is output in improper format.
org.apache.commons.math4.fraction.FractionFormat.format	(	Object	StringBuffer	FieldPosition	): Formats an object and appends the result to a StringBuffer. obj must be either a Fraction object or a Number object. Any other type of object will result in an IllegalArgumentException being thrown.
org.apache.commons.math4.fraction.FractionFormat.formatFraction	(	Fraction	): This static method calls formatFraction() on a default instance of FractionFormat.
org.apache.commons.math4.fraction.FractionFormat.getAvailableLocales	(	): Get the set of locales for which complex formats are available. This is the same set as the NumberFormat set.
org.apache.commons.math4.fraction.FractionFormat.getDefaultNumberFormat	(	): Create a default number format. The default number format is based on getNumberInstance() with the only customizing is the maximum number of fraction digits, which is set to 0.
org.apache.commons.math4.fraction.FractionFormat.getImproperInstance	(	): Returns the default complex format for the current locale.
org.apache.commons.math4.fraction.FractionFormat.getImproperInstance	(	Locale	): Returns the default complex format for the given locale.
org.apache.commons.math4.fraction.FractionFormat.getProperInstance	(	): Returns the default complex format for the current locale.
org.apache.commons.math4.fraction.FractionFormat.getProperInstance	(	Locale	): Returns the default complex format for the given locale.
org.apache.commons.math4.fraction.FractionFormat.parse	(	String	): Parses a string to produce a Fraction object.
org.apache.commons.math4.fraction.FractionFormat.parse	(	String	ParsePosition	): Parses a string to produce a Fraction object. This method expects the string to be formatted as an improper fraction.
org.apache.commons.math4.fraction.ProperBigFractionFormat: Formats a BigFraction number in proper format. The number format for each of the whole number, numerator and, denominator can be configured.  Minus signs are only allowed in the whole number part - i.e., "-3 1/2" is legitimate and denotes -7/2, but "-3 -1/2" is invalid and will result in a ParseException.
org.apache.commons.math4.fraction.ProperBigFractionFormat.ProperBigFractionFormat	(	): Create a proper formatting instance with the default number format for the whole, numerator, and denominator.
org.apache.commons.math4.fraction.ProperBigFractionFormat.ProperBigFractionFormat	(	NumberFormat	): Create a proper formatting instance with a custom number format for the whole, numerator, and denominator.
org.apache.commons.math4.fraction.ProperBigFractionFormat.ProperBigFractionFormat	(	NumberFormat	NumberFormat	NumberFormat	): Create a proper formatting instance with a custom number format for each of the whole, numerator, and denominator.
org.apache.commons.math4.fraction.ProperBigFractionFormat.format	(	BigFraction	StringBuffer	FieldPosition	): Formats a BigFraction object to produce a string. The BigFraction is output in proper format.
org.apache.commons.math4.fraction.ProperBigFractionFormat.getWholeFormat	(	): Access the whole format.
org.apache.commons.math4.fraction.ProperBigFractionFormat.parse	(	String	ParsePosition	): Parses a string to produce a BigFraction object. This method expects the string to be formatted as a proper BigFraction.  Minus signs are only allowed in the whole number part - i.e., "-3 1/2" is legitimate and denotes -7/2, but "-3 -1/2" is invalid and will result in a ParseException.
org.apache.commons.math4.fraction.ProperBigFractionFormat.setWholeFormat	(	NumberFormat	): Modify the whole format.
org.apache.commons.math4.fraction.ProperFractionFormat: Formats a Fraction number in proper format. The number format for each of the whole number, numerator and, denominator can be configured.  Minus signs are only allowed in the whole number part - i.e., "-3 1/2" is legitimate and denotes -7/2, but "-3 -1/2" is invalid and will result in a ParseException.
org.apache.commons.math4.fraction.ProperFractionFormat.ProperFractionFormat	(	): Create a proper formatting instance with the default number format for the whole, numerator, and denominator.
org.apache.commons.math4.fraction.ProperFractionFormat.ProperFractionFormat	(	NumberFormat	): Create a proper formatting instance with a custom number format for the whole, numerator, and denominator.
org.apache.commons.math4.fraction.ProperFractionFormat.ProperFractionFormat	(	NumberFormat	NumberFormat	NumberFormat	): Create a proper formatting instance with a custom number format for each of the whole, numerator, and denominator.
org.apache.commons.math4.fraction.ProperFractionFormat.format	(	Fraction	StringBuffer	FieldPosition	): Formats a Fraction object to produce a string. The fraction is output in proper format.
org.apache.commons.math4.fraction.ProperFractionFormat.getWholeFormat	(	): Access the whole format.
org.apache.commons.math4.fraction.ProperFractionFormat.parse	(	String	ParsePosition	): Parses a string to produce a Fraction object. This method expects the string to be formatted as a proper fraction.  Minus signs are only allowed in the whole number part - i.e., "-3 1/2" is legitimate and denotes -7/2, but "-3 -1/2" is invalid and will result in a ParseException.
org.apache.commons.math4.fraction.ProperFractionFormat.setWholeFormat	(	NumberFormat	): Modify the whole format.
org.apache.commons.math4.genetics.AbstractListChromosome: Chromosome represented by an immutable list of a fixed length.
org.apache.commons.math4.genetics.AbstractListChromosome.AbstractListChromosome	(	List	): Constructor, copying the input representation.
org.apache.commons.math4.genetics.AbstractListChromosome.AbstractListChromosome	(	List	boolean	): Constructor.
org.apache.commons.math4.genetics.AbstractListChromosome.AbstractListChromosome	(	T[]	): Constructor, copying the input representation.
org.apache.commons.math4.genetics.AbstractListChromosome.checkValidity	(	List	): Asserts that representation can represent a valid chromosome.
org.apache.commons.math4.genetics.AbstractListChromosome.getLength	(	): Returns the length of the chromosome.
org.apache.commons.math4.genetics.AbstractListChromosome.getRepresentation	(	): Returns the (immutable) inner representation of the chromosome.
org.apache.commons.math4.genetics.AbstractListChromosome.newFixedLengthChromosome	(	List	): Creates a new instance of the same class as this is, with a given arrayRepresentation. This is needed in crossover and mutation operators, where we need a new instance of the same class, but with different array representation.  Usually, this method just calls a constructor of the class.
org.apache.commons.math4.genetics.AbstractListChromosome.toString	(	):  
org.apache.commons.math4.genetics.BinaryChromosome: Chromosome represented by a vector of 0s and 1s.
org.apache.commons.math4.genetics.BinaryChromosome.BinaryChromosome	(	Integer[]	): Constructor.
org.apache.commons.math4.genetics.BinaryChromosome.BinaryChromosome	(	List	): Constructor.
org.apache.commons.math4.genetics.BinaryChromosome.checkValidity	(	List	): Asserts that representation can represent a valid chromosome.
org.apache.commons.math4.genetics.BinaryChromosome.isSame	(	Chromosome	): Returns true iff another has the same representation and therefore the same fitness. By default, it returns false -- override it in your implementation if you need it. 
org.apache.commons.math4.genetics.BinaryChromosome.randomBinaryRepresentation	(	int	): Returns a representation of a random binary array of length length.
org.apache.commons.math4.genetics.BinaryMutation: Mutation for BinaryChromosomes. Randomly changes one gene.
org.apache.commons.math4.genetics.BinaryMutation.mutate	(	Chromosome	): Mutate the given chromosome. Randomly changes one gene.
org.apache.commons.math4.genetics.Chromosome: Individual in a population. Chromosomes are compared based on their fitness.  The chromosomes are IMMUTABLE, and so their fitness is also immutable and therefore it can be cached.
org.apache.commons.math4.genetics.Chromosome.compareTo	(	Chromosome	): Compares two chromosomes based on their fitness. The bigger the fitness, the better the chromosome.
org.apache.commons.math4.genetics.Chromosome.findSameChromosome	(	Population	): Searches the population for another chromosome with the same representation. If such chromosome is found, it is returned, if no such chromosome exists, returns null.
org.apache.commons.math4.genetics.Chromosome.getFitness	(	): Access the fitness of this chromosome. The bigger the fitness, the better the chromosome.  Computation of fitness is usually very time-consuming task, therefore the fitness is cached.
org.apache.commons.math4.genetics.Chromosome.isSame	(	Chromosome	): Returns true iff another has the same representation and therefore the same fitness. By default, it returns false -- override it in your implementation if you need it.
org.apache.commons.math4.genetics.Chromosome.searchForFitnessUpdate	(	Population	): Searches the population for a chromosome representing the same solution, and if it finds one, updates the fitness to its value.
org.apache.commons.math4.genetics.ChromosomePair: A pair of Chromosome objects.
org.apache.commons.math4.genetics.ChromosomePair.ChromosomePair	(	Chromosome	Chromosome	): Create a chromosome pair.
org.apache.commons.math4.genetics.ChromosomePair.getFirst	(	): Access the first chromosome.
org.apache.commons.math4.genetics.ChromosomePair.getSecond	(	): Access the second chromosome.
org.apache.commons.math4.genetics.ChromosomePair.toString	(	):  
org.apache.commons.math4.genetics.CrossoverPolicy: Policy used to create a pair of new chromosomes by performing a crossover operation on a source pair of chromosomes.
org.apache.commons.math4.genetics.CrossoverPolicy.crossover	(	Chromosome	Chromosome	): Perform a crossover operation on the given chromosomes.
org.apache.commons.math4.genetics.CycleCrossover: Cycle Crossover [CX] builds offspring from ordered chromosomes by identifying cycles between two parent chromosomes. To form the children, the cycles are copied from the respective parents.  To form a cycle the following procedure is applied:  start with the first gene of parent 1 look at the gene at the same position of parent 2 go to the position with the same gene in parent 1 add this gene index to the cycle repeat the steps 2-5 until we arrive at the starting gene of this cycle  The indices that form a cycle are then used to form the children in alternating order, i.e. in cycle 1, the genes of parent 1 are copied to child 1, while in cycle 2 the genes of parent 1 are copied to child 2, and so forth ... Example (zero-start cycle):  p1 = (8 4 7 3 6 2 5 1 9 0) X c1 = (8 1 2 3 4 5 6 7 9 0) p2 = (0 1 2 3 4 5 6 7 8 9) X c2 = (0 4 7 3 6 2 5 1 8 9) cycle 1: 8 0 9 cycle 2: 4 1 7 2 5 6 cycle 3: 3  This policy works only on AbstractListChromosome, and therefore it is parameterized by T. Moreover, the chromosomes must have same lengths.
org.apache.commons.math4.genetics.CycleCrossover.CycleCrossover	(	): Creates a new CycleCrossover policy.
org.apache.commons.math4.genetics.CycleCrossover.CycleCrossover	(	boolean	): Creates a new CycleCrossover policy using the given randomStart behavior.
org.apache.commons.math4.genetics.CycleCrossover.crossover	(	Chromosome	Chromosome	): Perform a crossover operation on the given chromosomes.
org.apache.commons.math4.genetics.CycleCrossover.isRandomStart	(	): Returns whether the starting index is chosen randomly or set to zero.
org.apache.commons.math4.genetics.CycleCrossover.mate	(	AbstractListChromosome	AbstractListChromosome	): Helper for crossover(). Performs the actual crossover.
org.apache.commons.math4.genetics.DummyBinaryChromosome: Implementation of BinaryChromosome for testing purposes
org.apache.commons.math4.genetics.DummyListChromosome: Implementation of ListChromosome for testing purposes
org.apache.commons.math4.genetics.DummyRandomKey: Implementation of RandomKey for testing purposes
org.apache.commons.math4.genetics.ElitisticListPopulation: Population of chromosomes which uses elitism (certain percentage of the best chromosomes is directly copied to the next generation).
org.apache.commons.math4.genetics.ElitisticListPopulation.ElitisticListPopulation	(	List	int	double	): Creates a new ElitisticListPopulation instance.
org.apache.commons.math4.genetics.ElitisticListPopulation.ElitisticListPopulation	(	int	double	): Creates a new ElitisticListPopulation instance and initializes its inner chromosome list.
org.apache.commons.math4.genetics.ElitisticListPopulation.getElitismRate	(	): Access the elitism rate.
org.apache.commons.math4.genetics.ElitisticListPopulation.nextGeneration	(	): Start the population for the next generation. The elitismRate percents of the best chromosomes are directly copied to the next generation.
org.apache.commons.math4.genetics.ElitisticListPopulation.setElitismRate	(	double	): Sets the elitism rate, i.e. how many best chromosomes will be directly transferred to the next generation [in %].
org.apache.commons.math4.genetics.Fitness: Fitness of a chromosome.
org.apache.commons.math4.genetics.Fitness.fitness	(	): Compute the fitness. This is usually very time-consuming, so the value should be cached.
org.apache.commons.math4.genetics.FitnessCachingTest.randomPopulation	(	): Initializes a random population.
org.apache.commons.math4.genetics.FixedElapsedTime: Stops after a fixed amount of time has elapsed.  The first time isSatisfied() is invoked, the end time of the evolution is determined based on the provided maxTime value. Once the elapsed time reaches the configured maxTime value, isSatisfied() returns true.
org.apache.commons.math4.genetics.FixedElapsedTime.FixedElapsedTime	(	long	): Create a new FixedElapsedTime instance.
org.apache.commons.math4.genetics.FixedElapsedTime.FixedElapsedTime	(	long	TimeUnit	): Create a new FixedElapsedTime instance.
org.apache.commons.math4.genetics.FixedElapsedTime.isSatisfied	(	Population	): Determine whether or not the maximum allowed time has passed. The termination time is determined after the first generation.
org.apache.commons.math4.genetics.FixedGenerationCount: Stops after a fixed number of generations.  Each time isSatisfied() is invoked, a generation counter is incremented. Once the counter reaches the configured maxGenerations value, isSatisfied() returns true.
org.apache.commons.math4.genetics.FixedGenerationCount.FixedGenerationCount	(	int	): Create a new FixedGenerationCount instance.
org.apache.commons.math4.genetics.FixedGenerationCount.getNumGenerations	(	): Returns the number of generations that have already passed.
org.apache.commons.math4.genetics.FixedGenerationCount.isSatisfied	(	Population	): Determine whether or not the given number of generations have passed. Increments the number of generations counter if the maximum has not been reached.
org.apache.commons.math4.genetics.GeneticAlgorithm: Implementation of a genetic algorithm. All factors that govern the operation of the algorithm can be configured for a specific problem.
org.apache.commons.math4.genetics.GeneticAlgorithm.GeneticAlgorithm	(	CrossoverPolicy	double	MutationPolicy	double	SelectionPolicy	): Create a new genetic algorithm.
org.apache.commons.math4.genetics.GeneticAlgorithm.evolve	(	Population	StoppingCondition	): Evolve the given population. Evolution stops when the stopping condition is satisfied. Updates the getGenerationsEvolved() generationsEvolved property with the number of generations evolved before the StoppingCondition is satisfied.
org.apache.commons.math4.genetics.GeneticAlgorithm.getCrossoverPolicy	(	): Returns the crossover policy.
org.apache.commons.math4.genetics.GeneticAlgorithm.getCrossoverRate	(	): Returns the crossover rate.
org.apache.commons.math4.genetics.GeneticAlgorithm.getGenerationsEvolved	(	): Returns the number of generations evolved to reach StoppingCondition in the last run.
org.apache.commons.math4.genetics.GeneticAlgorithm.getMutationPolicy	(	): Returns the mutation policy.
org.apache.commons.math4.genetics.GeneticAlgorithm.getMutationRate	(	): Returns the mutation rate.
org.apache.commons.math4.genetics.GeneticAlgorithm.getRandomGenerator	(	): Returns the (static) random generator.
org.apache.commons.math4.genetics.GeneticAlgorithm.getSelectionPolicy	(	): Returns the selection policy.
org.apache.commons.math4.genetics.GeneticAlgorithm.nextGeneration	(	Population	): Evolve the given population into the next generation.  Get nextGeneration population to fill from current generation, using its nextGeneration method Loop until new generation is filled: Apply configured SelectionPolicy to select a pair of parents from current With probability = getCrossoverRate(), apply configured CrossoverPolicy to parents With probability = getMutationRate(), apply configured MutationPolicy to each of the offspring Add offspring individually to nextGeneration, space permitting  Return nextGeneration 
org.apache.commons.math4.genetics.GeneticAlgorithm.setRandomGenerator	(	UniformRandomProvider	): Set the (static) random generator.
org.apache.commons.math4.genetics.GeneticAlgorithmTestBinary: This is also an example of usage.
org.apache.commons.math4.genetics.GeneticAlgorithmTestBinary.FindOnes: Chromosomes represented by a binary chromosome. The goal is to set all bits (genes) to 1.
org.apache.commons.math4.genetics.GeneticAlgorithmTestBinary.FindOnes.fitness	(	): Returns number of elements != 0
org.apache.commons.math4.genetics.GeneticAlgorithmTestBinary.randomPopulation	(	): Initializes a random population.
org.apache.commons.math4.genetics.GeneticAlgorithmTestPermutations: This is also an example of usage. This algorithm does "stochastic sorting" of a sequence 0,...,N.
org.apache.commons.math4.genetics.GeneticAlgorithmTestPermutations.MinPermutations: Chromosomes representing a permutation of (0,1,2,...,DIMENSION-1). The goal is to sort the sequence.
org.apache.commons.math4.genetics.GeneticAlgorithmTestPermutations.randomPopulation	(	): Initializes a random population
org.apache.commons.math4.genetics.InvalidRepresentationException: Exception indicating that the representation of a chromosome is not valid.
org.apache.commons.math4.genetics.InvalidRepresentationException.InvalidRepresentationException	(	Localizable	Object	): Construct an InvalidRepresentationException with a specialized message.
org.apache.commons.math4.genetics.ListPopulation: Population of chromosomes represented by a List.
org.apache.commons.math4.genetics.ListPopulation.ListPopulation	(	List	int	): Creates a new ListPopulation instance.  Note: the chromosomes of the specified list are added to the population.
org.apache.commons.math4.genetics.ListPopulation.ListPopulation	(	int	): Creates a new ListPopulation instance and initializes its inner chromosome list.
org.apache.commons.math4.genetics.ListPopulation.addChromosome	(	Chromosome	): Add the given chromosome to the population.
org.apache.commons.math4.genetics.ListPopulation.addChromosomes	(	Collection	): Add a Collection of chromosomes to this Population.
org.apache.commons.math4.genetics.ListPopulation.getChromosomeList	(	): Access the list of chromosomes.
org.apache.commons.math4.genetics.ListPopulation.getChromosomes	(	): Returns an unmodifiable list of the chromosomes in this population.
org.apache.commons.math4.genetics.ListPopulation.getFittestChromosome	(	): Access the fittest chromosome in this population.
org.apache.commons.math4.genetics.ListPopulation.getPopulationLimit	(	): Access the maximum population size.
org.apache.commons.math4.genetics.ListPopulation.getPopulationSize	(	): Access the current population size.
org.apache.commons.math4.genetics.ListPopulation.iterator	(	): Returns an iterator over the unmodifiable list of chromosomes. Any call to remove() will result in a UnsupportedOperationException.
org.apache.commons.math4.genetics.ListPopulation.setPopulationLimit	(	int	): Sets the maximal population size.
org.apache.commons.math4.genetics.ListPopulation.toString	(	): 
org.apache.commons.math4.genetics.MutationPolicy: Algorithm used to mutate a chromosome.
org.apache.commons.math4.genetics.MutationPolicy.mutate	(	Chromosome	): Mutate the given chromosome.
org.apache.commons.math4.genetics.NPointCrossover: N-point crossover policy. For each iteration a random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise. Example (2-point crossover):  -C- denotes a crossover point -C- -C- -C- -C- p1 = (1 0 | 1 0 0 1 | 0 1 1) X p2 = (0 1 | 1 0 1 0 | 1 1 1) \----/ \-------/ \-----/ \----/ \--------/ \-----/ || (*) || || (**) || VV (**) VV VV (*) VV /----\ /--------\ /-----\ /----\ /--------\ /-----\ c1 = (1 0 | 1 0 1 0 | 0 1 1) X c2 = (0 1 | 1 0 0 1 | 0 1 1)  This policy works only on AbstractListChromosome, and therefore it is parameterized by T. Moreover, the chromosomes must have same lengths.
org.apache.commons.math4.genetics.NPointCrossover.NPointCrossover	(	int	): Creates a new NPointCrossover policy using the given number of points.  Note: the number of crossover points must be < chromosome length - 1. This condition can only be checked at runtime, as the chromosome length is not known in advance.
org.apache.commons.math4.genetics.NPointCrossover.crossover	(	Chromosome	Chromosome	): Performs a N-point crossover. N random crossover points are selected and are used to divide the parent chromosomes into segments. The segments are copied in alternate order from the two parents to the corresponding child chromosomes. Example (2-point crossover):  -C- denotes a crossover point -C- -C- -C- -C- p1 = (1 0 | 1 0 0 1 | 0 1 1) X p2 = (0 1 | 1 0 1 0 | 1 1 1) \----/ \-------/ \-----/ \----/ \--------/ \-----/ || (*) || || (**) || VV (**) VV VV (*) VV /----\ /--------\ /-----\ /----\ /--------\ /-----\ c1 = (1 0 | 1 0 1 0 | 0 1 1) X c2 = (0 1 | 1 0 0 1 | 0 1 1) 
org.apache.commons.math4.genetics.NPointCrossover.getCrossoverPoints	(	): Returns the number of crossover points used by this CrossoverPolicy.
org.apache.commons.math4.genetics.NPointCrossover.mate	(	AbstractListChromosome	AbstractListChromosome	): Helper for crossover(). Performs the actual crossover.
org.apache.commons.math4.genetics.OnePointCrossover: One point crossover policy. A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise. Example:  -C- denotes a crossover point -C- -C- p1 = (1 0 1 0 0 1 | 0 1 1) X p2 = (0 1 1 0 1 0 | 1 1 1) \------------/ \-----/ \------------/ \-----/ || (*) || (**) VV (**) VV (*) /------------\ /-----\ /------------\ /-----\ c1 = (1 0 1 0 0 1 | 1 1 1) X c2 = (0 1 1 0 1 0 | 0 1 1)  This policy works only on AbstractListChromosome, and therefore it is parameterized by T. Moreover, the chromosomes must have same lengths.
org.apache.commons.math4.genetics.OnePointCrossover.crossover	(	AbstractListChromosome	AbstractListChromosome	): Helper for crossover(). Performs the actual crossover.
org.apache.commons.math4.genetics.OnePointCrossover.crossover	(	Chromosome	Chromosome	): Performs one point crossover. A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise. Example:  -C- denotes a crossover point -C- -C- p1 = (1 0 1 0 0 1 | 0 1 1) X p2 = (0 1 1 0 1 0 | 1 1 1) \------------/ \-----/ \------------/ \-----/ || (*) || (**) VV (**) VV (*) /------------\ /-----\ /------------\ /-----\ c1 = (1 0 1 0 0 1 | 1 1 1) X c2 = (0 1 1 0 1 0 | 0 1 1) 
org.apache.commons.math4.genetics.OrderedCrossover: Order 1 Crossover [OX1] builds offspring from ordered chromosomes by copying a consecutive slice from one parent, and filling up the remaining genes from the other parent as they appear.  This policy works by applying the following rules:  select a random slice of consecutive genes from parent 1 copy the slice to child 1 and mark out the genes in parent 2 starting from the right side of the slice, copy genes from parent 2 as they appear to child 1 if they are not yet marked out.   Example (random sublist from index 3 to 7, underlined):  p1 = (8 4 7 3 6 2 5 1 9 0) X c1 = (0 4 7 3 6 2 5 1 8 9) --------- --------- p2 = (0 1 2 3 4 5 6 7 8 9) X c2 = (8 1 2 3 4 5 6 7 9 0)   This policy works only on AbstractListChromosome, and therefore it is parameterized by T. Moreover, the chromosomes must have same lengths.
org.apache.commons.math4.genetics.OrderedCrossover.crossover	(	Chromosome	Chromosome	): Perform a crossover operation on the given chromosomes.
org.apache.commons.math4.genetics.OrderedCrossover.mate	(	AbstractListChromosome	AbstractListChromosome	): Helper for crossover(). Performs the actual crossover.
org.apache.commons.math4.genetics.PermutationChromosome: Interface indicating that the chromosome represents a permutation of objects.
org.apache.commons.math4.genetics.PermutationChromosome.decode	(	List	): Permutes the sequence of objects of type T according to the permutation this chromosome represents. For example, if this chromosome represents a permutation (3,0,1,2), and the unpermuted sequence is (a,b,c,d), this yields (d,a,b,c).
org.apache.commons.math4.genetics.Population: A collection of chromosomes that facilitates generational evolution.
org.apache.commons.math4.genetics.Population.addChromosome	(	Chromosome	): Add the given chromosome to the population.
org.apache.commons.math4.genetics.Population.getFittestChromosome	(	): Access the fittest chromosome in this population.
org.apache.commons.math4.genetics.Population.getPopulationLimit	(	): Access the maximum population size.
org.apache.commons.math4.genetics.Population.getPopulationSize	(	): Access the current population size.
org.apache.commons.math4.genetics.Population.nextGeneration	(	): Start the population for the next generation.
org.apache.commons.math4.genetics.RandomKey: Random Key chromosome is used for permutation representation. It is a vector of a fixed length of real numbers in [0,1] interval. The index of the i-th smallest value in the vector represents an i-th member of the permutation.  For example, the random key [0.2, 0.3, 0.8, 0.1] corresponds to the permutation of indices (3,0,1,2). If the original (unpermuted) sequence would be (a,b,c,d), this would mean the sequence (d,a,b,c).  With this representation, common operators like n-point crossover can be used, because any such chromosome represents a valid permutation.  Since the chromosome (and thus its arrayRepresentation) is immutable, the array representation is sorted only once in the constructor.  For details, see:  Bean, J.C.: Genetic algorithms and random keys for sequencing and optimization. ORSA Journal on Computing 6 (1994) 154-160 Rothlauf, F.: Representations for Genetic and Evolutionary Algorithms. Volume 104 of Studies in Fuzziness and Soft Computing. Physica-Verlag, Heidelberg (2002) 
org.apache.commons.math4.genetics.RandomKey.RandomKey	(	Double[]	): Constructor.
org.apache.commons.math4.genetics.RandomKey.RandomKey	(	List	): Constructor.
org.apache.commons.math4.genetics.RandomKey.baseSequence	(	int	): Helper for constructor. Generates a list of natural numbers (0,1,...,l-1).
org.apache.commons.math4.genetics.RandomKey.checkValidity	(	List	): Asserts that representation can represent a valid chromosome.
org.apache.commons.math4.genetics.RandomKey.comparatorPermutation	(	List	Comparator	): Generates a representation of a permutation corresponding to the data sorted by comparator. The data is not modified during the process. This is useful if you want to inject some permutations to the initial population.
org.apache.commons.math4.genetics.RandomKey.decode	(	List	): Permutes the sequence of objects of type T according to the permutation this chromosome represents. For example, if this chromosome represents a permutation (3,0,1,2), and the unpermuted sequence is (a,b,c,d), this yields (d,a,b,c).
org.apache.commons.math4.genetics.RandomKey.decodeGeneric	(	List	List	List	): Decodes a permutation represented by representation and returns a (generic) list with the permuted values.
org.apache.commons.math4.genetics.RandomKey.identityPermutation	(	int	): Generates a representation corresponding to an identity permutation of length l which can be passed to the RandomKey constructor.
org.apache.commons.math4.genetics.RandomKey.inducedPermutation	(	List	List	): Generates a representation of a permutation corresponding to a permutation which yields permutedData when applied to originalData. This method can be viewed as an inverse to decode().
org.apache.commons.math4.genetics.RandomKey.isSame	(	Chromosome	): Returns true iff another is a RandomKey and encodes the same permutation.
org.apache.commons.math4.genetics.RandomKey.randomPermutation	(	int	): Generates a representation corresponding to a random permutation of length l which can be passed to the RandomKey constructor.
org.apache.commons.math4.genetics.RandomKey.toString	(	):   
org.apache.commons.math4.genetics.RandomKeyMutation: Mutation operator for RandomKeys. Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].
org.apache.commons.math4.genetics.RandomKeyMutation.mutate	(	Chromosome	): Mutate the given chromosome.
org.apache.commons.math4.genetics.SelectionPolicy: Algorithm used to select a chromosome pair from a population.
org.apache.commons.math4.genetics.SelectionPolicy.select	(	Population	): Select two chromosomes from the population.
org.apache.commons.math4.genetics.StoppingCondition: Algorithm used to determine when to stop evolution.
org.apache.commons.math4.genetics.StoppingCondition.isSatisfied	(	Population	): Determine whether or not the given population satisfies the stopping condition.
org.apache.commons.math4.genetics.TournamentSelection: Tournament selection scheme. Each of the two selected chromosomes is selected based on n-ary tournament -- this is done by drawing arity random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.
org.apache.commons.math4.genetics.TournamentSelection.TournamentSelection	(	int	): Creates a new TournamentSelection instance.
org.apache.commons.math4.genetics.TournamentSelection.getArity	(	): Gets the arity (number of chromosomes drawn to the tournament).
org.apache.commons.math4.genetics.TournamentSelection.select	(	Population	): Select two chromosomes from the population. Each of the two selected chromosomes is selected based on n-ary tournament -- this is done by drawing arity random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.
org.apache.commons.math4.genetics.TournamentSelection.setArity	(	int	): Sets the arity (number of chromosomes drawn to the tournament).
org.apache.commons.math4.genetics.TournamentSelection.tournament	(	ListPopulation	): Helper for select(). Draw arity random chromosomes without replacement from the population, and then select the fittest chromosome among them.
org.apache.commons.math4.genetics.UniformCrossover: Perform Uniform Crossover [UX] on the specified chromosomes. A fixed mixing ratio is used to combine genes from the first and second parents, e.g. using a ratio of 0.5 would result in approximately 50% of genes coming from each parent. This is typically a poor method of crossover, but empirical evidence suggests that it is more exploratory and results in a larger part of the problem space being searched.  This crossover policy evaluates each gene of the parent chromosomes by chosing a uniform random number p in the range [0, 1]. If p < ratio, the parent genes are swapped. This means with a ratio of 0.7, 30% of the genes from the first parent and 70% from the second parent will be selected for the first offspring (and vice versa for the second offspring).  This policy works only on AbstractListChromosome, and therefore it is parameterized by T. Moreover, the chromosomes must have same lengths.
org.apache.commons.math4.genetics.UniformCrossover.UniformCrossover	(	double	): Creates a new UniformCrossover policy using the given mixing ratio.
org.apache.commons.math4.genetics.UniformCrossover.crossover	(	Chromosome	Chromosome	): Perform a crossover operation on the given chromosomes.
org.apache.commons.math4.genetics.UniformCrossover.getRatio	(	): Returns the mixing ratio used by this CrossoverPolicy.
org.apache.commons.math4.genetics.UniformCrossover.mate	(	AbstractListChromosome	AbstractListChromosome	): Helper for crossover(). Performs the actual crossover.
org.apache.commons.math4.geometry.Point: This interface represents a generic geometrical point.
org.apache.commons.math4.geometry.Point.distance	(	Point	): Compute the distance between the instance and another point.
org.apache.commons.math4.geometry.Point.getSpace	(	): Get the space to which the point belongs.
org.apache.commons.math4.geometry.Point.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise
org.apache.commons.math4.geometry.Space: This interface represents a generic space, with affine and vectorial counterparts.
org.apache.commons.math4.geometry.Space.getDimension	(	): Get the dimension of the space.
org.apache.commons.math4.geometry.Space.getSubSpace	(	): Get the n-1 dimension subspace of this space.
org.apache.commons.math4.geometry.Vector: This interface represents a generic vector in a vectorial space or a point in an affine space.
org.apache.commons.math4.geometry.Vector.add	(	Vector	): Add a vector to the instance.
org.apache.commons.math4.geometry.Vector.add	(	double	Vector	): Add a scaled vector to the instance.
org.apache.commons.math4.geometry.Vector.distance	(	Vector	): Compute the distance between the instance and another vector.
org.apache.commons.math4.geometry.Vector.distance1	(	Vector	): Compute the distance between the instance and another vector according to the L1 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.Vector.distanceInf	(	Vector	): Compute the distance between the instance and another vector according to the L∞ norm. Calling this method is equivalent to calling: q.subtract(p).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.Vector.distanceSq	(	Vector	): Compute the square of the distance between the instance and another vector. Calling this method is equivalent to calling: q.subtract(p).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.Vector.dotProduct	(	Vector	): Compute the dot-product of the instance and another vector.
org.apache.commons.math4.geometry.Vector.getNorm	(	): Get the L2 norm for the vector.
org.apache.commons.math4.geometry.Vector.getNorm1	(	): Get the L1 norm for the vector.
org.apache.commons.math4.geometry.Vector.getNormInf	(	): Get the L∞ norm for the vector.
org.apache.commons.math4.geometry.Vector.getNormSq	(	): Get the square of the norm for the vector.
org.apache.commons.math4.geometry.Vector.getSpace	(	): Get the space to which the point belongs.
org.apache.commons.math4.geometry.Vector.getZero	(	): Get the null vector of the vectorial space or origin point of the affine space.
org.apache.commons.math4.geometry.Vector.isInfinite	(	): Returns true if any coordinate of this vector is infinite and none are NaN; false otherwise
org.apache.commons.math4.geometry.Vector.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise
org.apache.commons.math4.geometry.Vector.negate	(	): Get the opposite of the instance.
org.apache.commons.math4.geometry.Vector.normalize	(	): Get a normalized vector aligned with the instance.
org.apache.commons.math4.geometry.Vector.scalarMultiply	(	double	): Multiply the instance by a scalar.
org.apache.commons.math4.geometry.Vector.subtract	(	Vector	): Subtract a vector from the instance.
org.apache.commons.math4.geometry.Vector.subtract	(	double	Vector	): Subtract a scaled vector from the instance.
org.apache.commons.math4.geometry.Vector.toString	(	NumberFormat	): Get a string representation of this vector.
org.apache.commons.math4.geometry.VectorFormat: Formats a vector in components list format "{x; y; ...}". The prefix and suffix "{" and "}" and the separator "; " can be replaced by any user-defined strings. The number format for components can be configured. White space is ignored at parse time, even if it is in the prefix, suffix or separator specifications. So even if the default separator does include a space character that is used at format time, both input string "{1;1;1}" and " { 1 ; 1 ; 1 } " will be parsed without error and the same vector will be returned. In the second case, however, the parse position after parsing will be just after the closing curly brace, i.e. just before the trailing space. Note: using "," as a separator may interfere with the grouping separator of the default NumberFormat for the current locale. Thus it is advised to use a NumberFormat instance with disabled grouping in such a case.
org.apache.commons.math4.geometry.VectorFormat.VectorFormat	(	): Create an instance with default settings. The instance uses the default prefix, suffix and separator: "{", "}", and "; " and the default number format for components.
org.apache.commons.math4.geometry.VectorFormat.VectorFormat	(	NumberFormat	): Create an instance with a custom number format for components.
org.apache.commons.math4.geometry.VectorFormat.VectorFormat	(	String	String	String	): Create an instance with custom prefix, suffix and separator.
org.apache.commons.math4.geometry.VectorFormat.VectorFormat	(	String	String	String	NumberFormat	): Create an instance with custom prefix, suffix, separator and format for components.
org.apache.commons.math4.geometry.VectorFormat.format	(	StringBuffer	FieldPosition	double	): Formats the coordinates of a Vector to produce a string.
org.apache.commons.math4.geometry.VectorFormat.format	(	Vector	): Formats a Vector object to produce a string.
org.apache.commons.math4.geometry.VectorFormat.format	(	Vector	StringBuffer	FieldPosition	): Formats a Vector object to produce a string.
org.apache.commons.math4.geometry.VectorFormat.getAvailableLocales	(	): Get the set of locales for which point/vector formats are available. This is the same set as the NumberFormat set.
org.apache.commons.math4.geometry.VectorFormat.getFormat	(	): Get the components format.
org.apache.commons.math4.geometry.VectorFormat.getPrefix	(	): Get the format prefix.
org.apache.commons.math4.geometry.VectorFormat.getSeparator	(	): Get the format separator between components.
org.apache.commons.math4.geometry.VectorFormat.getSuffix	(	): Get the format suffix.
org.apache.commons.math4.geometry.VectorFormat.parse	(	String	): Parses a string to produce a Vector object.
org.apache.commons.math4.geometry.VectorFormat.parse	(	String	ParsePosition	): Parses a string to produce a Vector object.
org.apache.commons.math4.geometry.VectorFormat.parseCoordinates	(	int	String	ParsePosition	): Parses a string to produce an array of coordinates.
org.apache.commons.math4.geometry.enclosing.Encloser: Interface for algorithms computing enclosing balls.
org.apache.commons.math4.geometry.enclosing.Encloser.enclose	(	Iterable	): Find a ball enclosing a list of points.
org.apache.commons.math4.geometry.enclosing.EnclosingBall: This class represents a ball enclosing some points.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.EnclosingBall	(	P	double	P	): Simple constructor.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.contains	(	P	): Check if a point is within the ball or at boundary.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.contains	(	P	double	): Check if a point is within an enlarged ball or at boundary.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.getCenter	(	): Get the center of the ball.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.getRadius	(	): Get the radius of the ball.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.getSupport	(	): Get the support points used to define the ball.
org.apache.commons.math4.geometry.enclosing.EnclosingBall.getSupportSize	(	): Get the number of support points used to define the ball.
org.apache.commons.math4.geometry.enclosing.SupportBallGenerator: Interface for generating balls based on support points.  This generator is used in the WelzlEncloser Emo Welzl algorithm and its derivatives. 
org.apache.commons.math4.geometry.enclosing.SupportBallGenerator.ballOnSupport	(	List	): Create a ball whose boundary lies on prescribed support points.
org.apache.commons.math4.geometry.enclosing.WelzlEncloser: Class implementing Emo Welzl algorithm to find the smallest enclosing ball in linear time.  The class implements the algorithm described in paper Smallest Enclosing Disks (Balls and Ellipsoids) by Emo Welzl, Lecture Notes in Computer Science 555 (1991) 359-370. The pivoting improvement published in the paper Fast and Robust Smallest Enclosing Balls, by Bernd Gärtner and further modified in paper  Efficient Computation of Smallest Enclosing Balls in Three Dimensions by Linus Källberg to avoid performing local copies of data have been included. 
org.apache.commons.math4.geometry.enclosing.WelzlEncloser.WelzlEncloser	(	double	SupportBallGenerator	): Simple constructor.
org.apache.commons.math4.geometry.enclosing.WelzlEncloser.enclose	(	Iterable	): Find a ball enclosing a list of points. 
org.apache.commons.math4.geometry.enclosing.WelzlEncloser.moveToFrontBall	(	List	int	List	): Compute enclosing ball using Welzl's move to front heuristic.
org.apache.commons.math4.geometry.enclosing.WelzlEncloser.pivotingBall	(	Iterable	): Compute enclosing ball using Gärtner's pivoting heuristic.
org.apache.commons.math4.geometry.enclosing.WelzlEncloser.selectFarthest	(	Iterable	EnclosingBall	): Select the point farthest to the current ball.
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D: This class represents a 1D point or a 1D vector. An instance of Cartesian1D represents the point with the corresponding Cartesian coordinates. An instance of Cartesian1D also represents the vector which begins at the origin and ends at the point corresponding to the coordinates. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.Cartesian1D	(	double	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.Cartesian1D	(	double	Cartesian1D	): Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.Cartesian1D	(	double	Cartesian1D	double	Cartesian1D	): Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.Cartesian1D	(	double	Cartesian1D	double	Cartesian1D	double	Cartesian1D	): Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.Cartesian1D	(	double	Cartesian1D	double	Cartesian1D	double	Cartesian1D	double	Cartesian1D	): Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.add	(	Vector	): Add a vector to the instance. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.add	(	double	Vector	): Add a scaled vector to the instance. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distance	(	Cartesian1D	): Compute the distance between the instance and other coordinates.
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distance	(	Cartesian1D	Cartesian1D	): Compute the distance between two points according to the L2 norm. Calling this method is equivalent to calling: p1.subtract(p2).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distance	(	Point	): Compute the distance between the instance and another point. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distance	(	Vector	): Compute the distance between the instance and another vector. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distance1	(	Vector	): Compute the distance between the instance and another vector according to the L1 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm1() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distanceInf	(	Cartesian1D	Cartesian1D	): Compute the distance between two points according to the L∞ norm. Calling this method is equivalent to calling: p1.subtract(p2).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distanceInf	(	Vector	): Compute the distance between the instance and another vector according to the L∞ norm. Calling this method is equivalent to calling: q.subtract(p).getNormInf() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distanceSq	(	Cartesian1D	Cartesian1D	): Compute the square of the distance between two points. Calling this method is equivalent to calling: p1.subtract(p2).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.distanceSq	(	Vector	): Compute the square of the distance between the instance and another vector. Calling this method is equivalent to calling: q.subtract(p).getNormSq() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.dotProduct	(	Vector	): Compute the dot-product of the instance and another vector. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.equals	(	Object	): Test for the equality of two 1D vectors.  If all coordinates of two 1D vectors are exactly the same, and none are Double.NaN, the two 1D vectors are considered to be equal.   NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 1D vector are equal to Double.NaN, the 1D vector is equal to NaN. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getNorm	(	): Get the L2 norm for the vector. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getNorm1	(	): Get the L1 norm for the vector. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getNormInf	(	): Get the L∞ norm for the vector. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getNormSq	(	): Get the square of the norm for the vector. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getSpace	(	): Get the space to which the point belongs. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.getZero	(	): Get the null vector of the vectorial space or origin point of the affine space. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.hashCode	(	): Get a hashCode for the 1D vector.  All NaN values have the same hash code.
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.isInfinite	(	): Returns true if any coordinate of this vector is infinite and none are NaN; false otherwise 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.negate	(	): Get the opposite of the instance. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.normalize	(	): Get a normalized vector aligned with the instance. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.scalarMultiply	(	double	): Multiply the instance by a scalar. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.subtract	(	Vector	): Subtract a vector from the instance. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.subtract	(	double	Vector	): Subtract a scaled vector from the instance. 
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.toString	(	): Get a string representation of this vector.
org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D.toString	(	NumberFormat	): Get a string representation of this vector. 
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D: This class implements a one-dimensional space.
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.Euclidean1D	(	): Private constructor for the singleton.
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.NoSubSpaceException: Specialized exception for inexistent sub-space.  This exception is thrown when attempting to get the sub-space of a one-dimensional space 
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.NoSubSpaceException.NoSubSpaceException	(	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.getDimension	(	): Get the dimension of the space. 
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.getInstance	(	): Get the unique instance.
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.getSubSpace	(	): Get the n-1 dimension subspace of this space.  As the 1-dimension Euclidean space does not have proper sub-spaces, this method always throws a NoSubSpaceException 
org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.geometry.euclidean.oned.Interval: This class represents a 1D interval.
org.apache.commons.math4.geometry.euclidean.oned.Interval.Interval	(	double	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.oned.Interval.checkPoint	(	double	double	): Check a point with respect to the interval.
org.apache.commons.math4.geometry.euclidean.oned.Interval.getBarycenter	(	): Get the barycenter of the interval.
org.apache.commons.math4.geometry.euclidean.oned.Interval.getInf	(	): Get the lower bound of the interval.
org.apache.commons.math4.geometry.euclidean.oned.Interval.getSize	(	): Get the size of the interval.
org.apache.commons.math4.geometry.euclidean.oned.Interval.getSup	(	): Get the upper bound of the interval.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet: This class represents a 1D region: a set of intervals.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.IntervalsSet	(	BSPTree	double	): Build an intervals set from an inside/outside BSP tree. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.IntervalsSet	(	Collection	double	): Build an intervals set from a Boundary REPresentation (B-rep). The boundary is provided as a collection of SubHyperplane sub-hyperplanes. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side. The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the checkPoint() method will not be meaningful anymore. If the boundary is empty, the region will represent the whole space.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.IntervalsSet	(	double	): Build an intervals set representing the whole real line.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.IntervalsSet	(	double	double	double	): Build an intervals set corresponding to a single interval.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.SubIntervalsIterator: Local iterator for sub-intervals. 
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.SubIntervalsIterator.SubIntervalsIterator	(	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.SubIntervalsIterator.hasNext	(	):  
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.SubIntervalsIterator.next	(	):  
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.SubIntervalsIterator.remove	(	):  
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.SubIntervalsIterator.selectPending	(	): Walk the tree to select the pending sub-interval.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.asList	(	): Build an ordered list of intervals representing the instance. This method builds this intervals set as an ordered list of Interval Interval elements. If the intervals set has no lower limit, the first interval will have its low bound equal to Double.NEGATIVE_INFINITY. If the intervals set has no upper limit, the last interval will have its upper bound equal to Double.POSITIVE_INFINITY. An empty tree will build an empty list while a tree representing the whole real line will build a one element list with both bounds being infinite.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).  
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.buildTree	(	double	double	double	): Build an inside/outside tree representing a single interval.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.childAfter	(	BSPTree	): Find the child node just after an internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.childBefore	(	BSPTree	): Find the child node just before an internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.computeGeometricalProperties	(	): Compute some geometrical properties. The properties to compute are the barycenter and the size. 
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.finiteOrNullPoint	(	double	): Build a finite point.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.getAngle	(	BSPTree	): Get the abscissa of an internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.getFirstIntervalBoundary	(	): Get the node corresponding to the first interval boundary.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.getFirstLeaf	(	BSPTree	): Get the first leaf node of a tree.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.getInf	(	): Get the lowest value belonging to the instance.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.getSup	(	): Get the highest value belonging to the instance.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.isAfterParent	(	BSPTree	): Check if a node is the child after its parent in ascending order.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.isBeforeParent	(	BSPTree	): Check if a node is the child before its parent in ascending order.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.isDirect	(	BSPTree	): Check if an internal node has a direct oriented point.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.isIntervalEnd	(	BSPTree	): Check if an internal node corresponds to the end abscissa of an interval.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.isIntervalStart	(	BSPTree	): Check if an internal node corresponds to the start abscissa of an interval.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.iterator	(	):   The iterator returns the limit values of sub-intervals in ascending order.   The iterator does not support the optional remove operation. 
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.leafAfter	(	BSPTree	): Find the leaf node just after an internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.leafBefore	(	BSPTree	): Find the leaf node just before an internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.nextInternalNode	(	BSPTree	): Get the next internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.previousInternalNode	(	BSPTree	): Get the previous internal node.
org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet.projectToBoundary	(	Point	): Project a point on the boundary of the region.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint: This class represents a 1D oriented hyperplane. An hyperplane in 1D is a simple point, its orientation being a boolean. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.OrientedPoint	(	Cartesian1D	boolean	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.copySelf	(	): Copy the instance. Since instances are immutable, this method directly returns the instance.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.getLocation	(	): Get the hyperplane location on the real line.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.getOffset	(	Point	): Get the offset (oriented distance) of a point. The offset is 0 if the point is on the underlying hyperplane, it is positive if the point is on one particular side of the hyperplane, and it is negative if the point is on the other side, according to the hyperplane natural orientation. 
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.getOffset	(	Vector	): Get the offset (oriented distance) of a vector.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.getTolerance	(	): Get the tolerance below which points are considered to belong to the hyperplane.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.isDirect	(	): Check if the hyperplane orientation is direct.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.project	(	Point	): Project a point to the hyperplane.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.revertSelf	(	): Revert the instance.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.sameOrientationAs	(	Hyperplane	): Check if the instance has the same orientation as another hyperplane. This method is expected to be called on parallel hyperplanes. The method should not re-check for parallelism, only for orientation, typically by testing something like the sign of the dot-products of normals. 
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.wholeHyperplane	(	): Build a region covering the whole hyperplane. Since this class represent zero dimension spaces which does not have lower dimension sub-spaces, this method returns a dummy implementation of a org.apache.commons.math4.geometry.partitioning.SubHyperplane SubHyperplane. This implementation is only used to allow the org.apache.commons.math4.geometry.partitioning.SubHyperplane SubHyperplane class implementation to work properly, it should not be used otherwise.
org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint.wholeSpace	(	): Build a region covering the whole space.
org.apache.commons.math4.geometry.euclidean.oned.SubOrientedPoint: This class represents sub-hyperplane for OrientedPoint. An hyperplane in 1D is a simple point, its orientation being a boolean. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.oned.SubOrientedPoint.SubOrientedPoint	(	Hyperplane	Region	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.oned.SubOrientedPoint.buildNew	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region. 
org.apache.commons.math4.geometry.euclidean.oned.SubOrientedPoint.getSize	(	): Get the size of the instance.  
org.apache.commons.math4.geometry.euclidean.oned.SubOrientedPoint.isEmpty	(	): Check if the instance is empty.  
org.apache.commons.math4.geometry.euclidean.oned.SubOrientedPoint.split	(	Hyperplane	): Split the instance in two parts by an hyperplane.  
org.apache.commons.math4.geometry.euclidean.oned.Vector1D: This class represents a 1D vector.
org.apache.commons.math4.geometry.euclidean.oned.Vector1D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat: Formats a 1D vector in components list format "{x}". The prefix and suffix "{" and "}" can be replaced by any user-defined strings. The number format for components can be configured. White space is ignored at parse time, even if it is in the prefix, suffix or separator specifications. So even if the default separator does include a space character that is used at format time, both input string "{1}" and " { 1 } " will be parsed without error and the same vector will be returned. In the second case, however, the parse position after parsing will be just after the closing curly brace, i.e. just before the trailing space. Note: using "," as a separator may interfere with the grouping separator of the default NumberFormat for the current locale. Thus it is advised to use a NumberFormat instance with disabled grouping in such a case.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.Vector1DFormat	(	): Create an instance with default settings. The instance uses the default prefix, suffix and separator: "{", "}", and "; " and the default number format for components.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.Vector1DFormat	(	NumberFormat	): Create an instance with a custom number format for components.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.Vector1DFormat	(	String	String	): Create an instance with custom prefix, suffix and separator.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.Vector1DFormat	(	String	String	NumberFormat	): Create an instance with custom prefix, suffix, separator and format for components.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.format	(	Vector	StringBuffer	FieldPosition	): Formats a Vector object to produce a string. 
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.getInstance	(	): Returns the default 1D vector format for the current locale.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.getInstance	(	Locale	): Returns the default 1D vector format for the given locale.
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.parse	(	String	): Parses a string to produce a Vector object. 
org.apache.commons.math4.geometry.euclidean.oned.Vector1DFormat.parse	(	String	ParsePosition	): Parses a string to produce a Vector object. 
org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularityException: This class represents exceptions thrown while extractiong Cardan or Euler angles from a rotation.
org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularityException.CardanEulerSingularityException	(	boolean	): Simple constructor. build an exception with a default message.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D: This class represents points or vectors in a three-dimensional space. An instance of Cartesian3D represents the point with the corresponding coordinates. An instance of Cartesian3D also represents the vector which begins at the origin and ends at the point corresponding to the coordinates. Instance of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double	Cartesian3D	): Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double	Cartesian3D	double	Cartesian3D	): Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double	Cartesian3D	double	Cartesian3D	double	Cartesian3D	): Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double	Cartesian3D	double	Cartesian3D	double	Cartesian3D	double	Cartesian3D	): Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double	double	): Simple constructor. Build a vector from its azimuthal coordinates
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double	double	double	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.Cartesian3D	(	double[]	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.add	(	Vector	): Add a vector to the instance. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.add	(	double	Vector	): Add a scaled vector to the instance. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.angle	(	Cartesian3D	Cartesian3D	): Compute the angular separation between two vectors. This method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.crossProduct	(	Cartesian3D	Cartesian3D	): Compute the cross-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.crossProduct	(	Vector	): Compute the cross-product of the instance with another vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distance	(	Cartesian3D	): Compute the distance between the instance and other coordinates.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distance	(	Cartesian3D	Cartesian3D	): Compute the distance between two vectors according to the L2 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distance	(	Point	): Compute the distance between the instance and another point. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distance	(	Vector	): Compute the distance between the instance and another vector. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distance1	(	Cartesian3D	Cartesian3D	): Compute the distance between two vectors according to the L1 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distance1	(	Vector	): Compute the distance between the instance and another vector according to the L1 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm1() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distanceInf	(	Cartesian3D	Cartesian3D	): Compute the distance between two vectors according to the L∞ norm. Calling this method is equivalent to calling: v1.subtract(v2).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distanceInf	(	Vector	): Compute the distance between the instance and another vector according to the L∞ norm. Calling this method is equivalent to calling: q.subtract(p).getNormInf() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distanceSq	(	Cartesian3D	Cartesian3D	): Compute the square of the distance between two vectors. Calling this method is equivalent to calling: v1.subtract(v2).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.distanceSq	(	Vector	): Compute the square of the distance between the instance and another vector. Calling this method is equivalent to calling: q.subtract(p).getNormSq() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.dotProduct	(	Cartesian3D	Cartesian3D	): Compute the dot-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.dotProduct	(	Vector	): Compute the dot-product of the instance and another vector.  The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.equals	(	Object	): Test for the equality of two 3D vectors.  If all coordinates of two 3D vectors are exactly the same, and none are Double.NaN, the two 3D vectors are considered to be equal.   NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 3D vector are equal to Double.NaN, the 3D vector is equal to NaN. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getAlpha	(	): Get the azimuth of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getDelta	(	): Get the elevation of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getNorm	(	): Get the L2 norm for the vector. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getNorm1	(	): Get the L1 norm for the vector. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getNormInf	(	): Get the L∞ norm for the vector. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getNormSq	(	): Get the square of the norm for the vector. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getSpace	(	): Get the space to which the point belongs. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getY	(	): Get the ordinate of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getZ	(	): Get the height of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.getZero	(	): Get the null vector of the vectorial space or origin point of the affine space. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.hashCode	(	): Get a hashCode for the 3D vector.  All NaN values have the same hash code.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.isInfinite	(	): Returns true if any coordinate of this vector is infinite and none are NaN; false otherwise 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.negate	(	): Get the opposite of the instance. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.normalize	(	): Get a normalized vector aligned with the instance. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.orthogonal	(	): Get a vector orthogonal to the instance. There are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u :  Cartesian3D k = u.normalize(); Cartesian3D i = k.orthogonal(); Cartesian3D j = Cartesian3D.crossProduct(k, i); 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.scalarMultiply	(	double	): Multiply the instance by a scalar. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.subtract	(	Vector	): Subtract a vector from the instance. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.subtract	(	double	Vector	): Subtract a scaled vector from the instance. 
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.toArray	(	): Get the vector coordinates as a dimension 3 array.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.toString	(	): Get a string representation of this vector.
org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D.toString	(	NumberFormat	): Get a string representation of this vector. 
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D: This class implements a three-dimensional space.
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D.Euclidean3D	(	): Private constructor for the singleton.
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D.getDimension	(	): Get the dimension of the space. 
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D.getInstance	(	): Get the unique instance.
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D.getSubSpace	(	): Get the n-1 dimension subspace of this space. 
org.apache.commons.math4.geometry.euclidean.threed.Euclidean3D.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation: This class is a re-implementation of Rotation using RealFieldElement. Instance of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	FieldVector3D	FieldVector3D	): Build one of the rotations that transform one vector into another one. Except for a possible scale factor, if the instance were applied to the vector u it will produce the vector v. There is an infinite number of such rotations, this constructor choose the one with the smallest associated angle (i.e. the one whose axis is orthogonal to the (u, v) plane). If u and v are collinear, an arbitrary rotation axis is chosen.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	FieldVector3D	FieldVector3D	FieldVector3D	FieldVector3D	): Build the rotation that transforms a pair of vectors into another pair. Except for possible scale factors, if the instance were applied to the pair (u1, u2) it will produce the pair (v1, v2). If the angular separation between u1 and u2 is not the same as the angular separation between v1 and v2, then a corrected v'2 will be used rather than v2, the corrected vector will be in the (±v1, +v2) half-plane.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	FieldVector3D	T	): Build a rotation from an axis and an angle. We use the convention that angles are oriented according to the effect of the rotation on vectors around the axis. That means that if (i, j, k) is a direct frame and if we first provide +k as the axis and π/2 as the angle to this constructor, and then applyTo() apply the instance to +i, we will get +j. Another way to represent our convention is to say that a rotation of angle θ about the unit vector (x, y, z) is the same as the rotation build from quaternion components { cos(-θ/2), x * sin(-θ/2), y * sin(-θ/2), z * sin(-θ/2) }. Note the minus sign on the angle! On the one hand this convention is consistent with a vectorial perspective (moving vectors in fixed frames), on the other hand it is different from conventions with a frame perspective (fixed vectors viewed from different frames) like the ones used for example in spacecraft attitude community or in the graphics community.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	FieldVector3D	T	RotationConvention	): Build a rotation from an axis and an angle. We use the convention that angles are oriented according to the effect of the rotation on vectors around the axis. That means that if (i, j, k) is a direct frame and if we first provide +k as the axis and π/2 as the angle to this constructor, and then applyTo() apply the instance to +i, we will get +j. Another way to represent our convention is to say that a rotation of angle θ about the unit vector (x, y, z) is the same as the rotation build from quaternion components { cos(-θ/2), x * sin(-θ/2), y * sin(-θ/2), z * sin(-θ/2) }. Note the minus sign on the angle! On the one hand this convention is consistent with a vectorial perspective (moving vectors in fixed frames), on the other hand it is different from conventions with a frame perspective (fixed vectors viewed from different frames) like the ones used for example in spacecraft attitude community or in the graphics community.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	RotationOrder	RotationConvention	T	T	T	): Build a rotation from three Cardan or Euler elementary rotations. Cardan rotations are three successive rotations around the canonical axes X, Y and Z, each axis being used once. There are 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler rotations are three successive rotations around the canonical axes X, Y and Z, the first and last rotations being around the same axis. There are 6 such sets of rotations (XYX, XZX, YXY, YZY, ZXZ and ZYZ), the most popular one being ZXZ. Beware that many people routinely use the term Euler angles even for what really are Cardan angles (this confusion is especially widespread in the aerospace business where Roll, Pitch and Yaw angles are often wrongly tagged as Euler angles).
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	RotationOrder	T	T	T	): Build a rotation from three Cardan or Euler elementary rotations. Cardan rotations are three successive rotations around the canonical axes X, Y and Z, each axis being used once. There are 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler rotations are three successive rotations around the canonical axes X, Y and Z, the first and last rotations being around the same axis. There are 6 such sets of rotations (XYX, XZX, YXY, YZY, ZXZ and ZYZ), the most popular one being ZXZ. Beware that many people routinely use the term Euler angles even for what really are Cardan angles (this confusion is especially widespread in the aerospace business where Roll, Pitch and Yaw angles are often wrongly tagged as Euler angles).
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	T	T	T	T	boolean	): Build a rotation from the quaternion coordinates. A rotation can be built from a normalized quaternion, i.e. a quaternion for which q02 + q12 + q22 + q32 = 1. If the quaternion is not normalized, the constructor can normalize it in a preprocessing step. Note that some conventions put the scalar part of the quaternion as the 4th component and the vector part as the first three components. This is not our convention. We put the scalar part as the first component.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.FieldRotation	(	T[][]	double	): Build a rotation from a 3X3 matrix. Rotation matrices are orthogonal matrices, i.e. unit matrices (which are matrices for which m.mT = I) with real coefficients. The module of the determinant of unit matrices is 1, among the orthogonal 3X3 matrices, only the ones having a positive determinant (+1) are rotation matrices. When a rotation is defined by a matrix with truncated values (typically when it is extracted from a technical sheet where only four to five significant digits are available), the matrix is not orthogonal anymore. This constructor handles this case transparently by using a copy of the given matrix and applying a correction to the copy in order to perfect its orthogonality. If the Frobenius norm of the correction needed is above the given threshold, then the matrix is considered to be too far from a true rotation matrix and an exception is thrown.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	Cartesian3D	): Apply the inverse of the rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	FieldRotation	): Apply the inverse of the instance to another rotation.  Calling this method is equivalent to call composeInverse() composeInverse(r, RotationConvention.VECTOR_OPERATOR). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	FieldVector3D	): Apply the inverse of the rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	Rotation	): Apply the inverse of the instance to another rotation.  Calling this method is equivalent to call composeInverse() composeInverse(r, RotationConvention.VECTOR_OPERATOR). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	Rotation	FieldRotation	): Apply the inverse of a rotation to another rotation. Applying the inverse of a rotation to another rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the inverse image of v by rOuter (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where comp = applyInverseTo(rOuter, rInner).
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	Rotation	FieldVector3D	): Apply the inverse of a rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	T[]	T[]	): Apply the inverse of the rotation to a vector stored in an array.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyInverseTo	(	double[]	T[]	): Apply the inverse of the rotation to a vector stored in an array.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	Cartesian3D	): Apply the rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	FieldRotation	): Apply the instance to another rotation.  Calling this method is equivalent to call compose() compose(r, RotationConvention.VECTOR_OPERATOR). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	FieldVector3D	): Apply the rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	Rotation	): Apply the instance to another rotation.  Calling this method is equivalent to call compose() compose(r, RotationConvention.VECTOR_OPERATOR). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	Rotation	FieldRotation	): Apply a rotation to another rotation. Applying a rotation to another rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u), where comp = applyTo(rOuter, rInner).
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	Rotation	FieldVector3D	): Apply a rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	T[]	T[]	): Apply the rotation to a vector stored in an array.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.applyTo	(	double[]	T[]	): Apply the rotation to a vector stored in an array.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.buildArray	(	T	T	T	): Create a dimension 3 array.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.compose	(	FieldRotation	RotationConvention	): Compose the instance with another rotation.  If the semantics of the rotations composition corresponds to a VECTOR_OPERATOR vector operator convention, applying the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r1 (i.e. r1.applyTo(u) = v). Let w be the image of v by rotation r2 (i.e. r2.applyTo(v) = w). Then w = comp.applyTo(u), where comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR).   If the semantics of the rotations composition corresponds to a FRAME_TRANSFORM frame transform convention, the application order will be reversed. So keeping the exact same meaning of all r1, r2, u, v, w and comp as above, comp could also be computed as comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.compose	(	Rotation	RotationConvention	): Compose the instance with another rotation.  If the semantics of the rotations composition corresponds to a VECTOR_OPERATOR vector operator convention, applying the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r1 (i.e. r1.applyTo(u) = v). Let w be the image of v by rotation r2 (i.e. r2.applyTo(v) = w). Then w = comp.applyTo(u), where comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR).   If the semantics of the rotations composition corresponds to a FRAME_TRANSFORM frame transform convention, the application order will be reversed. So keeping the exact same meaning of all r1, r2, u, v, w and comp as above, comp could also be computed as comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.composeInternal	(	FieldRotation	): Compose the instance with another rotation using vector operator convention.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.composeInternal	(	Rotation	): Compose the instance with another rotation using vector operator convention.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.composeInverse	(	FieldRotation	RotationConvention	): Compose the inverse of the instance with another rotation.  If the semantics of the rotations composition corresponds to a VECTOR_OPERATOR vector operator convention, applying the inverse of the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r1 (i.e. r1.applyTo(u) = v). Let w be the inverse image of v by r2 (i.e. r2.applyInverseTo(v) = w). Then w = comp.applyTo(u), where comp = r2.composeInverse(r1).   If the semantics of the rotations composition corresponds to a FRAME_TRANSFORM frame transform convention, the application order will be reversed, which means it is the innermost rotation that will be reversed. So keeping the exact same meaning of all r1, r2, u, v, w and comp as above, comp could also be computed as comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.composeInverse	(	Rotation	RotationConvention	): Compose the inverse of the instance with another rotation.  If the semantics of the rotations composition corresponds to a VECTOR_OPERATOR vector operator convention, applying the inverse of the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r1 (i.e. r1.applyTo(u) = v). Let w be the inverse image of v by r2 (i.e. r2.applyInverseTo(v) = w). Then w = comp.applyTo(u), where comp = r2.composeInverse(r1).   If the semantics of the rotations composition corresponds to a FRAME_TRANSFORM frame transform convention, the application order will be reversed, which means it is the innermost rotation that will be reversed. So keeping the exact same meaning of all r1, r2, u, v, w and comp as above, comp could also be computed as comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM). 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.composeInverseInternal	(	FieldRotation	): Compose the inverse of the instance with another rotation using vector operator convention.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.composeInverseInternal	(	Rotation	): Compose the inverse of the instance with another rotation using vector operator convention.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.distance	(	FieldRotation	FieldRotation	): Compute the distance between two rotations. The distance is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:  r1(r) = r2  This distance is an angle between 0 and π. Its value is the smallest possible upper bound of the angle in radians between r1(v) and r2(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical. Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getAngle	(	): Get the angle of the rotation.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getAngles	(	RotationOrder	): Get the Cardan or Euler angles corresponding to the instance. The equations show that each rotation can be defined by two different values of the Cardan or Euler angles set. For example if Cardan angles are used, the rotation defined by the angles a1, a2 and a3 is the same as the rotation defined by the angles π + a1, π - a2 and π + a3. This method implements the following arbitrary choices:  for Cardan angles, the chosen set is the one for which the second angle is between -π/2 and π/2 (i.e its cosine is positive), for Euler angles, the chosen set is the one for which the second angle is between 0 and π (i.e its sine is positive).  Cardan and Euler angle have a very disappointing drawback: all of them have singularities. This means that if the instance is too close to the singularities corresponding to the given rotation order, it will be impossible to retrieve the angles. For Cardan angles, this is often called gimbal lock. There is nothing to do to prevent this, it is an intrinsic problem with Cardan and Euler representation (but not a problem with the rotation itself, which is perfectly well defined). For Cardan angles, singularities occur when the second angle is close to -π/2 or +π/2, for Euler angle singularities occur when the second angle is close to 0 or π, this implies that the identity rotation is always singular for Euler angles!
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getAngles	(	RotationOrder	RotationConvention	): Get the Cardan or Euler angles corresponding to the instance. The equations show that each rotation can be defined by two different values of the Cardan or Euler angles set. For example if Cardan angles are used, the rotation defined by the angles a1, a2 and a3 is the same as the rotation defined by the angles π + a1, π - a2 and π + a3. This method implements the following arbitrary choices:  for Cardan angles, the chosen set is the one for which the second angle is between -π/2 and π/2 (i.e its cosine is positive), for Euler angles, the chosen set is the one for which the second angle is between 0 and π (i.e its sine is positive).  Cardan and Euler angle have a very disappointing drawback: all of them have singularities. This means that if the instance is too close to the singularities corresponding to the given rotation order, it will be impossible to retrieve the angles. For Cardan angles, this is often called gimbal lock. There is nothing to do to prevent this, it is an intrinsic problem with Cardan and Euler representation (but not a problem with the rotation itself, which is perfectly well defined). For Cardan angles, singularities occur when the second angle is close to -π/2 or +π/2, for Euler angle singularities occur when the second angle is close to 0 or π, this implies that the identity rotation is always singular for Euler angles!
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getAxis	(	): Get the normalized axis of the rotation.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getAxis	(	RotationConvention	): Get the normalized axis of the rotation.  Note that as getAngle() always returns an angle between 0 and π, changing the convention changes the direction of the axis, not the sign of the angle. 
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getMatrix	(	): Get the 3X3 matrix corresponding to the instance
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getQ0	(	): Get the scalar coordinate of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getQ1	(	): Get the first coordinate of the vectorial part of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getQ2	(	): Get the second coordinate of the vectorial part of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.getQ3	(	): Get the third coordinate of the vectorial part of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.mat2quat	(	T[][]	): Convert an orthogonal rotation matrix to a quaternion.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.orthogonalizeMatrix	(	T[][]	double	): Perfect orthogonality on a 3X3 matrix.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.revert	(	): Revert a rotation. Build a rotation which reverse the effect of another rotation. This means that if r(u) = v, then r.revert(v) = u. The instance is not changed.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.toRotation	(	): Convert to a constant vector without derivatives.
org.apache.commons.math4.geometry.euclidean.threed.FieldRotation.vector	(	double	double	double	): Create a constant vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D: This class is a re-implementation of Cartesian3D using RealFieldElement. Instance of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	Cartesian3D	): Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	Cartesian3D	T	Cartesian3D	): Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	Cartesian3D	T	Cartesian3D	T	Cartesian3D	): Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	Cartesian3D	T	Cartesian3D	T	Cartesian3D	T	Cartesian3D	): Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	FieldVector3D	): Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	FieldVector3D	T	FieldVector3D	): Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	FieldVector3D	T	FieldVector3D	T	FieldVector3D	): Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	FieldVector3D	T	FieldVector3D	T	FieldVector3D	T	FieldVector3D	): Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	T	): Simple constructor. Build a vector from its azimuthal coordinates
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T	T	T	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	T[]	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	double	FieldVector3D	): Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	double	FieldVector3D	double	FieldVector3D	): Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	double	FieldVector3D	double	FieldVector3D	double	FieldVector3D	): Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.FieldVector3D	(	double	FieldVector3D	double	FieldVector3D	double	FieldVector3D	double	FieldVector3D	): Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.add	(	Cartesian3D	): Add a vector to the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.add	(	FieldVector3D	): Add a vector to the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.add	(	T	Cartesian3D	): Add a scaled vector to the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.add	(	T	FieldVector3D	): Add a scaled vector to the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.add	(	double	Cartesian3D	): Add a scaled vector to the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.add	(	double	FieldVector3D	): Add a scaled vector to the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.angle	(	Cartesian3D	FieldVector3D	): Compute the angular separation between two vectors. This method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.angle	(	FieldVector3D	Cartesian3D	): Compute the angular separation between two vectors. This method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.angle	(	FieldVector3D	FieldVector3D	): Compute the angular separation between two vectors. This method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.crossProduct	(	Cartesian3D	): Compute the cross-product of the instance with another vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.crossProduct	(	Cartesian3D	FieldVector3D	): Compute the cross-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.crossProduct	(	FieldVector3D	): Compute the cross-product of the instance with another vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.crossProduct	(	FieldVector3D	Cartesian3D	): Compute the cross-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.crossProduct	(	FieldVector3D	FieldVector3D	): Compute the cross-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance	(	Cartesian3D	): Compute the distance between the instance and another vector according to the L2 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance	(	Cartesian3D	FieldVector3D	): Compute the distance between two vectors according to the L2 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance	(	FieldVector3D	): Compute the distance between the instance and another vector according to the L2 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance	(	FieldVector3D	Cartesian3D	): Compute the distance between two vectors according to the L2 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance	(	FieldVector3D	FieldVector3D	): Compute the distance between two vectors according to the L2 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance1	(	Cartesian3D	): Compute the distance between the instance and another vector according to the L1 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance1	(	Cartesian3D	FieldVector3D	): Compute the distance between two vectors according to the L1 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance1	(	FieldVector3D	): Compute the distance between the instance and another vector according to the L1 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance1	(	FieldVector3D	Cartesian3D	): Compute the distance between two vectors according to the L1 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distance1	(	FieldVector3D	FieldVector3D	): Compute the distance between two vectors according to the L1 norm. Calling this method is equivalent to calling: v1.subtract(v2).getNorm1() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceInf	(	Cartesian3D	): Compute the distance between the instance and another vector according to the L∞ norm. Calling this method is equivalent to calling: q.subtract(p).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceInf	(	Cartesian3D	FieldVector3D	): Compute the distance between two vectors according to the L∞ norm. Calling this method is equivalent to calling: v1.subtract(v2).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceInf	(	FieldVector3D	): Compute the distance between the instance and another vector according to the L∞ norm. Calling this method is equivalent to calling: q.subtract(p).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceInf	(	FieldVector3D	Cartesian3D	): Compute the distance between two vectors according to the L∞ norm. Calling this method is equivalent to calling: v1.subtract(v2).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceInf	(	FieldVector3D	FieldVector3D	): Compute the distance between two vectors according to the L∞ norm. Calling this method is equivalent to calling: v1.subtract(v2).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceSq	(	Cartesian3D	): Compute the square of the distance between the instance and another vector. Calling this method is equivalent to calling: q.subtract(p).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceSq	(	Cartesian3D	FieldVector3D	): Compute the square of the distance between two vectors. Calling this method is equivalent to calling: v1.subtract(v2).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceSq	(	FieldVector3D	): Compute the square of the distance between the instance and another vector. Calling this method is equivalent to calling: q.subtract(p).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceSq	(	FieldVector3D	Cartesian3D	): Compute the square of the distance between two vectors. Calling this method is equivalent to calling: v1.subtract(v2).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.distanceSq	(	FieldVector3D	FieldVector3D	): Compute the square of the distance between two vectors. Calling this method is equivalent to calling: v1.subtract(v2).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.dotProduct	(	Cartesian3D	): Compute the dot-product of the instance and another vector.  The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. 
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.dotProduct	(	Cartesian3D	FieldVector3D	): Compute the dot-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.dotProduct	(	FieldVector3D	): Compute the dot-product of the instance and another vector.  The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. 
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.dotProduct	(	FieldVector3D	Cartesian3D	): Compute the dot-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.dotProduct	(	FieldVector3D	FieldVector3D	): Compute the dot-product of two vectors.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.equals	(	Object	): Test for the equality of two 3D vectors.  If all coordinates of two 3D vectors are exactly the same, and none of their getReal() real part are NaN, the two 3D vectors are considered to be equal.   NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) real part of the coordinates of the 3D vector are NaN, the 3D vector is NaN. 
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getAlpha	(	): Get the azimuth of the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getDelta	(	): Get the elevation of the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getNorm	(	): Get the L2 norm for the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getNorm1	(	): Get the L1 norm for the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getNormInf	(	): Get the L∞ norm for the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getNormSq	(	): Get the square of the norm for the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getY	(	): Get the ordinate of the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.getZ	(	): Get the height of the vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.hashCode	(	): Get a hashCode for the 3D vector.  All NaN values have the same hash code.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.isInfinite	(	): Returns true if any coordinate of this vector is infinite and none are NaN; false otherwise
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.isNaN	(	): Returns true if any coordinate of this vector is NaN; false otherwise
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.negate	(	): Get the opposite of the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.normalize	(	): Get a normalized vector aligned with the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.orthogonal	(	): Get a vector orthogonal to the instance. There are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u :  Cartesian3D k = u.normalize(); Cartesian3D i = k.orthogonal(); Cartesian3D j = Cartesian3D.crossProduct(k, i); 
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.scalarMultiply	(	T	): Multiply the instance by a scalar.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.scalarMultiply	(	double	): Multiply the instance by a scalar.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.subtract	(	Cartesian3D	): Subtract a vector from the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.subtract	(	FieldVector3D	): Subtract a vector from the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.subtract	(	T	Cartesian3D	): Subtract a scaled vector from the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.subtract	(	T	FieldVector3D	): Subtract a scaled vector from the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.subtract	(	double	Cartesian3D	): Subtract a scaled vector from the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.subtract	(	double	FieldVector3D	): Subtract a scaled vector from the instance.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.toArray	(	): Get the vector coordinates as a dimension 3 array.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.toString	(	): Get a string representation of this vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.toString	(	NumberFormat	): Get a string representation of this vector.
org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D.toVector3D	(	): Convert to a constant vector without derivatives.
org.apache.commons.math4.geometry.euclidean.threed.Line: The class represent lines in a three dimensional space. Each oriented line is intrinsically associated with an abscissa which is a coordinate on the line. The point at abscissa 0 is the orthogonal projection of the origin on the line, another equivalent way to express this is to say that it is the point of the line which is closest to the origin. Abscissa increases in the line direction.
org.apache.commons.math4.geometry.euclidean.threed.Line.Line	(	Cartesian3D	Cartesian3D	double	): Build a line from two points.
org.apache.commons.math4.geometry.euclidean.threed.Line.Line	(	Line	): Copy constructor. The created instance is completely independent from the original instance, it is a deep copy.
org.apache.commons.math4.geometry.euclidean.threed.Line.closestPoint	(	Line	): Compute the point of the instance closest to another line.
org.apache.commons.math4.geometry.euclidean.threed.Line.contains	(	Cartesian3D	): Check if the instance contains a point.
org.apache.commons.math4.geometry.euclidean.threed.Line.distance	(	Cartesian3D	): Compute the distance between the instance and a point.
org.apache.commons.math4.geometry.euclidean.threed.Line.distance	(	Line	): Compute the shortest distance between the instance and another line.
org.apache.commons.math4.geometry.euclidean.threed.Line.getAbscissa	(	Cartesian3D	): Get the abscissa of a point with respect to the line. The abscissa is 0 if the projection of the point and the projection of the frame origin on the line are the same point.
org.apache.commons.math4.geometry.euclidean.threed.Line.getDirection	(	): Get the normalized direction vector.
org.apache.commons.math4.geometry.euclidean.threed.Line.getOrigin	(	): Get the line point closest to the origin.
org.apache.commons.math4.geometry.euclidean.threed.Line.getTolerance	(	): Get the tolerance below which points are considered identical.
org.apache.commons.math4.geometry.euclidean.threed.Line.intersection	(	Line	): Get the intersection point of the instance and another line.
org.apache.commons.math4.geometry.euclidean.threed.Line.isSimilarTo	(	Line	): Check if the instance is similar to another line. Lines are considered similar if they contain the same points. This does not mean they are equal since they can have opposite directions.
org.apache.commons.math4.geometry.euclidean.threed.Line.pointAt	(	double	): Get one point from the line.
org.apache.commons.math4.geometry.euclidean.threed.Line.reset	(	Cartesian3D	Cartesian3D	): Reset the instance as if built from two points.
org.apache.commons.math4.geometry.euclidean.threed.Line.revert	(	): Get a line with reversed direction.
org.apache.commons.math4.geometry.euclidean.threed.Line.toSpace	(	Cartesian1D	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.euclidean.threed.Line.toSpace	(	Point	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.euclidean.threed.Line.toSpace	(	Vector	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.euclidean.threed.Line.toSubSpace	(	Cartesian3D	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.euclidean.threed.Line.toSubSpace	(	Point	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.euclidean.threed.Line.toSubSpace	(	Vector	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.euclidean.threed.Line.wholeLine	(	): Build a sub-line covering the whole line.
org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException: This class represents exceptions thrown while building rotations from matrices.
org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException.NotARotationMatrixException	(	Localizable	Object	): Simple constructor. Build an exception by translating and formating a message
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor: Extractor for PolygonsSet polyhedrons sets outlines. This class extracts the 2D outlines from {PolygonsSet polyhedrons sets in a specified projection plane.
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector: Visitor projecting the boundary facets on a plane. 
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector.BoundaryProjector	(	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector.addContribution	(	SubHyperplane	boolean	): Add he contribution of a boundary facet.
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector.getProjected	(	): Get the projection of the polyhedrons set on the plane.
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.BoundaryProjector.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.OutlineExtractor	(	Cartesian3D	Cartesian3D	): Build an extractor for a specific projection plane.
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.getOutline	(	PolyhedronsSet	): Extract the outline of a polyhedrons set.
org.apache.commons.math4.geometry.euclidean.threed.OutlineExtractor.pointIsBetween	(	Cartesian2D[]	int	int	): Check if a point is geometrically between its neighbor in an array. The neighbors are computed considering the array is a loop (i.e. point at index (n-1) is before point at index 0)
org.apache.commons.math4.geometry.euclidean.threed.PLYParser: This class is a small and incomplete parser for PLY files.  This parser is only intended for test purposes, it does not parse the full header, it does not handle all properties, it has rudimentary error handling. 
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.Field: Parsed line fields. 
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.Field.Field	(	String	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.Field.getToken	(	): Get the recognized token.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.Field.getValue	(	): Get the field value.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.PLYParser	(	InputStream	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.complain	(	): Complain about a bad line.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.getFaces	(	): Get the parsed faces.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.getVertices	(	): Get the parsed vertices.
org.apache.commons.math4.geometry.euclidean.threed.PLYParser.parseNextLine	(	): Parse next line.
org.apache.commons.math4.geometry.euclidean.threed.Plane: The class represent planes in a three dimensional space.
org.apache.commons.math4.geometry.euclidean.threed.Plane.Plane	(	Cartesian3D	Cartesian3D	Cartesian3D	double	): Build a plane from three points. The plane is oriented in the direction of (p2-p1) ^ (p3-p1)
org.apache.commons.math4.geometry.euclidean.threed.Plane.Plane	(	Cartesian3D	Cartesian3D	double	): Build a plane from a point and a normal.
org.apache.commons.math4.geometry.euclidean.threed.Plane.Plane	(	Cartesian3D	double	): Build a plane normal to a given direction and containing the origin.
org.apache.commons.math4.geometry.euclidean.threed.Plane.Plane	(	Plane	): Copy constructor. The instance created is completely independent of the original one. A deep copy is used, none of the underlying object are shared.
org.apache.commons.math4.geometry.euclidean.threed.Plane.contains	(	Cartesian3D	): Check if the instance contains a point.
org.apache.commons.math4.geometry.euclidean.threed.Plane.copySelf	(	): Copy the instance. The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for immutable objects).
org.apache.commons.math4.geometry.euclidean.threed.Plane.getNormal	(	): Get the normalized normal vector. The frame defined by (getU, getV, getNormal) is a rigth-handed orthonormalized frame).
org.apache.commons.math4.geometry.euclidean.threed.Plane.getOffset	(	Plane	): Get the offset (oriented distance) of a parallel plane. This method should be called only for parallel planes otherwise the result is not meaningful. The offset is 0 if both planes are the same, it is positive if the plane is on the plus side of the instance and negative if it is on the minus side, according to its natural orientation.
org.apache.commons.math4.geometry.euclidean.threed.Plane.getOffset	(	Point	): Get the offset (oriented distance) of a point. The offset is 0 if the point is on the underlying hyperplane, it is positive if the point is on one particular side of the hyperplane, and it is negative if the point is on the other side, according to the hyperplane natural orientation.
org.apache.commons.math4.geometry.euclidean.threed.Plane.getOrigin	(	): Get the origin point of the plane frame. The point returned is the orthogonal projection of the 3D-space origin in the plane.
org.apache.commons.math4.geometry.euclidean.threed.Plane.getPointAt	(	Cartesian2D	double	): Get one point from the 3D-space.
org.apache.commons.math4.geometry.euclidean.threed.Plane.getTolerance	(	): Get the tolerance below which points are considered to belong to the hyperplane.
org.apache.commons.math4.geometry.euclidean.threed.Plane.getU	(	): Get the plane first canonical vector. The frame defined by (getU, getV, getNormal) is a rigth-handed orthonormalized frame).
org.apache.commons.math4.geometry.euclidean.threed.Plane.getV	(	): Get the plane second canonical vector. The frame defined by (getU, getV, getNormal) is a rigth-handed orthonormalized frame).
org.apache.commons.math4.geometry.euclidean.threed.Plane.intersection	(	Line	): Get the intersection of a line with the instance.
org.apache.commons.math4.geometry.euclidean.threed.Plane.intersection	(	Plane	): Build the line shared by the instance and another plane.
org.apache.commons.math4.geometry.euclidean.threed.Plane.intersection	(	Plane	Plane	Plane	): Get the intersection point of three planes.
org.apache.commons.math4.geometry.euclidean.threed.Plane.isSimilarTo	(	Plane	): Check if the instance is similar to another plane. Planes are considered similar if they contain the same points. This does not mean they are equal since they can have opposite normals.
org.apache.commons.math4.geometry.euclidean.threed.Plane.project	(	Point	): Project a point to the hyperplane.
org.apache.commons.math4.geometry.euclidean.threed.Plane.reset	(	Cartesian3D	Cartesian3D	): Reset the instance as if built from a point and a normal.
org.apache.commons.math4.geometry.euclidean.threed.Plane.reset	(	Plane	): Reset the instance from another one. The updated instance is completely independant of the original one. A deep reset is used none of the underlying object is shared.
org.apache.commons.math4.geometry.euclidean.threed.Plane.revertSelf	(	): Revert the plane. Replace the instance by a similar plane with opposite orientation. The new plane frame is chosen in such a way that a 3D point that had (x, y) in-plane coordinates and z offset with respect to the plane and is unaffected by the change will have (y, x) in-plane coordinates and -z offset with respect to the new plane. This means that the u and v vectors returned by the getU and getV methods are exchanged, and the w vector returned by the getNormal method is reversed.
org.apache.commons.math4.geometry.euclidean.threed.Plane.rotate	(	Cartesian3D	Rotation	): Rotate the plane around the specified point. The instance is not modified, a new instance is created.
org.apache.commons.math4.geometry.euclidean.threed.Plane.sameOrientationAs	(	Hyperplane	): Check if the instance has the same orientation as another hyperplane.
org.apache.commons.math4.geometry.euclidean.threed.Plane.setFrame	(	): Reset the plane frame.
org.apache.commons.math4.geometry.euclidean.threed.Plane.setNormal	(	Cartesian3D	): Set the normal vactor.
org.apache.commons.math4.geometry.euclidean.threed.Plane.toSpace	(	Cartesian2D	): Transform an in-plane point into a 3D space point.
org.apache.commons.math4.geometry.euclidean.threed.Plane.toSpace	(	Point	): Transform an in-plane point into a 3D space point.
org.apache.commons.math4.geometry.euclidean.threed.Plane.toSpace	(	Vector	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.euclidean.threed.Plane.toSubSpace	(	Cartesian3D	): Transform a 3D space point into an in-plane point.
org.apache.commons.math4.geometry.euclidean.threed.Plane.toSubSpace	(	Point	): Transform a 3D space point into an in-plane point.
org.apache.commons.math4.geometry.euclidean.threed.Plane.toSubSpace	(	Vector	): Transform a space vector into a sub-space vector.
org.apache.commons.math4.geometry.euclidean.threed.Plane.translate	(	Cartesian3D	): Translate the plane by the specified amount. The instance is not modified, a new instance is created.
org.apache.commons.math4.geometry.euclidean.threed.Plane.wholeHyperplane	(	): Build a region covering the whole hyperplane.
org.apache.commons.math4.geometry.euclidean.threed.Plane.wholeSpace	(	): Build a region covering the whole space.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet: This class represents a 3D region: a set of polyhedrons.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor: Visitor computing geometrical properties. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.FacetsContributionVisitor	(	): Simple constructor. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.addContribution	(	SubHyperplane	boolean	): Add he contribution of a boundary facet.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet	(	BSPTree	double	): Build a polyhedrons set from a BSP tree. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE  This constructor is aimed at expert use, as building the tree may be a difficult task. It is not intended for general use and for performances reasons does not check thoroughly its input, as this would require walking the full tree each time. Failing to provide a tree with the proper attributes, will therefore generate problems like NullPointerException or ClassCastException only later on. This limitation is known and explains why this constructor is for expert use only. The caller does have the responsibility to provided correct arguments. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet	(	Collection	double	): Build a polyhedrons set from a Boundary REPresentation (B-rep) specified by sub-hyperplanes. The boundary is provided as a collection of SubHyperplane sub-hyperplanes. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side. The boundary elements can be in any order, and can form several non-connected sets (like for example polyhedrons with holes or a set of disjoint polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the checkPoint() method will not be meaningful anymore. If the boundary is empty, the region will represent the whole space.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet	(	List	List	double	): Build a polyhedrons set from a Boundary REPresentation (B-rep) specified by connected vertices.  The boundary is provided as a list of vertices and a list of facets. Each facet is specified as an integer array containing the arrays vertices indices in the vertices list. Each facet normal is oriented by right hand rule to the facet vertices list.   Some basic sanity checks are performed but not everything is thoroughly assessed, so it remains under caller responsibility to ensure the vertices and facets are consistent and properly define a polyhedrons set. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet	(	double	): Build a polyhedrons set representing the whole real line.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet	(	double	double	double	double	double	double	double	): Build a parallellepipedic box.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.RotationTransform: 3D rotation as a Transform. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.RotationTransform.RotationTransform	(	Cartesian3D	Rotation	): Build a rotation transform.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.RotationTransform.apply	(	Hyperplane	): Transform an hyperplane of a space. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.RotationTransform.apply	(	Point	): Transform a point of a space. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.RotationTransform.apply	(	SubHyperplane	Hyperplane	Hyperplane	): Transform a sub-hyperplane embedded in an hyperplane. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.TranslationTransform: 3D translation as a transform. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.TranslationTransform.TranslationTransform	(	Cartesian3D	): Build a translation transform.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.TranslationTransform.apply	(	Hyperplane	): Transform an hyperplane of a space. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.TranslationTransform.apply	(	Point	): Transform a point of a space. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.TranslationTransform.apply	(	SubHyperplane	Hyperplane	Hyperplane	): Transform a sub-hyperplane embedded in an hyperplane. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.boundaryFacet	(	Cartesian3D	BSPTree	): Check if a point belongs to the boundary part of a node.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.buildBoundary	(	List	List	double	): Build boundary from vertices and facets.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.buildBoundary	(	double	double	double	double	double	double	double	): Build a parallellepipedic box boundary.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).  
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.computeGeometricalProperties	(	): Compute some geometrical properties. The properties to compute are the barycenter and the size. 
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.findReferences	(	List	List	): Find the facets that reference each edges.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.firstIntersection	(	Cartesian3D	Line	): Get the first sub-hyperplane crossed by a semi-infinite line.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.recurseFirstIntersection	(	BSPTree	Cartesian3D	Line	): Get the first sub-hyperplane crossed by a semi-infinite line.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.rotate	(	Cartesian3D	Rotation	): Rotate the region around the specified point. The instance is not modified, a new instance is created.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.successors	(	List	List	int[][]	): Find the successors of all vertices among all facets they belong to.
org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSet.translate	(	Cartesian3D	): Translate the region by the specified amount. The instance is not modified, a new instance is created.
org.apache.commons.math4.geometry.euclidean.threed.Rotation: This class implements rotations in a three-dimensional space. Rotations can be represented by several different mathematical entities (matrices, axe and angle, Cardan or Euler angles, quaternions). This class presents an higher level abstraction, more user-oriented and hiding this implementation details. Well, for the curious, we use quaternions for the internal representation. The user can build a rotation from any of these representations, and any of these representations can be retrieved from a Rotation instance (see the various constructors and getters). In addition, a rotation can also be built implicitly from a set of vectors and their image. This implies that this class can be used to convert from one representation to another one. For example, converting a rotation matrix into a set of Cardan angles from can be done using the following single line of code:  double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);  Focus is oriented on what a rotation do rather than on its underlying representation. Once it has been built, and regardless of its internal representation, a rotation is an operator which basically transforms three dimensional Cartesian3D vectors into other three dimensional Cartesian3D vectors. Depending on the application, the meaning of these vectors may vary and the semantics of the rotation also. For example in an spacecraft attitude simulation tool, users will often consider the vectors are fixed (say the Earth direction for example) and the frames change. The rotation transforms the coordinates of the vector in inertial frame into the coordinates of the same vector in satellite frame. In this case, the rotation implicitly defines the relation between the two frames. Another example could be a telescope control application, where the rotation would transform the sighting direction at rest into the desired observing direction when the telescope is pointed towards an object of interest. In this case the rotation transforms the direction at rest in a topocentric frame into the sighting direction in the same topocentric frame. This implies in this case the frame is fixed and the vector moves. In many case, both approaches will be combined. In our telescope example, we will probably also need to transform the observing direction in the topocentric frame into the observing direction in inertial frame taking into account the observatory location and the Earth rotation, which would essentially be an application of the first approach. These examples show that a rotation is what the user wants it to be. This class does not push the user towards one specific definition and hence does not provide methods like projectVectorIntoDestinationFrame or computeTransformedDirection. It provides simpler and more generic methods: applyTo() applyTo(Cartesian3D) and applyInverseTo() applyInverseTo(Cartesian3D). Since a rotation is basically a vectorial operator, several rotations can be composed together and the composite operation r = r1 o r2 (which means that for each vector u, r(u) = r1(r2(u))) is also a rotation. Hence we can consider that in addition to vectors, a rotation can be applied to other rotations as well (or to itself). With our previous notations, we would say we can apply r1 to r2 and the result we get is r = r1 o r2. For this purpose, the class provides the methods: applyTo() applyTo(Rotation) and applyInverseTo() applyInverseTo(Rotation). Rotations are guaranteed to be immutable objects.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	Cartesian3D	Cartesian3D	): Build one of the rotations that transform one vector into another one. Except for a possible scale factor, if the instance were applied to the vector u it will produce the vector v. There is an infinite number of such rotations, this constructor choose the one with the smallest associated angle (i.e. the one whose axis is orthogonal to the (u, v) plane). If u and v are collinear, an arbitrary rotation axis is chosen.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	Cartesian3D	Cartesian3D	Cartesian3D	Cartesian3D	): Build the rotation that transforms a pair of vectors into another pair. Except for possible scale factors, if the instance were applied to the pair (u1, u2) it will produce the pair (v1, v2). If the angular separation between u1 and u2 is not the same as the angular separation between v1 and v2, then a corrected v'2 will be used rather than v2, the corrected vector will be in the (±v1, +v2) half-plane.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	Cartesian3D	double	): Build a rotation from an axis and an angle.  Calling this constructor is equivalent to call Rotation() new Rotation(axis, angle, RotationConvention.VECTOR_OPERATOR) 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	Cartesian3D	double	RotationConvention	): Build a rotation from an axis and an angle.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	RotationOrder	RotationConvention	double	double	double	): Build a rotation from three Cardan or Euler elementary rotations. Cardan rotations are three successive rotations around the canonical axes X, Y and Z, each axis being used once. There are 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler rotations are three successive rotations around the canonical axes X, Y and Z, the first and last rotations being around the same axis. There are 6 such sets of rotations (XYX, XZX, YXY, YZY, ZXZ and ZYZ), the most popular one being ZXZ. Beware that many people routinely use the term Euler angles even for what really are Cardan angles (this confusion is especially widespread in the aerospace business where Roll, Pitch and Yaw angles are often wrongly tagged as Euler angles).
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	RotationOrder	double	double	double	): Build a rotation from three Cardan or Euler elementary rotations.  Calling this constructor is equivalent to call Rotation() new Rotation(order, RotationConvention.VECTOR_OPERATOR, alpha1, alpha2, alpha3) 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	double	double	double	double	boolean	): Build a rotation from the quaternion coordinates. A rotation can be built from a normalized quaternion, i.e. a quaternion for which q02 + q12 + q22 + q32 = 1. If the quaternion is not normalized, the constructor can normalize it in a preprocessing step. Note that some conventions put the scalar part of the quaternion as the 4th component and the vector part as the first three components. This is not our convention. We put the scalar part as the first component.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.Rotation	(	double[][]	double	): Build a rotation from a 3X3 matrix. Rotation matrices are orthogonal matrices, i.e. unit matrices (which are matrices for which m.mT = I) with real coefficients. The module of the determinant of unit matrices is 1, among the orthogonal 3X3 matrices, only the ones having a positive determinant (+1) are rotation matrices. When a rotation is defined by a matrix with truncated values (typically when it is extracted from a technical sheet where only four to five significant digits are available), the matrix is not orthogonal anymore. This constructor handles this case transparently by using a copy of the given matrix and applying a correction to the copy in order to perfect its orthogonality. If the Frobenius norm of the correction needed is above the given threshold, then the matrix is considered to be too far from a true rotation matrix and an exception is thrown.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.applyInverseTo	(	Cartesian3D	): Apply the inverse of the rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.applyInverseTo	(	Rotation	): Apply the inverse of the instance to another rotation.  Calling this method is equivalent to call composeInverse() composeInverse(r, RotationConvention.VECTOR_OPERATOR). 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.applyInverseTo	(	double[]	double[]	): Apply the inverse of the rotation to a vector stored in an array.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.applyTo	(	Cartesian3D	): Apply the rotation to a vector.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.applyTo	(	Rotation	): Apply the instance to another rotation.  Calling this method is equivalent to call compose() compose(r, RotationConvention.VECTOR_OPERATOR). 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.applyTo	(	double[]	double[]	): Apply the rotation to a vector stored in an array.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.compose	(	Rotation	RotationConvention	): Compose the instance with another rotation.  If the semantics of the rotations composition corresponds to a VECTOR_OPERATOR vector operator convention, applying the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r1 (i.e. r1.applyTo(u) = v). Let w be the image of v by rotation r2 (i.e. r2.applyTo(v) = w). Then w = comp.applyTo(u), where comp = r2.compose(r1, RotationConvention.VECTOR_OPERATOR).   If the semantics of the rotations composition corresponds to a FRAME_TRANSFORM frame transform convention, the application order will be reversed. So keeping the exact same meaning of all r1, r2, u, v, w and comp as above, comp could also be computed as comp = r1.compose(r2, RotationConvention.FRAME_TRANSFORM). 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.composeInternal	(	Rotation	): Compose the instance with another rotation using vector operator convention.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.composeInverse	(	Rotation	RotationConvention	): Compose the inverse of the instance with another rotation.  If the semantics of the rotations composition corresponds to a VECTOR_OPERATOR vector operator convention, applying the inverse of the instance to a rotation is computing the composition in an order compliant with the following rule : let u be any vector and v its image by r1 (i.e. r1.applyTo(u) = v). Let w be the inverse image of v by r2 (i.e. r2.applyInverseTo(v) = w). Then w = comp.applyTo(u), where comp = r2.composeInverse(r1).   If the semantics of the rotations composition corresponds to a FRAME_TRANSFORM frame transform convention, the application order will be reversed, which means it is the innermost rotation that will be reversed. So keeping the exact same meaning of all r1, r2, u, v, w and comp as above, comp could also be computed as comp = r1.revert().composeInverse(r2.revert(), RotationConvention.FRAME_TRANSFORM). 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.composeInverseInternal	(	Rotation	): Compose the inverse of the instance with another rotation using vector operator convention.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.distance	(	Rotation	Rotation	): Compute the distance between two rotations. The distance is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:  r1(r) = r2  This distance is an angle between 0 and π. Its value is the smallest possible upper bound of the angle in radians between r1(v) and r2(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical. Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getAngle	(	): Get the angle of the rotation.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getAngles	(	RotationOrder	): Get the Cardan or Euler angles corresponding to the instance.  Calling this method is equivalent to call getAngles() getAngles(order, RotationConvention.VECTOR_OPERATOR) 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getAngles	(	RotationOrder	RotationConvention	): Get the Cardan or Euler angles corresponding to the instance. The equations show that each rotation can be defined by two different values of the Cardan or Euler angles set. For example if Cardan angles are used, the rotation defined by the angles a1, a2 and a3 is the same as the rotation defined by the angles π + a1, π - a2 and π + a3. This method implements the following arbitrary choices:  for Cardan angles, the chosen set is the one for which the second angle is between -π/2 and π/2 (i.e its cosine is positive), for Euler angles, the chosen set is the one for which the second angle is between 0 and π (i.e its sine is positive).  Cardan and Euler angle have a very disappointing drawback: all of them have singularities. This means that if the instance is too close to the singularities corresponding to the given rotation order, it will be impossible to retrieve the angles. For Cardan angles, this is often called gimbal lock. There is nothing to do to prevent this, it is an intrinsic problem with Cardan and Euler representation (but not a problem with the rotation itself, which is perfectly well defined). For Cardan angles, singularities occur when the second angle is close to -π/2 or +π/2, for Euler angle singularities occur when the second angle is close to 0 or π, this implies that the identity rotation is always singular for Euler angles!
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getAxis	(	): Get the normalized axis of the rotation.  Calling this method is equivalent to call getAxis() getAxis(RotationConvention.VECTOR_OPERATOR) 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getAxis	(	RotationConvention	): Get the normalized axis of the rotation.  Note that as getAngle() always returns an angle between 0 and π, changing the convention changes the direction of the axis, not the sign of the angle. 
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getMatrix	(	): Get the 3X3 matrix corresponding to the instance
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getQ0	(	): Get the scalar coordinate of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getQ1	(	): Get the first coordinate of the vectorial part of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getQ2	(	): Get the second coordinate of the vectorial part of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.getQ3	(	): Get the third coordinate of the vectorial part of the quaternion.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.mat2quat	(	double[][]	): Convert an orthogonal rotation matrix to a quaternion.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.orthogonalizeMatrix	(	double[][]	double	): Perfect orthogonality on a 3X3 matrix.
org.apache.commons.math4.geometry.euclidean.threed.Rotation.revert	(	): Revert a rotation. Build a rotation which reverse the effect of another rotation. This means that if r(u) = v, then r.revert(v) = u. The instance is not changed.
org.apache.commons.math4.geometry.euclidean.threed.RotationOrder: This class is a utility representing a rotation order specification for Cardan or Euler angles specification. This class cannot be instanciated by the user. He can only use one of the twelve predefined supported orders as an argument to either the Rotation() constructor or the getAngles method.
org.apache.commons.math4.geometry.euclidean.threed.RotationOrder.RotationOrder	(	String	Cartesian3D	Cartesian3D	Cartesian3D	): Private constructor. This is a utility class that cannot be instantiated by the user, so its only constructor is private.
org.apache.commons.math4.geometry.euclidean.threed.RotationOrder.getA1	(	): Get the axis of the first rotation.
org.apache.commons.math4.geometry.euclidean.threed.RotationOrder.getA2	(	): Get the axis of the second rotation.
org.apache.commons.math4.geometry.euclidean.threed.RotationOrder.getA3	(	): Get the axis of the second rotation.
org.apache.commons.math4.geometry.euclidean.threed.RotationOrder.toString	(	): Get a string representation of the instance.
org.apache.commons.math4.geometry.euclidean.threed.Segment: Simple container for a two-points segment.
org.apache.commons.math4.geometry.euclidean.threed.Segment.Segment	(	Cartesian3D	Cartesian3D	Line	): Build a segment.
org.apache.commons.math4.geometry.euclidean.threed.Segment.getEnd	(	): Get the end point of the segment.
org.apache.commons.math4.geometry.euclidean.threed.Segment.getLine	(	): Get the line containing the segment.
org.apache.commons.math4.geometry.euclidean.threed.Segment.getStart	(	): Get the start point of the segment.
org.apache.commons.math4.geometry.euclidean.threed.SphereGenerator: Class generating an enclosing ball from its support points.
org.apache.commons.math4.geometry.euclidean.threed.SphereGenerator.ballOnSupport	(	List	): Create a ball whose boundary lies on prescribed support points. 
org.apache.commons.math4.geometry.euclidean.threed.SphereGenerator.minor	(	BigFraction[]	BigFraction[]	BigFraction[]	): Compute a dimension 4 minor, when 4th column is known to be filled with 1.0.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates: This class provides conversions related to spherical coordinates.  The conventions used here are the mathematical ones, i.e. spherical coordinates are related to Cartesian coordinates as follows:   x = r cos(θ) sin(Φ) y = r sin(θ) sin(Φ) z = r cos(Φ)   r = √(x2+y2+z2) θ = atan2(y, x) Φ = acos(z/r)   r is the radius, θ is the azimuthal angle in the x-y plane and Φ is the polar (co-latitude) angle. These conventions are different from the conventions used in physics (and in particular in spherical harmonics) where the meanings of θ and Φ are reversed.   This class provides conversion of coordinates and also of gradient and Hessian between spherical and Cartesian coordinates. 
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.DataTransferObject: Internal class used only for serialization. 
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.DataTransferObject.DataTransferObject	(	double	double	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.DataTransferObject.readResolve	(	): Replace the deserialized data transfer object with a SphericalCoordinates.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.SphericalCoordinates	(	Cartesian3D	): Build a spherical coordinates transformer from Cartesian coordinates.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.SphericalCoordinates	(	double	double	double	): Build a spherical coordinates transformer from spherical coordinates.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.computeHessians	(	): Lazy evaluation of Hessians.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.computeJacobian	(	): Lazy evaluation of (r, θ, φ) Jacobian.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.getCartesian	(	): Get the Cartesian coordinates.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.getPhi	(	): Get the polar (co-latitude) angle.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.getR	(	): Get the radius.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.getTheta	(	): Get the azimuthal angle in x-y plane.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.toCartesianGradient	(	double[]	): Convert a gradient with respect to spherical coordinates into a gradient with respect to Cartesian coordinates.
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.toCartesianHessian	(	double[][]	double[]	): Convert a Hessian with respect to spherical coordinates into a Hessian with respect to Cartesian coordinates.  As Hessian are always symmetric, we use only the lower left part of the provided spherical Hessian, so the upper part may not be initialized. However, we still do fill up the complete array we create, with guaranteed symmetry. 
org.apache.commons.math4.geometry.euclidean.threed.SphericalCoordinates.writeReplace	(	): Replace the instance with a data transfer object for serialization.
org.apache.commons.math4.geometry.euclidean.threed.SubLine: This class represents a subset of a Line.
org.apache.commons.math4.geometry.euclidean.threed.SubLine.SubLine	(	Cartesian3D	Cartesian3D	double	): Create a sub-line from two endpoints.
org.apache.commons.math4.geometry.euclidean.threed.SubLine.SubLine	(	Line	IntervalsSet	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.threed.SubLine.SubLine	(	Segment	): Create a sub-line from a segment.
org.apache.commons.math4.geometry.euclidean.threed.SubLine.buildIntervalSet	(	Cartesian3D	Cartesian3D	double	): Build an interval set from two points.
org.apache.commons.math4.geometry.euclidean.threed.SubLine.getSegments	(	): Get the endpoints of the sub-line.  A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. 
org.apache.commons.math4.geometry.euclidean.threed.SubLine.intersection	(	SubLine	boolean	): Get the intersection of the instance and another sub-line.  This method is related to the intersection() method in the Line Line class, but in addition to compute the point along infinite lines, it also checks the point lies on both sub-line ranges. 
org.apache.commons.math4.geometry.euclidean.threed.SubPlane: This class represents a sub-hyperplane for Plane.
org.apache.commons.math4.geometry.euclidean.threed.SubPlane.SubPlane	(	Hyperplane	Region	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.threed.SubPlane.buildNew	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region. 
org.apache.commons.math4.geometry.euclidean.threed.SubPlane.split	(	Hyperplane	): Split the instance in two parts by an hyperplane.
org.apache.commons.math4.geometry.euclidean.threed.Vector3D: This class implements vectors in a three-dimensional space.
org.apache.commons.math4.geometry.euclidean.threed.Vector3D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Vector3D.getY	(	): Get the ordinate of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Vector3D.getZ	(	): Get the height of the vector.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat: Formats a 3D vector in components list format "{x; y; z}". The prefix and suffix "{" and "}" and the separator "; " can be replaced by any user-defined strings. The number format for components can be configured. White space is ignored at parse time, even if it is in the prefix, suffix or separator specifications. So even if the default separator does include a space character that is used at format time, both input string "{1;1;1}" and " { 1 ; 1 ; 1 } " will be parsed without error and the same vector will be returned. In the second case, however, the parse position after parsing will be just after the closing curly brace, i.e. just before the trailing space. Note: using "," as a separator may interfere with the grouping separator of the default NumberFormat for the current locale. Thus it is advised to use a NumberFormat instance with disabled grouping in such a case.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.Vector3DFormat	(	): Create an instance with default settings. The instance uses the default prefix, suffix and separator: "{", "}", and "; " and the default number format for components.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.Vector3DFormat	(	NumberFormat	): Create an instance with a custom number format for components.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.Vector3DFormat	(	String	String	String	): Create an instance with custom prefix, suffix and separator.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.Vector3DFormat	(	String	String	String	NumberFormat	): Create an instance with custom prefix, suffix, separator and format for components.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.format	(	Vector	StringBuffer	FieldPosition	): Formats a Vector3D object to produce a string.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.getInstance	(	): Returns the default 3D vector format for the current locale.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.getInstance	(	Locale	): Returns the default 3D vector format for the given locale.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.parse	(	String	): Parses a string to produce a Vector3D object.
org.apache.commons.math4.geometry.euclidean.threed.Vector3DFormat.parse	(	String	ParsePosition	): Parses a string to produce a Vector3D object.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D: This class represents a 2D point or a 2D vector. An instance of Cartesian2D represents the point with the corresponding coordinates. An instance of Cartesian2D also represents the vector which begins at the origin and ends at the point corresponding to the coordinates. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.Cartesian2D	(	double	Cartesian2D	): Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.Cartesian2D	(	double	Cartesian2D	double	Cartesian2D	): Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.Cartesian2D	(	double	Cartesian2D	double	Cartesian2D	double	Cartesian2D	): Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.Cartesian2D	(	double	Cartesian2D	double	Cartesian2D	double	Cartesian2D	double	Cartesian2D	): Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.Cartesian2D	(	double	double	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.Cartesian2D	(	double[]	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.add	(	Vector	): Add a vector to the instance. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.add	(	double	Vector	): Add a scaled vector to the instance. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.angle	(	Cartesian2D	Cartesian2D	): Compute the angular separation between two vectors. This method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.crossProduct	(	Cartesian2D	Cartesian2D	): Compute the cross-product of the instance and the given vector.  The cross product can be used to determine the location of a point with regard to the line formed by (p1, p2) and is calculated as: \[ P = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1) \] with \(p3 = (x_3, y_3)\) being this instance.  If the result is 0, the points are collinear, i.e. lie on a single straight line L; if it is positive, this point lies to the left, otherwise to the right of the line formed by (p1, p2).
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distance	(	Cartesian2D	): Compute the distance between the instance and other coordinates.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distance	(	Cartesian2D	Cartesian2D	): Compute the distance between two points according to the L2 norm. Calling this method is equivalent to calling: p1.subtract(p2).getNorm() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distance	(	Point	): Compute the distance between the instance and another point. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distance	(	Vector	): Compute the distance between the instance and another vector. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distance1	(	Vector	): Compute the distance between the instance and another vector according to the L1 norm. Calling this method is equivalent to calling: q.subtract(p).getNorm1() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distanceInf	(	Cartesian2D	Cartesian2D	): Compute the distance between two points according to the L∞ norm. Calling this method is equivalent to calling: p1.subtract(p2).getNormInf() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distanceInf	(	Vector	): Compute the distance between the instance and another vector according to the L∞ norm. Calling this method is equivalent to calling: q.subtract(p).getNormInf() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distanceSq	(	Cartesian2D	Cartesian2D	): Compute the square of the distance between two points. Calling this method is equivalent to calling: p1.subtract(p2).getNormSq() except that no intermediate vector is built
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.distanceSq	(	Vector	): Compute the square of the distance between the instance and another vector. Calling this method is equivalent to calling: q.subtract(p).getNormSq() except that no intermediate vector is built 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.dotProduct	(	Vector	): Compute the dot-product of the instance and another vector. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.equals	(	Object	): Test for the equality of two 2D instances.  If all coordinates of two 2D vectors are exactly the same, and none are Double.NaN, the two 2D instances are considered to be equal.   NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 2D vector are equal to Double.NaN, the 2D vector is equal to NaN. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getNorm	(	): Get the L2 norm for the vector. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getNorm1	(	): Get the L1 norm for the vector. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getNormInf	(	): Get the L∞ norm for the vector. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getNormSq	(	): Get the square of the norm for the vector. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getSpace	(	): Get the space to which the point belongs. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getY	(	): Get the ordinate of the vector.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.getZero	(	): Get the null vector of the vectorial space or origin point of the affine space. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.hashCode	(	): Get a hashCode for the 2D coordinates.  All NaN values have the same hash code.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.isInfinite	(	): Returns true if any coordinate of this vector is infinite and none are NaN; false otherwise 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.negate	(	): Get the opposite of the instance. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.normalize	(	): Get a normalized vector aligned with the instance. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.scalarMultiply	(	double	): Multiply the instance by a scalar. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.subtract	(	Vector	): Subtract a vector from the instance. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.subtract	(	double	Vector	): Subtract a scaled vector from the instance. 
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.toArray	(	): Get the vector coordinates as a dimension 2 array.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.toString	(	): Get a string representation of this vector.
org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D.toString	(	NumberFormat	): Get a string representation of this vector. 
org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator: Class generating an enclosing ball from its support points.
org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator.ballOnSupport	(	List	): Create a ball whose boundary lies on prescribed support points. 
org.apache.commons.math4.geometry.euclidean.twod.DiskGenerator.minor	(	BigFraction[]	BigFraction[]	): Compute a dimension 3 minor, when 3d column is known to be filled with 1.0.
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D: This class implements a two-dimensional space.
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D.Euclidean2D	(	): Private constructor for the singleton.
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D.getDimension	(	): Get the dimension of the space. 
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D.getInstance	(	): Get the unique instance.
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D.getSubSpace	(	): Get the n-1 dimension subspace of this space. 
org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.geometry.euclidean.twod.Line: This class represents an oriented line in the 2D plane. An oriented line can be defined either by prolongating a line segment between two points past these points, or by one point and an angular direction (in trigonometric orientation). Since it is oriented the two half planes at its two sides are unambiguously identified as a left half plane and a right half plane. This can be used to identify the interior and the exterior in a simple way by local properties only when part of a line is used to define part of a polygon boundary. A line can also be used to completely define a reference frame in the plane. It is sufficient to select one specific point in the line (the orthogonal projection of the original reference frame on the line) and to use the unit vector in the line direction and the orthogonal vector oriented from left half plane to right half plane. We define two coordinates by the process, the abscissa along the line, and the offset across the line. All points of the plane are uniquely identified by these two coordinates. The line is the set of points at zero offset, the left half plane is the set of points with negative offsets and the right half plane is the set of points with positive offsets.
org.apache.commons.math4.geometry.euclidean.twod.Line.Line	(	Cartesian2D	Cartesian2D	double	): Build a line from two points. The line is oriented from p1 to p2
org.apache.commons.math4.geometry.euclidean.twod.Line.Line	(	Cartesian2D	double	double	): Build a line from a point and an angle.
org.apache.commons.math4.geometry.euclidean.twod.Line.Line	(	Line	): Copy constructor. The created instance is completely independent from the original instance, it is a deep copy.
org.apache.commons.math4.geometry.euclidean.twod.Line.Line	(	double	double	double	double	double	): Build a line from its internal characteristics.
org.apache.commons.math4.geometry.euclidean.twod.Line.LineTransform: Class embedding an affine transform. This class is used in order to apply an affine transform to a line. Using a specific object allow to perform some computations on the transform only once even if the same transform is to be applied to a large number of lines (for example to a large polygon)./
org.apache.commons.math4.geometry.euclidean.twod.Line.LineTransform.LineTransform	(	double	double	double	double	double	double	): Build an affine line transform from a n AffineTransform.
org.apache.commons.math4.geometry.euclidean.twod.Line.LineTransform.apply	(	Hyperplane	): Transform an hyperplane of a space. 
org.apache.commons.math4.geometry.euclidean.twod.Line.LineTransform.apply	(	Point	): Transform a point of a space. 
org.apache.commons.math4.geometry.euclidean.twod.Line.LineTransform.apply	(	SubHyperplane	Hyperplane	Hyperplane	): Transform a sub-hyperplane embedded in an hyperplane. 
org.apache.commons.math4.geometry.euclidean.twod.Line.contains	(	Cartesian2D	): Check if the line contains a point.
org.apache.commons.math4.geometry.euclidean.twod.Line.copySelf	(	): Copy the instance. The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for immutable objects). 
org.apache.commons.math4.geometry.euclidean.twod.Line.distance	(	Cartesian2D	): Compute the distance between the instance and a point. This is a shortcut for invoking FastMath.abs(getOffset(p)), and provides consistency with what is in the org.apache.commons.math4.geometry.euclidean.threed.Line class.
org.apache.commons.math4.geometry.euclidean.twod.Line.getAngle	(	): Get the angle of the line.
org.apache.commons.math4.geometry.euclidean.twod.Line.getOffset	(	Cartesian2D	): Get the offset (oriented distance) of a point.
org.apache.commons.math4.geometry.euclidean.twod.Line.getOffset	(	Line	): Get the offset (oriented distance) of a parallel line. This method should be called only for parallel lines otherwise the result is not meaningful. The offset is 0 if both lines are the same, it is positive if the line is on the right side of the instance and negative if it is on the left side, according to its natural orientation.
org.apache.commons.math4.geometry.euclidean.twod.Line.getOffset	(	Point	): Get the offset (oriented distance) of a point. The offset is 0 if the point is on the underlying hyperplane, it is positive if the point is on one particular side of the hyperplane, and it is negative if the point is on the other side, according to the hyperplane natural orientation. 
org.apache.commons.math4.geometry.euclidean.twod.Line.getOffset	(	Vector	): Get the offset (oriented distance) of a vector.
org.apache.commons.math4.geometry.euclidean.twod.Line.getOriginOffset	(	): Get the offset of the origin.
org.apache.commons.math4.geometry.euclidean.twod.Line.getPointAt	(	Cartesian1D	double	): Get one point from the plane.
org.apache.commons.math4.geometry.euclidean.twod.Line.getReverse	(	): Get the reverse of the instance. Get a line with reversed orientation with respect to the instance.  As long as neither the instance nor its reverse are modified (i.e. as long as none of the reset(), reset(), revertSelf(), setAngle() or setOriginOffset() methods are called), then the line and its reverse remain linked together so that line.getReverse().getReverse() == line. When one of the line is modified, the link is deleted as both instance becomes independent. 
org.apache.commons.math4.geometry.euclidean.twod.Line.getTolerance	(	): Get the tolerance below which points are considered to belong to the hyperplane.
org.apache.commons.math4.geometry.euclidean.twod.Line.getTransform	(	double	double	double	double	double	double	): Get a org.apache.commons.math4.geometry.partitioning.Transform Transform embedding an affine transform.
org.apache.commons.math4.geometry.euclidean.twod.Line.intersection	(	Line	): Get the intersection point of the instance and another line.
org.apache.commons.math4.geometry.euclidean.twod.Line.isParallelTo	(	Line	): Check the instance is parallel to another line.
org.apache.commons.math4.geometry.euclidean.twod.Line.project	(	Point	): Project a point to the hyperplane.
org.apache.commons.math4.geometry.euclidean.twod.Line.reset	(	Cartesian2D	Cartesian2D	): Reset the instance as if built from two points. The line is oriented from p1 to p2
org.apache.commons.math4.geometry.euclidean.twod.Line.reset	(	Cartesian2D	double	): Reset the instance as if built from a line and an angle.
org.apache.commons.math4.geometry.euclidean.twod.Line.revertSelf	(	): Revert the instance.
org.apache.commons.math4.geometry.euclidean.twod.Line.sameOrientationAs	(	Hyperplane	): Check if the instance has the same orientation as another hyperplane. This method is expected to be called on parallel hyperplanes. The method should not re-check for parallelism, only for orientation, typically by testing something like the sign of the dot-products of normals. 
org.apache.commons.math4.geometry.euclidean.twod.Line.setAngle	(	double	): Set the angle of the line.
org.apache.commons.math4.geometry.euclidean.twod.Line.setOriginOffset	(	double	): Set the offset of the origin.
org.apache.commons.math4.geometry.euclidean.twod.Line.toSpace	(	Cartesian1D	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.euclidean.twod.Line.toSpace	(	Point	): Transform a sub-space point into a space point. 
org.apache.commons.math4.geometry.euclidean.twod.Line.toSpace	(	Vector	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.euclidean.twod.Line.toSubSpace	(	Cartesian2D	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.euclidean.twod.Line.toSubSpace	(	Point	): Transform a space point into a sub-space point. 
org.apache.commons.math4.geometry.euclidean.twod.Line.toSubSpace	(	Vector	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.euclidean.twod.Line.translateToPoint	(	Cartesian2D	): Translate the line to force it passing by a point.
org.apache.commons.math4.geometry.euclidean.twod.Line.unlinkReverse	(	): Unset the link between an instance and its reverse.
org.apache.commons.math4.geometry.euclidean.twod.Line.wholeHyperplane	(	): Build a sub-hyperplane covering the whole hyperplane. 
org.apache.commons.math4.geometry.euclidean.twod.Line.wholeSpace	(	): Build a region covering the whole space.
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops: This class represent a tree of nested 2D boundary loops. This class is used for piecewise polygons construction. Polygons are built using the outline edges as representative of boundaries, the orientation of these lines are meaningful. However, we want to allow the user to specify its outline loops without having to take care of this orientation. This class is devoted to correct mis-oriented loops. Orientation is computed assuming the piecewise polygon is finite, i.e. the outermost loops have their exterior side facing points at infinity, and hence are oriented counter-clockwise. The orientation of internal loops is computed as the reverse of the orientation of their immediate surrounding loop.
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops.NestedLoops	(	Cartesian2D[]	double	): Constructor. Build a tree node with neither parent nor children
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops.NestedLoops	(	double	): Simple Constructor. Build an empty tree of nested loops. This instance will become the root node of a complete tree, it is not associated with any loop by itself, the outermost loops are in the root tree child nodes.
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops.add	(	Cartesian2D[]	): Add a loop in a tree.
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops.add	(	NestedLoops	): Add a loop in a tree.
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops.correctOrientation	(	): Correct the orientation of the loops contained in the tree. This is this method that really inverts the loops that where provided through the add() method if they are mis-oriented
org.apache.commons.math4.geometry.euclidean.twod.NestedLoops.setClockWise	(	boolean	): Set the loop orientation.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet: This class represents a 2D region: a set of polygons.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment: Private extension of Segment allowing connection. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.ConnectableSegment	(	Cartesian2D	Cartesian2D	Line	BSPTree	BSPTree	BSPTree	): Build a segment.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.getEndNode	(	): Get the node whose intersection with current node defines end point.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.getNext	(	): Get the next segment.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.getNode	(	): Get the node containing segment.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.getPrevious	(	): Get the previous segment.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.getStartNode	(	): Get the node whose intersection with current node defines start point.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.isProcessed	(	): Check if the segment has been processed.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.setNext	(	ConnectableSegment	): Set the next segment.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.setPrevious	(	ConnectableSegment	): Set the previous segment.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.ConnectableSegment.setProcessed	(	boolean	): Set the processed flag.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge: Internal class for holding edges while they are processed to build a BSP tree. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.Edge	(	Vertex	Vertex	Line	): Build an edge not contained in any node yet.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.getEnd	(	): Get end vertex.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.getLine	(	): Get the line supporting this edge.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.getNode	(	): Get the node whose cut hyperplane contains this edge.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.getStart	(	): Get start vertex.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.setNode	(	BSPTree	): Set the node whose cut hyperplane contains this edge.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Edge.split	(	Line	): Split the edge.  Once split, this edge is not referenced anymore by the vertices, it is replaced by the two half-edges and an intermediate splitting vertex is introduced to connect these two halves. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.PolygonsSet	(	BSPTree	double	): Build a polygons set from a BSP tree. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE  This constructor is aimed at expert use, as building the tree may be a difficult task. It is not intended for general use and for performances reasons does not check thoroughly its input, as this would require walking the full tree each time. Failing to provide a tree with the proper attributes, will therefore generate problems like NullPointerException or ClassCastException only later on. This limitation is known and explains why this constructor is for expert use only. The caller does have the responsibility to provided correct arguments. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.PolygonsSet	(	Collection	double	): Build a polygons set from a Boundary REPresentation (B-rep). The boundary is provided as a collection of SubHyperplane sub-hyperplanes. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side. The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoint polygons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the checkPoint() method will not be meaningful anymore. If the boundary is empty, the region will represent the whole space.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.PolygonsSet	(	double	): Build a polygons set representing the whole plane.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.PolygonsSet	(	double	Cartesian2D	): Build a polygon from a simple list of vertices. The boundary is provided as a list of points considering to represent the vertices of a simple loop. The interior part of the region is on the left side of this path and the exterior is on its right side. This constructor does not handle polygons with a boundary forming several disconnected paths (such as polygons with holes). For cases where this simple constructor applies, it is expected to be numerically more robust than the PolygonsSet() general constructor using SubHyperplane subhyperplanes. If the list is empty, the region will represent the whole space.  Polygons with thin pikes or dents are inherently difficult to handle because they involve lines with almost opposite directions at some vertices. Polygons whose vertices come from some physical measurement with noise are also difficult because an edge that should be straight may be broken in lots of different pieces with almost equal directions. In both cases, computing the lines intersections is not numerically robust due to the almost 0 or almost π angle. Such cases need to carefully adjust the hyperplaneThickness parameter. A too small value would often lead to completely wrong polygons with large area wrongly identified as inside or outside. Large values are often much safer. As a rule of thumb, a value slightly below the size of the most accurate detail needed is a good value for the hyperplaneThickness parameter. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.PolygonsSet	(	double	double	double	double	double	): Build a parallellepipedic box.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder: Visitor building segments. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.SegmentsBuilder	(	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.addContribution	(	SubHyperplane	BSPTree	Iterable	boolean	): Add the contribution of a boundary facet.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.getSegments	(	): Get the segments.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.selectClosest	(	Cartesian2D	Iterable	): Select the node whose cut sub-hyperplane is closest to specified point.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex: Internal class for holding vertices while they are processed to build a BSP tree. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.Vertex	(	Cartesian2D	): Build a non-processed vertex not owned by any node yet.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.bindWith	(	Line	): Bind a line considered to contain this vertex.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.getIncoming	(	): Get incoming edge.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.getLocation	(	): Get Vertex location.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.getOutgoing	(	): Get outgoing edge.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.setIncoming	(	Edge	): Set incoming edge.  The line supporting the incoming edge is automatically bound with the instance. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.setOutgoing	(	Edge	): Set outgoing edge.  The line supporting the outgoing edge is automatically bound with the instance. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.Vertex.sharedLineWith	(	Vertex	): Get the common line bound with both the instance and another vertex, if any.  When two vertices are both bound to the same line, this means they are already handled by node associated with this line, so there is no need to create a cut hyperplane for them. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.boxBoundary	(	double	double	double	double	double	): Create a list of hyperplanes representing the boundary of a box.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).  
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.closeVerticesConnections	(	List	): Connect the segments using Euclidean distance.  This connection heuristic should be used last, as it relies only on a fuzzy distance criterion. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties	(	): Compute some geometrical properties. The properties to compute are the barycenter and the size. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.filterSpuriousVertices	(	List	): Filter out spurious vertices on straight lines (at machine precision).
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.followLoop	(	ConnectableSegment	): Build the loop containing a segment.  The segment put in the loop will be marked as processed. 
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.getUnprocessed	(	List	): Get first unprocessed segment from a list.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.getVertices	(	): Get the vertices of the polygon. The polygon boundary can be represented as an array of loops, each loop being itself an array of vertices. In order to identify open loops which start and end by infinite edges, the open loops arrays start with a null point. In this case, the first non null point and the last point of the array do not represent real vertices, they are dummy points intended only to get the direction of the first and last edge. An open loop consisting of a single infinite line will therefore be represented by a three elements array with one null point followed by two dummy points. The open loops are always the first ones in the loops array. If the polygon has no boundary at all, a zero length loop array will be returned. All line segments in the various loops have the inside of the region on their left side and the outside on their right side when moving in the underlying line direction. This means that closed loops surrounding finite areas obey the direct trigonometric orientation.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.insertEdges	(	double	BSPTree	List	): Recursively build a tree by inserting cut sub-hyperplanes.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.naturalFollowerConnections	(	List	): Connect the segments using only natural follower information.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.splitEdgeConnections	(	List	): Connect the segments resulting from a line splitting a straight edge.
org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet.verticesToTree	(	double	Cartesian2D	): Build the BSP tree of a polygons set from a simple list of vertices. The boundary is provided as a list of points considering to represent the vertices of a simple loop. The interior part of the region is on the left side of this path and the exterior is on its right side. This constructor does not handle polygons with a boundary forming several disconnected paths (such as polygons with holes). For cases where this simple constructor applies, it is expected to be numerically more robust than the PolygonsSet() general constructor using SubHyperplane subhyperplanes.
org.apache.commons.math4.geometry.euclidean.twod.Segment: Simple container for a two-points segment.
org.apache.commons.math4.geometry.euclidean.twod.Segment.Segment	(	Cartesian2D	Cartesian2D	Line	): Build a segment.
org.apache.commons.math4.geometry.euclidean.twod.Segment.distance	(	Cartesian2D	): Calculates the shortest distance from a point to this line segment.  If the perpendicular extension from the point to the line does not cross in the bounds of the line segment, the shortest distance to the two end points will be returned.  Algorithm adapted from:  Thread @ Codeguru
org.apache.commons.math4.geometry.euclidean.twod.Segment.getEnd	(	): Get the end point of the segment.
org.apache.commons.math4.geometry.euclidean.twod.Segment.getLine	(	): Get the line containing the segment.
org.apache.commons.math4.geometry.euclidean.twod.Segment.getStart	(	): Get the start point of the segment.
org.apache.commons.math4.geometry.euclidean.twod.SubLine: This class represents a sub-hyperplane for Line.
org.apache.commons.math4.geometry.euclidean.twod.SubLine.SubLine	(	Cartesian2D	Cartesian2D	double	): Create a sub-line from two endpoints.
org.apache.commons.math4.geometry.euclidean.twod.SubLine.SubLine	(	Hyperplane	Region	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.twod.SubLine.SubLine	(	Segment	): Create a sub-line from a segment.
org.apache.commons.math4.geometry.euclidean.twod.SubLine.buildIntervalSet	(	Cartesian2D	Cartesian2D	double	): Build an interval set from two points.
org.apache.commons.math4.geometry.euclidean.twod.SubLine.buildNew	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region. 
org.apache.commons.math4.geometry.euclidean.twod.SubLine.getSegments	(	): Get the endpoints of the sub-line.  A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. 
org.apache.commons.math4.geometry.euclidean.twod.SubLine.intersection	(	SubLine	boolean	): Get the intersection of the instance and another sub-line.  This method is related to the intersection() method in the Line Line class, but in addition to compute the point along infinite lines, it also checks the point lies on both sub-line ranges. 
org.apache.commons.math4.geometry.euclidean.twod.SubLine.split	(	Hyperplane	): Split the instance in two parts by an hyperplane.  
org.apache.commons.math4.geometry.euclidean.twod.Vector2D: This class represents a 2D vector.
org.apache.commons.math4.geometry.euclidean.twod.Vector2D.getX	(	): Get the abscissa of the vector.
org.apache.commons.math4.geometry.euclidean.twod.Vector2D.getY	(	): Get the ordinate of the vector.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat: Formats a 2D vector in components list format "{x; y}". The prefix and suffix "{" and "}" and the separator "; " can be replaced by any user-defined strings. The number format for components can be configured. White space is ignored at parse time, even if it is in the prefix, suffix or separator specifications. So even if the default separator does include a space character that is used at format time, both input string "{1;1}" and " { 1 ; 1 } " will be parsed without error and the same vector will be returned. In the second case, however, the parse position after parsing will be just after the closing curly brace, i.e. just before the trailing space. Note: using "," as a separator may interfere with the grouping separator of the default NumberFormat for the current locale. Thus it is advised to use a NumberFormat instance with disabled grouping in such a case.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.Vector2DFormat	(	): Create an instance with default settings. The instance uses the default prefix, suffix and separator: "{", "}", and "; " and the default number format for components.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.Vector2DFormat	(	NumberFormat	): Create an instance with a custom number format for components.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.Vector2DFormat	(	String	String	String	): Create an instance with custom prefix, suffix and separator.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.Vector2DFormat	(	String	String	String	NumberFormat	): Create an instance with custom prefix, suffix, separator and format for components.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.format	(	Vector	StringBuffer	FieldPosition	): Formats a Vector object to produce a string. 
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.getInstance	(	): Returns the default 2D vector format for the current locale.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.getInstance	(	Locale	): Returns the default 2D vector format for the given locale.
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.parse	(	String	): Parses a string to produce a Vector object. 
org.apache.commons.math4.geometry.euclidean.twod.Vector2DFormat.parse	(	String	ParsePosition	): Parses a string to produce a Vector object. 
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D: Abstract base class for convex hull generators in the two-dimensional euclidean space.
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.AbstractConvexHullGenerator2D	(	boolean	): Simple constructor.  The default tolerance (1e-10) will be used to determine identical points.
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.AbstractConvexHullGenerator2D	(	boolean	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.findHullVertices	(	Collection	): Find the convex hull vertices from the set of input points.
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.generate	(	Collection	): Builds the convex hull from the set of input points.  
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.getTolerance	(	): Get the tolerance below which points are considered identical.
org.apache.commons.math4.geometry.euclidean.twod.hull.AbstractConvexHullGenerator2D.isIncludeCollinearPoints	(	): Returns if collinear points on the hull will be added as hull vertices.
org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristic: A simple heuristic to improve the performance of convex hull algorithms.  The heuristic is based on the idea of a convex quadrilateral, which is formed by four points with the lowest and highest x / y coordinates. Any point that lies inside this quadrilateral can not be part of the convex hull and can thus be safely discarded before generating the convex hull itself.  The complexity of the operation is O(n), and may greatly improve the time it takes to construct the convex hull afterwards, depending on the point distribution.
org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristic.AklToussaintHeuristic	(	): Hide utility constructor. 
org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristic.buildQuadrilateral	(	Cartesian2D	): Build the convex quadrilateral with the found corner points (with min/max x/y coordinates).
org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristic.insideQuadrilateral	(	Cartesian2D	List	): Checks if the given point is located within the convex quadrilateral.
org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristic.reducePoints	(	Collection	): Returns a point set that is reduced by all points for which it is safe to assume that they are not part of the convex hull.
org.apache.commons.math4.geometry.euclidean.twod.hull.AklToussaintHeuristicTest: Test class for AklToussaintHeuristic.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D: This class represents a convex hull in an two-dimensional euclidean space.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D.ConvexHull2D	(	Cartesian2D[]	double	): Simple constructor.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D.createRegion	(	): Returns a new region that is enclosed by the convex hull. 
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D.getLineSegments	(	): Get the line segments of the convex hull, ordered.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D.getVertices	(	): Get the vertices of the convex hull. 
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D.isConvex	(	Cartesian2D[]	): Checks whether the given hull vertices form a convex hull.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHull2D.retrieveLineSegments	(	): Retrieve the line segments from the cached array or create them if needed.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2D: Interface for convex hull generators in the two-dimensional euclidean space.
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2D.generate	(	Collection	): Builds the convex hull from the set of input points. 
org.apache.commons.math4.geometry.euclidean.twod.hull.ConvexHullGenerator2DAbstractTest: Abstract base test class for 2D convex hull generators.
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain: Implements Andrew's monotone chain method to generate the convex hull of a finite set of points in the two-dimensional euclidean space.  The runtime complexity is O(n log n), with n being the number of input points. If the point set is already sorted (by x-coordinate), the runtime complexity is O(n).  The implementation is not sensitive to collinear points on the hull. The parameter includeCollinearPoints allows to control the behavior with regard to collinear points. If true, all points on the boundary of the hull will be added to the hull vertices, otherwise only the extreme points will be present. By default, collinear points are not added as hull vertices.  The tolerance parameter (default: 1e-10) is used as epsilon criteria to determine identical and collinear points.
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain.MonotoneChain	(	): Create a new MonotoneChain instance.
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain.MonotoneChain	(	boolean	): Create a new MonotoneChain instance.
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain.MonotoneChain	(	boolean	double	): Create a new MonotoneChain instance.
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain.findHullVertices	(	Collection	): Find the convex hull vertices from the set of input points. 
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChain.updateHull	(	Cartesian2D	List	): Update the partial hull with the current point.
org.apache.commons.math4.geometry.euclidean.twod.hull.MonotoneChainTest: Test class for MonotoneChain.
org.apache.commons.math4.geometry.hull.ConvexHull: This class represents a convex hull.
org.apache.commons.math4.geometry.hull.ConvexHull.createRegion	(	): Returns a new region that is enclosed by the convex hull.
org.apache.commons.math4.geometry.hull.ConvexHull.getVertices	(	): Get the vertices of the convex hull.
org.apache.commons.math4.geometry.hull.ConvexHullGenerator: Interface for convex hull generators.
org.apache.commons.math4.geometry.hull.ConvexHullGenerator.generate	(	Collection	): Builds the convex hull from the set of input points.
org.apache.commons.math4.geometry.partitioning.AbstractRegion: Abstract class for all regions, independently of geometry type or dimension.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.AbstractRegion	(	BSPTree	double	): Build a region from an inside/outside BSP tree. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).
org.apache.commons.math4.geometry.partitioning.AbstractRegion.AbstractRegion	(	Collection	double	): Build a Region from a Boundary REPresentation (B-rep). The boundary is provided as a collection of SubHyperplane sub-hyperplanes. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side. The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the checkPoint() method will not be meaningful anymore. If the boundary is empty, the region will represent the whole space.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.AbstractRegion	(	Hyperplane[]	double	): Build a convex region from an array of bounding hyperplanes.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.AbstractRegion	(	double	): Build a region representing the whole space.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.applyTransform	(	Transform	): Transform a region. Applying a transform to a region consist in applying the transform to all the hyperplanes of the underlying BSP tree and of the boundary (and also to the sub-hyperplanes embedded in these hyperplanes) and to the barycenter. The instance is not modified, a new instance is built.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method). 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.checkPoint	(	BSPTree	Point	): Check a point with respect to the region starting at a given node.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.checkPoint	(	BSPTree	Vector	): Check a point with respect to the region starting at a given node.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.checkPoint	(	Point	): Check a point with respect to the region. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.computeGeometricalProperties	(	): Compute some geometrical properties. The properties to compute are the barycenter and the size.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.contains	(	Region	): Check if the instance entirely contains another region. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.copySelf	(	): Copy the instance. The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for the underlying tree Boolean attributes and immutable objects). 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.getBarycenter	(	): Get the barycenter of the instance. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.getBoundarySize	(	): Get the size of the boundary. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.getSize	(	): Get the size of the instance. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.getTolerance	(	): Get the tolerance below which points are considered to belong to hyperplanes.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.getTree	(	boolean	): Get the underlying BSP tree. Regions are represented by an underlying inside/outside BSP tree whose leaf attributes are Boolean instances representing inside leaf cells if the attribute value is true and outside leaf cells if the attribute is false. These leaf attributes are always present and guaranteed to be non null. In addition to the leaf attributes, the internal nodes which correspond to cells split by cut sub-hyperplanes may contain BoundaryAttribute BoundaryAttribute objects representing the parts of the corresponding cut sub-hyperplane that belong to the boundary. When the boundary attributes have been computed, all internal nodes are guaranteed to have non-null attributes, however some BoundaryAttribute BoundaryAttribute instances may have their getPlusInside() and getPlusOutside() methods both returning null if the corresponding cut sub-hyperplane does not have any parts belonging to the boundary. Since computing the boundary is not always required and can be time-consuming for large trees, these internal nodes attributes are computed using lazy evaluation only when required by setting the includeBoundaryAttributes argument to true. Once computed, these attributes remain in the tree, which implies that in this case, further calls to the method for the same region will always include these attributes regardless of the value of the includeBoundaryAttributes argument. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.insertCuts	(	BSPTree	Collection	): Recursively build a tree by inserting cut sub-hyperplanes.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.intersection	(	SubHyperplane	): Get the parts of a sub-hyperplane that are contained in the region. The parts of the sub-hyperplane that belong to the boundary are not included in the resulting parts. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.isEmpty	(	): Check if the instance is empty. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.isEmpty	(	BSPTree	): Check if the sub-tree starting at a given node is empty. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.isFull	(	): Check if the instance covers the full space. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.isFull	(	BSPTree	): Check if the sub-tree starting at a given node covers the full space. 
org.apache.commons.math4.geometry.partitioning.AbstractRegion.projectToBoundary	(	Point	): Project a point on the boundary of the region.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.recurseIntersection	(	BSPTree	SubHyperplane	): Recursively compute the parts of a sub-hyperplane that are contained in the region.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.recurseTransform	(	BSPTree	Transform	Map	): Recursively transform an inside/outside BSP-tree.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.setBarycenter	(	Point	): Set the barycenter of the instance.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.setBarycenter	(	Vector	): Set the barycenter of the instance.
org.apache.commons.math4.geometry.partitioning.AbstractRegion.setSize	(	double	): Set the size of the instance.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane: This class implements the dimension-independent parts of SubHyperplane. sub-hyperplanes are obtained when parts of an Hyperplane hyperplane are chopped off by other hyperplanes that intersect it. The remaining part is a convex region. Such objects appear in BSPTree BSP trees as the intersection of a cut hyperplane with the convex region which it splits, the chopping hyperplanes are the cut hyperplanes closer to the tree root.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.AbstractSubHyperplane	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.applyTransform	(	Transform	): Apply a transform to the instance. The instance must be a (D-1)-dimension sub-hyperplane with respect to the transform not a (D-2)-dimension sub-hyperplane the transform knows how to transform by itself. The transform will consist in transforming first the hyperplane and then the all region using the various methods provided by the transform.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.buildNew	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.copySelf	(	): Copy the instance. The instance created is completely independent of the original one. A deep copy is used, none of the underlying objects are shared (except for the nodes attributes and immutable objects). 
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.getHyperplane	(	): Get the underlying hyperplane.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.getRemainingRegion	(	): Get the remaining region of the hyperplane. The returned region is expressed in the canonical hyperplane frame and has the hyperplane dimension. For example a chopped hyperplane in the 3D euclidean is a 2D plane and the corresponding region is a convex 2D polygon.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.getSize	(	): Get the size of the instance. 
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.isEmpty	(	): Check if the instance is empty. 
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.recurseTransform	(	BSPTree	Hyperplane	Transform	Map	): Recursively transform a BSP-tree from a sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.reunite	(	SubHyperplane	): Compute the union of the instance and another sub-hyperplane. 
org.apache.commons.math4.geometry.partitioning.AbstractSubHyperplane.split	(	Hyperplane	): Split the instance in two parts by an hyperplane. 
org.apache.commons.math4.geometry.partitioning.BSPTree: This class represent a Binary Space Partition tree. BSP trees are an efficient way to represent space partitions and to associate attributes with each cell. Each node in a BSP tree represents a convex region which is partitioned in two convex sub-regions at each side of a cut hyperplane. The root tree contains the complete space. The main use of such partitions is to use a boolean attribute to define an inside/outside property, hence representing arbitrary polytopes (line segments in 1D, polygons in 2D and polyhedrons in 3D) and to operate on them. Another example would be to represent Voronoi tesselations, the attribute of each cell holding the defining point of the cell. The application-defined attributes are shared among copied instances and propagated to split parts. These attributes are not used by the BSP-tree algorithms themselves, so the application can use them for any purpose. Since the tree visiting method holds internal and leaf nodes differently, it is possible to use different classes for internal nodes attributes and leaf nodes attributes. This should be used with care, though, because if the tree is modified in any way after attributes have been set, some internal nodes may become leaf nodes and some leaf nodes may become internal nodes. One of the main sources for the development of this package was Bruce Naylor, John Amanatides and William Thibault paper Merging BSP Trees Yields Polyhedral Set Operations Proc. Siggraph '90, Computer Graphics 24(4), August 1990, pp 115-124, published by the Association for Computing Machinery (ACM).
org.apache.commons.math4.geometry.partitioning.BSPTree.BSPTree	(	): Build a tree having only one root cell representing the whole space.
org.apache.commons.math4.geometry.partitioning.BSPTree.BSPTree	(	Object	): Build a tree having only one root cell representing the whole space.
org.apache.commons.math4.geometry.partitioning.BSPTree.BSPTree	(	SubHyperplane	BSPTree	BSPTree	Object	): Build a BSPTree from its underlying elements. This method does not perform any verification on consistency of its arguments, it should therefore be used only when then caller knows what it is doing. This method is mainly useful to build trees bottom-up. Building trees top-down is realized with the help of method insertCut.
org.apache.commons.math4.geometry.partitioning.BSPTree.LeafMerger: This interface gather the merging operations between a BSP tree leaf and another BSP tree. As explained in Bruce Naylor, John Amanatides and William Thibault paper Merging BSP Trees Yields Polyhedral Set Operations, the operations on BSPTree BSP trees can be expressed as a generic recursive merging operation where only the final part, when one of the operand is a leaf, is specific to the real operation semantics. For example, a tree representing a region using a boolean attribute to identify inside cells and outside cells would use four different objects to implement the final merging phase of the four set operations union, intersection, difference and symmetric difference (exclusive or).
org.apache.commons.math4.geometry.partitioning.BSPTree.LeafMerger.merge	(	BSPTree	BSPTree	BSPTree	boolean	boolean	): Merge a leaf node and a tree node. This method is called at the end of a recursive merging resulting from a tree1.merge(tree2, leafMerger) call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm. Since the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree (tree1) or the argument tree (tree2). The third argument of the method is devoted to this. It can be ignored for commutative operations. The insertInTree BSPTree.insertInTree method may be useful to implement this method.
org.apache.commons.math4.geometry.partitioning.BSPTree.VanishingCutHandler: This interface handles the corner cases when an internal node cut sub-hyperplane vanishes.  Such cases happens for example when a cut sub-hyperplane is inserted into another tree (during a merge operation), and is split in several parts, some of which becomes smaller than the tolerance. The corresponding node as then no cut sub-hyperplane anymore, but does have children. This interface specifies how to handle this situation. setting 
org.apache.commons.math4.geometry.partitioning.BSPTree.VanishingCutHandler.fixNode	(	BSPTree	): Fix a node with both vanished cut and children.
org.apache.commons.math4.geometry.partitioning.BSPTree.chopOffMinus	(	Hyperplane	VanishingCutHandler	): Chop off parts of the tree. The instance is modified in place, all the parts that are on the minus side of the chopping hyperplane are discarded, only the parts on the plus side remain.
org.apache.commons.math4.geometry.partitioning.BSPTree.chopOffPlus	(	Hyperplane	VanishingCutHandler	): Chop off parts of the tree. The instance is modified in place, all the parts that are on the plus side of the chopping hyperplane are discarded, only the parts on the minus side remain.
org.apache.commons.math4.geometry.partitioning.BSPTree.condense	(	): Perform condensation on a tree. The condensation operation is not recursive, it must be called explicitly from leaves to root.
org.apache.commons.math4.geometry.partitioning.BSPTree.copySelf	(	): Copy the instance. The instance created is completely independent of the original one. A deep copy is used, none of the underlying objects are shared (except for the nodes attributes and immutable objects).
org.apache.commons.math4.geometry.partitioning.BSPTree.fitToCell	(	SubHyperplane	): Fit a sub-hyperplane inside the cell defined by the instance. Fitting is done by chopping off the parts of the sub-hyperplane that lie outside of the cell using the cut-hyperplanes of the parent nodes of the instance.
org.apache.commons.math4.geometry.partitioning.BSPTree.getAttribute	(	): Get the attribute associated with the instance.
org.apache.commons.math4.geometry.partitioning.BSPTree.getCell	(	Point	double	): Get the cell to which a point belongs. If the returned cell is a leaf node the points belongs to the interior of the node, if the cell is an internal node the points belongs to the node cut sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.BSPTree.getCloseCuts	(	Point	double	): Get the cells whose cut sub-hyperplanes are close to the point.
org.apache.commons.math4.geometry.partitioning.BSPTree.getCut	(	): Get the cut sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.BSPTree.getMinus	(	): Get the tree on the minus side of the cut hyperplane.
org.apache.commons.math4.geometry.partitioning.BSPTree.getParent	(	): Get the parent node.
org.apache.commons.math4.geometry.partitioning.BSPTree.getPlus	(	): Get the tree on the plus side of the cut hyperplane.
org.apache.commons.math4.geometry.partitioning.BSPTree.insertCut	(	Hyperplane	): Insert a cut sub-hyperplane in a node. The sub-tree starting at this node will be completely overwritten. The new cut sub-hyperplane will be built from the intersection of the provided hyperplane with the cell. If the hyperplane does intersect the cell, the cell will have two children cells with null attributes on each side of the inserted cut sub-hyperplane. If the hyperplane does not intersect the cell then no cut hyperplane will be inserted and the cell will be changed to a leaf cell. The attribute of the node is never changed. This method is mainly useful when called on leaf nodes (i.e. nodes for which getCut returns null), in this case it provides a way to build a tree top-down (whereas the BSPTree() 4 arguments constructor is devoted to build trees bottom-up).
org.apache.commons.math4.geometry.partitioning.BSPTree.insertInTree	(	BSPTree	boolean	VanishingCutHandler	): Insert the instance into another tree. The instance itself is modified so its former parent should not be used anymore.
org.apache.commons.math4.geometry.partitioning.BSPTree.merge	(	BSPTree	LeafMerger	): Merge a BSP tree with the instance. All trees are modified (parts of them are reused in the new tree), it is the responsibility of the caller to ensure a copy has been done before if any of the former tree should be preserved, no such copy is done here! The algorithm used here is directly derived from the one described in the Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).
org.apache.commons.math4.geometry.partitioning.BSPTree.merge	(	BSPTree	LeafMerger	BSPTree	boolean	): Merge a BSP tree with the instance.
org.apache.commons.math4.geometry.partitioning.BSPTree.pruneAroundConvexCell	(	Object	Object	Object	): Prune a tree around a cell.  This method can be used to extract a convex cell from a tree. The original cell may either be a leaf node or an internal node. If it is an internal node, it's subtree will be ignored (i.e. the extracted cell will be a leaf node in all cases). The original tree to which the original cell belongs is not touched at all, a new independent tree will be built. 
org.apache.commons.math4.geometry.partitioning.BSPTree.recurseCloseCuts	(	Point	double	List	): Get the cells whose cut sub-hyperplanes are close to the point.
org.apache.commons.math4.geometry.partitioning.BSPTree.setAttribute	(	Object	): Associate an attribute with the instance.
org.apache.commons.math4.geometry.partitioning.BSPTree.split	(	SubHyperplane	): Split a BSP tree by an external sub-hyperplane. Split a tree in two halves, on each side of the sub-hyperplane. The instance is not modified. The tree returned is not upward-consistent: despite all of its sub-trees cut sub-hyperplanes (including its own cut sub-hyperplane) are bounded to the current cell, it is not attached to any parent tree yet. This tree is intended to be later inserted into an higher level tree. The algorithm used here is the one given in Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).
org.apache.commons.math4.geometry.partitioning.BSPTree.visit	(	BSPTreeVisitor	): Visit the BSP tree nodes.
org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor: This interface is used to visit BSPTree BSP tree nodes. Navigation through BSPTree BSP trees can be done using two different point of views:   the first one is in a node-oriented way using the getPlus, getMinus and getParent methods. Terminal nodes without associated SubHyperplane sub-hyperplanes can be visited this way, there is no constraint in the visit order, and it is possible to visit either all nodes or only a subset of the nodes   the second one is in a sub-hyperplane-oriented way using classes implementing this interface which obeys the visitor design pattern. The visit order is provided by the visitor as each node is first encountered. Each node is visited exactly once.  
org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node.
org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node.
org.apache.commons.math4.geometry.partitioning.BoundaryAttribute: Class holding boundary attributes. This class is used for the attributes associated with the nodes of region boundary shell trees returned by the getTree() Region.getTree(includeBoundaryAttributes) when the boolean includeBoundaryAttributes parameter is set to true. It contains the parts of the node cut sub-hyperplane that belong to the boundary. This class is a simple placeholder, it does not provide any processing methods.
org.apache.commons.math4.geometry.partitioning.BoundaryAttribute.BoundaryAttribute	(	SubHyperplane	SubHyperplane	NodesSet	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.BoundaryAttribute.getPlusInside	(	): Get the part of the node cut sub-hyperplane that belongs to the boundary and has the inside of the region on the plus side of its underlying hyperplane.
org.apache.commons.math4.geometry.partitioning.BoundaryAttribute.getPlusOutside	(	): Get the part of the node cut sub-hyperplane that belongs to the boundary and has the outside of the region on the plus side of its underlying hyperplane.
org.apache.commons.math4.geometry.partitioning.BoundaryAttribute.getSplitters	(	): Get the sub-hyperplanes that were used to split the boundary part.
org.apache.commons.math4.geometry.partitioning.BoundaryBuilder: Visitor building boundary shell tree.  The boundary shell is represented as BoundaryAttribute boundary attributes at each internal node. 
org.apache.commons.math4.geometry.partitioning.BoundaryBuilder.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.BoundaryBuilder.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.partitioning.BoundaryBuilder.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.BoundaryProjection: Class holding the result of point projection on region boundary. This class is a simple placeholder, it does not provide any processing methods. Instances of this class are guaranteed to be immutable
org.apache.commons.math4.geometry.partitioning.BoundaryProjection.BoundaryProjection	(	Point	Point	double	): Constructor from raw elements.
org.apache.commons.math4.geometry.partitioning.BoundaryProjection.getOffset	(	): Offset of the point with respect to the boundary it is projected on.  The offset with respect to the boundary is negative if the getOriginal() original point is inside the region, and positive otherwise.   If there are no boundary, the value is set to either Double.POSITIVE_INFINITY if the region is empty (i.e. all points are outside of the region) or Double.NEGATIVE_INFINITY if the region covers the whole space (i.e. all points are inside of the region). 
org.apache.commons.math4.geometry.partitioning.BoundaryProjection.getOriginal	(	): Get the original point.
org.apache.commons.math4.geometry.partitioning.BoundaryProjection.getProjected	(	): Projected point.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector: Local tree visitor to compute projection on boundary.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.BoundaryProjector	(	Point	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.addRegion	(	SubHyperplane	List	): Add a boundary region to a list.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.belongsToPart	(	Point	Hyperplane	Region	): Check if a projected point lies on a boundary part.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.boundaryRegions	(	BSPTree	): Extract the regions of the boundary on an internal node.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.getProjection	(	): Get the projection.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.singularProjection	(	Point	Hyperplane	Region	): Get the projection to the closest boundary singular point.
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.partitioning.BoundaryProjector.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.BoundarySizeVisitor: Visitor computing the boundary size.
org.apache.commons.math4.geometry.partitioning.BoundarySizeVisitor.BoundarySizeVisitor	(	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.BoundarySizeVisitor.getSize	(	): Get the size of the boundary.
org.apache.commons.math4.geometry.partitioning.BoundarySizeVisitor.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node.
org.apache.commons.math4.geometry.partitioning.BoundarySizeVisitor.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.BoundarySizeVisitor.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node.
org.apache.commons.math4.geometry.partitioning.Characterization: Cut sub-hyperplanes characterization with respect to inside/outside cells.
org.apache.commons.math4.geometry.partitioning.Characterization.Characterization	(	BSPTree	SubHyperplane	): Simple constructor. Characterization consists in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to compute characterization twice for each cut sub-hyperplane in the tree, once on the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.
org.apache.commons.math4.geometry.partitioning.Characterization.addInsideTouching	(	SubHyperplane	List	): Add a part of the cut sub-hyperplane known to touch an inside cell.
org.apache.commons.math4.geometry.partitioning.Characterization.addOutsideTouching	(	SubHyperplane	List	): Add a part of the cut sub-hyperplane known to touch an outside cell.
org.apache.commons.math4.geometry.partitioning.Characterization.characterize	(	BSPTree	SubHyperplane	List	): Filter the parts of an hyperplane belonging to the boundary. The filtering consist in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to call this method twice for each cut sub-hyperplane in the tree, once on the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.
org.apache.commons.math4.geometry.partitioning.Characterization.getInsideSplitters	(	): Get the nodes that were used to split the inside touching part.  Splitting nodes are internal nodes (i.e. they have a non-null cut sub-hyperplane). 
org.apache.commons.math4.geometry.partitioning.Characterization.getOutsideSplitters	(	): Get the nodes that were used to split the outside touching part.  Splitting nodes are internal nodes (i.e. they have a non-null cut sub-hyperplane). 
org.apache.commons.math4.geometry.partitioning.Characterization.insideTouching	(	): Get all the parts of the cut sub-hyperplane known to touch inside cells.
org.apache.commons.math4.geometry.partitioning.Characterization.outsideTouching	(	): Get all the parts of the cut sub-hyperplane known to touch outside cells.
org.apache.commons.math4.geometry.partitioning.Characterization.touchInside	(	): Check if the cut sub-hyperplane touches inside cells.
org.apache.commons.math4.geometry.partitioning.Characterization.touchOutside	(	): Check if the cut sub-hyperplane touches outside cells.
org.apache.commons.math4.geometry.partitioning.Embedding: This interface defines mappers between a space and one of its sub-spaces. Sub-spaces are the lower dimensions subsets of a n-dimensions space. The (n-1)-dimension sub-spaces are specific sub-spaces known as Hyperplane hyperplanes. This interface can be used regardless of the dimensions differences. As an example, org.apache.commons.math4.geometry.euclidean.threed.Line Line in 3D implements Embedding<org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D Cartesian3D, org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D Cartesian1D>, i.e. it maps directly dimensions 3 and 1. In the 3D euclidean space, hyperplanes are 2D planes, and the 1D sub-spaces are lines.  Note that this interface is not intended to be implemented by Apache Commons Math users, it is only intended to be implemented within the library itself. New methods may be added even for minor versions, which breaks compatibility for external implementations. 
org.apache.commons.math4.geometry.partitioning.Embedding.toSpace	(	Point	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.partitioning.Embedding.toSubSpace	(	Point	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.partitioning.Hyperplane: This interface represents an hyperplane of a space. The most prominent place where hyperplane appears in space partitioning is as cutters. Each partitioning node in a BSPTree BSP tree has a cut SubHyperplane sub-hyperplane which is either an hyperplane or a part of an hyperplane. In an n-dimensions euclidean space, an hyperplane is an (n-1)-dimensions hyperplane (for example a traditional plane in the 3D euclidean space). They can be more exotic objects in specific fields, for example a circle on the surface of the unit sphere.  Note that this interface is not intended to be implemented by Apache Commons Math users, it is only intended to be implemented within the library itself. New methods may be added even for minor versions, which breaks compatibility for external implementations. 
org.apache.commons.math4.geometry.partitioning.Hyperplane.copySelf	(	): Copy the instance. The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for immutable objects).
org.apache.commons.math4.geometry.partitioning.Hyperplane.getOffset	(	Point	): Get the offset (oriented distance) of a point. The offset is 0 if the point is on the underlying hyperplane, it is positive if the point is on one particular side of the hyperplane, and it is negative if the point is on the other side, according to the hyperplane natural orientation.
org.apache.commons.math4.geometry.partitioning.Hyperplane.getTolerance	(	): Get the tolerance below which points are considered to belong to the hyperplane.
org.apache.commons.math4.geometry.partitioning.Hyperplane.project	(	Point	): Project a point to the hyperplane.
org.apache.commons.math4.geometry.partitioning.Hyperplane.sameOrientationAs	(	Hyperplane	): Check if the instance has the same orientation as another hyperplane. This method is expected to be called on parallel hyperplanes. The method should not re-check for parallelism, only for orientation, typically by testing something like the sign of the dot-products of normals.
org.apache.commons.math4.geometry.partitioning.Hyperplane.wholeHyperplane	(	): Build a sub-hyperplane covering the whole hyperplane.
org.apache.commons.math4.geometry.partitioning.Hyperplane.wholeSpace	(	): Build a region covering the whole space.
org.apache.commons.math4.geometry.partitioning.InsideFinder: Utility class checking if inside nodes can be found on the plus and minus sides of an hyperplane.
org.apache.commons.math4.geometry.partitioning.InsideFinder.InsideFinder	(	Region	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.InsideFinder.minusFound	(	): Check if inside leaf nodes have been found on the minus side.
org.apache.commons.math4.geometry.partitioning.InsideFinder.plusFound	(	): Check if inside leaf nodes have been found on the plus side.
org.apache.commons.math4.geometry.partitioning.InsideFinder.recurseSides	(	BSPTree	SubHyperplane	): Search recursively for inside leaf nodes on each side of the given hyperplane. The algorithm used here is directly derived from the one described in section III (Binary Partitioning of a BSP Tree) of the Bruce Naylor, John Amanatides and William Thibault paper Merging BSP Trees Yields Polyhedral Set Operations Proc. Siggraph '90, Computer Graphics 24(4), August 1990, pp 115-124, published by the Association for Computing Machinery (ACM)..
org.apache.commons.math4.geometry.partitioning.NodesSet: Set of BSPTree BSP tree nodes.
org.apache.commons.math4.geometry.partitioning.NodesSet.NodesSet	(	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.NodesSet.add	(	BSPTree	): Add a node if not already known.
org.apache.commons.math4.geometry.partitioning.NodesSet.addAll	(	Iterable	): Add nodes if they are not already known.
org.apache.commons.math4.geometry.partitioning.NodesSet.iterator	(	):  
org.apache.commons.math4.geometry.partitioning.Region: This interface represents a region of a space as a partition. Region are subsets of a space, they can be infinite (whole space, half space, infinite stripe ...) or finite (polygons in 2D, polyhedrons in 3D ...). Their main characteristic is to separate points that are considered to be inside the region from points considered to be outside of it. In between, there may be points on the boundary of the region. This implementation is limited to regions for which the boundary is composed of several SubHyperplane sub-hyperplanes, including regions with no boundary at all: the whole space and the empty region. They are not necessarily finite and not necessarily path-connected. They can contain holes. Regions can be combined using the traditional sets operations : union, intersection, difference and symetric difference (exclusive or) for the binary operations, complement for the unary operation.  Note that this interface is not intended to be implemented by Apache Commons Math users, it is only intended to be implemented within the library itself. New methods may be added even for minor versions, which breaks compatibility for external implementations. 
org.apache.commons.math4.geometry.partitioning.Region.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).
org.apache.commons.math4.geometry.partitioning.Region.checkPoint	(	Point	): Check a point with respect to the region.
org.apache.commons.math4.geometry.partitioning.Region.contains	(	Region	): Check if the instance entirely contains another region.
org.apache.commons.math4.geometry.partitioning.Region.copySelf	(	): Copy the instance. The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for the underlying tree Boolean attributes and immutable objects).
org.apache.commons.math4.geometry.partitioning.Region.getBarycenter	(	): Get the barycenter of the instance.
org.apache.commons.math4.geometry.partitioning.Region.getBoundarySize	(	): Get the size of the boundary.
org.apache.commons.math4.geometry.partitioning.Region.getSize	(	): Get the size of the instance.
org.apache.commons.math4.geometry.partitioning.Region.getTree	(	boolean	): Get the underlying BSP tree. Regions are represented by an underlying inside/outside BSP tree whose leaf attributes are Boolean instances representing inside leaf cells if the attribute value is true and outside leaf cells if the attribute is false. These leaf attributes are always present and guaranteed to be non null. In addition to the leaf attributes, the internal nodes which correspond to cells split by cut sub-hyperplanes may contain BoundaryAttribute BoundaryAttribute objects representing the parts of the corresponding cut sub-hyperplane that belong to the boundary. When the boundary attributes have been computed, all internal nodes are guaranteed to have non-null attributes, however some BoundaryAttribute BoundaryAttribute instances may have their getPlusInside() and getPlusOutside() methods both returning null if the corresponding cut sub-hyperplane does not have any parts belonging to the boundary. Since computing the boundary is not always required and can be time-consuming for large trees, these internal nodes attributes are computed using lazy evaluation only when required by setting the includeBoundaryAttributes argument to true. Once computed, these attributes remain in the tree, which implies that in this case, further calls to the method for the same region will always include these attributes regardless of the value of the includeBoundaryAttributes argument.
org.apache.commons.math4.geometry.partitioning.Region.intersection	(	SubHyperplane	): Get the parts of a sub-hyperplane that are contained in the region. The parts of the sub-hyperplane that belong to the boundary are not included in the resulting parts.
org.apache.commons.math4.geometry.partitioning.Region.isEmpty	(	): Check if the instance is empty.
org.apache.commons.math4.geometry.partitioning.Region.isEmpty	(	BSPTree	): Check if the sub-tree starting at a given node is empty.
org.apache.commons.math4.geometry.partitioning.Region.isFull	(	): Check if the instance covers the full space.
org.apache.commons.math4.geometry.partitioning.Region.isFull	(	BSPTree	): Check if the sub-tree starting at a given node covers the full space.
org.apache.commons.math4.geometry.partitioning.Region.projectToBoundary	(	Point	): Project a point on the boundary of the region.
org.apache.commons.math4.geometry.partitioning.RegionDumper: Class dumping a string representation of an AbstractRegion.  This class is intended for tests and debug purposes only. 
org.apache.commons.math4.geometry.partitioning.RegionDumper.RegionDumper	(	): Private constructor for a utility class
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper: Dumping visitor.
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.TreeDumper	(	String	double	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.formatHyperplane	(	Hyperplane	): Format a string representation of the hyperplane underlying a cut sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.getDump	(	): Get the string representation of the tree.
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.getFormatter	(	): Get the formatter to use.
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.type	(	BSPTree	): Get the type of the node.
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.partitioning.RegionDumper.TreeDumper.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.RegionDumper.dump	(	ArcsSet	): Get a string representation of an ArcsSet.
org.apache.commons.math4.geometry.partitioning.RegionDumper.dump	(	IntervalsSet	): Get a string representation of an IntervalsSet.
org.apache.commons.math4.geometry.partitioning.RegionDumper.dump	(	PolygonsSet	): Get a string representation of a PolygonsSet.
org.apache.commons.math4.geometry.partitioning.RegionDumper.dump	(	PolyhedronsSet	): Get a string representation of a PolyhedronsSet.
org.apache.commons.math4.geometry.partitioning.RegionDumper.dump	(	SphericalPolygonsSet	): Get a string representation of a SphericalPolygonsSet.
org.apache.commons.math4.geometry.partitioning.RegionFactory: This class is a factory for Region.
org.apache.commons.math4.geometry.partitioning.RegionFactory.DifferenceMerger: BSP tree leaf merger computing difference of two regions. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.DifferenceMerger.DifferenceMerger	(	Region	Region	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.RegionFactory.DifferenceMerger.fixNode	(	BSPTree	): Fix a node with both vanished cut and children. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.DifferenceMerger.merge	(	BSPTree	BSPTree	BSPTree	boolean	boolean	): Merge a leaf node and a tree node. This method is called at the end of a recursive merging resulting from a tree1.merge(tree2, leafMerger) call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm. Since the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree (tree1) or the argument tree (tree2). The third argument of the method is devoted to this. It can be ignored for commutative operations. The insertInTree BSPTree.insertInTree method may be useful to implement this method. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.IntersectionMerger: BSP tree leaf merger computing intersection of two regions. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.IntersectionMerger.merge	(	BSPTree	BSPTree	BSPTree	boolean	boolean	): Merge a leaf node and a tree node. This method is called at the end of a recursive merging resulting from a tree1.merge(tree2, leafMerger) call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm. Since the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree (tree1) or the argument tree (tree2). The third argument of the method is devoted to this. It can be ignored for commutative operations. The insertInTree BSPTree.insertInTree method may be useful to implement this method. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.NodesCleaner: Visitor removing internal nodes attributes. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.NodesCleaner.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.NodesCleaner.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.NodesCleaner.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.RegionFactory	(	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.RegionFactory.UnionMerger: BSP tree leaf merger computing union of two regions. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.UnionMerger.merge	(	BSPTree	BSPTree	BSPTree	boolean	boolean	): Merge a leaf node and a tree node. This method is called at the end of a recursive merging resulting from a tree1.merge(tree2, leafMerger) call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm. Since the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree (tree1) or the argument tree (tree2). The third argument of the method is devoted to this. It can be ignored for commutative operations. The insertInTree BSPTree.insertInTree method may be useful to implement this method. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.VanishingToLeaf: Handler replacing nodes with vanishing cuts with leaf nodes. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.VanishingToLeaf.VanishingToLeaf	(	boolean	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.RegionFactory.VanishingToLeaf.fixNode	(	BSPTree	): Fix a node with both vanished cut and children. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.XorMerger: BSP tree leaf merger computing symmetric difference (exclusive or) of two regions. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.XorMerger.merge	(	BSPTree	BSPTree	BSPTree	boolean	boolean	): Merge a leaf node and a tree node. This method is called at the end of a recursive merging resulting from a tree1.merge(tree2, leafMerger) call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm. Since the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree (tree1) or the argument tree (tree2). The third argument of the method is devoted to this. It can be ignored for commutative operations. The insertInTree BSPTree.insertInTree method may be useful to implement this method. 
org.apache.commons.math4.geometry.partitioning.RegionFactory.buildConvex	(	Hyperplane	): Build a convex region from a collection of bounding hyperplanes.
org.apache.commons.math4.geometry.partitioning.RegionFactory.difference	(	Region	Region	): Compute the difference of two regions.
org.apache.commons.math4.geometry.partitioning.RegionFactory.getComplement	(	Region	): Get the complement of the region (exchanged interior/exterior).
org.apache.commons.math4.geometry.partitioning.RegionFactory.intersection	(	Region	Region	): Compute the intersection of two regions.
org.apache.commons.math4.geometry.partitioning.RegionFactory.recurseComplement	(	BSPTree	): Recursively build the complement of a BSP tree.
org.apache.commons.math4.geometry.partitioning.RegionFactory.recurseComplement	(	BSPTree	Map	): Recursively build the complement of a BSP tree.
org.apache.commons.math4.geometry.partitioning.RegionFactory.union	(	Region	Region	): Compute the union of two regions.
org.apache.commons.math4.geometry.partitioning.RegionFactory.xor	(	Region	Region	): Compute the symmetric difference (exclusive or) of two regions.
org.apache.commons.math4.geometry.partitioning.RegionParser: Class parsing a string representation of an AbstractRegion.  This class is intended for tests and debug purposes only. 
org.apache.commons.math4.geometry.partitioning.RegionParser.RegionParser	(	): Private constructor for a utility class
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder: Local class for building an AbstractRegion tree.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.TreeBuilder	(	String	String	): Simple constructor.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.getBoolean	(	): Get next boolean.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.getNumber	(	): Get next number.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.getTolerance	(	): Get the tolerance.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.getTree	(	): Get the built tree.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.getWord	(	String	): Get next word.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.parseHyperplane	(	): Parse an hyperplane.
org.apache.commons.math4.geometry.partitioning.RegionParser.TreeBuilder.parseTree	(	BSPTree	): Parse a tree.
org.apache.commons.math4.geometry.partitioning.RegionParser.parseArcsSet	(	String	): Parse a string representation of an ArcsSet.
org.apache.commons.math4.geometry.partitioning.RegionParser.parseIntervalsSet	(	String	): Parse a string representation of an IntervalsSet.
org.apache.commons.math4.geometry.partitioning.RegionParser.parsePolygonsSet	(	String	): Parse a string representation of a PolygonsSet.
org.apache.commons.math4.geometry.partitioning.RegionParser.parsePolyhedronsSet	(	String	): Parse a string representation of a PolyhedronsSet.
org.apache.commons.math4.geometry.partitioning.RegionParser.parseSphericalPolygonsSet	(	String	): Parse a string representation of a SphericalPolygonsSet.
org.apache.commons.math4.geometry.partitioning.SubHyperplane: This interface represents the remaining parts of an hyperplane after other parts have been chopped off. sub-hyperplanes are obtained when parts of an Hyperplane hyperplane are chopped off by other hyperplanes that intersect it. The remaining part is a convex region. Such objects appear in BSPTree BSP trees as the intersection of a cut hyperplane with the convex region which it splits, the chopping hyperplanes are the cut hyperplanes closer to the tree root.  Note that this interface is not intended to be implemented by Apache Commons Math users, it is only intended to be implemented within the library itself. New methods may be added even for minor versions, which breaks compatibility for external implementations. 
org.apache.commons.math4.geometry.partitioning.SubHyperplane.SplitSubHyperplane: Class holding the results of the split method.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.SplitSubHyperplane.SplitSubHyperplane	(	SubHyperplane	SubHyperplane	): Build a SplitSubHyperplane from its parts.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.SplitSubHyperplane.getMinus	(	): Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.SplitSubHyperplane.getPlus	(	): Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.SplitSubHyperplane.getSide	(	): Get the side of the split sub-hyperplane with respect to its splitter.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.copySelf	(	): Copy the instance. The instance created is completely independent of the original one. A deep copy is used, none of the underlying objects are shared (except for the nodes attributes and immutable objects).
org.apache.commons.math4.geometry.partitioning.SubHyperplane.getHyperplane	(	): Get the underlying hyperplane.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.getSize	(	): Get the size of the instance.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.isEmpty	(	): Check if the instance is empty.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.reunite	(	SubHyperplane	): Compute the union of the instance and another sub-hyperplane.
org.apache.commons.math4.geometry.partitioning.SubHyperplane.split	(	Hyperplane	): Split the instance in two parts by an hyperplane.
org.apache.commons.math4.geometry.partitioning.Transform: This interface represents an inversible affine transform in a space. Inversible affine transform include for example scalings, translations, rotations. Transforms are dimension-specific. The consistency rules between the three apply methods are the following ones for a transformed defined for dimension D:   the transform can be applied to a point in the D-dimension space using its apply() method   the transform can be applied to a (D-1)-dimension hyperplane in the D-dimension space using its apply() method   the transform can be applied to a (D-2)-dimension sub-hyperplane in a (D-1)-dimension hyperplane using its apply() method  
org.apache.commons.math4.geometry.partitioning.Transform.apply	(	Hyperplane	): Transform an hyperplane of a space.
org.apache.commons.math4.geometry.partitioning.Transform.apply	(	Point	): Transform a point of a space.
org.apache.commons.math4.geometry.partitioning.Transform.apply	(	SubHyperplane	Hyperplane	Hyperplane	): Transform a sub-hyperplane embedded in an hyperplane.
org.apache.commons.math4.geometry.spherical.oned.Arc: This class represents an arc on a circle.
org.apache.commons.math4.geometry.spherical.oned.Arc.Arc	(	double	double	double	): Simple constructor.  If either lower is equals to upper or the interval exceeds \( 2 \pi \), the arc is considered to be the full circle and its initial defining boundaries will be forgotten. lower is not allowed to be greater than upper (an exception is thrown in this case). lower will be canonicalized between 0 and \( 2 \pi \), and upper shifted accordingly, so the getInf() and getSup() may not return the value used at instance construction. 
org.apache.commons.math4.geometry.spherical.oned.Arc.checkPoint	(	double	): Check a point with respect to the arc.
org.apache.commons.math4.geometry.spherical.oned.Arc.getBarycenter	(	): Get the barycenter of the arc.
org.apache.commons.math4.geometry.spherical.oned.Arc.getInf	(	): Get the lower angular bound of the arc.
org.apache.commons.math4.geometry.spherical.oned.Arc.getSize	(	): Get the angular size of the arc.
org.apache.commons.math4.geometry.spherical.oned.Arc.getSup	(	): Get the upper angular bound of the arc.
org.apache.commons.math4.geometry.spherical.oned.Arc.getTolerance	(	): Get the tolerance below which angles are considered identical.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet: This class represents a region of a circle: a set of arcs.  Note that due to the wrapping around \(2 \pi\), barycenter is ill-defined here. It was defined only in order to fulfill the requirements of the org.apache.commons.math4.geometry.partitioning.Region Region interface, but its use is discouraged. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.ArcsSet	(	BSPTree	double	): Build an arcs set from an inside/outside BSP tree. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.ArcsSet	(	Collection	double	): Build an arcs set from a Boundary REPresentation (B-rep). The boundary is provided as a collection of SubHyperplane sub-hyperplanes. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side. The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the checkPoint() method will not be meaningful anymore. If the boundary is empty, the region will represent the whole space.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.ArcsSet	(	double	): Build an arcs set representing the whole circle.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.ArcsSet	(	double	double	double	): Build an arcs set corresponding to a single arc.  If either lower is equals to upper or the interval exceeds \( 2 \pi \), the arc is considered to be the full circle and its initial defining boundaries will be forgotten. lower is not allowed to be greater than upper (an exception is thrown in this case). 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.InconsistentStateAt2PiWrapping: Specialized exception for inconsistent BSP tree state inconsistency.  This exception is thrown at ArcsSet construction time when the org.apache.commons.math4.geometry.partitioning.Region.Location inside/outside state is not consistent at the 0, \(2 \pi \) crossing. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.InconsistentStateAt2PiWrapping.InconsistentStateAt2PiWrapping	(	): Simple constructor.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.Split: Class holding the results of the split method.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.Split.Split	(	ArcsSet	ArcsSet	): Build a Split from its parts.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.Split.getMinus	(	): Get the part of the arcs set on the minus side of the splitting arc.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.Split.getPlus	(	): Get the part of the arcs set on the plus side of the splitting arc.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.Split.getSide	(	): Get the side of the split arc with respect to its splitter.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.SubArcsIterator: Local iterator for sub-arcs. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.SubArcsIterator.SubArcsIterator	(	): Simple constructor.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.SubArcsIterator.hasNext	(	):  
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.SubArcsIterator.next	(	):  
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.SubArcsIterator.remove	(	):  
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.SubArcsIterator.selectPending	(	): Walk the tree to select the pending sub-arc.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.addArcLimit	(	BSPTree	double	boolean	): Add an arc limit to a BSP tree under construction.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.asList	(	): Build an ordered list of arcs representing the instance. This method builds this arcs set as an ordered list of Arc Arc elements. An empty tree will build an empty list while a tree representing the whole circle will build a one element list with bounds set to \( 0 and 2 \pi \).
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).  
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.buildTree	(	double	double	double	): Build an inside/outside tree representing a single arc.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.check2PiConsistency	(	): Check consistency.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.childAfter	(	BSPTree	): Find the child node just after an internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.childBefore	(	BSPTree	): Find the child node just before an internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.computeGeometricalProperties	(	): Compute some geometrical properties. The properties to compute are the barycenter and the size. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.createSplitPart	(	List	): Create a split part.  As per construction, the list of limit angles is known to have an even number of entries, with start angles at even indices and end angles at odd indices. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.getAngle	(	BSPTree	): Get the limit angle of an internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.getFirstArcStart	(	): Get the node corresponding to the first arc start.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.getFirstLeaf	(	BSPTree	): Get the first leaf node of a tree.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.getLastLeaf	(	BSPTree	): Get the last leaf node of a tree.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.isAfterParent	(	BSPTree	): Check if a node is the child after its parent in trigonometric order.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.isArcEnd	(	BSPTree	): Check if an internal node corresponds to the end angle of an arc.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.isArcStart	(	BSPTree	): Check if an internal node corresponds to the start angle of an arc.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.isBeforeParent	(	BSPTree	): Check if a node is the child before its parent in trigonometric order.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.isDirect	(	BSPTree	): Check if an internal node has a direct limit angle.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.iterator	(	):   The iterator returns the limit angles pairs of sub-arcs in trigonometric order.   The iterator does not support the optional remove operation. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.leafAfter	(	BSPTree	): Find the leaf node just after an internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.leafBefore	(	BSPTree	): Find the leaf node just before an internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.nextInternalNode	(	BSPTree	): Get the next internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.previousInternalNode	(	BSPTree	): Get the previous internal node.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.projectToBoundary	(	Point	): Project a point on the boundary of the region.
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.side	(	Arc	): Compute the relative position of the instance with respect to an arc.  The MINUS side of the arc is the one covered by the arc. 
org.apache.commons.math4.geometry.spherical.oned.ArcsSet.split	(	Arc	): Split the instance in two parts by an arc.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle: This class represents a 1D oriented hyperplane on the circle. An hyperplane on the 1-sphere is an angle with an orientation. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.LimitAngle	(	S1Point	boolean	double	): Simple constructor.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.copySelf	(	): Copy the instance. Since instances are immutable, this method directly returns the instance.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.getLocation	(	): Get the hyperplane location on the circle.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.getOffset	(	Point	): Get the offset (oriented distance) of a point. The offset is 0 if the point is on the underlying hyperplane, it is positive if the point is on one particular side of the hyperplane, and it is negative if the point is on the other side, according to the hyperplane natural orientation. 
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.getReverse	(	): Get the reverse of the instance. Get a limit angle with reversed orientation with respect to the instance. A new object is built, the instance is untouched.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.getTolerance	(	): Get the tolerance below which points are considered to belong to the hyperplane. 
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.isDirect	(	): Check if the hyperplane orientation is direct.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.project	(	Point	): Project a point to the hyperplane. 
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.sameOrientationAs	(	Hyperplane	): Check if the instance has the same orientation as another hyperplane. This method is expected to be called on parallel hyperplanes. The method should not re-check for parallelism, only for orientation, typically by testing something like the sign of the dot-products of normals. 
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.wholeHyperplane	(	): Build a region covering the whole hyperplane. Since this class represent zero dimension spaces which does not have lower dimension sub-spaces, this method returns a dummy implementation of a org.apache.commons.math4.geometry.partitioning.SubHyperplane SubHyperplane. This implementation is only used to allow the org.apache.commons.math4.geometry.partitioning.SubHyperplane SubHyperplane class implementation to work properly, it should not be used otherwise.
org.apache.commons.math4.geometry.spherical.oned.LimitAngle.wholeSpace	(	): Build a region covering the whole space.
org.apache.commons.math4.geometry.spherical.oned.S1Point: This class represents a point on the 1-sphere. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.spherical.oned.S1Point.S1Point	(	double	): Simple constructor. Build a vector from its coordinates
org.apache.commons.math4.geometry.spherical.oned.S1Point.S1Point	(	double	Cartesian2D	): Build a point from its internal components.
org.apache.commons.math4.geometry.spherical.oned.S1Point.distance	(	Point	): Compute the distance between the instance and another point. 
org.apache.commons.math4.geometry.spherical.oned.S1Point.distance	(	S1Point	S1Point	): Compute the distance (angular separation) between two points.
org.apache.commons.math4.geometry.spherical.oned.S1Point.equals	(	Object	): Test for the equality of two points on the 2-sphere.  If all coordinates of two points are exactly the same, and none are Double.NaN, the two points are considered to be equal.   NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 2D vector are equal to Double.NaN, the 2D vector is equal to NaN. 
org.apache.commons.math4.geometry.spherical.oned.S1Point.getAlpha	(	): Get the azimuthal angle \( \alpha \).
org.apache.commons.math4.geometry.spherical.oned.S1Point.getSpace	(	): Get the space to which the point belongs. 
org.apache.commons.math4.geometry.spherical.oned.S1Point.getVector	(	): Get the corresponding normalized vector in the 2D euclidean space.
org.apache.commons.math4.geometry.spherical.oned.S1Point.hashCode	(	): Get a hashCode for the 2D vector.  All NaN values have the same hash code.
org.apache.commons.math4.geometry.spherical.oned.S1Point.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise 
org.apache.commons.math4.geometry.spherical.oned.Sphere1D: This class implements a one-dimensional sphere (i.e. a circle).  We use here the topologists definition of the 1-sphere (see Sphere on MathWorld), i.e. the 1-sphere is the one-dimensional closed curve defined in 2D as x2+y2=1. 
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.NoSubSpaceException: Specialized exception for inexistent sub-space.  This exception is thrown when attempting to get the sub-space of a one-dimensional space 
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.NoSubSpaceException.NoSubSpaceException	(	): Simple constructor.
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.Sphere1D	(	): Private constructor for the singleton.
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.getDimension	(	): Get the dimension of the space. 
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.getInstance	(	): Get the unique instance.
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.getSubSpace	(	): Get the n-1 dimension subspace of this space.  As the 1-dimension sphere does not have proper sub-spaces, this method always throws a NoSubSpaceException 
org.apache.commons.math4.geometry.spherical.oned.Sphere1D.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.geometry.spherical.oned.SubLimitAngle: This class represents sub-hyperplane for LimitAngle. Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.spherical.oned.SubLimitAngle.SubLimitAngle	(	Hyperplane	Region	): Simple constructor.
org.apache.commons.math4.geometry.spherical.oned.SubLimitAngle.buildNew	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region. 
org.apache.commons.math4.geometry.spherical.oned.SubLimitAngle.getSize	(	): Get the size of the instance.  
org.apache.commons.math4.geometry.spherical.oned.SubLimitAngle.isEmpty	(	): Check if the instance is empty.  
org.apache.commons.math4.geometry.spherical.oned.SubLimitAngle.split	(	Hyperplane	): Split the instance in two parts by an hyperplane.  
org.apache.commons.math4.geometry.spherical.twod.Circle: This class represents an oriented great circle on the 2-sphere. An oriented circle can be defined by a center point. The circle is the the set of points that are in the normal plan the center. Since it is oriented the two spherical caps at its two sides are unambiguously identified as a left cap and a right cap. This can be used to identify the interior and the exterior in a simple way by local properties only when part of a line is used to define part of a spherical polygon boundary.
org.apache.commons.math4.geometry.spherical.twod.Circle.Circle	(	Cartesian3D	Cartesian3D	Cartesian3D	double	): Build a circle from its internal components. The circle is oriented in the trigonometric direction around center.
org.apache.commons.math4.geometry.spherical.twod.Circle.Circle	(	Cartesian3D	double	): Build a great circle from its pole. The circle is oriented in the trigonometric direction around pole.
org.apache.commons.math4.geometry.spherical.twod.Circle.Circle	(	Circle	): Copy constructor. The created instance is completely independent from the original instance, it is a deep copy.
org.apache.commons.math4.geometry.spherical.twod.Circle.Circle	(	S2Point	S2Point	double	): Build a great circle from two non-aligned points. The circle is oriented from first to second point using the path smaller than \( \pi \).
org.apache.commons.math4.geometry.spherical.twod.Circle.CircleTransform: Class embedding a 3D rotation. 
org.apache.commons.math4.geometry.spherical.twod.Circle.CircleTransform.CircleTransform	(	Rotation	): Build a transform from a Rotation.
org.apache.commons.math4.geometry.spherical.twod.Circle.CircleTransform.apply	(	Hyperplane	): Transform an hyperplane of a space. 
org.apache.commons.math4.geometry.spherical.twod.Circle.CircleTransform.apply	(	Point	): Transform a point of a space. 
org.apache.commons.math4.geometry.spherical.twod.Circle.CircleTransform.apply	(	SubHyperplane	Hyperplane	Hyperplane	): Transform a sub-hyperplane embedded in an hyperplane. 
org.apache.commons.math4.geometry.spherical.twod.Circle.copySelf	(	): Copy the instance. The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for immutable objects). 
org.apache.commons.math4.geometry.spherical.twod.Circle.getInsideArc	(	Circle	): Get the arc of the instance that lies inside the other circle.
org.apache.commons.math4.geometry.spherical.twod.Circle.getOffset	(	Cartesian3D	): Get the offset (oriented distance) of a direction. The offset is defined as the angular distance between the circle center and the direction minus the circle radius. It is therefore 0 on the circle, positive for directions outside of the cone delimited by the circle, and negative inside the cone.
org.apache.commons.math4.geometry.spherical.twod.Circle.getOffset	(	Point	): Get the offset (oriented distance) of a point. The offset is 0 if the point is on the underlying hyperplane, it is positive if the point is on one particular side of the hyperplane, and it is negative if the point is on the other side, according to the hyperplane natural orientation.
org.apache.commons.math4.geometry.spherical.twod.Circle.getPhase	(	Cartesian3D	): Get the phase angle of a direction.  The direction may not belong to the circle as the phase is computed for the meridian plane between the circle pole and the direction. 
org.apache.commons.math4.geometry.spherical.twod.Circle.getPointAt	(	double	): Get a circle point from its phase around the circle.
org.apache.commons.math4.geometry.spherical.twod.Circle.getPole	(	): Get the pole of the circle.  As the circle is a great circle, the pole does not belong to it. 
org.apache.commons.math4.geometry.spherical.twod.Circle.getReverse	(	): Get the reverse of the instance. Get a circle with reversed orientation with respect to the instance. A new object is built, the instance is untouched.
org.apache.commons.math4.geometry.spherical.twod.Circle.getTolerance	(	): Get the tolerance below which points are considered to belong to the hyperplane. 
org.apache.commons.math4.geometry.spherical.twod.Circle.getTransform	(	Rotation	): Get a org.apache.commons.math4.geometry.partitioning.Transform Transform embedding a 3D rotation.
org.apache.commons.math4.geometry.spherical.twod.Circle.getXAxis	(	): Get the X axis of the circle.  This method returns the same value as getPointAt() getPointAt(0.0) but it does not do any computation and always return the same instance. 
org.apache.commons.math4.geometry.spherical.twod.Circle.getYAxis	(	): Get the Y axis of the circle.  This method returns the same value as getPointAt() getPointAt(0.5 * FastMath.PI) but it does not do any computation and always return the same instance. 
org.apache.commons.math4.geometry.spherical.twod.Circle.project	(	Point	): Project a point to the hyperplane. 
org.apache.commons.math4.geometry.spherical.twod.Circle.reset	(	Cartesian3D	): Reset the instance as if built from a pole. The circle is oriented in the trigonometric direction around pole.
org.apache.commons.math4.geometry.spherical.twod.Circle.revertSelf	(	): Revert the instance.
org.apache.commons.math4.geometry.spherical.twod.Circle.sameOrientationAs	(	Hyperplane	): Check if the instance has the same orientation as another hyperplane. This method is expected to be called on parallel hyperplanes. The method should not re-check for parallelism, only for orientation, typically by testing something like the sign of the dot-products of normals. 
org.apache.commons.math4.geometry.spherical.twod.Circle.toSpace	(	Point	): Transform a sub-space point into a space point.
org.apache.commons.math4.geometry.spherical.twod.Circle.toSubSpace	(	Point	): Transform a space point into a sub-space point.
org.apache.commons.math4.geometry.spherical.twod.Circle.wholeHyperplane	(	): Build a sub-hyperplane covering the whole hyperplane. 
org.apache.commons.math4.geometry.spherical.twod.Circle.wholeSpace	(	): Build a region covering the whole space.
org.apache.commons.math4.geometry.spherical.twod.Edge: Spherical polygons boundary edge.
org.apache.commons.math4.geometry.spherical.twod.Edge.Edge	(	Vertex	Vertex	double	Circle	): Build an edge not contained in any node yet.
org.apache.commons.math4.geometry.spherical.twod.Edge.addSubEdge	(	Vertex	Vertex	double	List	Circle	): Add a sub-edge to a list if long enough.  If the length of the sub-edge to add is smaller than the getTolerance() tolerance of the support circle, it will be ignored. 
org.apache.commons.math4.geometry.spherical.twod.Edge.getCircle	(	): Get the circle supporting this edge.
org.apache.commons.math4.geometry.spherical.twod.Edge.getEnd	(	): Get end vertex.
org.apache.commons.math4.geometry.spherical.twod.Edge.getLength	(	): Get the length of the arc.
org.apache.commons.math4.geometry.spherical.twod.Edge.getPointAt	(	double	): Get an intermediate point.  The angle along the edge should normally be between 0 and getLength() in order to remain within edge limits. However, there are no checks on the value of the angle, so user can rebuild the full circle on which an edge is defined if they want. 
org.apache.commons.math4.geometry.spherical.twod.Edge.getStart	(	): Get start vertex.
org.apache.commons.math4.geometry.spherical.twod.Edge.setNextEdge	(	Edge	): Connect the instance with a following edge.
org.apache.commons.math4.geometry.spherical.twod.Edge.split	(	Circle	List	List	): Split the edge.  Once split, this edge is not referenced anymore by the vertices, it is replaced by the two or three sub-edges and intermediate splitting vertices are introduced to connect these sub-edges together. 
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder: Visitor building edges.
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.EdgesBuilder	(	BSPTree	double	): Simple constructor.
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.addContribution	(	SubCircle	boolean	BSPTree	): Add the contribution of a boundary edge.
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.getEdges	(	): Get the boundary edges.
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.getFollowingEdge	(	Edge	): Get the edge that should naturally follow another one.
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.spherical.twod.EdgesBuilder.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer: Visitor computing geometrical properties.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.PropertiesComputer	(	double	): Simple constructor.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.convexCellArea	(	Vertex	): Compute convex cell area.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.convexCellBarycenter	(	Vertex	): Compute convex cell barycenter.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.getArea	(	): Get the area.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.getBarycenter	(	): Get the barycenter.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.getConvexCellsInsidePoints	(	): Get the points strictly inside convex cells.
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.visitInternalNode	(	BSPTree	): Visit a BSP tree node node having a non-null sub-hyperplane. It is guaranteed that this method will be called after visitOrder has been called for a given node, it wil be called exactly once for each internal node. 
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.visitLeafNode	(	BSPTree	): Visit a leaf BSP tree node node having a null sub-hyperplane. 
org.apache.commons.math4.geometry.spherical.twod.PropertiesComputer.visitOrder	(	BSPTree	): Determine the visit order for this node. Before attempting to visit an internal node, this method is called to determine the desired ordering of the visit. It is guaranteed that this method will be called before visitInternalNode for a given node, it will be called exactly once for each internal node. 
org.apache.commons.math4.geometry.spherical.twod.S2Point: This class represents a point on the 2-sphere.  We use the mathematical convention to use the azimuthal angle \( \theta \) in the x-y plane as the first coordinate, and the polar angle \( \varphi \) as the second coordinate (see Spherical Coordinates in MathWorld).  Instances of this class are guaranteed to be immutable.
org.apache.commons.math4.geometry.spherical.twod.S2Point.S2Point	(	Cartesian3D	): Simple constructor. Build a vector from its underlying 3D vector
org.apache.commons.math4.geometry.spherical.twod.S2Point.S2Point	(	double	double	): Simple constructor. Build a vector from its spherical coordinates
org.apache.commons.math4.geometry.spherical.twod.S2Point.S2Point	(	double	double	Cartesian3D	): Build a point from its internal components.
org.apache.commons.math4.geometry.spherical.twod.S2Point.distance	(	Point	): Compute the distance between the instance and another point. 
org.apache.commons.math4.geometry.spherical.twod.S2Point.distance	(	S2Point	S2Point	): Compute the distance (angular separation) between two points.
org.apache.commons.math4.geometry.spherical.twod.S2Point.equals	(	Object	): Test for the equality of two points on the 2-sphere.  If all coordinates of two points are exactly the same, and none are Double.NaN, the two points are considered to be equal.   NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 2D vector are equal to Double.NaN, the 2D vector is equal to NaN. 
org.apache.commons.math4.geometry.spherical.twod.S2Point.getPhi	(	): Get the polar angle \( \varphi \).
org.apache.commons.math4.geometry.spherical.twod.S2Point.getSpace	(	): Get the space to which the point belongs. 
org.apache.commons.math4.geometry.spherical.twod.S2Point.getTheta	(	): Get the azimuthal angle \( \theta \) in the x-y plane.
org.apache.commons.math4.geometry.spherical.twod.S2Point.getVector	(	): Get the corresponding normalized vector in the 3D euclidean space.
org.apache.commons.math4.geometry.spherical.twod.S2Point.hashCode	(	): Get a hashCode for the 2D vector.  All NaN values have the same hash code.
org.apache.commons.math4.geometry.spherical.twod.S2Point.isNaN	(	): Returns true if any coordinate of this point is NaN; false otherwise 
org.apache.commons.math4.geometry.spherical.twod.S2Point.negate	(	): Get the opposite of the instance.
org.apache.commons.math4.geometry.spherical.twod.S2Point.vector	(	double	double	): Build the normalized vector corresponding to spherical coordinates.
org.apache.commons.math4.geometry.spherical.twod.Sphere2D: This class implements a two-dimensional sphere (i.e. the regular sphere).  We use here the topologists definition of the 2-sphere (see Sphere on MathWorld), i.e. the 2-sphere is the two-dimensional surface defined in 3D as x2+y2+z2=1. 
org.apache.commons.math4.geometry.spherical.twod.Sphere2D.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.geometry.spherical.twod.Sphere2D.Sphere2D	(	): Private constructor for the singleton.
org.apache.commons.math4.geometry.spherical.twod.Sphere2D.getDimension	(	): Get the dimension of the space. 
org.apache.commons.math4.geometry.spherical.twod.Sphere2D.getInstance	(	): Get the unique instance.
org.apache.commons.math4.geometry.spherical.twod.Sphere2D.getSubSpace	(	): Get the n-1 dimension subspace of this space. 
org.apache.commons.math4.geometry.spherical.twod.Sphere2D.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet: This class represents a region on the 2-sphere: a set of spherical polygons.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.SphericalPolygonsSet	(	BSPTree	double	): Build a polygons set from a BSP tree. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.SphericalPolygonsSet	(	Cartesian3D	Cartesian3D	double	int	double	): Build a polygons set representing a regular polygon.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.SphericalPolygonsSet	(	Cartesian3D	double	): Build a polygons set representing a hemisphere.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.SphericalPolygonsSet	(	Collection	double	): Build a polygons set from a Boundary REPresentation (B-rep). The boundary is provided as a collection of SubHyperplane sub-hyperplanes. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side. The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoint polygons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the checkPoint() method will not be meaningful anymore. If the boundary is empty, the region will represent the whole space.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.SphericalPolygonsSet	(	double	): Build a polygons set representing the whole real 2-sphere.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.SphericalPolygonsSet	(	double	S2Point	): Build a polygon from a simple list of vertices. The boundary is provided as a list of points considering to represent the vertices of a simple loop. The interior part of the region is on the left side of this path and the exterior is on its right side. This constructor does not handle polygons with a boundary forming several disconnected paths (such as polygons with holes). For cases where this simple constructor applies, it is expected to be numerically more robust than the SphericalPolygonsSet() general constructor using SubHyperplane subhyperplanes. If the list is empty, the region will represent the whole space.  Polygons with thin pikes or dents are inherently difficult to handle because they involve circles with almost opposite directions at some vertices. Polygons whose vertices come from some physical measurement with noise are also difficult because an edge that should be straight may be broken in lots of different pieces with almost equal directions. In both cases, computing the circles intersections is not numerically robust due to the almost 0 or almost π angle. Such cases need to carefully adjust the hyperplaneThickness parameter. A too small value would often lead to completely wrong polygons with large area wrongly identified as inside or outside. Large values are often much safer. As a rule of thumb, a value slightly below the size of the most accurate detail needed is a good value for the hyperplaneThickness parameter. 
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.buildNew	(	BSPTree	): Build a region using the instance as a prototype. This method allow to create new instances without knowing exactly the type of the region. It is an application of the prototype design pattern. The leaf nodes of the BSP tree must have a Boolean attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants Boolean.TRUE and Boolean.FALSE. The tree also must have either null internal nodes or internal nodes representing the boundary as specified in the getTree method).  
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.computeGeometricalProperties	(	): Compute some geometrical properties. The properties to compute are the barycenter and the size.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.createRegularPolygonVertices	(	Cartesian3D	Cartesian3D	double	int	): Build the vertices representing a regular polygon.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.getBoundaryLoops	(	): Get the boundary loops of the polygon. The polygon boundary can be represented as a list of closed loops, each loop being given by exactly one of its vertices. From each loop start vertex, one can follow the loop by finding the outgoing edge, then the end vertex, then the next outgoing edge ... until the start vertex of the loop (exactly the same instance) is found again once the full loop has been visited. If the polygon has no boundary at all, a zero length loop array will be returned. If the polygon is a simple one-piece polygon, then the returned array will contain a single vertex.  All edges in the various loops have the inside of the region on their left side (i.e. toward their pole) and the outside on their right side (i.e. away from their pole) when moving in the underlying circle direction. This means that the closed loops obey the direct trigonometric orientation.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.getEnclosingCap	(	): Get a spherical cap enclosing the polygon.  This method is intended as a first test to quickly identify points that are guaranteed to be outside of the region, hence performing a full checkPoint() only if the point status remains undecided after the quick check. It is is therefore mostly useful to speed up computation for small polygons with complex shapes (say a country boundary on Earth), as the spherical cap will be small and hence will reliably identify a large part of the sphere as outside, whereas the full check can be more computing intensive. A typical use case is therefore:  // compute region, plus an enclosing spherical cap SphericalPolygonsSet complexShape = ...; EnclosingBall cap = complexShape.getEnclosingCap(); // check lots of points for (Cartesian3D p : points) final Location l; if (cap.contains(p)) { // we cannot be sure where the point is // we need to perform the full computation l = complexShape.checkPoint(v); } else { // no need to do further computation, // we already know the point is outside l = Location.OUTSIDE; } // use l ... } }  In the special cases of empty or whole sphere polygons, special spherical caps are returned, with angular radius set to negative or positive infinity so the contains() ball.contains(point) method return always false or true.   This method is not guaranteed to return the smallest enclosing cap. 
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.getInsidePoints	(	): Gather some inside points.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.getOutsidePoints	(	): Gather some outside points.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.insertEdges	(	double	BSPTree	List	): Recursively build a tree by inserting cut sub-hyperplanes.
org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet.verticesToTree	(	double	S2Point	): Build the BSP tree of a polygons set from a simple list of vertices. The boundary is provided as a list of points considering to represent the vertices of a simple loop. The interior part of the region is on the left side of this path and the exterior is on its right side. This constructor does not handle polygons with a boundary forming several disconnected paths (such as polygons with holes). This constructor handles only polygons with edges strictly shorter than \( \pi \). If longer edges are needed, they need to be broken up in smaller sub-edges so this constraint holds. For cases where this simple constructor applies, it is expected to be numerically more robust than the PolygonsSet() general constructor using SubHyperplane subhyperplanes.
org.apache.commons.math4.geometry.spherical.twod.SubCircle: This class represents a sub-hyperplane for Circle.
org.apache.commons.math4.geometry.spherical.twod.SubCircle.SubCircle	(	Hyperplane	Region	): Simple constructor.
org.apache.commons.math4.geometry.spherical.twod.SubCircle.buildNew	(	Hyperplane	Region	): Build a sub-hyperplane from an hyperplane and a region. 
org.apache.commons.math4.geometry.spherical.twod.SubCircle.split	(	Hyperplane	): Split the instance in two parts by an hyperplane.  
org.apache.commons.math4.geometry.spherical.twod.Vertex: Spherical polygons boundary vertex.
org.apache.commons.math4.geometry.spherical.twod.Vertex.Vertex	(	S2Point	): Build a non-processed vertex not owned by any node yet.
org.apache.commons.math4.geometry.spherical.twod.Vertex.bindWith	(	Circle	): Bind a circle considered to contain this vertex.
org.apache.commons.math4.geometry.spherical.twod.Vertex.getIncoming	(	): Get incoming edge.
org.apache.commons.math4.geometry.spherical.twod.Vertex.getLocation	(	): Get Vertex location.
org.apache.commons.math4.geometry.spherical.twod.Vertex.getOutgoing	(	): Get outgoing edge.
org.apache.commons.math4.geometry.spherical.twod.Vertex.setIncoming	(	Edge	): Set incoming edge.  The circle supporting the incoming edge is automatically bound with the instance. 
org.apache.commons.math4.geometry.spherical.twod.Vertex.setOutgoing	(	Edge	): Set outgoing edge.  The circle supporting the outgoing edge is automatically bound with the instance. 
org.apache.commons.math4.geometry.spherical.twod.Vertex.sharedCircleWith	(	Vertex	): Get the common circle bound with both the instance and another vertex, if any.  When two vertices are both bound to the same circle, this means they are already handled by node associated with this circle, so there is no need to create a cut hyperplane for them. 
org.apache.commons.math4.linear.AbstractFieldMatrix: Basic implementation of FieldMatrix methods regardless of the underlying storage. All the methods implemented here use getEntry() to access matrix elements. Derived class can provide faster implementations. 
org.apache.commons.math4.linear.AbstractFieldMatrix.AbstractFieldMatrix	(	): Constructor for use with Serializable
org.apache.commons.math4.linear.AbstractFieldMatrix.AbstractFieldMatrix	(	Field	): Creates a matrix with no data
org.apache.commons.math4.linear.AbstractFieldMatrix.AbstractFieldMatrix	(	Field	int	int	): Create a new FieldMatrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.AbstractFieldMatrix.add	(	FieldMatrix	): Compute the sum of this and m. 
org.apache.commons.math4.linear.AbstractFieldMatrix.addToEntry	(	int	int	T	): Change an entry in the specified row and column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.checkAdditionCompatible	(	FieldMatrix	): Check if a matrix is addition compatible with the instance.
org.apache.commons.math4.linear.AbstractFieldMatrix.checkColumnIndex	(	int	): Check if a column index is valid.
org.apache.commons.math4.linear.AbstractFieldMatrix.checkMultiplicationCompatible	(	FieldMatrix	): Check if a matrix is multiplication compatible with the instance.
org.apache.commons.math4.linear.AbstractFieldMatrix.checkRowIndex	(	int	): Check if a row index is valid.
org.apache.commons.math4.linear.AbstractFieldMatrix.checkSubMatrixIndex	(	int	int	int	int	): Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.AbstractFieldMatrix.checkSubMatrixIndex	(	int[]	int[]	): Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.AbstractFieldMatrix.checkSubtractionCompatible	(	FieldMatrix	): Check if a matrix is subtraction compatible with the instance.
org.apache.commons.math4.linear.AbstractFieldMatrix.copy	(	): Make a (deep) copy of this. 
org.apache.commons.math4.linear.AbstractFieldMatrix.copySubMatrix	(	int	int	int	int	T[][]	): Copy a submatrix. Rows and columns are 0-based. The designated submatrix is copied into the top left portion of the destination array. 
org.apache.commons.math4.linear.AbstractFieldMatrix.copySubMatrix	(	int[]	int[]	T[][]	): Copy a submatrix. Rows and columns are indicated counting from 0 to n - 1. 
org.apache.commons.math4.linear.AbstractFieldMatrix.createMatrix	(	int	int	): Create a new FieldMatrix of the same type as the instance with the supplied row and column dimensions. 
org.apache.commons.math4.linear.AbstractFieldMatrix.equals	(	Object	): Returns true iff object is a FieldMatrix instance with the same dimensions as this and all corresponding matrix entries are equal.
org.apache.commons.math4.linear.AbstractFieldMatrix.extractField	(	T[]	): Get the elements type from an array.
org.apache.commons.math4.linear.AbstractFieldMatrix.extractField	(	T[][]	): Get the elements type from an array.
org.apache.commons.math4.linear.AbstractFieldMatrix.getColumn	(	int	): Get the entries in column number col as an array. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getColumnDimension	(	): Returns the number of columns in the matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getColumnMatrix	(	int	): Get the entries in column number column as a column matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getColumnVector	(	int	): Returns the entries in column number column as a vector. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getData	(	): Returns matrix entries as a two-dimensional array. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getEntry	(	int	int	): Returns the entry in the specified row and column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getField	(	): Get the type of field elements of the matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getRow	(	int	): Get the entries in row number row as an array. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getRowDimension	(	): Returns the number of rows in the matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getRowMatrix	(	int	): Get the entries in row number row as a row matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getRowVector	(	int	): Get the entries in row number row as a vector. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getSubMatrix	(	int	int	int	int	): Get a submatrix. Rows and columns are indicated counting from 0 to n - 1. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getSubMatrix	(	int[]	int[]	): Get a submatrix. Rows and columns are indicated counting from 0 to n - 1. 
org.apache.commons.math4.linear.AbstractFieldMatrix.getTrace	(	): Returns the  trace of the matrix (the sum of the elements on the main diagonal). 
org.apache.commons.math4.linear.AbstractFieldMatrix.hashCode	(	): Computes a hashcode for the matrix.
org.apache.commons.math4.linear.AbstractFieldMatrix.isSquare	(	): Is this a square matrix? 
org.apache.commons.math4.linear.AbstractFieldMatrix.multiply	(	FieldMatrix	): Postmultiply this matrix by m. 
org.apache.commons.math4.linear.AbstractFieldMatrix.multiplyEntry	(	int	int	T	): Change an entry in the specified row and column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.operate	(	FieldVector	): Returns the result of multiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractFieldMatrix.operate	(	T[]	): Returns the result of multiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractFieldMatrix.power	(	int	): Returns the result multiplying this with itself p times. Depending on the type of the field elements, T, instability for high powers might occur. 
org.apache.commons.math4.linear.AbstractFieldMatrix.preMultiply	(	FieldMatrix	): Premultiply this matrix by m. 
org.apache.commons.math4.linear.AbstractFieldMatrix.preMultiply	(	FieldVector	): Returns the (row) vector result of premultiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractFieldMatrix.preMultiply	(	T[]	): Returns the (row) vector result of premultiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractFieldMatrix.scalarAdd	(	T	): Increment each entry of this matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.scalarMultiply	(	T	): Multiply each entry by d. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setColumn	(	int	T[]	): Set the entries in column number column as a column matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setColumnMatrix	(	int	FieldMatrix	): Set the entries in column number column as a column matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setColumnVector	(	int	FieldVector	): Set the entries in column number column as a vector. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setEntry	(	int	int	T	): Set the entry in the specified row and column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setRow	(	int	T[]	): Set the entries in row number row as a row matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setRowMatrix	(	int	FieldMatrix	): Set the entries in row number row as a row matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setRowVector	(	int	FieldVector	): Set the entries in row number row as a vector. 
org.apache.commons.math4.linear.AbstractFieldMatrix.setSubMatrix	(	T[][]	int	int	): Replace the submatrix starting at (row, column) using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2  
org.apache.commons.math4.linear.AbstractFieldMatrix.subtract	(	FieldMatrix	): Subtract m from this matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.toString	(	): Get a string representation for this matrix.
org.apache.commons.math4.linear.AbstractFieldMatrix.transpose	(	): Returns the transpose of this matrix. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInColumnOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInColumnOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInColumnOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInColumnOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInOptimizedOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInOptimizedOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInOptimizedOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInOptimizedOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractFieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractRealMatrix: Basic implementation of RealMatrix methods regardless of the underlying storage. All the methods implemented here use getEntry() to access matrix elements. Derived class can provide faster implementations.
org.apache.commons.math4.linear.AbstractRealMatrix.AbstractRealMatrix	(	): Creates a matrix with no data
org.apache.commons.math4.linear.AbstractRealMatrix.AbstractRealMatrix	(	int	int	): Create a new RealMatrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.AbstractRealMatrix.add	(	RealMatrix	): Returns the sum of this and m. 
org.apache.commons.math4.linear.AbstractRealMatrix.addToEntry	(	int	int	double	): Adds (in place) the specified value to the specified entry of this matrix. Row and column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.copy	(	): Returns a (deep) copy of this. 
org.apache.commons.math4.linear.AbstractRealMatrix.copySubMatrix	(	int	int	int	int	double[][]	): Copy a submatrix. Rows and columns are indicated counting from 0 to n-1. 
org.apache.commons.math4.linear.AbstractRealMatrix.copySubMatrix	(	int[]	int[]	double[][]	): Copy a submatrix. Rows and columns are indicated counting from 0 to n-1. 
org.apache.commons.math4.linear.AbstractRealMatrix.createMatrix	(	int	int	): Create a new RealMatrix of the same type as the instance with the supplied row and column dimensions. 
org.apache.commons.math4.linear.AbstractRealMatrix.equals	(	Object	): Returns true iff object is a RealMatrix instance with the same dimensions as this and all corresponding matrix entries are equal.
org.apache.commons.math4.linear.AbstractRealMatrix.getColumn	(	int	): Get the entries at the given column index as an array. Column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getColumnDimension	(	): Returns the number of columns of this matrix.
org.apache.commons.math4.linear.AbstractRealMatrix.getColumnMatrix	(	int	): Get the entries at the given column index as a column matrix. Column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getColumnVector	(	int	): Get the entries at the given column index as a vector. Column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getData	(	): Returns matrix entries as a two-dimensional array. 
org.apache.commons.math4.linear.AbstractRealMatrix.getEntry	(	int	int	): Get the entry in the specified row and column. Row and column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getFrobeniusNorm	(	): Returns the  Frobenius norm of the matrix. 
org.apache.commons.math4.linear.AbstractRealMatrix.getNorm	(	): Returns the  maximum absolute row sum norm of the matrix. 
org.apache.commons.math4.linear.AbstractRealMatrix.getRow	(	int	): Get the entries at the given row index. Row indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getRowDimension	(	): Returns the number of rows of this matrix.
org.apache.commons.math4.linear.AbstractRealMatrix.getRowMatrix	(	int	): Get the entries at the given row index as a row matrix. Row indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getRowVector	(	int	): Returns the entries in row number row as a vector. Row indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.getSubMatrix	(	int	int	int	int	): Gets a submatrix. Rows and columns are indicated counting from 0 to n-1. 
org.apache.commons.math4.linear.AbstractRealMatrix.getSubMatrix	(	int[]	int[]	): Gets a submatrix. Rows and columns are indicated counting from 0 to n-1. 
org.apache.commons.math4.linear.AbstractRealMatrix.getTrace	(	): Returns the  trace of the matrix (the sum of the elements on the main diagonal). 
org.apache.commons.math4.linear.AbstractRealMatrix.hashCode	(	): Computes a hashcode for the matrix.
org.apache.commons.math4.linear.AbstractRealMatrix.isSquare	(	): Is this a square matrix? 
org.apache.commons.math4.linear.AbstractRealMatrix.multiply	(	RealMatrix	): Returns the result of postmultiplying this by m. 
org.apache.commons.math4.linear.AbstractRealMatrix.multiplyEntry	(	int	int	double	): Multiplies (in place) the specified entry of this matrix by the specified value. Row and column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.operate	(	RealVector	): Returns the result of multiplying this by the vector x. 
org.apache.commons.math4.linear.AbstractRealMatrix.operate	(	double[]	): Returns the result of multiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractRealMatrix.power	(	int	): Returns the result of multiplying this with itself p times. Depending on the underlying storage, instability for high powers might occur. 
org.apache.commons.math4.linear.AbstractRealMatrix.preMultiply	(	RealMatrix	): Returns the result of premultiplying this by m. 
org.apache.commons.math4.linear.AbstractRealMatrix.preMultiply	(	RealVector	): Returns the (row) vector result of premultiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractRealMatrix.preMultiply	(	double[]	): Returns the (row) vector result of premultiplying this by the vector v. 
org.apache.commons.math4.linear.AbstractRealMatrix.scalarAdd	(	double	): Returns the result of adding d to each entry of this. 
org.apache.commons.math4.linear.AbstractRealMatrix.scalarMultiply	(	double	): Returns the result of multiplying each entry of this by d. 
org.apache.commons.math4.linear.AbstractRealMatrix.setColumn	(	int	double[]	): Sets the specified column of this matrix to the entries of the specified array. Column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setColumnMatrix	(	int	RealMatrix	): Sets the specified column of this matrix to the entries of the specified column matrix. Column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setColumnVector	(	int	RealVector	): Sets the specified column of this matrix to the entries of the specified vector. Column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setEntry	(	int	int	double	): Set the entry in the specified row and column. Row and column indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setRow	(	int	double[]	): Sets the specified row of this matrix to the entries of the specified array. Row indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setRowMatrix	(	int	RealMatrix	): Sets the specified row of this matrix to the entries of the specified row matrix. Row indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setRowVector	(	int	RealVector	): Sets the specified row of this matrix to the entries of the specified vector. Row indices start at 0. 
org.apache.commons.math4.linear.AbstractRealMatrix.setSubMatrix	(	double[][]	int	int	): Replace the submatrix starting at row, column using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2  
org.apache.commons.math4.linear.AbstractRealMatrix.subtract	(	RealMatrix	): Returns this minus m. 
org.apache.commons.math4.linear.AbstractRealMatrix.toString	(	): Get a string representation for this matrix.
org.apache.commons.math4.linear.AbstractRealMatrix.transpose	(	): Returns the transpose of this matrix. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInColumnOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInColumnOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInColumnOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInColumnOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInOptimizedOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInOptimizedOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInOptimizedOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInOptimizedOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AbstractRealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row. 
org.apache.commons.math4.linear.AnyMatrix: Interface defining very basic matrix operations.
org.apache.commons.math4.linear.AnyMatrix.getColumnDimension	(	): Returns the number of columns in the matrix.
org.apache.commons.math4.linear.AnyMatrix.getRowDimension	(	): Returns the number of rows in the matrix.
org.apache.commons.math4.linear.AnyMatrix.isSquare	(	): Is this a square matrix?
org.apache.commons.math4.linear.Array2DRowFieldMatrix: Implementation of FieldMatrix using a FieldElement[][] array to store entries.  As specified in the FieldMatrix interface, matrix element indexing is 0-based -- e.g., getEntry(0, 0) returns the element in the first row, first column of the matrix. 
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	Field	): Creates a matrix with no data
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	Field	T[]	): Create a new (column) FieldMatrix using v as the data for the unique column of the created matrix. The input array is copied.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	Field	T[][]	): Create a new FieldMatrix using the input array as the underlying data array. The input array is copied, not referenced. This constructor has the same effect as calling Array2DRowFieldMatrix() with the second argument set to true.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	Field	T[][]	boolean	): Create a new FieldMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a FieldMatrix and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	Field	int	int	): Create a new FieldMatrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	T[]	): Create a new (column) FieldMatrix using v as the data for the unique column of the created matrix. The input array is copied.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	T[][]	): Create a new FieldMatrix using the input array as the underlying data array. The input array is copied, not referenced. This constructor has the same effect as calling Array2DRowFieldMatrix() with the second argument set to true.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix	(	T[][]	boolean	): Create a new FieldMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a FieldMatrix and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.add	(	Array2DRowFieldMatrix	): Add m to this matrix.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.addToEntry	(	int	int	T	): Change an entry in the specified row and column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.copy	(	): Make a (deep) copy of this.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.copyIn	(	T[][]	): Replace data with a fresh copy of the input array.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.copyOut	(	): Get a fresh copy of the underlying data array.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.createMatrix	(	int	int	): Create a new FieldMatrix of the same type as the instance with the supplied row and column dimensions.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.getColumnDimension	(	): Returns the number of columns in the matrix.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.getData	(	): Returns matrix entries as a two-dimensional array.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.getDataRef	(	): Get a reference to the underlying data array. This methods returns internal data, not fresh copy of it.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.getEntry	(	int	int	): Returns the entry in the specified row and column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.getRowDimension	(	): Returns the number of rows in the matrix.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.multiply	(	Array2DRowFieldMatrix	): Postmultiplying this matrix by m.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.multiplyEntry	(	int	int	T	): Change an entry in the specified row and column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.operate	(	T[]	): Returns the result of multiplying this by the vector v.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.preMultiply	(	T[]	): Returns the (row) vector result of premultiplying this by the vector v.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.setEntry	(	int	int	T	): Set the entry in the specified row and column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.setSubMatrix	(	T[][]	int	int	): Replace the submatrix starting at (row, column) using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2   
org.apache.commons.math4.linear.Array2DRowFieldMatrix.subtract	(	Array2DRowFieldMatrix	): Subtract m from this matrix.
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInColumnOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInColumnOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInColumnOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInColumnOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowFieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowRealMatrix: Implementation of RealMatrix using a double[][] array to store entries.
org.apache.commons.math4.linear.Array2DRowRealMatrix.Array2DRowRealMatrix	(	): Creates a matrix with no data
org.apache.commons.math4.linear.Array2DRowRealMatrix.Array2DRowRealMatrix	(	double[]	): Create a new (column) RealMatrix using v as the data for the unique column of the created matrix. The input array is copied.
org.apache.commons.math4.linear.Array2DRowRealMatrix.Array2DRowRealMatrix	(	double[][]	): Create a new RealMatrix using the input array as the underlying data array. The input array is copied, not referenced. This constructor has the same effect as calling Array2DRowRealMatrix() with the second argument set to true.
org.apache.commons.math4.linear.Array2DRowRealMatrix.Array2DRowRealMatrix	(	double[][]	boolean	): Create a new RealMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a RealMatrix and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied.
org.apache.commons.math4.linear.Array2DRowRealMatrix.Array2DRowRealMatrix	(	int	int	): Create a new RealMatrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.Array2DRowRealMatrix.add	(	Array2DRowRealMatrix	): Compute the sum of this and m.
org.apache.commons.math4.linear.Array2DRowRealMatrix.addToEntry	(	int	int	double	): Adds (in place) the specified value to the specified entry of this matrix. Row and column indices start at 0.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.copy	(	): Returns a (deep) copy of this.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.copyIn	(	double[][]	): Replace data with a fresh copy of the input array.
org.apache.commons.math4.linear.Array2DRowRealMatrix.copyOut	(	): Get a fresh copy of the underlying data array.
org.apache.commons.math4.linear.Array2DRowRealMatrix.createMatrix	(	int	int	): Create a new RealMatrix of the same type as the instance with the supplied row and column dimensions.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.getColumnDimension	(	): Returns the number of columns of this matrix. 
org.apache.commons.math4.linear.Array2DRowRealMatrix.getData	(	): Returns matrix entries as a two-dimensional array.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.getDataRef	(	): Get a reference to the underlying data array.
org.apache.commons.math4.linear.Array2DRowRealMatrix.getEntry	(	int	int	): Get the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.getRow	(	int	): Get the entries at the given row index. Row indices start at 0.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.getRowDimension	(	): Returns the number of rows of this matrix. 
org.apache.commons.math4.linear.Array2DRowRealMatrix.getSubMatrix	(	int	int	int	int	): Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.multiply	(	Array2DRowRealMatrix	): Returns the result of postmultiplying this by m.
org.apache.commons.math4.linear.Array2DRowRealMatrix.multiplyEntry	(	int	int	double	): Multiplies (in place) the specified entry of this matrix by the specified value. Row and column indices start at 0.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.operate	(	double[]	): Returns the result of multiplying this by the vector v.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.preMultiply	(	double[]	): Returns the (row) vector result of premultiplying this by the vector v.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.setEntry	(	int	int	double	): Set the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.setRow	(	int	double[]	): Sets the specified row of this matrix to the entries of the specified array. Row indices start at 0.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.setSubMatrix	(	double[][]	int	int	): Replace the submatrix starting at row, column using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2   
org.apache.commons.math4.linear.Array2DRowRealMatrix.subtract	(	Array2DRowRealMatrix	): Returns this minus m.
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInColumnOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInColumnOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInColumnOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInColumnOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowRealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.Array2DRowRealMatrixTest: Test cases for the Array2DRowRealMatrix class.
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.permuteRows	(	RealMatrix	int[]	): Returns the result of applying the given row permutation to the matrix 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.splitLU	(	RealMatrix	double[][]	double[][]	): extracts the l and u matrices from compact lu representation 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testAdd	(	): test add 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testAddFail	(	): test add failure 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testCopyFunctions	(	): test copy functions 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testExamples	(	): test examples in user guide 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testFrobeniusNorm	(	): test Frobenius norm 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testMath209	(	): test issue MATH-209 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testMultiply	(	): test multiply 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testNorm	(	): test norm 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testOperate	(	): test operate 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testPlusMinus	(	): test m-n = m + -n 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testPremultiplyVector	(	): test preMultiply by vector 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testScalarAdd	(	): test sclarAdd 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testTrace	(	): test trace 
org.apache.commons.math4.linear.Array2DRowRealMatrixTest.testTranspose	(	): test transpose 
org.apache.commons.math4.linear.ArrayFieldVector: This class implements the FieldVector interface with a FieldElement array.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	ArrayFieldVector	): Construct a vector from another vector, using a deep copy.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	ArrayFieldVector	boolean	): Construct a vector from another vector.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	Field	): Build a 0-length vector. Zero-length vectors may be used to initialize construction of vectors by data gathering. We start with zero-length and use either the ArrayFieldVector() constructor or one of the append methods (add() or append()) to gather data into this vector.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	Field	T[]	): Construct a vector from an array, copying the input array.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	Field	T[]	T[]	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	Field	T[]	boolean	): Create a new ArrayFieldVector using the input array as the underlying data array. If an array is built specially in order to be embedded in a ArrayFieldVector and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	Field	T[]	int	int	): Construct a vector from part of a array.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	Field	int	): Construct a vector of zeroes.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	FieldVector	): Construct a vector from another vector, using a deep copy.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	FieldVector	FieldVector	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	FieldVector	T[]	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	T[]	): Construct a vector from an array, copying the input array. This constructor needs a non-empty d array to retrieve the field from its first element. This implies it cannot build 0 length vectors. To build vectors from any size, one should use the ArrayFieldVector() constructor.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	T[]	FieldVector	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	T[]	T[]	): Construct a vector by appending one vector to another vector. This constructor needs at least one non-empty array to retrieve the field from its first element. This implies it cannot build 0 length vectors. To build vectors from any size, one should use the ArrayFieldVector() constructor.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	T[]	boolean	): Create a new ArrayFieldVector using the input array as the underlying data array. If an array is built specially in order to be embedded in a ArrayFieldVector and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied. This constructor needs a non-empty d array to retrieve the field from its first element. This implies it cannot build 0 length vectors. To build vectors from any size, one should use the ArrayFieldVector() constructor.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	T[]	int	int	): Construct a vector from part of a array.
org.apache.commons.math4.linear.ArrayFieldVector.ArrayFieldVector	(	int	T	): Construct a vector with preset values.
org.apache.commons.math4.linear.ArrayFieldVector.add	(	ArrayFieldVector	): Compute the sum of this and v.
org.apache.commons.math4.linear.ArrayFieldVector.add	(	FieldVector	): Compute the sum of this and v. 
org.apache.commons.math4.linear.ArrayFieldVector.append	(	ArrayFieldVector	): Construct a vector by appending a vector to this vector.
org.apache.commons.math4.linear.ArrayFieldVector.append	(	FieldVector	): Construct a vector by appending a vector to this vector. 
org.apache.commons.math4.linear.ArrayFieldVector.append	(	T	): Construct a vector by appending a T to this vector. 
org.apache.commons.math4.linear.ArrayFieldVector.checkIndex	(	int	): Check if an index is valid.
org.apache.commons.math4.linear.ArrayFieldVector.checkIndices	(	int	int	): Checks that the indices of a subvector are valid.
org.apache.commons.math4.linear.ArrayFieldVector.checkVectorDimensions	(	FieldVector	): Check if instance and specified vectors have the same dimension.
org.apache.commons.math4.linear.ArrayFieldVector.checkVectorDimensions	(	int	): Check if instance dimension is equal to some expected value.
org.apache.commons.math4.linear.ArrayFieldVector.copy	(	): Returns a (deep) copy of this. 
org.apache.commons.math4.linear.ArrayFieldVector.dotProduct	(	ArrayFieldVector	): Compute the dot product.
org.apache.commons.math4.linear.ArrayFieldVector.dotProduct	(	FieldVector	): Compute the dot product. 
org.apache.commons.math4.linear.ArrayFieldVector.ebeDivide	(	ArrayFieldVector	): Element-by-element division.
org.apache.commons.math4.linear.ArrayFieldVector.ebeDivide	(	FieldVector	): Element-by-element division. 
org.apache.commons.math4.linear.ArrayFieldVector.ebeMultiply	(	ArrayFieldVector	): Element-by-element multiplication.
org.apache.commons.math4.linear.ArrayFieldVector.ebeMultiply	(	FieldVector	): Element-by-element multiplication. 
org.apache.commons.math4.linear.ArrayFieldVector.equals	(	Object	): Test for the equality of two vectors.
org.apache.commons.math4.linear.ArrayFieldVector.getDataRef	(	): Returns a reference to the underlying data array. Does not make a fresh copy of the underlying data.
org.apache.commons.math4.linear.ArrayFieldVector.getDimension	(	): Returns the size of the vector. 
org.apache.commons.math4.linear.ArrayFieldVector.getEntry	(	int	): Returns the entry in the specified index. 
org.apache.commons.math4.linear.ArrayFieldVector.getField	(	): Get the type of field elements of the vector. 
org.apache.commons.math4.linear.ArrayFieldVector.getSubVector	(	int	int	): Get a subvector from consecutive elements. 
org.apache.commons.math4.linear.ArrayFieldVector.hashCode	(	): Get a hashCode for the real vector. All NaN values have the same hash code.
org.apache.commons.math4.linear.ArrayFieldVector.mapAdd	(	T	): Map an addition operation to each entry. 
org.apache.commons.math4.linear.ArrayFieldVector.mapAddToSelf	(	T	): Map an addition operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.ArrayFieldVector.mapDivide	(	T	): Map a division operation to each entry. 
org.apache.commons.math4.linear.ArrayFieldVector.mapDivideToSelf	(	T	): Map a division operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.ArrayFieldVector.mapInv	(	): Map the 1/x function to each entry. 
org.apache.commons.math4.linear.ArrayFieldVector.mapInvToSelf	(	): Map the 1/x function to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.ArrayFieldVector.mapMultiply	(	T	): Map a multiplication operation to each entry. 
org.apache.commons.math4.linear.ArrayFieldVector.mapMultiplyToSelf	(	T	): Map a multiplication operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.ArrayFieldVector.mapSubtract	(	T	): Map a subtraction operation to each entry. 
org.apache.commons.math4.linear.ArrayFieldVector.mapSubtractToSelf	(	T	): Map a subtraction operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.ArrayFieldVector.outerProduct	(	ArrayFieldVector	): Compute the outer product.
org.apache.commons.math4.linear.ArrayFieldVector.outerProduct	(	FieldVector	): Compute the outer product. 
org.apache.commons.math4.linear.ArrayFieldVector.projection	(	ArrayFieldVector	): Find the orthogonal projection of this vector onto another vector.
org.apache.commons.math4.linear.ArrayFieldVector.projection	(	FieldVector	): Find the orthogonal projection of this vector onto another vector. 
org.apache.commons.math4.linear.ArrayFieldVector.set	(	T	): Set all elements to a single value. 
org.apache.commons.math4.linear.ArrayFieldVector.set	(	int	ArrayFieldVector	): Set a set of consecutive elements.
org.apache.commons.math4.linear.ArrayFieldVector.setEntry	(	int	T	): Set a single element. 
org.apache.commons.math4.linear.ArrayFieldVector.setSubVector	(	int	FieldVector	): Set a set of consecutive elements. 
org.apache.commons.math4.linear.ArrayFieldVector.subtract	(	ArrayFieldVector	): Compute this minus v.
org.apache.commons.math4.linear.ArrayFieldVector.subtract	(	FieldVector	): Compute this minus v. 
org.apache.commons.math4.linear.ArrayFieldVector.toArray	(	): Convert the vector to a T array. The array is independent from vector data, it's elements are copied. 
org.apache.commons.math4.linear.ArrayFieldVector.walkInDefaultOrder	(	FieldVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.ArrayFieldVector.walkInDefaultOrder	(	FieldVectorChangingVisitor	int	int	): Visits (and possibly alters) some entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.ArrayFieldVector.walkInDefaultOrder	(	FieldVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.ArrayFieldVector.walkInDefaultOrder	(	FieldVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.ArrayFieldVector.walkInOptimizedOrder	(	FieldVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.ArrayFieldVector.walkInOptimizedOrder	(	FieldVectorChangingVisitor	int	int	): Visits (and possibly change) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.ArrayFieldVector.walkInOptimizedOrder	(	FieldVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.ArrayFieldVector.walkInOptimizedOrder	(	FieldVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.ArrayFieldVectorTest: Test cases for the ArrayFieldVector class.
org.apache.commons.math4.linear.ArrayFieldVectorTest.FieldVectorTestImpl.buildArray	(	int	): Build an array of elements.
org.apache.commons.math4.linear.ArrayFieldVectorTest.checkArray	(	String	Fraction[]	Fraction[]	): verifies that two vectors are equals 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInDefaultOrderChangingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInDefaultOrderChangingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInDefaultOrderChangingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInDefaultOrderPreservingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInDefaultOrderPreservingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInDefaultOrderPreservingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInOptimizedOrderChangingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInOptimizedOrderChangingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInOptimizedOrderChangingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInOptimizedOrderPreservingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInOptimizedOrderPreservingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.ArrayFieldVectorTest.testWalkInOptimizedOrderPreservingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.ArrayRealVector: This class implements the RealVector interface with a double array.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	): Build a 0-length vector. Zero-length vectors may be used to initialized construction of vectors by data gathering. We start with zero-length and use either the ArrayRealVector() constructor or one of the append method (append(), append()) to gather data into this vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	ArrayRealVector	): Construct a vector from another vector, using a deep copy.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	ArrayRealVector	ArrayRealVector	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	ArrayRealVector	RealVector	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	ArrayRealVector	boolean	): Construct a vector from another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	ArrayRealVector	double[]	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	Double[]	): Construct a vector from an array.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	Double[]	int	int	): Construct a vector from part of an array.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	RealVector	): Construct a vector from another vector, using a deep copy.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	RealVector	ArrayRealVector	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	double[]	): Construct a vector from an array, copying the input array.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	double[]	ArrayRealVector	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	double[]	boolean	): Create a new ArrayRealVector using the input array as the underlying data array. If an array is built specially in order to be embedded in a ArrayRealVector and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	double[]	double[]	): Construct a vector by appending one vector to another vector.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	double[]	int	int	): Construct a vector from part of a array.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	int	): Construct a vector of zeroes.
org.apache.commons.math4.linear.ArrayRealVector.ArrayRealVector	(	int	double	): Construct a vector with preset values.
org.apache.commons.math4.linear.ArrayRealVector.add	(	RealVector	): Compute the sum of this vector and v. Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.ArrayRealVector.addToEntry	(	int	double	): Change an entry at the specified index. 
org.apache.commons.math4.linear.ArrayRealVector.append	(	ArrayRealVector	): Construct a vector by appending a vector to this vector.
org.apache.commons.math4.linear.ArrayRealVector.append	(	RealVector	): Construct a new vector by appending a vector to this vector. 
org.apache.commons.math4.linear.ArrayRealVector.append	(	double	): Construct a new vector by appending a double to this vector. 
org.apache.commons.math4.linear.ArrayRealVector.checkVectorDimensions	(	RealVector	): Check if instance and specified vectors have the same dimension.
org.apache.commons.math4.linear.ArrayRealVector.checkVectorDimensions	(	int	): Check if instance dimension is equal to some expected value.
org.apache.commons.math4.linear.ArrayRealVector.combine	(	double	double	RealVector	): Returns a new vector representing a * this + b * y, the linear combination of this and y. Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.ArrayRealVector.combineToSelf	(	double	double	RealVector	): Updates this with the linear combination of this and y. 
org.apache.commons.math4.linear.ArrayRealVector.copy	(	): Returns a (deep) copy of this vector. 
org.apache.commons.math4.linear.ArrayRealVector.dotProduct	(	RealVector	): Compute the dot product of this vector with v. 
org.apache.commons.math4.linear.ArrayRealVector.ebeDivide	(	RealVector	): Element-by-element division. 
org.apache.commons.math4.linear.ArrayRealVector.ebeMultiply	(	RealVector	): Element-by-element multiplication. 
org.apache.commons.math4.linear.ArrayRealVector.equals	(	Object	):  Test for the equality of two real vectors. If all coordinates of two real vectors are exactly the same, and none are NaN, the two real vectors are considered to be equal. NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the real vector are equal to NaN, the real vector is equal to a vector with all NaN coordinates.   This method must be overriden by concrete subclasses of RealVector (the current implementation throws an exception).  
org.apache.commons.math4.linear.ArrayRealVector.getDataRef	(	): Get a reference to the underlying data array. This method does not make a fresh copy of the underlying data.
org.apache.commons.math4.linear.ArrayRealVector.getDimension	(	): Returns the size of the vector. 
org.apache.commons.math4.linear.ArrayRealVector.getDistance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with the L2 norm, i.e. the square root of the sum of element differences, or Euclidean distance. 
org.apache.commons.math4.linear.ArrayRealVector.getEntry	(	int	): Return the entry at the specified index. 
org.apache.commons.math4.linear.ArrayRealVector.getL1Distance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with L1 norm, i.e. the sum of the absolute values of the elements differences. 
org.apache.commons.math4.linear.ArrayRealVector.getL1Norm	(	): Returns the L1 norm of the vector. The L1 norm is the sum of the absolute values of the elements. 
org.apache.commons.math4.linear.ArrayRealVector.getLInfDistance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with L∞ norm, i.e. the max of the absolute values of element differences. 
org.apache.commons.math4.linear.ArrayRealVector.getLInfNorm	(	): Returns the L∞ norm of the vector. The L∞ norm is the max of the absolute values of the elements. 
org.apache.commons.math4.linear.ArrayRealVector.getNorm	(	): Returns the L2 norm of the vector. The L2 norm is the root of the sum of the squared elements. 
org.apache.commons.math4.linear.ArrayRealVector.getSubVector	(	int	int	): Get a subvector from consecutive elements. 
org.apache.commons.math4.linear.ArrayRealVector.hashCode	(	): . This method must be overriden by concrete subclasses of RealVector (current implementation throws an exception). All NaN values have the same hash code.
org.apache.commons.math4.linear.ArrayRealVector.isInfinite	(	): Check whether any coordinate of this vector is infinite and none are NaN.
org.apache.commons.math4.linear.ArrayRealVector.isNaN	(	): Check if any coordinate of this vector is NaN.
org.apache.commons.math4.linear.ArrayRealVector.map	(	UnivariateFunction	): Acts as if implemented as:  return copy().mapToSelf(function);  Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.ArrayRealVector.mapAddToSelf	(	double	): Add a value to each entry. The instance is changed in-place. 
org.apache.commons.math4.linear.ArrayRealVector.mapDivideToSelf	(	double	): Divide each entry by the argument. The instance is changed in-place. 
org.apache.commons.math4.linear.ArrayRealVector.mapMultiplyToSelf	(	double	): Multiply each entry. The instance is changed in-place. 
org.apache.commons.math4.linear.ArrayRealVector.mapSubtractToSelf	(	double	): Subtract a value from each entry. The instance is changed in-place. 
org.apache.commons.math4.linear.ArrayRealVector.mapToSelf	(	UnivariateFunction	): Acts as if it is implemented as: Entry e = null; for(Iterator it = iterator(); it.hasNext(); e = it.next()) e.setValue(function.value(e.getValue())); } } Entries of this vector are modified in-place by this method. 
org.apache.commons.math4.linear.ArrayRealVector.outerProduct	(	RealVector	): Compute the outer product. 
org.apache.commons.math4.linear.ArrayRealVector.set	(	double	): Set all elements to a single value. 
org.apache.commons.math4.linear.ArrayRealVector.setEntry	(	int	double	): Set a single element. 
org.apache.commons.math4.linear.ArrayRealVector.setSubVector	(	int	RealVector	): Set a sequence of consecutive elements. 
org.apache.commons.math4.linear.ArrayRealVector.setSubVector	(	int	double[]	): Set a set of consecutive elements.
org.apache.commons.math4.linear.ArrayRealVector.subtract	(	RealVector	): Subtract v from this vector. Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.ArrayRealVector.toArray	(	): Convert the vector to an array of doubles. The array is independent from this vector data: the elements are copied. 
org.apache.commons.math4.linear.ArrayRealVector.toString	(	):  
org.apache.commons.math4.linear.ArrayRealVector.walkInDefaultOrder	(	RealVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in default order (increasing index). 
org.apache.commons.math4.linear.ArrayRealVector.walkInDefaultOrder	(	RealVectorChangingVisitor	int	int	): Visits (and possibly alters) some entries of this vector in default order (increasing index). 
org.apache.commons.math4.linear.ArrayRealVector.walkInDefaultOrder	(	RealVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in default order (increasing index). 
org.apache.commons.math4.linear.ArrayRealVector.walkInDefaultOrder	(	RealVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in default order (increasing index). 
org.apache.commons.math4.linear.ArrayRealVector.walkInOptimizedOrder	(	RealVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class. In this implementation, the optimized order is the default order.
org.apache.commons.math4.linear.ArrayRealVector.walkInOptimizedOrder	(	RealVectorChangingVisitor	int	int	): Visits (and possibly change) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class. In this implementation, the optimized order is the default order.
org.apache.commons.math4.linear.ArrayRealVector.walkInOptimizedOrder	(	RealVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class. In this implementation, the optimized order is the default order.
org.apache.commons.math4.linear.ArrayRealVector.walkInOptimizedOrder	(	RealVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class. In this implementation, the optimized order is the default order.
org.apache.commons.math4.linear.ArrayRealVectorTest: Test cases for the ArrayRealVector class.
org.apache.commons.math4.linear.BiDiagonalTransformer: Class transforming any matrix to bi-diagonal shape. Any m × n matrix A can be written as the product of three matrices: A = U × B × VT with U an m × m orthogonal matrix, B an m × n bi-diagonal matrix (lower diagonal if m < n, upper diagonal otherwise), and V an n × n orthogonal matrix. Transformation to bi-diagonal shape is often not a goal by itself, but it is an intermediate step in more general decomposition algorithms like SingularValueDecomposition Singular Value Decomposition. This class is therefore intended for internal use by the library and is not public. As a consequence of this explicitly limited scope, many methods directly returns references to internal arrays, not copies.
org.apache.commons.math4.linear.BiDiagonalTransformer.BiDiagonalTransformer	(	RealMatrix	): Build the transformation to bi-diagonal shape of a matrix.
org.apache.commons.math4.linear.BiDiagonalTransformer.getB	(	): Returns the bi-diagonal matrix B of the transform.
org.apache.commons.math4.linear.BiDiagonalTransformer.getHouseholderVectorsRef	(	): Get the Householder vectors of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.BiDiagonalTransformer.getMainDiagonalRef	(	): Get the main diagonal elements of the matrix B of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.BiDiagonalTransformer.getSecondaryDiagonalRef	(	): Get the secondary diagonal elements of the matrix B of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.BiDiagonalTransformer.getU	(	): Returns the matrix U of the transform. U is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.BiDiagonalTransformer.getV	(	): Returns the matrix V of the transform. V is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.BiDiagonalTransformer.isUpperBiDiagonal	(	): Check if the matrix is transformed to upper bi-diagonal.
org.apache.commons.math4.linear.BiDiagonalTransformer.transformToLowerBiDiagonal	(	): Transform original matrix to lower bi-diagonal form. Transformation is done using alternate Householder transforms on rows and columns.
org.apache.commons.math4.linear.BiDiagonalTransformer.transformToUpperBiDiagonal	(	): Transform original matrix to upper bi-diagonal form. Transformation is done using alternate Householder transforms on columns and rows.
org.apache.commons.math4.linear.BlockFieldMatrix: Cache-friendly implementation of FieldMatrix using a flat arrays to store square blocks of the matrix.  This implementation is specially designed to be cache-friendly. Square blocks are stored as small arrays and allow efficient traversal of data both in row major direction and columns major direction, one block at a time. This greatly increases performances for algorithms that use crossed directions loops like multiplication or transposition.   The size of square blocks is a static parameter. It may be tuned according to the cache size of the target computer processor. As a rule of thumbs, it should be the largest value that allows three blocks to be simultaneously cached (this is necessary for example for matrix multiplication). The default value is to use 36x36 blocks.   The regular blocks represent BLOCK_SIZE x BLOCK_SIZE squares. Blocks at right hand side and bottom side which may be smaller to fit matrix dimensions. The square blocks are flattened in row major order in single dimension arrays which are therefore BLOCK_SIZE2 elements long for regular blocks. The blocks are themselves organized in row major order.   As an example, for a block size of 36x36, a 100x60 matrix would be stored in 6 blocks. Block 0 would be a Field[1296] array holding the upper left 36x36 square, block 1 would be a Field[1296] array holding the upper center 36x36 square, block 2 would be a Field[1008] array holding the upper right 36x28 rectangle, block 3 would be a Field[864] array holding the lower left 24x36 rectangle, block 4 would be a Field[864] array holding the lower center 24x36 rectangle and block 5 would be a Field[672] array holding the lower right 24x28 rectangle.   The layout complexity overhead versus simple mapping of matrices to java arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads to up to 3-fold improvements for matrices of moderate to large size. 
org.apache.commons.math4.linear.BlockFieldMatrix.BlockFieldMatrix	(	Field	int	int	): Create a new matrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.BlockFieldMatrix.BlockFieldMatrix	(	T[][]	): Create a new dense matrix copying entries from raw layout data. The input array must already be in raw layout. Calling this constructor is equivalent to call: matrix = new BlockFieldMatrix(getField(), rawData.length, rawData[0].length, toBlocksLayout(rawData), false);
org.apache.commons.math4.linear.BlockFieldMatrix.BlockFieldMatrix	(	int	int	T[][]	boolean	): Create a new dense matrix copying entries from block layout data. The input array must already be in blocks layout.
org.apache.commons.math4.linear.BlockFieldMatrix.add	(	BlockFieldMatrix	): Compute the sum of this and m.
org.apache.commons.math4.linear.BlockFieldMatrix.add	(	FieldMatrix	): Compute the sum of this and m.  
org.apache.commons.math4.linear.BlockFieldMatrix.addToEntry	(	int	int	T	): Change an entry in the specified row and column.  
org.apache.commons.math4.linear.BlockFieldMatrix.blockHeight	(	int	): Get the height of a block.
org.apache.commons.math4.linear.BlockFieldMatrix.blockWidth	(	int	): Get the width of a block.
org.apache.commons.math4.linear.BlockFieldMatrix.copy	(	): Make a (deep) copy of this.  
org.apache.commons.math4.linear.BlockFieldMatrix.copyBlockPart	(	T[]	int	int	int	int	int	T[]	int	int	int	): Copy a part of a block into another one This method can be called only when the specified part fits in both blocks, no verification is done here.
org.apache.commons.math4.linear.BlockFieldMatrix.createBlocksLayout	(	Field	int	int	): Create a data array in blocks layout.  This method can be used to create the array argument of the BlockFieldMatrix() constructor. 
org.apache.commons.math4.linear.BlockFieldMatrix.createMatrix	(	int	int	): Create a new FieldMatrix of the same type as the instance with the supplied row and column dimensions.  
org.apache.commons.math4.linear.BlockFieldMatrix.getColumn	(	int	): Get the entries in column number col as an array.  
org.apache.commons.math4.linear.BlockFieldMatrix.getColumnDimension	(	): Returns the number of columns in the matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.getColumnMatrix	(	int	): Get the entries in column number column as a column matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.getColumnVector	(	int	): Returns the entries in column number column as a vector.  
org.apache.commons.math4.linear.BlockFieldMatrix.getData	(	): Returns matrix entries as a two-dimensional array.  
org.apache.commons.math4.linear.BlockFieldMatrix.getEntry	(	int	int	): Returns the entry in the specified row and column.  
org.apache.commons.math4.linear.BlockFieldMatrix.getRow	(	int	): Get the entries in row number row as an array.  
org.apache.commons.math4.linear.BlockFieldMatrix.getRowDimension	(	): Returns the number of rows in the matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.getRowMatrix	(	int	): Get the entries in row number row as a row matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.getRowVector	(	int	): Get the entries in row number row as a vector.  
org.apache.commons.math4.linear.BlockFieldMatrix.getSubMatrix	(	int	int	int	int	): Get a submatrix. Rows and columns are indicated counting from 0 to n - 1.  
org.apache.commons.math4.linear.BlockFieldMatrix.multiply	(	BlockFieldMatrix	): Returns the result of postmultiplying this by m.
org.apache.commons.math4.linear.BlockFieldMatrix.multiply	(	FieldMatrix	): Postmultiply this matrix by m.  
org.apache.commons.math4.linear.BlockFieldMatrix.multiplyEntry	(	int	int	T	): Change an entry in the specified row and column.  
org.apache.commons.math4.linear.BlockFieldMatrix.operate	(	T[]	): Returns the result of multiplying this by the vector v.  
org.apache.commons.math4.linear.BlockFieldMatrix.preMultiply	(	T[]	): Returns the (row) vector result of premultiplying this by the vector v.  
org.apache.commons.math4.linear.BlockFieldMatrix.scalarAdd	(	T	): Increment each entry of this matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.scalarMultiply	(	T	): Multiply each entry by d.  
org.apache.commons.math4.linear.BlockFieldMatrix.setColumn	(	int	T[]	): Set the entries in column number column as a column matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.setColumnMatrix	(	int	BlockFieldMatrix	): Sets the entries in column number column as a column matrix. Column indices start at 0.
org.apache.commons.math4.linear.BlockFieldMatrix.setColumnMatrix	(	int	FieldMatrix	): Set the entries in column number column as a column matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.setColumnVector	(	int	FieldVector	): Set the entries in column number column as a vector.  
org.apache.commons.math4.linear.BlockFieldMatrix.setEntry	(	int	int	T	): Set the entry in the specified row and column.  
org.apache.commons.math4.linear.BlockFieldMatrix.setRow	(	int	T[]	): Set the entries in row number row as a row matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.setRowMatrix	(	int	BlockFieldMatrix	): Sets the entries in row number row as a row matrix. Row indices start at 0.
org.apache.commons.math4.linear.BlockFieldMatrix.setRowMatrix	(	int	FieldMatrix	): Set the entries in row number row as a row matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.setRowVector	(	int	FieldVector	): Set the entries in row number row as a vector.  
org.apache.commons.math4.linear.BlockFieldMatrix.setSubMatrix	(	T[][]	int	int	): Replace the submatrix starting at (row, column) using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2   
org.apache.commons.math4.linear.BlockFieldMatrix.subtract	(	BlockFieldMatrix	): Compute this - m.
org.apache.commons.math4.linear.BlockFieldMatrix.subtract	(	FieldMatrix	): Subtract m from this matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.toBlocksLayout	(	T[][]	): Convert a data array from raw layout to blocks layout.  Raw layout is the straightforward layout where element at row i and column j is in array element rawData[i][j]. Blocks layout is the layout used in BlockFieldMatrix instances, where the matrix is split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array.   This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the BlockFieldMatrix() constructor. 
org.apache.commons.math4.linear.BlockFieldMatrix.transpose	(	): Returns the transpose of this matrix.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInOptimizedOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInOptimizedOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInOptimizedOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInOptimizedOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockFieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockFieldMatrixTest: Test cases for the BlockFieldMatrix class.
org.apache.commons.math4.linear.BlockFieldMatrixTest.testAdd	(	): test add 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testAddFail	(	): test add failure 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testCopyFunctions	(	): test copy functions 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testExamples	(	): test examples in user guide 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testMath209	(	): test issue MATH-209 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testMultiply	(	): test multiply 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testOperate	(	): test operate 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testPlusMinus	(	): test m-n = m + -n 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testPremultiplyVector	(	): test preMultiply by vector 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testScalarAdd	(	): test scalarAdd 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testTrace	(	): test trace 
org.apache.commons.math4.linear.BlockFieldMatrixTest.testTranspose	(	): test transpose 
org.apache.commons.math4.linear.BlockRealMatrix: Cache-friendly implementation of RealMatrix using a flat arrays to store square blocks of the matrix.  This implementation is specially designed to be cache-friendly. Square blocks are stored as small arrays and allow efficient traversal of data both in row major direction and columns major direction, one block at a time. This greatly increases performances for algorithms that use crossed directions loops like multiplication or transposition.   The size of square blocks is a static parameter. It may be tuned according to the cache size of the target computer processor. As a rule of thumbs, it should be the largest value that allows three blocks to be simultaneously cached (this is necessary for example for matrix multiplication). The default value is to use 52x52 blocks which is well suited for processors with 64k L1 cache (one block holds 2704 values or 21632 bytes). This value could be lowered to 36x36 for processors with 32k L1 cache.   The regular blocks represent BLOCK_SIZE x BLOCK_SIZE squares. Blocks at right hand side and bottom side which may be smaller to fit matrix dimensions. The square blocks are flattened in row major order in single dimension arrays which are therefore BLOCK_SIZE2 elements long for regular blocks. The blocks are themselves organized in row major order.   As an example, for a block size of 52x52, a 100x60 matrix would be stored in 4 blocks. Block 0 would be a double[2704] array holding the upper left 52x52 square, block 1 would be a double[416] array holding the upper right 52x8 rectangle, block 2 would be a double[2496] array holding the lower left 48x52 rectangle and block 3 would be a double[384] array holding the lower right 48x8 rectangle.   The layout complexity overhead versus simple mapping of matrices to java arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads to up to 3-fold improvements for matrices of moderate to large size. 
org.apache.commons.math4.linear.BlockRealMatrix.BlockRealMatrix	(	double[][]	): Create a new dense matrix copying entries from raw layout data. The input array must already be in raw layout. Calling this constructor is equivalent to call: matrix = new BlockRealMatrix(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);
org.apache.commons.math4.linear.BlockRealMatrix.BlockRealMatrix	(	int	int	): Create a new matrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.BlockRealMatrix.BlockRealMatrix	(	int	int	double[][]	boolean	): Create a new dense matrix copying entries from block layout data. The input array must already be in blocks layout.
org.apache.commons.math4.linear.BlockRealMatrix.add	(	BlockRealMatrix	): Compute the sum of this matrix and m.
org.apache.commons.math4.linear.BlockRealMatrix.add	(	RealMatrix	): Returns the sum of this and m.  
org.apache.commons.math4.linear.BlockRealMatrix.addToEntry	(	int	int	double	): Adds (in place) the specified value to the specified entry of this matrix. Row and column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.blockHeight	(	int	): Get the height of a block.
org.apache.commons.math4.linear.BlockRealMatrix.blockWidth	(	int	): Get the width of a block.
org.apache.commons.math4.linear.BlockRealMatrix.copy	(	): Returns a (deep) copy of this.  
org.apache.commons.math4.linear.BlockRealMatrix.copyBlockPart	(	double[]	int	int	int	int	int	double[]	int	int	int	): Copy a part of a block into another one This method can be called only when the specified part fits in both blocks, no verification is done here.
org.apache.commons.math4.linear.BlockRealMatrix.createBlocksLayout	(	int	int	): Create a data array in blocks layout.  This method can be used to create the array argument of the BlockRealMatrix() constructor. 
org.apache.commons.math4.linear.BlockRealMatrix.createMatrix	(	int	int	): Create a new RealMatrix of the same type as the instance with the supplied row and column dimensions.  
org.apache.commons.math4.linear.BlockRealMatrix.getColumn	(	int	): Get the entries at the given column index as an array. Column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getColumnDimension	(	): Returns the number of columns of this matrix. 
org.apache.commons.math4.linear.BlockRealMatrix.getColumnMatrix	(	int	): Get the entries at the given column index as a column matrix. Column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getColumnVector	(	int	): Get the entries at the given column index as a vector. Column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getData	(	): Returns matrix entries as a two-dimensional array.  
org.apache.commons.math4.linear.BlockRealMatrix.getEntry	(	int	int	): Get the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getFrobeniusNorm	(	): Returns the  Frobenius norm of the matrix.  
org.apache.commons.math4.linear.BlockRealMatrix.getNorm	(	): Returns the  maximum absolute row sum norm of the matrix.  
org.apache.commons.math4.linear.BlockRealMatrix.getRow	(	int	): Get the entries at the given row index. Row indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getRowDimension	(	): Returns the number of rows of this matrix. 
org.apache.commons.math4.linear.BlockRealMatrix.getRowMatrix	(	int	): Get the entries at the given row index as a row matrix. Row indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getRowVector	(	int	): Returns the entries in row number row as a vector. Row indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.getSubMatrix	(	int	int	int	int	): Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.  
org.apache.commons.math4.linear.BlockRealMatrix.multiply	(	BlockRealMatrix	): Returns the result of postmultiplying this by m.
org.apache.commons.math4.linear.BlockRealMatrix.multiply	(	RealMatrix	): Returns the result of postmultiplying this by m.  
org.apache.commons.math4.linear.BlockRealMatrix.multiplyEntry	(	int	int	double	): Multiplies (in place) the specified entry of this matrix by the specified value. Row and column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.operate	(	double[]	): Returns the result of multiplying this by the vector v.  
org.apache.commons.math4.linear.BlockRealMatrix.preMultiply	(	double[]	): Returns the (row) vector result of premultiplying this by the vector v.  
org.apache.commons.math4.linear.BlockRealMatrix.scalarAdd	(	double	): Returns the result of adding d to each entry of this.  
org.apache.commons.math4.linear.BlockRealMatrix.scalarMultiply	(	double	): Returns the result of multiplying each entry of this by d.  
org.apache.commons.math4.linear.BlockRealMatrix.setColumn	(	int	double[]	): Sets the specified column of this matrix to the entries of the specified array. Column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setColumnMatrix	(	int	BlockRealMatrix	): Sets the entries in column number column as a column matrix. Column indices start at 0.
org.apache.commons.math4.linear.BlockRealMatrix.setColumnMatrix	(	int	RealMatrix	): Sets the specified column of this matrix to the entries of the specified column matrix. Column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setColumnVector	(	int	RealVector	): Sets the specified column of this matrix to the entries of the specified vector. Column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setEntry	(	int	int	double	): Set the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setRow	(	int	double[]	): Sets the specified row of this matrix to the entries of the specified array. Row indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setRowMatrix	(	int	BlockRealMatrix	): Sets the entries in row number row as a row matrix. Row indices start at 0.
org.apache.commons.math4.linear.BlockRealMatrix.setRowMatrix	(	int	RealMatrix	): Sets the specified row of this matrix to the entries of the specified row matrix. Row indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setRowVector	(	int	RealVector	): Sets the specified row of this matrix to the entries of the specified vector. Row indices start at 0.  
org.apache.commons.math4.linear.BlockRealMatrix.setSubMatrix	(	double[][]	int	int	): Replace the submatrix starting at row, column using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2   
org.apache.commons.math4.linear.BlockRealMatrix.subtract	(	BlockRealMatrix	): Subtract m from this matrix.
org.apache.commons.math4.linear.BlockRealMatrix.subtract	(	RealMatrix	): Returns this minus m.  
org.apache.commons.math4.linear.BlockRealMatrix.toBlocksLayout	(	double[][]	): Convert a data array from raw layout to blocks layout.  Raw layout is the straightforward layout where element at row i and column j is in array element rawData[i][j]. Blocks layout is the layout used in BlockRealMatrix instances, where the matrix is split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array.   This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the BlockRealMatrix() constructor. 
org.apache.commons.math4.linear.BlockRealMatrix.transpose	(	): Returns the transpose of this matrix.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInOptimizedOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInOptimizedOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInOptimizedOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInOptimizedOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockRealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.  
org.apache.commons.math4.linear.BlockRealMatrixTest: Test cases for the BlockRealMatrix class.
org.apache.commons.math4.linear.BlockRealMatrixTest.assertClose	(	RealMatrix	RealMatrix	double	): verifies that two matrices are close (1-norm) 
org.apache.commons.math4.linear.BlockRealMatrixTest.assertClose	(	double[]	double[]	double	): verifies that two vectors are close (sup norm) 
org.apache.commons.math4.linear.BlockRealMatrixTest.testAdd	(	): test add 
org.apache.commons.math4.linear.BlockRealMatrixTest.testAddFail	(	): test add failure 
org.apache.commons.math4.linear.BlockRealMatrixTest.testCopyFunctions	(	): test copy functions 
org.apache.commons.math4.linear.BlockRealMatrixTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.BlockRealMatrixTest.testExamples	(	): test examples in user guide 
org.apache.commons.math4.linear.BlockRealMatrixTest.testFrobeniusNorm	(	): test Frobenius norm 
org.apache.commons.math4.linear.BlockRealMatrixTest.testMath209	(	): test issue MATH-209 
org.apache.commons.math4.linear.BlockRealMatrixTest.testMultiply	(	): test multiply 
org.apache.commons.math4.linear.BlockRealMatrixTest.testNorm	(	): test norm 
org.apache.commons.math4.linear.BlockRealMatrixTest.testOperate	(	): test operate 
org.apache.commons.math4.linear.BlockRealMatrixTest.testPlusMinus	(	): test m-n = m + -n 
org.apache.commons.math4.linear.BlockRealMatrixTest.testPremultiplyVector	(	): test preMultiply by vector 
org.apache.commons.math4.linear.BlockRealMatrixTest.testScalarAdd	(	): test scalarAdd 
org.apache.commons.math4.linear.BlockRealMatrixTest.testTrace	(	): test trace 
org.apache.commons.math4.linear.BlockRealMatrixTest.testTranspose	(	): test transpose 
org.apache.commons.math4.linear.CholeskyDecomposition: Calculates the Cholesky decomposition of a matrix. The Cholesky decomposition of a real symmetric positive-definite matrix A consists of a lower triangular matrix L with same size such that: A = LLT. In a sense, this is the square root of A. This class is based on the class with similar name from the JAMA library, with the following changes:  a getLT() method has been added, the isspd method has been removed, since the constructor of this class throws a NonPositiveDefiniteMatrixException when a matrix cannot be decomposed, a getDeterminant() method has been added, the solve method has been replaced by a getSolver() method and the equivalent method provided by the returned DecompositionSolver. 
org.apache.commons.math4.linear.CholeskyDecomposition.CholeskyDecomposition	(	RealMatrix	): Calculates the Cholesky decomposition of the given matrix.  Calling this constructor is equivalent to call CholeskyDecomposition() with the thresholds set to the default values DEFAULT_RELATIVE_SYMMETRY_THRESHOLD and DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD 
org.apache.commons.math4.linear.CholeskyDecomposition.CholeskyDecomposition	(	RealMatrix	double	double	): Calculates the Cholesky decomposition of the given matrix.
org.apache.commons.math4.linear.CholeskyDecomposition.Solver: Specialized solver. 
org.apache.commons.math4.linear.CholeskyDecomposition.Solver.Solver	(	double[][]	): Build a solver from decomposed matrix.
org.apache.commons.math4.linear.CholeskyDecomposition.Solver.getInverse	(	): Get the inverse of the decomposed matrix.
org.apache.commons.math4.linear.CholeskyDecomposition.Solver.isNonSingular	(	): Check if the decomposed matrix is non-singular. 
org.apache.commons.math4.linear.CholeskyDecomposition.Solver.solve	(	RealMatrix	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.CholeskyDecomposition.Solver.solve	(	RealVector	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.CholeskyDecomposition.getDeterminant	(	): Return the determinant of the matrix
org.apache.commons.math4.linear.CholeskyDecomposition.getL	(	): Returns the matrix L of the decomposition. L is an lower-triangular matrix
org.apache.commons.math4.linear.CholeskyDecomposition.getLT	(	): Returns the transpose of the matrix L of the decomposition. LT is an upper-triangular matrix
org.apache.commons.math4.linear.CholeskyDecomposition.getSolver	(	): Get a solver for finding the A × X = B solution in least square sense.
org.apache.commons.math4.linear.CholeskyDecompositionTest.testAEqualLLT	(	): test A = LLT 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testLLowerTriangular	(	): test that L is lower triangular 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testLTTransposed	(	): test that LT is transpose of L 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testMatricesValues	(	): test matrices values 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testNonSquare	(	): test non-square matrix 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testNotPositiveDefinite	(	): test non positive definite matrix 
org.apache.commons.math4.linear.CholeskyDecompositionTest.testNotSymmetricMatrixException	(	): test non-symmetric matrix 
org.apache.commons.math4.linear.CholeskySolverTest.testDeterminant	(	): test determinant 
org.apache.commons.math4.linear.CholeskySolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.CholeskySolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.ConjugateGradient:  This is an implementation of the conjugate gradient method for RealLinearOperator. It follows closely the template by Barrett et al. (1994) (figure 2.5). The linear system at hand is A · x = b, and the residual is r = b - A · x.  Default stopping criterion  A default stopping criterion is implemented. The iterations stop when || r || ≤ δ || b ||, where b is the right-hand side vector, r the current estimate of the residual, and δ a user-specified tolerance. It should be noted that r is the so-called updated residual, which might differ from the true residual due to rounding-off errors (see e.g. Strakos and Tichy, 2002).  Iteration count  In the present context, an iteration should be understood as one evaluation of the matrix-vector product A · x. The initialization phase therefore counts as one iteration.  Exception context  Besides standard DimensionMismatchException, this class might throw NonPositiveDefiniteOperatorException if the linear operator or the preconditioner are not positive definite. In this case, the ExceptionContext provides some more information  key "operator" points to the offending linear operator, say L, key "vector" points to the offending vector, say x, such that xT · L · x < 0.  References  Barret et al. (1994) R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. M. Donato, J. Dongarra, V. Eijkhout, R. Pozo, C. Romine and H. Van der Vorst,  Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods, SIAM Strakos and Tichy (2002) Z. Strakos and P. Tichy,  On error estimation in the conjugate gradient method and why it works in finite precision computations, Electronic Transactions on Numerical Analysis 13: 56-80, 2002 
org.apache.commons.math4.linear.ConjugateGradient.ConjugateGradient	(	IterationManager	double	boolean	): Creates a new instance of this class, with default stopping criterion and custom iteration manager.
org.apache.commons.math4.linear.ConjugateGradient.ConjugateGradient	(	int	double	boolean	): Creates a new instance of this class, with default stopping criterion.
org.apache.commons.math4.linear.ConjugateGradient.getCheck	(	): Returns true if positive-definiteness should be checked for both matrix and preconditioner.
org.apache.commons.math4.linear.ConjugateGradient.solveInPlace	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. The solution is computed in-place (initial guess is modified).
org.apache.commons.math4.linear.ConjugateGradientTest.testUnpreconditionedResidual	(	): Check whether the estimate of the (updated) residual corresponds to the exact residual. This fails to be true for a large number of iterations, due to the loss of orthogonality of the successive search directions. Therefore, in the present test, the number of iterations is limited.
org.apache.commons.math4.linear.DecompositionSolver: Interface handling decomposition algorithms that can solve A × X = B.  Decomposition algorithms decompose an A matrix has a product of several specific matrices from which they can solve A × X = B in least squares sense: they find X such that ||A × X - B|| is minimal.  Some solvers like LUDecomposition can only find the solution for square matrices and when the solution is an exact linear solution, i.e. when ||A × X - B|| is exactly 0. Other solvers can also find solutions with non-square matrix A and with non-null minimal norm. If an exact linear solution exists it is also the minimal norm solution.
org.apache.commons.math4.linear.DecompositionSolver.getInverse	(	): Get the pseudo-inverse of the decomposed matrix.  This is equal to the inverse of the decomposed matrix, if such an inverse exists.  If no such inverse exists, then the result has properties that resemble that of an inverse.  In particular, in this case, if the decomposed matrix is A, then the system of equations \( A x = b \) may have no solutions, or many. If it has no solutions, then the pseudo-inverse \( A^+ \) gives the "closest" solution \( z = A^+ b \), meaning \( \left \| A z - b \right \|_2 \) is minimized. If there are many solutions, then \( z = A^+ b \) is the smallest solution, meaning \( \left \| z \right \|_2 \) is minimized.  Note however that some decompositions cannot compute a pseudo-inverse for all matrices. For example, the LUDecomposition is not defined for non-square matrices to begin with. The QRDecomposition can operate on non-square matrices, but will throw SingularMatrixException if the decomposed matrix is singular. Refer to the javadoc of specific decomposition implementations for more details.
org.apache.commons.math4.linear.DecompositionSolver.isNonSingular	(	): Check if the decomposed matrix is non-singular.
org.apache.commons.math4.linear.DecompositionSolver.solve	(	RealMatrix	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm.
org.apache.commons.math4.linear.DecompositionSolver.solve	(	RealVector	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm.
org.apache.commons.math4.linear.DefaultFieldMatrixChangingVisitor: Default implementation of the FieldMatrixChangingVisitor interface.  This class is a convenience to create custom visitors without defining all methods. This class provides default implementations that do nothing. 
org.apache.commons.math4.linear.DefaultFieldMatrixChangingVisitor.DefaultFieldMatrixChangingVisitor	(	T	): Build a new instance.
org.apache.commons.math4.linear.DefaultFieldMatrixChangingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited. 
org.apache.commons.math4.linear.DefaultFieldMatrixChangingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited. 
org.apache.commons.math4.linear.DefaultFieldMatrixChangingVisitor.visit	(	int	int	T	): Visit one matrix entry. 
org.apache.commons.math4.linear.DefaultFieldMatrixPreservingVisitor: Default implementation of the FieldMatrixPreservingVisitor interface.  This class is a convenience to create custom visitors without defining all methods. This class provides default implementations that do nothing. 
org.apache.commons.math4.linear.DefaultFieldMatrixPreservingVisitor.DefaultFieldMatrixPreservingVisitor	(	T	): Build a new instance.
org.apache.commons.math4.linear.DefaultFieldMatrixPreservingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited. 
org.apache.commons.math4.linear.DefaultFieldMatrixPreservingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited. 
org.apache.commons.math4.linear.DefaultFieldMatrixPreservingVisitor.visit	(	int	int	T	): Visit one matrix entry. 
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent: A default concrete implementation of the abstract class IterativeLinearSolverEvent.
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.DefaultIterativeLinearSolverEvent	(	Object	int	RealVector	RealVector	RealVector	double	): Creates a new instance of this class. This implementation does not deep copy the specified vectors x, b, r. Therefore the user must make sure that these vectors are either unmodifiable views or deep copies of the same vectors actually used by the source. Failure to do so may compromise subsequent iterations of the source. If the residual vector r is null, then getResidual() throws a MathUnsupportedOperationException, and providesResidual() returns false.
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.DefaultIterativeLinearSolverEvent	(	Object	int	RealVector	RealVector	double	): Creates a new instance of this class. This implementation does not deep copy the specified vectors x, b. Therefore the user must make sure that these vectors are either unmodifiable views or deep copies of the same vectors actually used by the source. Failure to do so may compromise subsequent iterations of the source. Callling getResidual() on instances returned by this constructor throws a MathUnsupportedOperationException, while providesResidual() returns false.
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.getNormOfResidual	(	): Returns the norm of the residual. The returned value is not required to be exact. Instead, the norm of the so-called updated residual (if available) should be returned. For example, the ConjugateGradient conjugate gradient method computes a sequence of residuals, the norm of which is cheap to compute. However, due to accumulation of round-off errors, this residual might differ from the true residual after some iterations. See e.g. A. Greenbaum and Z. Strakos, Predicting the Behavior of Finite Precision Lanzos and Conjugate Gradient Computations, Technical Report 538, Department of Computer Science, New York University, 1991 (available here). 
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.getResidual	(	):  Returns the residual. This is an optional operation, as all iterative linear solvers do not provide cheap estimate of the updated residual vector, in which case   this method should throw a MathUnsupportedOperationException, providesResidual() returns false.   The default implementation throws a MathUnsupportedOperationException. If this method is overriden, then providesResidual() should be overriden as well.  This implementation throws an MathUnsupportedOperationException if no residual vector r was provided at construction time.
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.getRightHandSideVector	(	): Returns the current right-hand side of the linear system to be solved. This method should return an unmodifiable view, or a deep copy of the actual right-hand side vector, in order not to compromise subsequent iterations of the source IterativeLinearSolver. 
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.getSolution	(	): Returns the current estimate of the solution to the linear system to be solved. This method should return an unmodifiable view, or a deep copy of the actual current solution, in order not to compromise subsequent iterations of the source IterativeLinearSolver. 
org.apache.commons.math4.linear.DefaultIterativeLinearSolverEvent.providesResidual	(	): Returns true if getResidual() is supported. The default implementation returns false. This implementation returns true if a non-null value was specified for the residual vector r at construction time.
org.apache.commons.math4.linear.DefaultRealMatrixChangingVisitor: Default implementation of the RealMatrixChangingVisitor interface.  This class is a convenience to create custom visitors without defining all methods. This class provides default implementations that do nothing. 
org.apache.commons.math4.linear.DefaultRealMatrixChangingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited. 
org.apache.commons.math4.linear.DefaultRealMatrixChangingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited. 
org.apache.commons.math4.linear.DefaultRealMatrixChangingVisitor.visit	(	int	int	double	): Visit one matrix entry. 
org.apache.commons.math4.linear.DefaultRealMatrixPreservingVisitor: Default implementation of the RealMatrixPreservingVisitor interface.  This class is a convenience to create custom visitors without defining all methods. This class provides default implementations that do nothing. 
org.apache.commons.math4.linear.DefaultRealMatrixPreservingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited. 
org.apache.commons.math4.linear.DefaultRealMatrixPreservingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited. 
org.apache.commons.math4.linear.DefaultRealMatrixPreservingVisitor.visit	(	int	int	double	): Visit one matrix entry. 
org.apache.commons.math4.linear.DiagonalMatrix: Implementation of a diagonal matrix.
org.apache.commons.math4.linear.DiagonalMatrix.DiagonalMatrix	(	double[]	): Creates a matrix using the input array as the underlying data.  The input array is copied, not referenced.
org.apache.commons.math4.linear.DiagonalMatrix.DiagonalMatrix	(	double[]	boolean	): Creates a matrix using the input array as the underlying data.  If an array is created specially in order to be embedded in a this instance and not used directly, the copyArray may be set to false. This will prevent the copying and improve performance as no new array will be built and no data will be copied.
org.apache.commons.math4.linear.DiagonalMatrix.DiagonalMatrix	(	int	): Creates a matrix with the supplied dimension.
org.apache.commons.math4.linear.DiagonalMatrix.add	(	DiagonalMatrix	): Compute the sum of this and m.
org.apache.commons.math4.linear.DiagonalMatrix.addToEntry	(	int	int	double	): Adds (in place) the specified value to the specified entry of this matrix. Row and column indices start at 0. 
org.apache.commons.math4.linear.DiagonalMatrix.copy	(	): Returns a (deep) copy of this.  
org.apache.commons.math4.linear.DiagonalMatrix.createMatrix	(	int	int	): Create a new RealMatrix of the same type as the instance with the supplied row and column dimensions. 
org.apache.commons.math4.linear.DiagonalMatrix.ensureZero	(	double	): Ensure a value is zero.
org.apache.commons.math4.linear.DiagonalMatrix.getColumnDimension	(	): Returns the number of columns of this matrix. 
org.apache.commons.math4.linear.DiagonalMatrix.getData	(	): Returns matrix entries as a two-dimensional array.  
org.apache.commons.math4.linear.DiagonalMatrix.getDataRef	(	): Gets a reference to the underlying data array.
org.apache.commons.math4.linear.DiagonalMatrix.getEntry	(	int	int	): Get the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.DiagonalMatrix.getRowDimension	(	): Returns the number of rows of this matrix. 
org.apache.commons.math4.linear.DiagonalMatrix.inverse	(	): Computes the inverse of this diagonal matrix.  Note: this method will use a singularity threshold of 0, use inverse() if a different threshold is needed.
org.apache.commons.math4.linear.DiagonalMatrix.inverse	(	double	): Computes the inverse of this diagonal matrix.
org.apache.commons.math4.linear.DiagonalMatrix.isSingular	(	double	): Returns whether this diagonal matrix is singular, i.e. any diagonal entry is equal to 0 within the given threshold.
org.apache.commons.math4.linear.DiagonalMatrix.multiply	(	DiagonalMatrix	): Returns the result of postmultiplying this by m.
org.apache.commons.math4.linear.DiagonalMatrix.multiply	(	RealMatrix	): Returns the result of postmultiplying this by m.
org.apache.commons.math4.linear.DiagonalMatrix.multiplyEntry	(	int	int	double	): Multiplies (in place) the specified entry of this matrix by the specified value. Row and column indices start at 0.  
org.apache.commons.math4.linear.DiagonalMatrix.operate	(	double[]	): Returns the result of multiplying this by the vector v.  
org.apache.commons.math4.linear.DiagonalMatrix.preMultiply	(	RealVector	): Returns the (row) vector result of premultiplying this by the vector v.  
org.apache.commons.math4.linear.DiagonalMatrix.preMultiply	(	double[]	): Returns the (row) vector result of premultiplying this by the vector v.  
org.apache.commons.math4.linear.DiagonalMatrix.setEntry	(	int	int	double	): Set the entry in the specified row and column. Row and column indices start at 0. 
org.apache.commons.math4.linear.DiagonalMatrix.subtract	(	DiagonalMatrix	): Returns this minus m.
org.apache.commons.math4.linear.DiagonalMatrixTest: Test cases for the DiagonalMatrix class.
org.apache.commons.math4.linear.EigenDecomposition: Calculates the eigen decomposition of a real matrix.  The eigen decomposition of matrix A is a set of two matrices: V and D such that A = V × D × VT. A, V and D are all m × m matrices.  This class is similar in spirit to the EigenvalueDecomposition class from the JAMA library, with the following changes:  a getVT() getVt method has been added, two getRealEigenvalue() and getImagEigenvalue() methods to pick up a single eigenvalue have been added, a getEigenvector() method to pick up a single eigenvector has been added, a getDeterminant() method has been added. a getSolver() method has been added.   As of 3.1, this class supports general real matrices (both symmetric and non-symmetric):  If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal and the eigenvector matrix V is orthogonal, i.e. A = V.multiply(D.multiply(V.transpose())) and V.multiply(V.transpose()) equals the identity matrix.   If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2 blocks:  [lambda, mu ] [ -mu, lambda]  The columns of V represent the eigenvectors in the sense that A*V = V*D, i.e. A.multiply(V) equals V.multiply(D). The matrix V may be badly conditioned, or even singular, so the validity of the equation A = V*D*inverse(V) depends upon the condition of V.  This implementation is based on the paper by A. Drubrulle, R.S. Martin and J.H. Wilkinson "The Implicit QL Algorithm" in Wilksinson and Reinsch (1971) Handbook for automatic computation, vol. 2, Linear algebra, Springer-Verlag, New-York.
org.apache.commons.math4.linear.EigenDecomposition.EigenDecomposition	(	RealMatrix	): Calculates the eigen decomposition of the given real matrix.  Supports decomposition of a general matrix since 3.1.
org.apache.commons.math4.linear.EigenDecomposition.EigenDecomposition	(	double[]	double[]	): Calculates the eigen decomposition of the symmetric tridiagonal matrix. The Householder matrix is assumed to be the identity matrix.
org.apache.commons.math4.linear.EigenDecomposition.Solver: Specialized solver. 
org.apache.commons.math4.linear.EigenDecomposition.Solver.Solver	(	double[]	double[]	ArrayRealVector[]	): Builds a solver from decomposed matrix.
org.apache.commons.math4.linear.EigenDecomposition.Solver.eigenvalueNorm	(	int	): 
org.apache.commons.math4.linear.EigenDecomposition.Solver.getInverse	(	): Get the inverse of the decomposed matrix.
org.apache.commons.math4.linear.EigenDecomposition.Solver.isNonSingular	(	): Checks whether the decomposed matrix is non-singular.
org.apache.commons.math4.linear.EigenDecomposition.Solver.solve	(	RealMatrix	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.EigenDecomposition.Solver.solve	(	RealVector	): Solves the linear equation A × X = B for symmetric matrices A.  This method only finds exact linear solutions, i.e. solutions for which ||A × X - B|| is exactly 0. 
org.apache.commons.math4.linear.EigenDecomposition.cdiv	(	double	double	double	double	): Performs a division of two complex numbers.
org.apache.commons.math4.linear.EigenDecomposition.findEigenVectors	(	double[][]	): Find eigenvalues and eigenvectors (Dubrulle et al., 1971)
org.apache.commons.math4.linear.EigenDecomposition.findEigenVectorsFromSchur	(	SchurTransformer	): Find eigenvectors from a matrix transformed to Schur form.
org.apache.commons.math4.linear.EigenDecomposition.getD	(	): Gets the block diagonal matrix D of the decomposition. D is a block diagonal matrix. Real eigenvalues are on the diagonal while complex values are on 2x2 blocks { {real +imaginary}, {-imaginary, real} }.
org.apache.commons.math4.linear.EigenDecomposition.getDeterminant	(	): Computes the determinant of the matrix.
org.apache.commons.math4.linear.EigenDecomposition.getEigenvector	(	int	): Gets a copy of the ith eigenvector of the original matrix.
org.apache.commons.math4.linear.EigenDecomposition.getImagEigenvalue	(	int	): Gets the imaginary part of the ith eigenvalue of the original matrix.
org.apache.commons.math4.linear.EigenDecomposition.getImagEigenvalues	(	): Gets a copy of the imaginary parts of the eigenvalues of the original matrix.
org.apache.commons.math4.linear.EigenDecomposition.getRealEigenvalue	(	int	): Returns the real part of the ith eigenvalue of the original matrix.
org.apache.commons.math4.linear.EigenDecomposition.getRealEigenvalues	(	): Gets a copy of the real parts of the eigenvalues of the original matrix.
org.apache.commons.math4.linear.EigenDecomposition.getSolver	(	): Gets a solver for finding the A × X = B solution in exact linear sense.  Since 3.1, eigen decomposition of a general matrix is supported, but the DecompositionSolver only supports real eigenvalues.
org.apache.commons.math4.linear.EigenDecomposition.getSquareRoot	(	): Computes the square-root of the matrix. This implementation assumes that the matrix is symmetric and positive definite.
org.apache.commons.math4.linear.EigenDecomposition.getV	(	): Gets the matrix V of the decomposition. V is an orthogonal matrix, i.e. its transpose is also its inverse. The columns of V are the eigenvectors of the original matrix. No assumption is made about the orientation of the system axes formed by the columns of V (e.g. in a 3-dimension space, V can form a left- or right-handed system).
org.apache.commons.math4.linear.EigenDecomposition.getVT	(	): Gets the transpose of the matrix V of the decomposition. V is an orthogonal matrix, i.e. its transpose is also its inverse. The columns of V are the eigenvectors of the original matrix. No assumption is made about the orientation of the system axes formed by the columns of V (e.g. in a 3-dimension space, V can form a left- or right-handed system).
org.apache.commons.math4.linear.EigenDecomposition.hasComplexEigenvalues	(	): Returns whether the calculated eigen values are complex or real. The method performs a zero check for each element of the getImagEigenvalues() array and returns true if any element is not equal to zero.
org.apache.commons.math4.linear.EigenDecomposition.transformToSchur	(	RealMatrix	): Transforms the matrix to Schur form and calculates the eigenvalues.
org.apache.commons.math4.linear.EigenDecomposition.transformToTridiagonal	(	RealMatrix	): Transforms the matrix to tridiagonal form.
org.apache.commons.math4.linear.EigenDecompositionTest.checkEigenValues	(	double[]	EigenDecomposition	double	): Verifies that the given EigenDecomposition has eigenvalues equivalent to the targetValues, ignoring the order of the values and allowing values to differ by tolerance.
org.apache.commons.math4.linear.EigenDecompositionTest.checkEigenVector	(	double[]	EigenDecomposition	double	): Returns true iff eigenVector is a scalar multiple of one of the columns of ed.getV(). Does not try linear combinations - i.e., should only be used to find vectors in one-dimensional eigenspaces.
org.apache.commons.math4.linear.EigenDecompositionTest.checkUnsymmetricMatrix	(	RealMatrix	): Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by checking: A*V = V*D
org.apache.commons.math4.linear.EigenDecompositionTest.isIncludedColumn	(	double[]	RealMatrix	double	): Returns true iff there is a column that is a scalar multiple of column in searchMatrix (modulo tolerance)
org.apache.commons.math4.linear.EigenDecompositionTest.isIncludedValue	(	double	double[]	double	): Returns true iff there is an entry within tolerance of value in searchArray.
org.apache.commons.math4.linear.EigenDecompositionTest.testAEqualVDVt	(	): test A = VDVt 
org.apache.commons.math4.linear.EigenDecompositionTest.testBigMatrix	(	): test eigenvalues for a big matrix. 
org.apache.commons.math4.linear.EigenDecompositionTest.testDiagonal	(	): test diagonal matrix 
org.apache.commons.math4.linear.EigenDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.EigenDecompositionTest.testDistinctEigenvalues	(	): Matrix with eigenvalues {2, 0, 12}
org.apache.commons.math4.linear.EigenDecompositionTest.testEigenvalues	(	): test eigenvalues 
org.apache.commons.math4.linear.EigenDecompositionTest.testEigenvectors	(	): test eigenvectors 
org.apache.commons.math4.linear.EigenDecompositionTest.testMath1051	(	): Tests the porting of a bugfix in Jama-1.0.3 (from changelog): Patched hqr2 method in Jama.EigenvalueDecomposition to avoid infinite loop; Thanks Frederic Devernay 
org.apache.commons.math4.linear.EigenDecompositionTest.testRepeatedEigenvalue	(	): Matrix with eigenvalues {8, -1, -1}
org.apache.commons.math4.linear.EigenDecompositionTest.testTinyValues	(	): Verifies operation on very small values. Matrix with eigenvalues {2e-100, 0, 12e-100}
org.apache.commons.math4.linear.EigenDecompositionTest.testTridiagonal	(	): test a matrix already in tridiagonal form. 
org.apache.commons.math4.linear.EigenDecompositionTest.testVOrthogonal	(	): test that V is orthogonal 
org.apache.commons.math4.linear.EigenDecompositionTest.testZeroDivide	(	): Verifies operation on indefinite matrix
org.apache.commons.math4.linear.EigenSolverTest.testInvertible	(	): test invertible matrix 
org.apache.commons.math4.linear.EigenSolverTest.testInvertibleTinyValues	(	): Verifies operation on very small values. Matrix with eigenvalues {8e-100, -1e-100, -1e-100}
org.apache.commons.math4.linear.EigenSolverTest.testNonInvertible	(	): test non invertible matrix 
org.apache.commons.math4.linear.EigenSolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.EigenSolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.FieldDecompositionSolver: Interface handling decomposition algorithms that can solve A × X = B. Decomposition algorithms decompose an A matrix has a product of several specific matrices from which they can solve A × X = B in least squares sense: they find X such that ||A × X - B|| is minimal. Some solvers like FieldLUDecomposition can only find the solution for square matrices and when the solution is an exact linear solution, i.e. when ||A × X - B|| is exactly 0. Other solvers can also find solutions with non-square matrix A and with non-null minimal norm. If an exact linear solution exists it is also the minimal norm solution.
org.apache.commons.math4.linear.FieldDecompositionSolver.getInverse	(	): Get the inverse (or pseudo-inverse) of the decomposed matrix.
org.apache.commons.math4.linear.FieldDecompositionSolver.isNonSingular	(	): Check if the decomposed matrix is non-singular.
org.apache.commons.math4.linear.FieldDecompositionSolver.solve	(	FieldMatrix	): Solve the linear equation A × X = B for matrices A. The A matrix is implicit, it is provided by the underlying decomposition algorithm.
org.apache.commons.math4.linear.FieldDecompositionSolver.solve	(	FieldVector	): Solve the linear equation A × X = B for matrices A. The A matrix is implicit, it is provided by the underlying decomposition algorithm.
org.apache.commons.math4.linear.FieldLUDecomposition: Calculates the LUP-decomposition of a square matrix. The LUP-decomposition of a matrix A consists of three matrices L, U and P that satisfy: PA = LU, L is lower triangular, and U is upper triangular and P is a permutation matrix. All matrices are m×m. Since FieldElement field elements do not provide an ordering operator, the permutation matrix is computed here only in order to avoid a zero pivot element, no attempt is done to get the largest pivot element. This class is based on the class with similar name from the JAMA library.  a getP() method has been added, the det method has been renamed as getDeterminant() , the getDoublePivot method has been removed (but the int based getPivot() method has been kept), the solve and isNonSingular methods have been replaced by a getSolver() method and the equivalent methods provided by the returned DecompositionSolver. 
org.apache.commons.math4.linear.FieldLUDecomposition.FieldLUDecomposition	(	FieldMatrix	): Calculates the LU-decomposition of the given matrix.
org.apache.commons.math4.linear.FieldLUDecomposition.Solver: Specialized solver.
org.apache.commons.math4.linear.FieldLUDecomposition.Solver.Solver	(	Field	T[][]	int[]	boolean	): Build a solver from decomposed matrix.
org.apache.commons.math4.linear.FieldLUDecomposition.Solver.getInverse	(	): Get the inverse (or pseudo-inverse) of the decomposed matrix. 
org.apache.commons.math4.linear.FieldLUDecomposition.Solver.isNonSingular	(	): Check if the decomposed matrix is non-singular. 
org.apache.commons.math4.linear.FieldLUDecomposition.Solver.solve	(	ArrayFieldVector	): Solve the linear equation A × X = B. The A matrix is implicit here. It is 
org.apache.commons.math4.linear.FieldLUDecomposition.Solver.solve	(	FieldMatrix	): Solve the linear equation A × X = B for matrices A. The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.FieldLUDecomposition.Solver.solve	(	FieldVector	): Solve the linear equation A × X = B for matrices A. The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.FieldLUDecomposition.getDeterminant	(	): Return the determinant of the matrix.
org.apache.commons.math4.linear.FieldLUDecomposition.getL	(	): Returns the matrix L of the decomposition. L is a lower-triangular matrix
org.apache.commons.math4.linear.FieldLUDecomposition.getP	(	): Returns the P rows permutation matrix. P is a sparse matrix with exactly one element set to 1.0 in each row and each column, all other elements being set to 0.0. The positions of the 1 elements are given by the getPivot() pivot permutation vector.
org.apache.commons.math4.linear.FieldLUDecomposition.getPivot	(	): Returns the pivot permutation vector.
org.apache.commons.math4.linear.FieldLUDecomposition.getSolver	(	): Get a solver for finding the A × X = B solution in exact linear sense.
org.apache.commons.math4.linear.FieldLUDecomposition.getU	(	): Returns the matrix U of the decomposition. U is an upper-triangular matrix
org.apache.commons.math4.linear.FieldLUDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testLLowerTriangular	(	): test that L is lower triangular with unit diagonal 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testMatricesValues1	(	): test matrices values 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testMatricesValues2	(	): test matrices values 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testNonSquare	(	): test non-square matrix 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testPAEqualLU	(	): test PA = LU 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testPPermutation	(	): test that P is a permutation matrix 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testSingular	(	): test singular 
org.apache.commons.math4.linear.FieldLUDecompositionTest.testUUpperTriangular	(	): test that U is upper triangular 
org.apache.commons.math4.linear.FieldLUSolverTest.testDeterminant	(	): test determinant 
org.apache.commons.math4.linear.FieldLUSolverTest.testSingular	(	): test singular 
org.apache.commons.math4.linear.FieldLUSolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.FieldLUSolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.FieldLUSolverTest.testSolveSingularityErrors	(	): test solve singularity errors 
org.apache.commons.math4.linear.FieldMatrix: Interface defining field-valued matrix with basic algebraic operations.  Matrix element indexing is 0-based -- e.g., getEntry(0, 0) returns the element in the first row, first column of the matrix.
org.apache.commons.math4.linear.FieldMatrix.add	(	FieldMatrix	): Compute the sum of this and m.
org.apache.commons.math4.linear.FieldMatrix.addToEntry	(	int	int	T	): Change an entry in the specified row and column.
org.apache.commons.math4.linear.FieldMatrix.copy	(	): Make a (deep) copy of this.
org.apache.commons.math4.linear.FieldMatrix.copySubMatrix	(	int	int	int	int	T[][]	): Copy a submatrix. Rows and columns are 0-based. The designated submatrix is copied into the top left portion of the destination array.
org.apache.commons.math4.linear.FieldMatrix.copySubMatrix	(	int[]	int[]	T[][]	): Copy a submatrix. Rows and columns are indicated counting from 0 to n - 1.
org.apache.commons.math4.linear.FieldMatrix.createMatrix	(	int	int	): Create a new FieldMatrix of the same type as the instance with the supplied row and column dimensions.
org.apache.commons.math4.linear.FieldMatrix.getColumn	(	int	): Get the entries in column number col as an array.
org.apache.commons.math4.linear.FieldMatrix.getColumnMatrix	(	int	): Get the entries in column number column as a column matrix.
org.apache.commons.math4.linear.FieldMatrix.getColumnVector	(	int	): Returns the entries in column number column as a vector.
org.apache.commons.math4.linear.FieldMatrix.getData	(	): Returns matrix entries as a two-dimensional array.
org.apache.commons.math4.linear.FieldMatrix.getEntry	(	int	int	): Returns the entry in the specified row and column.
org.apache.commons.math4.linear.FieldMatrix.getField	(	): Get the type of field elements of the matrix.
org.apache.commons.math4.linear.FieldMatrix.getRow	(	int	): Get the entries in row number row as an array.
org.apache.commons.math4.linear.FieldMatrix.getRowMatrix	(	int	): Get the entries in row number row as a row matrix.
org.apache.commons.math4.linear.FieldMatrix.getRowVector	(	int	): Get the entries in row number row as a vector.
org.apache.commons.math4.linear.FieldMatrix.getSubMatrix	(	int	int	int	int	): Get a submatrix. Rows and columns are indicated counting from 0 to n - 1.
org.apache.commons.math4.linear.FieldMatrix.getSubMatrix	(	int[]	int[]	): Get a submatrix. Rows and columns are indicated counting from 0 to n - 1.
org.apache.commons.math4.linear.FieldMatrix.getTrace	(	): Returns the  trace of the matrix (the sum of the elements on the main diagonal).
org.apache.commons.math4.linear.FieldMatrix.multiply	(	FieldMatrix	): Postmultiply this matrix by m.
org.apache.commons.math4.linear.FieldMatrix.multiplyEntry	(	int	int	T	): Change an entry in the specified row and column.
org.apache.commons.math4.linear.FieldMatrix.operate	(	FieldVector	): Returns the result of multiplying this by the vector v.
org.apache.commons.math4.linear.FieldMatrix.operate	(	T[]	): Returns the result of multiplying this by the vector v.
org.apache.commons.math4.linear.FieldMatrix.power	(	int	): Returns the result multiplying this with itself p times. Depending on the type of the field elements, T, instability for high powers might occur.
org.apache.commons.math4.linear.FieldMatrix.preMultiply	(	FieldMatrix	): Premultiply this matrix by m.
org.apache.commons.math4.linear.FieldMatrix.preMultiply	(	FieldVector	): Returns the (row) vector result of premultiplying this by the vector v.
org.apache.commons.math4.linear.FieldMatrix.preMultiply	(	T[]	): Returns the (row) vector result of premultiplying this by the vector v.
org.apache.commons.math4.linear.FieldMatrix.scalarAdd	(	T	): Increment each entry of this matrix.
org.apache.commons.math4.linear.FieldMatrix.scalarMultiply	(	T	): Multiply each entry by d.
org.apache.commons.math4.linear.FieldMatrix.setColumn	(	int	T[]	): Set the entries in column number column as a column matrix.
org.apache.commons.math4.linear.FieldMatrix.setColumnMatrix	(	int	FieldMatrix	): Set the entries in column number column as a column matrix.
org.apache.commons.math4.linear.FieldMatrix.setColumnVector	(	int	FieldVector	): Set the entries in column number column as a vector.
org.apache.commons.math4.linear.FieldMatrix.setEntry	(	int	int	T	): Set the entry in the specified row and column.
org.apache.commons.math4.linear.FieldMatrix.setRow	(	int	T[]	): Set the entries in row number row as a row matrix.
org.apache.commons.math4.linear.FieldMatrix.setRowMatrix	(	int	FieldMatrix	): Set the entries in row number row as a row matrix.
org.apache.commons.math4.linear.FieldMatrix.setRowVector	(	int	FieldVector	): Set the entries in row number row as a vector.
org.apache.commons.math4.linear.FieldMatrix.setSubMatrix	(	T[][]	int	int	): Replace the submatrix starting at (row, column) using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2 
org.apache.commons.math4.linear.FieldMatrix.subtract	(	FieldMatrix	): Subtract m from this matrix.
org.apache.commons.math4.linear.FieldMatrix.transpose	(	): Returns the transpose of this matrix.
org.apache.commons.math4.linear.FieldMatrix.walkInColumnOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.FieldMatrix.walkInColumnOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.FieldMatrix.walkInColumnOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.FieldMatrix.walkInColumnOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.FieldMatrix.walkInOptimizedOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.FieldMatrix.walkInOptimizedOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.FieldMatrix.walkInOptimizedOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.FieldMatrix.walkInOptimizedOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.FieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.FieldMatrix.walkInRowOrder	(	FieldMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.FieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.FieldMatrix.walkInRowOrder	(	FieldMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.FieldMatrixChangingVisitor: Interface defining a visitor for matrix entries.
org.apache.commons.math4.linear.FieldMatrixChangingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited.
org.apache.commons.math4.linear.FieldMatrixChangingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited.
org.apache.commons.math4.linear.FieldMatrixChangingVisitor.visit	(	int	int	T	): Visit one matrix entry.
org.apache.commons.math4.linear.FieldMatrixImplTest: Test cases for the Array2DRowFieldMatrix class.
org.apache.commons.math4.linear.FieldMatrixImplTest.permuteRows	(	FieldMatrix	int[]	): Returns the result of applying the given row permutation to the matrix 
org.apache.commons.math4.linear.FieldMatrixImplTest.splitLU	(	FieldMatrix	Fraction[][]	Fraction[][]	): extracts the l and u matrices from compact lu representation 
org.apache.commons.math4.linear.FieldMatrixImplTest.testAdd	(	): test add 
org.apache.commons.math4.linear.FieldMatrixImplTest.testAddFail	(	): test add failure 
org.apache.commons.math4.linear.FieldMatrixImplTest.testCopyFunctions	(	): test copy functions 
org.apache.commons.math4.linear.FieldMatrixImplTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.FieldMatrixImplTest.testExamples	(	): test examples in user guide 
org.apache.commons.math4.linear.FieldMatrixImplTest.testMath209	(	): test issue MATH-209 
org.apache.commons.math4.linear.FieldMatrixImplTest.testMultiply	(	): test multiply 
org.apache.commons.math4.linear.FieldMatrixImplTest.testOperate	(	): test operate 
org.apache.commons.math4.linear.FieldMatrixImplTest.testPlusMinus	(	): test m-n = m + -n 
org.apache.commons.math4.linear.FieldMatrixImplTest.testPremultiplyVector	(	): test preMultiply by vector 
org.apache.commons.math4.linear.FieldMatrixImplTest.testScalarAdd	(	): test sclarAdd 
org.apache.commons.math4.linear.FieldMatrixImplTest.testTrace	(	): test trace 
org.apache.commons.math4.linear.FieldMatrixImplTest.testTranspose	(	): test transpose 
org.apache.commons.math4.linear.FieldMatrixPreservingVisitor: Interface defining a visitor for matrix entries.
org.apache.commons.math4.linear.FieldMatrixPreservingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited.
org.apache.commons.math4.linear.FieldMatrixPreservingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited.
org.apache.commons.math4.linear.FieldMatrixPreservingVisitor.visit	(	int	int	T	): Visit one matrix entry.
org.apache.commons.math4.linear.FieldVector: Interface defining a field-valued vector with basic algebraic operations.  vector element indexing is 0-based -- e.g., getEntry(0) returns the first element of the vector.   The various mapXxx and mapXxxToSelf methods operate on vectors element-wise, i.e. they perform the same operation (adding a scalar, applying a function ...) on each element in turn. The mapXxx versions create a new vector to hold the result and do not change the instance. The mapXxxToSelf versions use the instance itself to store the results, so the instance is changed by these methods. In both cases, the result vector is returned by the methods, this allows to use the fluent API style, like this:   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();   Note that as almost all operations on FieldElement throw NullArgumentException when operating on a null element, it is the responsibility of FieldVector implementations to make sure no null elements are inserted into the vector. This must be done in all constructors and all setters. 
org.apache.commons.math4.linear.FieldVector.add	(	FieldVector	): Compute the sum of this and v.
org.apache.commons.math4.linear.FieldVector.append	(	FieldVector	): Construct a vector by appending a vector to this vector.
org.apache.commons.math4.linear.FieldVector.append	(	T	): Construct a vector by appending a T to this vector.
org.apache.commons.math4.linear.FieldVector.copy	(	): Returns a (deep) copy of this.
org.apache.commons.math4.linear.FieldVector.dotProduct	(	FieldVector	): Compute the dot product.
org.apache.commons.math4.linear.FieldVector.ebeDivide	(	FieldVector	): Element-by-element division.
org.apache.commons.math4.linear.FieldVector.ebeMultiply	(	FieldVector	): Element-by-element multiplication.
org.apache.commons.math4.linear.FieldVector.getDimension	(	): Returns the size of the vector.
org.apache.commons.math4.linear.FieldVector.getEntry	(	int	): Returns the entry in the specified index.
org.apache.commons.math4.linear.FieldVector.getField	(	): Get the type of field elements of the vector.
org.apache.commons.math4.linear.FieldVector.getSubVector	(	int	int	): Get a subvector from consecutive elements.
org.apache.commons.math4.linear.FieldVector.mapAdd	(	T	): Map an addition operation to each entry.
org.apache.commons.math4.linear.FieldVector.mapAddToSelf	(	T	): Map an addition operation to each entry. The instance is changed by this method.
org.apache.commons.math4.linear.FieldVector.mapDivide	(	T	): Map a division operation to each entry.
org.apache.commons.math4.linear.FieldVector.mapDivideToSelf	(	T	): Map a division operation to each entry. The instance is changed by this method.
org.apache.commons.math4.linear.FieldVector.mapInv	(	): Map the 1/x function to each entry.
org.apache.commons.math4.linear.FieldVector.mapInvToSelf	(	): Map the 1/x function to each entry. The instance is changed by this method.
org.apache.commons.math4.linear.FieldVector.mapMultiply	(	T	): Map a multiplication operation to each entry.
org.apache.commons.math4.linear.FieldVector.mapMultiplyToSelf	(	T	): Map a multiplication operation to each entry. The instance is changed by this method.
org.apache.commons.math4.linear.FieldVector.mapSubtract	(	T	): Map a subtraction operation to each entry.
org.apache.commons.math4.linear.FieldVector.mapSubtractToSelf	(	T	): Map a subtraction operation to each entry. The instance is changed by this method.
org.apache.commons.math4.linear.FieldVector.outerProduct	(	FieldVector	): Compute the outer product.
org.apache.commons.math4.linear.FieldVector.projection	(	FieldVector	): Find the orthogonal projection of this vector onto another vector.
org.apache.commons.math4.linear.FieldVector.set	(	T	): Set all elements to a single value.
org.apache.commons.math4.linear.FieldVector.setEntry	(	int	T	): Set a single element.
org.apache.commons.math4.linear.FieldVector.setSubVector	(	int	FieldVector	): Set a set of consecutive elements.
org.apache.commons.math4.linear.FieldVector.subtract	(	FieldVector	): Compute this minus v.
org.apache.commons.math4.linear.FieldVector.toArray	(	): Convert the vector to a T array. The array is independent from vector data, it's elements are copied.
org.apache.commons.math4.linear.FieldVectorChangingVisitor: This interface defines a visitor for the entries of a vector. Visitors implementing this interface may alter the entries of the vector being visited.
org.apache.commons.math4.linear.FieldVectorChangingVisitor.end	(	): End visiting a vector. This method is called once, after all entries of the vector have been visited.
org.apache.commons.math4.linear.FieldVectorChangingVisitor.start	(	int	int	int	): Start visiting a vector. This method is called once, before any entry of the vector is visited.
org.apache.commons.math4.linear.FieldVectorChangingVisitor.visit	(	int	T	): Visit one entry of the vector.
org.apache.commons.math4.linear.FieldVectorPreservingVisitor: This interface defines a visitor for the entries of a vector. Visitors implementing this interface do not alter the entries of the vector being visited.
org.apache.commons.math4.linear.FieldVectorPreservingVisitor.end	(	): End visiting a vector. This method is called once, after all entries of the vector have been visited.
org.apache.commons.math4.linear.FieldVectorPreservingVisitor.start	(	int	int	int	): Start visiting a vector. This method is called once, before any entry of the vector is visited.
org.apache.commons.math4.linear.FieldVectorPreservingVisitor.visit	(	int	T	): Visit one entry of the vector.
org.apache.commons.math4.linear.HessenbergTransformer: Class transforming a general real matrix to Hessenberg form. A m × m matrix A can be written as the product of three matrices: A = P × H × PT with P an orthogonal matrix and H a Hessenberg matrix. Both P and H are m × m matrices. Transformation to Hessenberg form is often not a goal by itself, but it is an intermediate step in more general decomposition algorithms like EigenDecomposition eigen decomposition. This class is therefore intended for internal use by the library and is not public. As a consequence of this explicitly limited scope, many methods directly returns references to internal arrays, not copies. This class is based on the method orthes in class EigenvalueDecomposition from the JAMA library.
org.apache.commons.math4.linear.HessenbergTransformer.HessenbergTransformer	(	RealMatrix	): Build the transformation to Hessenberg form of a general matrix.
org.apache.commons.math4.linear.HessenbergTransformer.getH	(	): Returns the Hessenberg matrix H of the transform.
org.apache.commons.math4.linear.HessenbergTransformer.getHouseholderVectorsRef	(	): Get the Householder vectors of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.HessenbergTransformer.getP	(	): Returns the matrix P of the transform. P is an orthogonal matrix, i.e. its inverse is also its transpose.
org.apache.commons.math4.linear.HessenbergTransformer.getPT	(	): Returns the transpose of the matrix P of the transform. P is an orthogonal matrix, i.e. its inverse is also its transpose.
org.apache.commons.math4.linear.HessenbergTransformer.transform	(	): Transform original matrix to Hessenberg form. Transformation is done using Householder transforms.
org.apache.commons.math4.linear.HilbertMatrix: This class implements Hilbert Matrices as RealLinearOperator. 
org.apache.commons.math4.linear.HilbertMatrix.HilbertMatrix	(	int	): Creates a new instance of this class.
org.apache.commons.math4.linear.HilbertMatrix.getColumnDimension	(	): Returns the dimension of the domain of this operator. 
org.apache.commons.math4.linear.HilbertMatrix.getRowDimension	(	): Returns the dimension of the codomain of this operator. 
org.apache.commons.math4.linear.HilbertMatrix.operate	(	RealVector	): Returns the result of multiplying this by the vector x. 
org.apache.commons.math4.linear.IllConditionedOperatorException: An exception to be thrown when the condition number of a RealLinearOperator is too high.
org.apache.commons.math4.linear.IllConditionedOperatorException.IllConditionedOperatorException	(	double	): Creates a new instance of this class.
org.apache.commons.math4.linear.InverseHilbertMatrix: This class implements inverses of Hilbert Matrices as RealLinearOperator.
org.apache.commons.math4.linear.InverseHilbertMatrix.InverseHilbertMatrix	(	int	): Creates a new instance of this class.
org.apache.commons.math4.linear.InverseHilbertMatrix.getColumnDimension	(	): Returns the dimension of the domain of this operator. 
org.apache.commons.math4.linear.InverseHilbertMatrix.getEntry	(	int	int	): Returns the (i, j) entry of the inverse Hilbert matrix. Exact arithmetic is used; in case of overflow, an exception is thrown.
org.apache.commons.math4.linear.InverseHilbertMatrix.getRowDimension	(	): Returns the dimension of the codomain of this operator. 
org.apache.commons.math4.linear.InverseHilbertMatrix.operate	(	RealVector	): Returns the result of multiplying this by the vector x. 
org.apache.commons.math4.linear.IterativeLinearSolver: This abstract class defines an iterative solver for the linear system A · x = b. In what follows, the residual r is defined as r = b - A · x, where A is the linear operator of the linear system, b is the right-hand side vector, and x the current estimate of the solution.
org.apache.commons.math4.linear.IterativeLinearSolver.IterativeLinearSolver	(	IterationManager	): Creates a new instance of this class, with custom iteration manager.
org.apache.commons.math4.linear.IterativeLinearSolver.IterativeLinearSolver	(	int	): Creates a new instance of this class, with default iteration manager.
org.apache.commons.math4.linear.IterativeLinearSolver.checkParameters	(	RealLinearOperator	RealVector	RealVector	): Performs all dimension checks on the parameters of solve() and solveInPlace(), and throws an exception if one of the checks fails.
org.apache.commons.math4.linear.IterativeLinearSolver.getIterationManager	(	): Returns the iteration manager attached to this solver.
org.apache.commons.math4.linear.IterativeLinearSolver.solve	(	RealLinearOperator	RealVector	): Returns an estimate of the solution to the linear system A · x = b.
org.apache.commons.math4.linear.IterativeLinearSolver.solve	(	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b.
org.apache.commons.math4.linear.IterativeLinearSolver.solveInPlace	(	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. The solution is computed in-place (initial guess is modified).
org.apache.commons.math4.linear.IterativeLinearSolverEvent: This is the base class for all events occurring during the iterations of a IterativeLinearSolver.
org.apache.commons.math4.linear.IterativeLinearSolverEvent.IterativeLinearSolverEvent	(	Object	int	): Creates a new instance of this class.
org.apache.commons.math4.linear.IterativeLinearSolverEvent.getNormOfResidual	(	): Returns the norm of the residual. The returned value is not required to be exact. Instead, the norm of the so-called updated residual (if available) should be returned. For example, the ConjugateGradient conjugate gradient method computes a sequence of residuals, the norm of which is cheap to compute. However, due to accumulation of round-off errors, this residual might differ from the true residual after some iterations. See e.g. A. Greenbaum and Z. Strakos, Predicting the Behavior of Finite Precision Lanzos and Conjugate Gradient Computations, Technical Report 538, Department of Computer Science, New York University, 1991 (available here).
org.apache.commons.math4.linear.IterativeLinearSolverEvent.getResidual	(	):  Returns the residual. This is an optional operation, as all iterative linear solvers do not provide cheap estimate of the updated residual vector, in which case   this method should throw a MathUnsupportedOperationException, providesResidual() returns false.   The default implementation throws a MathUnsupportedOperationException. If this method is overriden, then providesResidual() should be overriden as well. 
org.apache.commons.math4.linear.IterativeLinearSolverEvent.getRightHandSideVector	(	): Returns the current right-hand side of the linear system to be solved. This method should return an unmodifiable view, or a deep copy of the actual right-hand side vector, in order not to compromise subsequent iterations of the source IterativeLinearSolver.
org.apache.commons.math4.linear.IterativeLinearSolverEvent.getSolution	(	): Returns the current estimate of the solution to the linear system to be solved. This method should return an unmodifiable view, or a deep copy of the actual current solution, in order not to compromise subsequent iterations of the source IterativeLinearSolver.
org.apache.commons.math4.linear.IterativeLinearSolverEvent.providesResidual	(	): Returns true if getResidual() is supported. The default implementation returns false.
org.apache.commons.math4.linear.JacobiPreconditioner: This class implements the standard Jacobi (diagonal) preconditioner. For a matrix Aij, this preconditioner is M = diag(1 / A11, 1 / A22, …).
org.apache.commons.math4.linear.JacobiPreconditioner.JacobiPreconditioner	(	double[]	boolean	): Creates a new instance of this class.
org.apache.commons.math4.linear.JacobiPreconditioner.create	(	RealLinearOperator	): Creates a new instance of this class. This method extracts the diagonal coefficients of the specified linear operator. If a does not extend AbstractRealMatrix, then the coefficients of the underlying matrix are not accessible, coefficient extraction is made by matrix-vector products with the basis vectors (and might therefore take some time). With matrices, direct entry access is carried out.
org.apache.commons.math4.linear.JacobiPreconditioner.getColumnDimension	(	): Returns the dimension of the domain of this operator. 
org.apache.commons.math4.linear.JacobiPreconditioner.getRowDimension	(	): Returns the dimension of the codomain of this operator. 
org.apache.commons.math4.linear.JacobiPreconditioner.operate	(	RealVector	): Returns the result of multiplying this by the vector x. 
org.apache.commons.math4.linear.JacobiPreconditioner.sqrt	(	): Returns the square root of this diagonal operator. More precisely, this method returns P = diag(1 / √A11, 1 / √A22, …).
org.apache.commons.math4.linear.LUDecomposition: Calculates the LUP-decomposition of a square matrix. The LUP-decomposition of a matrix A consists of three matrices L, U and P that satisfy: P×A = L×U. L is lower triangular (with unit diagonal terms), U is upper triangular and P is a permutation matrix. All matrices are m×m. As shown by the presence of the P matrix, this decomposition is implemented using partial pivoting. This class is based on the class with similar name from the JAMA library.  a getP() method has been added, the det method has been renamed as getDeterminant() , the getDoublePivot method has been removed (but the int based getPivot() method has been kept), the solve and isNonSingular methods have been replaced by a getSolver() method and the equivalent methods provided by the returned DecompositionSolver. 
org.apache.commons.math4.linear.LUDecomposition.LUDecomposition	(	RealMatrix	): Calculates the LU-decomposition of the given matrix. This constructor uses 1e-11 as default value for the singularity threshold.
org.apache.commons.math4.linear.LUDecomposition.LUDecomposition	(	RealMatrix	double	): Calculates the LU-decomposition of the given matrix.
org.apache.commons.math4.linear.LUDecomposition.Solver: Specialized solver. 
org.apache.commons.math4.linear.LUDecomposition.Solver.Solver	(	double[][]	int[]	boolean	): Build a solver from decomposed matrix.
org.apache.commons.math4.linear.LUDecomposition.Solver.getInverse	(	): Get the inverse of the decomposed matrix.
org.apache.commons.math4.linear.LUDecomposition.Solver.isNonSingular	(	): Check if the decomposed matrix is non-singular. 
org.apache.commons.math4.linear.LUDecomposition.Solver.solve	(	RealMatrix	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.LUDecomposition.Solver.solve	(	RealVector	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.LUDecomposition.getDeterminant	(	): Return the determinant of the matrix
org.apache.commons.math4.linear.LUDecomposition.getL	(	): Returns the matrix L of the decomposition. L is a lower-triangular matrix
org.apache.commons.math4.linear.LUDecomposition.getP	(	): Returns the P rows permutation matrix. P is a sparse matrix with exactly one element set to 1.0 in each row and each column, all other elements being set to 0.0. The positions of the 1 elements are given by the getPivot() pivot permutation vector.
org.apache.commons.math4.linear.LUDecomposition.getPivot	(	): Returns the pivot permutation vector.
org.apache.commons.math4.linear.LUDecomposition.getSolver	(	): Get a solver for finding the A × X = B solution in exact linear sense.
org.apache.commons.math4.linear.LUDecomposition.getU	(	): Returns the matrix U of the decomposition. U is an upper-triangular matrix
org.apache.commons.math4.linear.LUDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.LUDecompositionTest.testLLowerTriangular	(	): test that L is lower triangular with unit diagonal 
org.apache.commons.math4.linear.LUDecompositionTest.testMatricesValues1	(	): test matrices values 
org.apache.commons.math4.linear.LUDecompositionTest.testMatricesValues2	(	): test matrices values 
org.apache.commons.math4.linear.LUDecompositionTest.testNonSquare	(	): test non-square matrix 
org.apache.commons.math4.linear.LUDecompositionTest.testPAEqualLU	(	): test PA = LU 
org.apache.commons.math4.linear.LUDecompositionTest.testPPermutation	(	): test that P is a permutation matrix 
org.apache.commons.math4.linear.LUDecompositionTest.testSingular	(	): test singular 
org.apache.commons.math4.linear.LUDecompositionTest.testUUpperTriangular	(	): test that U is upper triangular 
org.apache.commons.math4.linear.LUSolverTest.testDeterminant	(	): test determinant 
org.apache.commons.math4.linear.LUSolverTest.testSingular	(	): test singular 
org.apache.commons.math4.linear.LUSolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.LUSolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.LUSolverTest.testSolveSingularityErrors	(	): test solve singularity errors 
org.apache.commons.math4.linear.LUSolverTest.testThreshold	(	): test threshold impact 
org.apache.commons.math4.linear.MatrixDimensionMismatchException: Exception to be thrown when either the number of rows or the number of columns of a matrix do not match the expected values.
org.apache.commons.math4.linear.MatrixDimensionMismatchException.MatrixDimensionMismatchException	(	int	int	int	int	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.linear.MatrixDimensionMismatchException.getExpectedColumnDimension	(	): 
org.apache.commons.math4.linear.MatrixDimensionMismatchException.getExpectedRowDimension	(	): 
org.apache.commons.math4.linear.MatrixDimensionMismatchException.getWrongColumnDimension	(	): 
org.apache.commons.math4.linear.MatrixDimensionMismatchException.getWrongRowDimension	(	): 
org.apache.commons.math4.linear.MatrixDimensionMismatchExceptionTest: Test for MatrixDimensionMismatchException.
org.apache.commons.math4.linear.MatrixUtils: A collection of static methods that operate on or return matrices.
org.apache.commons.math4.linear.MatrixUtils.BigFractionMatrixConverter: Converter for FieldMatrix/BigFraction. 
org.apache.commons.math4.linear.MatrixUtils.BigFractionMatrixConverter.BigFractionMatrixConverter	(	): Simple constructor. 
org.apache.commons.math4.linear.MatrixUtils.BigFractionMatrixConverter.getConvertedMatrix	(	): Get the converted matrix.
org.apache.commons.math4.linear.MatrixUtils.BigFractionMatrixConverter.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited.  
org.apache.commons.math4.linear.MatrixUtils.BigFractionMatrixConverter.visit	(	int	int	BigFraction	):  
org.apache.commons.math4.linear.MatrixUtils.FractionMatrixConverter: Converter for FieldMatrix/Fraction. 
org.apache.commons.math4.linear.MatrixUtils.FractionMatrixConverter.FractionMatrixConverter	(	): Simple constructor. 
org.apache.commons.math4.linear.MatrixUtils.FractionMatrixConverter.getConvertedMatrix	(	): Get the converted matrix.
org.apache.commons.math4.linear.MatrixUtils.FractionMatrixConverter.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited.  
org.apache.commons.math4.linear.MatrixUtils.FractionMatrixConverter.visit	(	int	int	Fraction	):  
org.apache.commons.math4.linear.MatrixUtils.MatrixUtils	(	): Private constructor.
org.apache.commons.math4.linear.MatrixUtils.bigFractionMatrixToRealMatrix	(	FieldMatrix	): Convert a FieldMatrix/BigFraction matrix to a RealMatrix.
org.apache.commons.math4.linear.MatrixUtils.blockInverse	(	RealMatrix	int	): Computes the inverse of the given matrix by splitting it into 4 sub-matrices.
org.apache.commons.math4.linear.MatrixUtils.checkAdditionCompatible	(	AnyMatrix	AnyMatrix	): Check if matrices are addition compatible.
org.apache.commons.math4.linear.MatrixUtils.checkColumnIndex	(	AnyMatrix	int	): Check if a column index is valid.
org.apache.commons.math4.linear.MatrixUtils.checkMatrixIndex	(	AnyMatrix	int	int	): Check if matrix indices are valid.
org.apache.commons.math4.linear.MatrixUtils.checkMultiplicationCompatible	(	AnyMatrix	AnyMatrix	): Check if matrices are multiplication compatible
org.apache.commons.math4.linear.MatrixUtils.checkRowIndex	(	AnyMatrix	int	): Check if a row index is valid.
org.apache.commons.math4.linear.MatrixUtils.checkSubMatrixIndex	(	AnyMatrix	int	int	int	int	): Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n - 1.
org.apache.commons.math4.linear.MatrixUtils.checkSubMatrixIndex	(	AnyMatrix	int[]	int[]	): Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.MatrixUtils.checkSubtractionCompatible	(	AnyMatrix	AnyMatrix	): Check if matrices are subtraction compatible
org.apache.commons.math4.linear.MatrixUtils.checkSymmetric	(	RealMatrix	double	): Checks whether a matrix is symmetric.
org.apache.commons.math4.linear.MatrixUtils.createColumnFieldMatrix	(	T[]	): Creates a column FieldMatrix using the data from the input array.
org.apache.commons.math4.linear.MatrixUtils.createColumnRealMatrix	(	double[]	): Creates a column RealMatrix using the data from the input array.
org.apache.commons.math4.linear.MatrixUtils.createFieldDiagonalMatrix	(	T[]	): Returns a diagonal matrix with specified elements.
org.apache.commons.math4.linear.MatrixUtils.createFieldIdentityMatrix	(	Field	int	): Returns dimension x dimension identity matrix.
org.apache.commons.math4.linear.MatrixUtils.createFieldMatrix	(	Field	int	int	): Returns a FieldMatrix with specified dimensions. The type of matrix returned depends on the dimension. Below 212 elements (i.e. 4096 elements or 64×64 for a square matrix), a FieldMatrix instance is built. Above this threshold a BlockFieldMatrix instance is built. The matrix elements are all set to field.getZero().
org.apache.commons.math4.linear.MatrixUtils.createFieldMatrix	(	T[][]	): Returns a FieldMatrix whose entries are the the values in the the input array. The type of matrix returned depends on the dimension. Below 212 elements (i.e. 4096 elements or 64×64 for a square matrix), a FieldMatrix instance is built. Above this threshold a BlockFieldMatrix instance is built. The input array is copied, not referenced.
org.apache.commons.math4.linear.MatrixUtils.createFieldVector	(	T[]	): Creates a FieldVector using the data from the input array.
org.apache.commons.math4.linear.MatrixUtils.createRealDiagonalMatrix	(	double[]	): Creates a diagonal matrix with the specified diagonal elements.
org.apache.commons.math4.linear.MatrixUtils.createRealIdentityMatrix	(	int	): Returns dimension x dimension identity matrix.
org.apache.commons.math4.linear.MatrixUtils.createRealMatrix	(	double[][]	): Returns a RealMatrix whose entries are the the values in the the input array. The type of matrix returned depends on the dimension. Below 212 elements (i.e. 4096 elements or 64×64 for a square matrix) which can be stored in a 32kB array, a Array2DRowRealMatrix instance is built. Above this threshold a BlockRealMatrix instance is built. The input array is copied, not referenced.
org.apache.commons.math4.linear.MatrixUtils.createRealMatrix	(	int	int	): Returns a RealMatrix with specified dimensions. The type of matrix returned depends on the dimension. Below 212 elements (i.e. 4096 elements or 64×64 for a square matrix) which can be stored in a 32kB array, a Array2DRowRealMatrix instance is built. Above this threshold a BlockRealMatrix instance is built. The matrix elements are all set to 0.0.
org.apache.commons.math4.linear.MatrixUtils.createRealMatrixWithDiagonal	(	double[]	): Creates a dense matrix with the specified diagonal elements.
org.apache.commons.math4.linear.MatrixUtils.createRealVector	(	double[]	): Creates a RealVector using the data from the input array.
org.apache.commons.math4.linear.MatrixUtils.createRowFieldMatrix	(	T[]	): Create a row FieldMatrix using the data from the input array.
org.apache.commons.math4.linear.MatrixUtils.createRowRealMatrix	(	double[]	): Create a row RealMatrix using the data from the input array.
org.apache.commons.math4.linear.MatrixUtils.deserializeRealMatrix	(	Object	String	ObjectInputStream	): Deserialize a RealMatrix field in a class.  This method is intended to be called from within a private readObject method (after a call to ois.defaultReadObject()) in a class that has a RealMatrix field, which should be declared transient. This way, the default handling does not deserialize the matrix (the RealMatrix interface is not serializable by default) but this method does deserialize it specifically. 
org.apache.commons.math4.linear.MatrixUtils.deserializeRealVector	(	Object	String	ObjectInputStream	): Deserialize a RealVector field in a class.  This method is intended to be called from within a private readObject method (after a call to ois.defaultReadObject()) in a class that has a RealVector field, which should be declared transient. This way, the default handling does not deserialize the vector (the RealVector interface is not serializable by default) but this method does deserialize it specifically. 
org.apache.commons.math4.linear.MatrixUtils.fractionMatrixToRealMatrix	(	FieldMatrix	): Convert a FieldMatrix/Fraction matrix to a RealMatrix.
org.apache.commons.math4.linear.MatrixUtils.inverse	(	RealMatrix	): Computes the inverse of the given matrix.  By default, the inverse of the matrix is computed using the QR-decomposition, unless a more efficient method can be determined for the input matrix.  Note: this method will use a singularity threshold of 0, use inverse() if a different threshold is needed.
org.apache.commons.math4.linear.MatrixUtils.inverse	(	RealMatrix	double	): Computes the inverse of the given matrix.  By default, the inverse of the matrix is computed using the QR-decomposition, unless a more efficient method can be determined for the input matrix.
org.apache.commons.math4.linear.MatrixUtils.isSymmetric	(	RealMatrix	double	): Checks whether a matrix is symmetric.
org.apache.commons.math4.linear.MatrixUtils.isSymmetricInternal	(	RealMatrix	double	boolean	): Checks whether a matrix is symmetric, within a given relative tolerance.
org.apache.commons.math4.linear.MatrixUtils.serializeRealMatrix	(	RealMatrix	ObjectOutputStream	): Serialize a RealMatrix.  This method is intended to be called from within a private writeObject method (after a call to oos.defaultWriteObject()) in a class that has a RealMatrix field, which should be declared transient. This way, the default handling does not serialize the matrix (the RealMatrix interface is not serializable by default) but this method does serialize it specifically.   The following example shows how a simple class with a name and a real matrix should be written:  public class NamedMatrix implements Serializable { private final String name; private final transient RealMatrix coefficients; // omitted constructors, getters ... private void writeObject(ObjectOutputStream oos) throws IOException { oos.defaultWriteObject(); // takes care of name field MatrixUtils.serializeRealMatrix(coefficients, oos); } private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException { ois.defaultReadObject(); // takes care of name field MatrixUtils.deserializeRealMatrix(this, "coefficients", ois); } } 
org.apache.commons.math4.linear.MatrixUtils.serializeRealVector	(	RealVector	ObjectOutputStream	): Serialize a RealVector.  This method is intended to be called from within a private writeObject method (after a call to oos.defaultWriteObject()) in a class that has a RealVector field, which should be declared transient. This way, the default handling does not serialize the vector (the RealVector interface is not serializable by default) but this method does serialize it specifically.   The following example shows how a simple class with a name and a real vector should be written:  public class NamedVector implements Serializable { private final String name; private final transient RealVector coefficients; // omitted constructors, getters ... private void writeObject(ObjectOutputStream oos) throws IOException { oos.defaultWriteObject(); // takes care of name field MatrixUtils.serializeRealVector(coefficients, oos); } private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException { ois.defaultReadObject(); // takes care of name field MatrixUtils.deserializeRealVector(this, "coefficients", ois); } } 
org.apache.commons.math4.linear.MatrixUtils.solveLowerTriangularSystem	(	RealMatrix	RealVector	): Solve a system of composed of a Lower Triangular Matrix RealMatrix.  This method is called to solve systems of equations which are of the lower triangular form. The matrix RealMatrix is assumed, though not checked, to be in lower triangular form. The vector RealVector is overwritten with the solution. The matrix is checked that it is square and its dimensions match the length of the vector. 
org.apache.commons.math4.linear.MatrixUtils.solveUpperTriangularSystem	(	RealMatrix	RealVector	): Solver a system composed of an Upper Triangular Matrix RealMatrix.  This method is called to solve systems of equations which are of the lower triangular form. The matrix RealMatrix is assumed, though not checked, to be in upper triangular form. The vector RealVector is overwritten with the solution. The matrix is checked that it is square and its dimensions match the length of the vector. 
org.apache.commons.math4.linear.MatrixUtilsTest: Test cases for the MatrixUtils class.
org.apache.commons.math4.linear.MatrixUtilsTest.checkIdentityFieldMatrix	(	FieldMatrix	): Verifies that the matrix is an identity matrix
org.apache.commons.math4.linear.MatrixUtilsTest.checkIdentityMatrix	(	RealMatrix	): Verifies that the matrix is an identity matrix
org.apache.commons.math4.linear.MatrixUtilsTest.testBlockInverse	(	): This test should probably be replaced by one that could show whether this algorithm can sometimes perform better (precision- or performance-wise) than the direct inversion of the whole matrix.
org.apache.commons.math4.linear.NonPositiveDefiniteMatrixException: Exception to be thrown when a positive definite matrix is expected.
org.apache.commons.math4.linear.NonPositiveDefiniteMatrixException.NonPositiveDefiniteMatrixException	(	double	int	double	): Construct an exception.
org.apache.commons.math4.linear.NonPositiveDefiniteMatrixException.getColumn	(	): 
org.apache.commons.math4.linear.NonPositiveDefiniteMatrixException.getRow	(	): 
org.apache.commons.math4.linear.NonPositiveDefiniteMatrixException.getThreshold	(	): 
org.apache.commons.math4.linear.NonPositiveDefiniteOperatorException: Exception to be thrown when a symmetric, definite positive RealLinearOperator is expected. Since the coefficients of the matrix are not accessible, the most general definition is used to check that A is not positive definite, i.e. there exists x such that x' A x <= 0. In the terminology of this exception, A is the "offending" linear operator and x the "offending" vector.
org.apache.commons.math4.linear.NonPositiveDefiniteOperatorException.NonPositiveDefiniteOperatorException	(	): Creates a new instance of this class. 
org.apache.commons.math4.linear.NonSelfAdjointOperatorException: Exception to be thrown when a self-adjoint RealLinearOperator is expected. Since the coefficients of the matrix are not accessible, the most general definition is used to check that A is not self-adjoint, i.e. there exist x and y such as | x' A y - y' A x | >= eps, where eps is a user-specified tolerance, and x' denotes the transpose of x. In the terminology of this exception, A is the "offending" linear operator, x and y are the first and second "offending" vectors, respectively.
org.apache.commons.math4.linear.NonSelfAdjointOperatorException.NonSelfAdjointOperatorException	(	): Creates a new instance of this class. 
org.apache.commons.math4.linear.NonSquareMatrixException: Exception to be thrown when a square matrix is expected.
org.apache.commons.math4.linear.NonSquareMatrixException.NonSquareMatrixException	(	int	int	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.linear.NonSquareOperatorException: Exception to be thrown when a square linear operator is expected.
org.apache.commons.math4.linear.NonSquareOperatorException.NonSquareOperatorException	(	int	int	): Construct an exception from the mismatched dimensions.
org.apache.commons.math4.linear.NonSymmetricMatrixException: Exception to be thrown when a symmetric matrix is expected.
org.apache.commons.math4.linear.NonSymmetricMatrixException.NonSymmetricMatrixException	(	int	int	double	): Construct an exception.
org.apache.commons.math4.linear.NonSymmetricMatrixException.getColumn	(	): 
org.apache.commons.math4.linear.NonSymmetricMatrixException.getRow	(	): 
org.apache.commons.math4.linear.NonSymmetricMatrixException.getThreshold	(	): 
org.apache.commons.math4.linear.OpenMapRealMatrix: Sparse matrix implementation based on an open addressed map.  Caveat: This implementation assumes that, for any x, the equality x * 0d == 0d holds. But it is is not true for NaN. Moreover, zero entries will lose their sign. Some operations (that involve NaN and/or infinities) may thus give incorrect results. 
org.apache.commons.math4.linear.OpenMapRealMatrix.OpenMapRealMatrix	(	OpenMapRealMatrix	): Build a matrix by copying another one.
org.apache.commons.math4.linear.OpenMapRealMatrix.OpenMapRealMatrix	(	int	int	): Build a sparse matrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.OpenMapRealMatrix.add	(	OpenMapRealMatrix	): Compute the sum of this matrix and m.
org.apache.commons.math4.linear.OpenMapRealMatrix.addToEntry	(	int	int	double	): Adds (in place) the specified value to the specified entry of this matrix. Row and column indices start at 0.  
org.apache.commons.math4.linear.OpenMapRealMatrix.computeKey	(	int	int	): Compute the key to access a matrix element
org.apache.commons.math4.linear.OpenMapRealMatrix.copy	(	): Returns a (deep) copy of this.  
org.apache.commons.math4.linear.OpenMapRealMatrix.createMatrix	(	int	int	): Create a new RealMatrix of the same type as the instance with the supplied row and column dimensions. 
org.apache.commons.math4.linear.OpenMapRealMatrix.getColumnDimension	(	): Returns the number of columns of this matrix. 
org.apache.commons.math4.linear.OpenMapRealMatrix.getEntry	(	int	int	): Get the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.OpenMapRealMatrix.getRowDimension	(	): Returns the number of rows of this matrix. 
org.apache.commons.math4.linear.OpenMapRealMatrix.multiply	(	OpenMapRealMatrix	): Postmultiply this matrix by m.
org.apache.commons.math4.linear.OpenMapRealMatrix.multiply	(	RealMatrix	): Returns the result of postmultiplying this by m. 
org.apache.commons.math4.linear.OpenMapRealMatrix.multiplyEntry	(	int	int	double	): Multiplies (in place) the specified entry of this matrix by the specified value. Row and column indices start at 0.  
org.apache.commons.math4.linear.OpenMapRealMatrix.setEntry	(	int	int	double	): Set the entry in the specified row and column. Row and column indices start at 0.  
org.apache.commons.math4.linear.OpenMapRealMatrix.subtract	(	OpenMapRealMatrix	): Subtract m from this matrix.
org.apache.commons.math4.linear.OpenMapRealMatrix.subtract	(	RealMatrix	): Returns this minus m.  
org.apache.commons.math4.linear.OpenMapRealVector: This class implements the RealVector interface with a OpenIntToDoubleHashMap backing store.  Caveat: This implementation assumes that, for any x, the equality x * 0d == 0d holds. But it is is not true for NaN. Moreover, zero entries will lose their sign. Some operations (that involve NaN and/or infinities) may thus give incorrect results, like multiplications, divisions or functions mapping. 
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapEntry: Implementation of Entry optimized for OpenMap. This implementation does not allow arbitrary calls to setIndex since the order in which entries are returned is undefined.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapEntry.OpenMapEntry	(	Iterator	): Build an entry from an iterator point to an element.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapEntry.getIndex	(	): Get the index of the entry. 
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapEntry.getValue	(	): Get the value of the entry. 
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapEntry.setValue	(	double	): Set the value of the entry. 
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	): Build a 0-length vector. Zero-length vectors may be used to initialized construction of vectors by data gathering. We start with zero-length and use either the OpenMapRealVector() constructor or one of the append method (append(), append()) to gather data into this vector.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	Double[]	): Create from an array. Only non-zero entries will be stored.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	Double[]	double	): Create from an array. Only non-zero entries will be stored.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	OpenMapRealVector	): Copy constructor.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	OpenMapRealVector	int	): Build a resized vector, for use with append.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	RealVector	): Generic copy constructor.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	double[]	): Create from an array. Only non-zero entries will be stored.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	double[]	double	): Create from an array, specifying zero tolerance. Only non-zero entries will be stored.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	int	): Construct a vector of zeroes.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	int	double	): Construct a vector of zeroes, specifying zero tolerance.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	int	int	): Build a vector with known the sparseness (for advanced use only).
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapRealVector	(	int	int	double	): Build a vector with known the sparseness and zero tolerance setting (for advanced use only).
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapSparseIterator: Iterator class to do iteration over just the non-zero elements. This implementation is fail-fast, so cannot be used to modify any zero element.
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapSparseIterator.OpenMapSparseIterator	(	): Simple constructor. 
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapSparseIterator.hasNext	(	):  
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapSparseIterator.next	(	):  
org.apache.commons.math4.linear.OpenMapRealVector.OpenMapSparseIterator.remove	(	):  
org.apache.commons.math4.linear.OpenMapRealVector.add	(	OpenMapRealVector	): Optimized method to add two OpenMapRealVectors. It copies the larger vector, then iterates over the smaller.
org.apache.commons.math4.linear.OpenMapRealVector.add	(	RealVector	): Compute the sum of this vector and v. Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.OpenMapRealVector.append	(	OpenMapRealVector	): Optimized method to append a OpenMapRealVector.
org.apache.commons.math4.linear.OpenMapRealVector.append	(	RealVector	): Construct a new vector by appending a vector to this vector. 
org.apache.commons.math4.linear.OpenMapRealVector.append	(	double	): Construct a new vector by appending a double to this vector. 
org.apache.commons.math4.linear.OpenMapRealVector.copy	(	): Returns a (deep) copy of this vector.
org.apache.commons.math4.linear.OpenMapRealVector.ebeDivide	(	RealVector	): Element-by-element division. 
org.apache.commons.math4.linear.OpenMapRealVector.ebeMultiply	(	RealVector	): Element-by-element multiplication. 
org.apache.commons.math4.linear.OpenMapRealVector.equals	(	Object	):  Test for the equality of two real vectors. If all coordinates of two real vectors are exactly the same, and none are NaN, the two real vectors are considered to be equal. NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the real vector are equal to NaN, the real vector is equal to a vector with all NaN coordinates.   This method must be overriden by concrete subclasses of RealVector (the current implementation throws an exception).  Implementation Note: This performs an exact comparison, and as a result it is possible for a.subtract(b} to be the zero vector, while a.equals(b) == false.
org.apache.commons.math4.linear.OpenMapRealVector.getDimension	(	): Returns the size of the vector. 
org.apache.commons.math4.linear.OpenMapRealVector.getDistance	(	OpenMapRealVector	): Optimized method to compute distance.
org.apache.commons.math4.linear.OpenMapRealVector.getDistance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with the L2 norm, i.e. the square root of the sum of element differences, or Euclidean distance. 
org.apache.commons.math4.linear.OpenMapRealVector.getEntries	(	): Get the entries of this instance.
org.apache.commons.math4.linear.OpenMapRealVector.getEntry	(	int	): Return the entry at the specified index. 
org.apache.commons.math4.linear.OpenMapRealVector.getL1Distance	(	OpenMapRealVector	): Distance between two vectors. This method computes the distance consistent with L1 norm, i.e. the sum of the absolute values of elements differences.
org.apache.commons.math4.linear.OpenMapRealVector.getL1Distance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with L1 norm, i.e. the sum of the absolute values of the elements differences. 
org.apache.commons.math4.linear.OpenMapRealVector.getLInfDistance	(	OpenMapRealVector	): Optimized method to compute LInfDistance.
org.apache.commons.math4.linear.OpenMapRealVector.getLInfDistance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with L∞ norm, i.e. the max of the absolute values of element differences. 
org.apache.commons.math4.linear.OpenMapRealVector.getSparsity	(	): 
org.apache.commons.math4.linear.OpenMapRealVector.getSubVector	(	int	int	): Get a subvector from consecutive elements. 
org.apache.commons.math4.linear.OpenMapRealVector.hashCode	(	): . This method must be overriden by concrete subclasses of RealVector (current implementation throws an exception). Implementation Note: This works on exact values, and as a result it is possible for a.subtract(b) to be the zero vector, while a.hashCode() != b.hashCode().
org.apache.commons.math4.linear.OpenMapRealVector.isDefaultValue	(	double	): Determine if this value is within epsilon of zero.
org.apache.commons.math4.linear.OpenMapRealVector.isInfinite	(	): Check whether any coordinate of this vector is infinite and none are NaN. 
org.apache.commons.math4.linear.OpenMapRealVector.isNaN	(	): Check whether any coordinate of this vector is NaN. 
org.apache.commons.math4.linear.OpenMapRealVector.mapAdd	(	double	): Add a value to each entry. Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.OpenMapRealVector.mapAddToSelf	(	double	): Add a value to each entry. The instance is changed in-place. 
org.apache.commons.math4.linear.OpenMapRealVector.set	(	double	): Set all elements to a single value. 
org.apache.commons.math4.linear.OpenMapRealVector.setEntry	(	int	double	): Set a single element. 
org.apache.commons.math4.linear.OpenMapRealVector.setSubVector	(	int	RealVector	): Set a sequence of consecutive elements. 
org.apache.commons.math4.linear.OpenMapRealVector.sparseIterator	(	): Create a sparse iterator over the vector, which may omit some entries. The ommitted entries are either exact zeroes (for dense implementations) or are the entries which are not stored (for real sparse vectors). No guarantees are made about order of iteration. Note: derived classes are required to return an Iterator that returns non-null Entry objects as long as hasNext() returns true. 
org.apache.commons.math4.linear.OpenMapRealVector.subtract	(	OpenMapRealVector	): Optimized method to subtract OpenMapRealVectors.
org.apache.commons.math4.linear.OpenMapRealVector.subtract	(	RealVector	): Subtract v from this vector. Returns a new vector. Does not change instance data. 
org.apache.commons.math4.linear.OpenMapRealVector.toArray	(	): Convert the vector to an array of doubles. The array is independent from this vector data: the elements are copied. 
org.apache.commons.math4.linear.OpenMapRealVector.unitVector	(	): Creates a unit vector pointing in the direction of this vector. The instance is not changed by this method. 
org.apache.commons.math4.linear.OpenMapRealVector.unitize	(	): Converts this vector into a unit vector. The instance itself is changed by this method. 
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver:  This abstract class defines preconditioned iterative solvers. When A is ill-conditioned, instead of solving system A · x = b directly, it is preferable to solve either  (M · A) · x = M · b  (left preconditioning), or  (A · M) · y = b,     followed by M · y = x  (right preconditioning), where M approximates in some way A-1, while matrix-vector products of the type M · y remain comparatively easy to compute. In this library, M (not M-1!) is called the preconditionner.  Concrete implementations of this abstract class must be provided with the preconditioner M, as a RealLinearOperator. 
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.PreconditionedIterativeLinearSolver	(	IterationManager	): Creates a new instance of this class, with custom iteration manager.
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.PreconditionedIterativeLinearSolver	(	int	): Creates a new instance of this class, with default iteration manager.
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.checkParameters	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	): Performs all dimension checks on the parameters of solve() and solveInPlace(), and throws an exception if one of the checks fails.
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.solve	(	RealLinearOperator	RealLinearOperator	RealVector	): Returns an estimate of the solution to the linear system A · x = b.
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.solve	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b.
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.solve	(	RealLinearOperator	RealVector	): Returns an estimate of the solution to the linear system A · x = b. 
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.solve	(	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. 
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.solveInPlace	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. The solution is computed in-place (initial guess is modified).
org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver.solveInPlace	(	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. The solution is computed in-place (initial guess is modified). 
org.apache.commons.math4.linear.QRDecomposition: Calculates the QR-decomposition of a matrix. The QR-decomposition of a matrix A consists of two matrices Q and R that satisfy: A = QR, Q is orthogonal (QTQ = I), and R is upper triangular. If A is m×n, Q is m×m and R m×n. This class compute the decomposition using Householder reflectors. For efficiency purposes, the decomposition in packed form is transposed. This allows inner loop to iterate inside rows, which is much more cache-efficient in Java. This class is based on the class with similar name from the JAMA library, with the following changes:  a getQT() method has been added, the solve and isFullRank methods have been replaced by a getSolver() method and the equivalent methods provided by the returned DecompositionSolver. 
org.apache.commons.math4.linear.QRDecomposition.QRDecomposition	(	RealMatrix	): Calculates the QR-decomposition of the given matrix. The singularity threshold defaults to zero.
org.apache.commons.math4.linear.QRDecomposition.QRDecomposition	(	RealMatrix	double	): Calculates the QR-decomposition of the given matrix.
org.apache.commons.math4.linear.QRDecomposition.Solver: Specialized solver. 
org.apache.commons.math4.linear.QRDecomposition.Solver.Solver	(	double[][]	double[]	double	): Build a solver from decomposed matrix.
org.apache.commons.math4.linear.QRDecomposition.Solver.checkSingular	(	double[]	double	boolean	): Check singularity.
org.apache.commons.math4.linear.QRDecomposition.Solver.getInverse	(	): Get the pseudo-inverse of the decomposed matrix.  This is equal to the inverse of the decomposed matrix, if such an inverse exists.  If no such inverse exists, then the result has properties that resemble that of an inverse.  In particular, in this case, if the decomposed matrix is A, then the system of equations \( A x = b \) may have no solutions, or many. If it has no solutions, then the pseudo-inverse \( A^+ \) gives the "closest" solution \( z = A^+ b \), meaning \( \left \| A z - b \right \|_2 \) is minimized. If there are many solutions, then \( z = A^+ b \) is the smallest solution, meaning \( \left \| z \right \|_2 \) is minimized.  Note however that some decompositions cannot compute a pseudo-inverse for all matrices. For example, the LUDecomposition is not defined for non-square matrices to begin with. The QRDecomposition can operate on non-square matrices, but will throw SingularMatrixException if the decomposed matrix is singular. Refer to the javadoc of specific decomposition implementations for more details.
org.apache.commons.math4.linear.QRDecomposition.Solver.isNonSingular	(	): Check if the decomposed matrix is non-singular. 
org.apache.commons.math4.linear.QRDecomposition.Solver.solve	(	RealMatrix	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.QRDecomposition.Solver.solve	(	RealVector	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.QRDecomposition.decompose	(	double[][]	): Decompose matrix.
org.apache.commons.math4.linear.QRDecomposition.getH	(	): Returns the Householder reflector vectors. H is a lower trapezoidal matrix whose columns represent each successive Householder reflector vector. This matrix is used to compute Q.
org.apache.commons.math4.linear.QRDecomposition.getQ	(	): Returns the matrix Q of the decomposition. Q is an orthogonal matrix
org.apache.commons.math4.linear.QRDecomposition.getQT	(	): Returns the transpose of the matrix Q of the decomposition. Q is an orthogonal matrix
org.apache.commons.math4.linear.QRDecomposition.getR	(	): Returns the matrix R of the decomposition. R is an upper-triangular matrix
org.apache.commons.math4.linear.QRDecomposition.getSolver	(	): Get a solver for finding the A × X = B solution in least square sense.  Least Square sense means a solver can be computed for an overdetermined system, (i.e. a system with more equations than unknowns, which corresponds to a tall A matrix with more rows than columns). In any case, if the matrix is singular within the tolerance set at QRDecomposition() construction, an error will be triggered when the solve() method will be called. 
org.apache.commons.math4.linear.QRDecomposition.performHouseholderReflection	(	int	double[][]	): Perform Householder reflection for a minor A(minor, minor) of A.
org.apache.commons.math4.linear.QRDecompositionTest.testAEqualQR	(	): test A = QR 
org.apache.commons.math4.linear.QRDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.QRDecompositionTest.testHTrapezoidal	(	): test that H is trapezoidal 
org.apache.commons.math4.linear.QRDecompositionTest.testMatricesValues	(	): test matrices values 
org.apache.commons.math4.linear.QRDecompositionTest.testQOrthogonal	(	): test the orthogonality of Q 
org.apache.commons.math4.linear.QRDecompositionTest.testRUpperTriangular	(	): test that R is upper triangular 
org.apache.commons.math4.linear.QRSolverTest.testRank	(	): test rank 
org.apache.commons.math4.linear.QRSolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.QRSolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.QRSolverTest.testSolveRankErrors	(	): test solve rank errors 
org.apache.commons.math4.linear.RRQRDecomposition: Calculates the rank-revealing QR-decomposition of a matrix, with column pivoting. The rank-revealing QR-decomposition of a matrix A consists of three matrices Q, R and P such that AP=QR. Q is orthogonal (QTQ = I), and R is upper triangular. If A is m×n, Q is m×m and R is m×n and P is n×n. QR decomposition with column pivoting produces a rank-revealing QR decomposition and the getRank() method may be used to return the rank of the input matrix A. This class compute the decomposition using Householder reflectors. For efficiency purposes, the decomposition in packed form is transposed. This allows inner loop to iterate inside rows, which is much more cache-efficient in Java. This class is based on the class with similar name from the JAMA library, with the following changes:  a getQT() method has been added, the solve and isFullRank methods have been replaced by a getSolver() method and the equivalent methods provided by the returned DecompositionSolver. 
org.apache.commons.math4.linear.RRQRDecomposition.RRQRDecomposition	(	RealMatrix	): Calculates the QR-decomposition of the given matrix. The singularity threshold defaults to zero.
org.apache.commons.math4.linear.RRQRDecomposition.RRQRDecomposition	(	RealMatrix	double	): Calculates the QR-decomposition of the given matrix.
org.apache.commons.math4.linear.RRQRDecomposition.Solver: Specialized solver. 
org.apache.commons.math4.linear.RRQRDecomposition.Solver.Solver	(	DecompositionSolver	RealMatrix	): Build a solver from decomposed matrix.
org.apache.commons.math4.linear.RRQRDecomposition.Solver.getInverse	(	): Get the pseudo-inverse of the decomposed matrix.  This is equal to the inverse of the decomposed matrix, if such an inverse exists.  If no such inverse exists, then the result has properties that resemble that of an inverse.  In particular, in this case, if the decomposed matrix is A, then the system of equations \( A x = b \) may have no solutions, or many. If it has no solutions, then the pseudo-inverse \( A^+ \) gives the "closest" solution \( z = A^+ b \), meaning \( \left \| A z - b \right \|_2 \) is minimized. If there are many solutions, then \( z = A^+ b \) is the smallest solution, meaning \( \left \| z \right \|_2 \) is minimized.  Note however that some decompositions cannot compute a pseudo-inverse for all matrices. For example, the LUDecomposition is not defined for non-square matrices to begin with. The QRDecomposition can operate on non-square matrices, but will throw SingularMatrixException if the decomposed matrix is singular. Refer to the javadoc of specific decomposition implementations for more details.
org.apache.commons.math4.linear.RRQRDecomposition.Solver.isNonSingular	(	): Check if the decomposed matrix is non-singular. 
org.apache.commons.math4.linear.RRQRDecomposition.Solver.solve	(	RealMatrix	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.RRQRDecomposition.Solver.solve	(	RealVector	): Solve the linear equation A × X = B for matrices A.  The A matrix is implicit, it is provided by the underlying decomposition algorithm. 
org.apache.commons.math4.linear.RRQRDecomposition.decompose	(	double[][]	): Decompose matrix.
org.apache.commons.math4.linear.RRQRDecomposition.getP	(	): Returns the pivot matrix, P, used in the QR Decomposition of matrix A such that AP = QR. If no pivoting is used in this decomposition then P is equal to the identity matrix.
org.apache.commons.math4.linear.RRQRDecomposition.getRank	(	double	): Return the effective numerical matrix rank. The effective numerical rank is the number of non-negligible singular values. This implementation looks at Frobenius norms of the sequence of bottom right submatrices. When a large fall in norm is seen, the rank is returned. The drop is computed as:  (thisNorm/lastNorm) * rNorm < dropThreshold   where thisNorm is the Frobenius norm of the current submatrix, lastNorm is the Frobenius norm of the previous submatrix, rNorm is is the Frobenius norm of the complete matrix 
org.apache.commons.math4.linear.RRQRDecomposition.getSolver	(	): Get a solver for finding the A × X = B solution in least square sense.  Least Square sense means a solver can be computed for an overdetermined system, (i.e. a system with more equations than unknowns, which corresponds to a tall A matrix with more rows than columns). In any case, if the matrix is singular within the tolerance set at RRQRDecomposition() construction, an error will be triggered when the solve() method will be called. 
org.apache.commons.math4.linear.RRQRDecomposition.performHouseholderReflection	(	int	double[][]	): Perform Householder reflection for a minor A(minor, minor) of A.
org.apache.commons.math4.linear.RRQRDecompositionTest.testAPEqualQR	(	): test AP = QR 
org.apache.commons.math4.linear.RRQRDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.RRQRDecompositionTest.testHTrapezoidal	(	): test that H is trapezoidal 
org.apache.commons.math4.linear.RRQRDecompositionTest.testQOrthogonal	(	): test the orthogonality of Q 
org.apache.commons.math4.linear.RRQRDecompositionTest.testRUpperTriangular	(	): test that R is upper triangular 
org.apache.commons.math4.linear.RRQRDecompositionTest.testRank	(	): test the rank is returned correctly 
org.apache.commons.math4.linear.RRQRSolverTest.testRank	(	): test rank 
org.apache.commons.math4.linear.RRQRSolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.RRQRSolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.RRQRSolverTest.testSolveRankErrors	(	): test solve rank errors 
org.apache.commons.math4.linear.RealLinearOperator: This class defines a linear operator operating on real (double) vector spaces. No direct access to the coefficients of the underlying matrix is provided. The motivation for such an interface is well stated by Barrett et al. (1994):  We restrict ourselves to iterative methods, which work by repeatedly improving an approximate solution until it is accurate enough. These methods access the coefficient matrix A of the linear system only via the matrix-vector product y = A · x (and perhaps z = AT · x). Thus the user need only supply a subroutine for computing y (and perhaps z) given x, which permits full exploitation of the sparsity or other special structure of A.    Barret et al. (1994)  R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. M. Donato, J. Dongarra, V. Eijkhout, R. Pozo, C. Romine and H. Van der Vorst, Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods, SIAM  
org.apache.commons.math4.linear.RealLinearOperator.getColumnDimension	(	): Returns the dimension of the domain of this operator.
org.apache.commons.math4.linear.RealLinearOperator.getRowDimension	(	): Returns the dimension of the codomain of this operator.
org.apache.commons.math4.linear.RealLinearOperator.isTransposable	(	): Returns true if this operator supports operateTranspose(). If true is returned, operateTranspose() should not throw UnsupportedOperationException. The default implementation returns false.
org.apache.commons.math4.linear.RealLinearOperator.operate	(	RealVector	): Returns the result of multiplying this by the vector x.
org.apache.commons.math4.linear.RealLinearOperator.operateTranspose	(	RealVector	): Returns the result of multiplying the transpose of this operator by the vector x (optional operation). The default implementation throws an UnsupportedOperationException. Users overriding this method must also override isTransposable().
org.apache.commons.math4.linear.RealMatrix: Interface defining a real-valued matrix with basic algebraic operations.  Matrix element indexing is 0-based -- e.g., getEntry(0, 0) returns the element in the first row, first column of the matrix.
org.apache.commons.math4.linear.RealMatrix.add	(	RealMatrix	): Returns the sum of this and m.
org.apache.commons.math4.linear.RealMatrix.addToEntry	(	int	int	double	): Adds (in place) the specified value to the specified entry of this matrix. Row and column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.copy	(	): Returns a (deep) copy of this.
org.apache.commons.math4.linear.RealMatrix.copySubMatrix	(	int	int	int	int	double[][]	): Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.RealMatrix.copySubMatrix	(	int[]	int[]	double[][]	): Copy a submatrix. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.RealMatrix.createMatrix	(	int	int	): Create a new RealMatrix of the same type as the instance with the supplied row and column dimensions.
org.apache.commons.math4.linear.RealMatrix.getColumn	(	int	): Get the entries at the given column index as an array. Column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getColumnMatrix	(	int	): Get the entries at the given column index as a column matrix. Column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getColumnVector	(	int	): Get the entries at the given column index as a vector. Column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getData	(	): Returns matrix entries as a two-dimensional array.
org.apache.commons.math4.linear.RealMatrix.getEntry	(	int	int	): Get the entry in the specified row and column. Row and column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getFrobeniusNorm	(	): Returns the  Frobenius norm of the matrix.
org.apache.commons.math4.linear.RealMatrix.getNorm	(	): Returns the  maximum absolute row sum norm of the matrix.
org.apache.commons.math4.linear.RealMatrix.getRow	(	int	): Get the entries at the given row index. Row indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getRowMatrix	(	int	): Get the entries at the given row index as a row matrix. Row indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getRowVector	(	int	): Returns the entries in row number row as a vector. Row indices start at 0.
org.apache.commons.math4.linear.RealMatrix.getSubMatrix	(	int	int	int	int	): Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.RealMatrix.getSubMatrix	(	int[]	int[]	): Gets a submatrix. Rows and columns are indicated counting from 0 to n-1.
org.apache.commons.math4.linear.RealMatrix.getTrace	(	): Returns the  trace of the matrix (the sum of the elements on the main diagonal).
org.apache.commons.math4.linear.RealMatrix.multiply	(	RealMatrix	): Returns the result of postmultiplying this by m.
org.apache.commons.math4.linear.RealMatrix.multiplyEntry	(	int	int	double	): Multiplies (in place) the specified entry of this matrix by the specified value. Row and column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.operate	(	RealVector	): Returns the result of multiplying this by the vector v.
org.apache.commons.math4.linear.RealMatrix.operate	(	double[]	): Returns the result of multiplying this by the vector v.
org.apache.commons.math4.linear.RealMatrix.power	(	int	): Returns the result of multiplying this with itself p times. Depending on the underlying storage, instability for high powers might occur.
org.apache.commons.math4.linear.RealMatrix.preMultiply	(	RealMatrix	): Returns the result of premultiplying this by m.
org.apache.commons.math4.linear.RealMatrix.preMultiply	(	RealVector	): Returns the (row) vector result of premultiplying this by the vector v.
org.apache.commons.math4.linear.RealMatrix.preMultiply	(	double[]	): Returns the (row) vector result of premultiplying this by the vector v.
org.apache.commons.math4.linear.RealMatrix.scalarAdd	(	double	): Returns the result of adding d to each entry of this.
org.apache.commons.math4.linear.RealMatrix.scalarMultiply	(	double	): Returns the result of multiplying each entry of this by d.
org.apache.commons.math4.linear.RealMatrix.setColumn	(	int	double[]	): Sets the specified column of this matrix to the entries of the specified array. Column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setColumnMatrix	(	int	RealMatrix	): Sets the specified column of this matrix to the entries of the specified column matrix. Column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setColumnVector	(	int	RealVector	): Sets the specified column of this matrix to the entries of the specified vector. Column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setEntry	(	int	int	double	): Set the entry in the specified row and column. Row and column indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setRow	(	int	double[]	): Sets the specified row of this matrix to the entries of the specified array. Row indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setRowMatrix	(	int	RealMatrix	): Sets the specified row of this matrix to the entries of the specified row matrix. Row indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setRowVector	(	int	RealVector	): Sets the specified row of this matrix to the entries of the specified vector. Row indices start at 0.
org.apache.commons.math4.linear.RealMatrix.setSubMatrix	(	double[][]	int	int	): Replace the submatrix starting at row, column using data in the input subMatrix array. Indexes are 0-based.  Example: Starting with  1 2 3 4 5 6 7 8 9 0 1 2  and subMatrix = {{3, 4} {5,6}}, invoking setSubMatrix(subMatrix,1,1)) will result in  1 2 3 4 5 3 4 8 9 5 6 2 
org.apache.commons.math4.linear.RealMatrix.subtract	(	RealMatrix	): Returns this minus m.
org.apache.commons.math4.linear.RealMatrix.transpose	(	): Returns the transpose of this matrix.
org.apache.commons.math4.linear.RealMatrix.walkInColumnOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.RealMatrix.walkInColumnOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.RealMatrix.walkInColumnOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.RealMatrix.walkInColumnOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in column order. Column order starts at upper left and iterating through all elements of a column from top to bottom before going to the topmost element of the next column.
org.apache.commons.math4.linear.RealMatrix.walkInOptimizedOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.RealMatrix.walkInOptimizedOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.RealMatrix.walkInOptimizedOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.RealMatrix.walkInOptimizedOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries using the fastest possible order. The fastest walking order depends on the exact matrix class. It may be different from traditional row or column orders.
org.apache.commons.math4.linear.RealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	): Visit (and possibly change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.RealMatrix.walkInRowOrder	(	RealMatrixChangingVisitor	int	int	int	int	): Visit (and possibly change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.RealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	): Visit (but don't change) all matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.RealMatrix.walkInRowOrder	(	RealMatrixPreservingVisitor	int	int	int	int	): Visit (but don't change) some matrix entries in row order. Row order starts at upper left and iterating through all elements of a row from left to right before going to the leftmost element of the next row.
org.apache.commons.math4.linear.RealMatrixChangingVisitor: Interface defining a visitor for matrix entries.
org.apache.commons.math4.linear.RealMatrixChangingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited.
org.apache.commons.math4.linear.RealMatrixChangingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited.
org.apache.commons.math4.linear.RealMatrixChangingVisitor.visit	(	int	int	double	): Visit one matrix entry.
org.apache.commons.math4.linear.RealMatrixFormat: Formats a nxm matrix in components list format "{{a00,a01, ..., a0m-1},{a10, a11, ..., a1m-1},{...},{ an-10, an-11, ..., an-1m-1}}". The prefix and suffix "{" and "}", the row prefix and suffix "{" and "}", the row separator "," and the column separator "," can be replaced by any user-defined strings. The number format for components can be configured. White space is ignored at parse time, even if it is in the prefix, suffix or separator specifications. So even if the default separator does include a space character that is used at format time, both input string "{{1,1,1}}" and " { { 1 , 1 , 1 } } " will be parsed without error and the same matrix will be returned. In the second case, however, the parse position after parsing will be just after the closing curly brace, i.e. just before the trailing space. Note: the grouping functionality of the used NumberFormat is disabled to prevent problems when parsing (e.g. 1,345.34 would be a valid number but conflicts with the default column separator).
org.apache.commons.math4.linear.RealMatrixFormat.RealMatrixFormat	(	): Create an instance with default settings. The instance uses the default prefix, suffix and row/column separator: "[", "]", ";" and ", " and the default number format for components.
org.apache.commons.math4.linear.RealMatrixFormat.RealMatrixFormat	(	NumberFormat	): Create an instance with a custom number format for components.
org.apache.commons.math4.linear.RealMatrixFormat.RealMatrixFormat	(	String	String	String	String	String	String	): Create an instance with custom prefix, suffix and separator.
org.apache.commons.math4.linear.RealMatrixFormat.RealMatrixFormat	(	String	String	String	String	String	String	NumberFormat	): Create an instance with custom prefix, suffix, separator and format for components.
org.apache.commons.math4.linear.RealMatrixFormat.format	(	RealMatrix	): This method calls format().
org.apache.commons.math4.linear.RealMatrixFormat.format	(	RealMatrix	StringBuffer	FieldPosition	): Formats a RealMatrix object to produce a string.
org.apache.commons.math4.linear.RealMatrixFormat.getAvailableLocales	(	): Get the set of locales for which real vectors formats are available. This is the same set as the NumberFormat set.
org.apache.commons.math4.linear.RealMatrixFormat.getColumnSeparator	(	): Get the format separator between components.
org.apache.commons.math4.linear.RealMatrixFormat.getFormat	(	): Get the components format.
org.apache.commons.math4.linear.RealMatrixFormat.getInstance	(	): Returns the default real vector format for the current locale.
org.apache.commons.math4.linear.RealMatrixFormat.getInstance	(	Locale	): Returns the default real vector format for the given locale.
org.apache.commons.math4.linear.RealMatrixFormat.getPrefix	(	): Get the format prefix.
org.apache.commons.math4.linear.RealMatrixFormat.getRowPrefix	(	): Get the format prefix.
org.apache.commons.math4.linear.RealMatrixFormat.getRowSeparator	(	): Get the format separator between rows of the matrix.
org.apache.commons.math4.linear.RealMatrixFormat.getRowSuffix	(	): Get the format suffix.
org.apache.commons.math4.linear.RealMatrixFormat.getSuffix	(	): Get the format suffix.
org.apache.commons.math4.linear.RealMatrixFormat.parse	(	String	): Parse a string to produce a RealMatrix object.
org.apache.commons.math4.linear.RealMatrixFormat.parse	(	String	ParsePosition	): Parse a string to produce a RealMatrix object.
org.apache.commons.math4.linear.RealMatrixPreservingVisitor: Interface defining a visitor for matrix entries.
org.apache.commons.math4.linear.RealMatrixPreservingVisitor.end	(	): End visiting a matrix. This method is called once after all entries of the matrix have been visited.
org.apache.commons.math4.linear.RealMatrixPreservingVisitor.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited.
org.apache.commons.math4.linear.RealMatrixPreservingVisitor.visit	(	int	int	double	): Visit one matrix entry.
org.apache.commons.math4.linear.RealVector: Class defining a real-valued vector with basic algebraic operations.  vector element indexing is 0-based -- e.g., getEntry(0) returns the first element of the vector.   The code map and mapToSelf methods operate on vectors element-wise, i.e. they perform the same operation (adding a scalar, applying a function ...) on each element in turn. The map versions create a new vector to hold the result and do not change the instance. The mapToSelf version uses the instance itself to store the results, so the instance is changed by this method. In all cases, the result vector is returned by the methods, allowing the fluent API style, like this:   RealVector result = v.mapAddToSelf(3.4).mapToSelf(new Tan()).mapToSelf(new Power(2.3)); 
org.apache.commons.math4.linear.RealVector.Entry: An entry in the vector. 
org.apache.commons.math4.linear.RealVector.Entry.Entry	(	): Simple constructor. 
org.apache.commons.math4.linear.RealVector.Entry.getIndex	(	): Get the index of the entry.
org.apache.commons.math4.linear.RealVector.Entry.getValue	(	): Get the value of the entry.
org.apache.commons.math4.linear.RealVector.Entry.setIndex	(	int	): Set the index of the entry.
org.apache.commons.math4.linear.RealVector.Entry.setValue	(	double	): Set the value of the entry.
org.apache.commons.math4.linear.RealVector.SparseEntryIterator: This class should rarely be used, but is here to provide a default implementation of sparseIterator(), which is implemented by walking over the entries, skipping those that are zero. Concrete subclasses which are SparseVector implementations should make their own sparse iterator, rather than using this one. This implementation might be useful for ArrayRealVector, when expensive operations which preserve the default value are to be done on the entries, and the fraction of non-default values is small (i.e. someone took a SparseVector, and passed it into the copy-constructor of ArrayRealVector)
org.apache.commons.math4.linear.RealVector.SparseEntryIterator.SparseEntryIterator	(	): Simple constructor. 
org.apache.commons.math4.linear.RealVector.SparseEntryIterator.advance	(	Entry	): Advance an entry up to the next nonzero one.
org.apache.commons.math4.linear.RealVector.SparseEntryIterator.hasNext	(	):  
org.apache.commons.math4.linear.RealVector.SparseEntryIterator.next	(	):  
org.apache.commons.math4.linear.RealVector.SparseEntryIterator.remove	(	): 
org.apache.commons.math4.linear.RealVector.add	(	RealVector	): Compute the sum of this vector and v. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.addToEntry	(	int	double	): Change an entry at the specified index.
org.apache.commons.math4.linear.RealVector.append	(	RealVector	): Construct a new vector by appending a vector to this vector.
org.apache.commons.math4.linear.RealVector.append	(	double	): Construct a new vector by appending a double to this vector.
org.apache.commons.math4.linear.RealVector.checkIndex	(	int	): Check if an index is valid.
org.apache.commons.math4.linear.RealVector.checkIndices	(	int	int	): Checks that the indices of a subvector are valid.
org.apache.commons.math4.linear.RealVector.checkVectorDimensions	(	RealVector	): Check if instance and specified vectors have the same dimension.
org.apache.commons.math4.linear.RealVector.checkVectorDimensions	(	int	): Check if instance dimension is equal to some expected value.
org.apache.commons.math4.linear.RealVector.combine	(	double	double	RealVector	): Returns a new vector representing a * this + b * y, the linear combination of this and y. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.combineToSelf	(	double	double	RealVector	): Updates this with the linear combination of this and y.
org.apache.commons.math4.linear.RealVector.copy	(	): Returns a (deep) copy of this vector.
org.apache.commons.math4.linear.RealVector.cosine	(	RealVector	): Computes the cosine of the angle between this vector and the argument.
org.apache.commons.math4.linear.RealVector.dotProduct	(	RealVector	): Compute the dot product of this vector with v.
org.apache.commons.math4.linear.RealVector.ebeDivide	(	RealVector	): Element-by-element division.
org.apache.commons.math4.linear.RealVector.ebeMultiply	(	RealVector	): Element-by-element multiplication.
org.apache.commons.math4.linear.RealVector.equals	(	Object	):  Test for the equality of two real vectors. If all coordinates of two real vectors are exactly the same, and none are NaN, the two real vectors are considered to be equal. NaN coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the real vector are equal to NaN, the real vector is equal to a vector with all NaN coordinates.   This method must be overriden by concrete subclasses of RealVector (the current implementation throws an exception). 
org.apache.commons.math4.linear.RealVector.getDimension	(	): Returns the size of the vector.
org.apache.commons.math4.linear.RealVector.getDistance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with the L2 norm, i.e. the square root of the sum of element differences, or Euclidean distance.
org.apache.commons.math4.linear.RealVector.getEntry	(	int	): Return the entry at the specified index.
org.apache.commons.math4.linear.RealVector.getL1Distance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with L1 norm, i.e. the sum of the absolute values of the elements differences.
org.apache.commons.math4.linear.RealVector.getL1Norm	(	): Returns the L1 norm of the vector. The L1 norm is the sum of the absolute values of the elements.
org.apache.commons.math4.linear.RealVector.getLInfDistance	(	RealVector	): Distance between two vectors. This method computes the distance consistent with L∞ norm, i.e. the max of the absolute values of element differences.
org.apache.commons.math4.linear.RealVector.getLInfNorm	(	): Returns the L∞ norm of the vector. The L∞ norm is the max of the absolute values of the elements.
org.apache.commons.math4.linear.RealVector.getMaxIndex	(	): Get the index of the maximum entry.
org.apache.commons.math4.linear.RealVector.getMaxValue	(	): Get the value of the maximum entry.
org.apache.commons.math4.linear.RealVector.getMinIndex	(	): Get the index of the minimum entry.
org.apache.commons.math4.linear.RealVector.getMinValue	(	): Get the value of the minimum entry.
org.apache.commons.math4.linear.RealVector.getNorm	(	): Returns the L2 norm of the vector. The L2 norm is the root of the sum of the squared elements.
org.apache.commons.math4.linear.RealVector.getSubVector	(	int	int	): Get a subvector from consecutive elements.
org.apache.commons.math4.linear.RealVector.hashCode	(	): . This method must be overriden by concrete subclasses of RealVector (current implementation throws an exception).
org.apache.commons.math4.linear.RealVector.isInfinite	(	): Check whether any coordinate of this vector is infinite and none are NaN.
org.apache.commons.math4.linear.RealVector.isNaN	(	): Check whether any coordinate of this vector is NaN.
org.apache.commons.math4.linear.RealVector.iterator	(	): Generic dense iterator. Iteration is in increasing order of the vector index. Note: derived classes are required to return an Iterator that returns non-null Entry objects as long as hasNext() returns true.
org.apache.commons.math4.linear.RealVector.map	(	UnivariateFunction	): Acts as if implemented as:  return copy().mapToSelf(function);  Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.mapAdd	(	double	): Add a value to each entry. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.mapAddToSelf	(	double	): Add a value to each entry. The instance is changed in-place.
org.apache.commons.math4.linear.RealVector.mapDivide	(	double	): Divide each entry by the argument. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.mapDivideToSelf	(	double	): Divide each entry by the argument. The instance is changed in-place.
org.apache.commons.math4.linear.RealVector.mapMultiply	(	double	): Multiply each entry by the argument. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.mapMultiplyToSelf	(	double	): Multiply each entry. The instance is changed in-place.
org.apache.commons.math4.linear.RealVector.mapSubtract	(	double	): Subtract a value from each entry. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.mapSubtractToSelf	(	double	): Subtract a value from each entry. The instance is changed in-place.
org.apache.commons.math4.linear.RealVector.mapToSelf	(	UnivariateFunction	): Acts as if it is implemented as: Entry e = null; for(Iterator it = iterator(); it.hasNext(); e = it.next()) e.setValue(function.value(e.getValue())); } } Entries of this vector are modified in-place by this method.
org.apache.commons.math4.linear.RealVector.outerProduct	(	RealVector	): Compute the outer product.
org.apache.commons.math4.linear.RealVector.projection	(	RealVector	): Find the orthogonal projection of this vector onto another vector.
org.apache.commons.math4.linear.RealVector.set	(	double	): Set all elements to a single value.
org.apache.commons.math4.linear.RealVector.setEntry	(	int	double	): Set a single element.
org.apache.commons.math4.linear.RealVector.setSubVector	(	int	RealVector	): Set a sequence of consecutive elements.
org.apache.commons.math4.linear.RealVector.sparseIterator	(	): Create a sparse iterator over the vector, which may omit some entries. The ommitted entries are either exact zeroes (for dense implementations) or are the entries which are not stored (for real sparse vectors). No guarantees are made about order of iteration. Note: derived classes are required to return an Iterator that returns non-null Entry objects as long as hasNext() returns true.
org.apache.commons.math4.linear.RealVector.subtract	(	RealVector	): Subtract v from this vector. Returns a new vector. Does not change instance data.
org.apache.commons.math4.linear.RealVector.toArray	(	): Convert the vector to an array of doubles. The array is independent from this vector data: the elements are copied.
org.apache.commons.math4.linear.RealVector.unitVector	(	): Creates a unit vector pointing in the direction of this vector. The instance is not changed by this method.
org.apache.commons.math4.linear.RealVector.unitize	(	): Converts this vector into a unit vector. The instance itself is changed by this method.
org.apache.commons.math4.linear.RealVector.unmodifiableRealVector	(	RealVector	): Returns an unmodifiable view of the specified vector. The returned vector has read-only access. An attempt to modify it will result in a MathUnsupportedOperationException. However, the returned vector is not immutable, since any modification of v will also change the returned view. For example, in the following piece of code  RealVector v = new ArrayRealVector(2); RealVector w = RealVector.unmodifiableRealVector(v); v.setEntry(0, 1.2); v.setEntry(1, -3.4);  the changes will be seen in the w view of v.
org.apache.commons.math4.linear.RealVector.walkInDefaultOrder	(	RealVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.RealVector.walkInDefaultOrder	(	RealVectorChangingVisitor	int	int	): Visits (and possibly alters) some entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.RealVector.walkInDefaultOrder	(	RealVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.RealVector.walkInDefaultOrder	(	RealVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.RealVector.walkInOptimizedOrder	(	RealVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.RealVector.walkInOptimizedOrder	(	RealVectorChangingVisitor	int	int	): Visits (and possibly change) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.RealVector.walkInOptimizedOrder	(	RealVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.RealVector.walkInOptimizedOrder	(	RealVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.RealVectorAbstractTest.RealVectorTestImpl: Minimal implementation of the RealVector abstract class, for mixed types unit tests.
org.apache.commons.math4.linear.RealVectorAbstractTest.create	(	double[]	): Creates a new instance of RealVector, with specified entries. The returned vector must be of the type currently tested. It should be noted that some tests assume that no references to the specified double[] are kept in the returned object: if necessary, defensive copy of this array should be made.
org.apache.commons.math4.linear.RealVectorAbstractTest.createAlien	(	double[]	): Creates a new instance of RealVector, with specified entries. The type of the returned vector must be different from the type currently tested. It should be noted that some tests assume that no references to the specified double[] are kept in the returned object: if necessary, defensive copy of this array should be made.
org.apache.commons.math4.linear.RealVectorAbstractTest.getPreferredEntryValue	(	): Returns a preferred value of the entries, to be tested specifically. Some implementations of RealVector (e.g. OpenMapRealVector) do not store specific values of entries. In order to ensure that all tests take into account this specific value, some entries of the vectors to be tested are deliberately set to the value returned by the present method. The default implementation returns 0.0.
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInDefaultOrderChangingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInDefaultOrderChangingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInDefaultOrderChangingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInDefaultOrderPreservingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInDefaultOrderPreservingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInDefaultOrderPreservingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInOptimizedOrderChangingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInOptimizedOrderChangingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInOptimizedOrderChangingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInOptimizedOrderPreservingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInOptimizedOrderPreservingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.RealVectorAbstractTest.testWalkInOptimizedOrderPreservingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.RealVectorChangingVisitor: This interface defines a visitor for the entries of a vector. Visitors implementing this interface may alter the entries of the vector being visited.
org.apache.commons.math4.linear.RealVectorChangingVisitor.end	(	): End visiting a vector. This method is called once, after all entries of the vector have been visited.
org.apache.commons.math4.linear.RealVectorChangingVisitor.start	(	int	int	int	): Start visiting a vector. This method is called once, before any entry of the vector is visited.
org.apache.commons.math4.linear.RealVectorChangingVisitor.visit	(	int	double	): Visit one entry of the vector.
org.apache.commons.math4.linear.RealVectorFormat: Formats a vector in components list format "{v0; v1; ...; vk-1}". The prefix and suffix "{" and "}" and the separator "; " can be replaced by any user-defined strings. The number format for components can be configured. White space is ignored at parse time, even if it is in the prefix, suffix or separator specifications. So even if the default separator does include a space character that is used at format time, both input string "{1;1;1}" and " { 1 ; 1 ; 1 } " will be parsed without error and the same vector will be returned. In the second case, however, the parse position after parsing will be just after the closing curly brace, i.e. just before the trailing space.
org.apache.commons.math4.linear.RealVectorFormat.RealVectorFormat	(	): Create an instance with default settings. The instance uses the default prefix, suffix and separator: "{", "}", and "; " and the default number format for components.
org.apache.commons.math4.linear.RealVectorFormat.RealVectorFormat	(	NumberFormat	): Create an instance with a custom number format for components.
org.apache.commons.math4.linear.RealVectorFormat.RealVectorFormat	(	String	String	String	): Create an instance with custom prefix, suffix and separator.
org.apache.commons.math4.linear.RealVectorFormat.RealVectorFormat	(	String	String	String	NumberFormat	): Create an instance with custom prefix, suffix, separator and format for components.
org.apache.commons.math4.linear.RealVectorFormat.format	(	RealVector	): This method calls format().
org.apache.commons.math4.linear.RealVectorFormat.format	(	RealVector	StringBuffer	FieldPosition	): Formats a RealVector object to produce a string.
org.apache.commons.math4.linear.RealVectorFormat.getAvailableLocales	(	): Get the set of locales for which real vectors formats are available. This is the same set as the NumberFormat set.
org.apache.commons.math4.linear.RealVectorFormat.getFormat	(	): Get the components format.
org.apache.commons.math4.linear.RealVectorFormat.getInstance	(	): Returns the default real vector format for the current locale.
org.apache.commons.math4.linear.RealVectorFormat.getInstance	(	Locale	): Returns the default real vector format for the given locale.
org.apache.commons.math4.linear.RealVectorFormat.getPrefix	(	): Get the format prefix.
org.apache.commons.math4.linear.RealVectorFormat.getSeparator	(	): Get the format separator between components.
org.apache.commons.math4.linear.RealVectorFormat.getSuffix	(	): Get the format suffix.
org.apache.commons.math4.linear.RealVectorFormat.parse	(	String	): Parse a string to produce a RealVector object.
org.apache.commons.math4.linear.RealVectorFormat.parse	(	String	ParsePosition	): Parse a string to produce a RealVector object.
org.apache.commons.math4.linear.RealVectorPreservingVisitor: This interface defines a visitor for the entries of a vector. Visitors implementing this interface do not alter the entries of the vector being visited.
org.apache.commons.math4.linear.RealVectorPreservingVisitor.end	(	): End visiting a vector. This method is called once, after all entries of the vector have been visited.
org.apache.commons.math4.linear.RealVectorPreservingVisitor.start	(	int	int	int	): Start visiting a vector. This method is called once, before any entry of the vector is visited.
org.apache.commons.math4.linear.RealVectorPreservingVisitor.visit	(	int	double	): Visit one entry of the vector.
org.apache.commons.math4.linear.RealVectorTest: Tests for RealVector.
org.apache.commons.math4.linear.RectangularCholeskyDecomposition: Calculates the rectangular Cholesky decomposition of a matrix. The rectangular Cholesky decomposition of a real symmetric positive semidefinite matrix A consists of a rectangular matrix B with the same number of rows such that: A is almost equal to BBT, depending on a user-defined tolerance. In a sense, this is the square root of A. The difference with respect to the regular CholeskyDecomposition is that rows/columns may be permuted (hence the rectangular shape instead of the traditional triangular shape) and there is a threshold to ignore small diagonal elements. This is used for example to generate org.apache.commons.math4.random.CorrelatedRandomVectorGenerator correlated random n-dimensions vectors in a p-dimension subspace (p < n). In other words, it allows generating random vectors from a covariance matrix that is only positive semidefinite, and not positive definite. Rectangular Cholesky decomposition is not suited for solving linear systems, so it does not provide any DecompositionSolver decomposition solver.
org.apache.commons.math4.linear.RectangularCholeskyDecomposition.RectangularCholeskyDecomposition	(	RealMatrix	): Decompose a symmetric positive semidefinite matrix.  Note: this constructor follows the linpack method to detect dependent columns by proceeding with the Cholesky algorithm until a nonpositive diagonal element is encountered.
org.apache.commons.math4.linear.RectangularCholeskyDecomposition.RectangularCholeskyDecomposition	(	RealMatrix	double	): Decompose a symmetric positive semidefinite matrix.
org.apache.commons.math4.linear.RectangularCholeskyDecomposition.getRank	(	): Get the rank of the symmetric positive semidefinite matrix. The r is the number of independent rows in the symmetric positive semidefinite matrix, it is also the number of columns of the rectangular matrix of the decomposition.
org.apache.commons.math4.linear.RectangularCholeskyDecomposition.getRootMatrix	(	): Get the root of the covariance matrix. The root is the rectangular matrix B such that the covariance matrix is equal to B.BT
org.apache.commons.math4.linear.SchurTransformer: Class transforming a general real matrix to Schur form. A m × m matrix A can be written as the product of three matrices: A = P × T × PT with P an orthogonal matrix and T an quasi-triangular matrix. Both P and T are m × m matrices. Transformation to Schur form is often not a goal by itself, but it is an intermediate step in more general decomposition algorithms like EigenDecomposition eigen decomposition. This class is therefore intended for internal use by the library and is not public. As a consequence of this explicitly limited scope, many methods directly returns references to internal arrays, not copies. This class is based on the method hqr2 in class EigenvalueDecomposition from the JAMA library.
org.apache.commons.math4.linear.SchurTransformer.SchurTransformer	(	RealMatrix	): Build the transformation to Schur form of a general real matrix.
org.apache.commons.math4.linear.SchurTransformer.ShiftInfo: Internal data structure holding the current shift information. Contains variable names as present in the original JAMA code.
org.apache.commons.math4.linear.SchurTransformer.computeShift	(	int	int	int	ShiftInfo	): Compute the shift for the current iteration.
org.apache.commons.math4.linear.SchurTransformer.findSmallSubDiagonalElement	(	int	double	): Find the first small sub-diagonal element and returns its index.
org.apache.commons.math4.linear.SchurTransformer.getNorm	(	): Computes the L1 norm of the (quasi-)triangular matrix T.
org.apache.commons.math4.linear.SchurTransformer.getP	(	): Returns the matrix P of the transform. P is an orthogonal matrix, i.e. its inverse is also its transpose.
org.apache.commons.math4.linear.SchurTransformer.getPT	(	): Returns the transpose of the matrix P of the transform. P is an orthogonal matrix, i.e. its inverse is also its transpose.
org.apache.commons.math4.linear.SchurTransformer.getT	(	): Returns the quasi-triangular Schur matrix T of the transform.
org.apache.commons.math4.linear.SchurTransformer.initQRStep	(	int	int	ShiftInfo	double[]	): Initialize the householder vectors for the QR step.
org.apache.commons.math4.linear.SchurTransformer.performDoubleQRStep	(	int	int	int	ShiftInfo	double[]	): Perform a double QR step involving rows l:idx and columns m:n
org.apache.commons.math4.linear.SchurTransformer.transform	(	): Transform original matrix to Schur form.
org.apache.commons.math4.linear.SingularMatrixException: Exception to be thrown when a non-singular matrix is expected.
org.apache.commons.math4.linear.SingularMatrixException.SingularMatrixException	(	): Construct an exception.
org.apache.commons.math4.linear.SingularOperatorException: Exception to be thrown when trying to invert a singular operator.
org.apache.commons.math4.linear.SingularOperatorException.SingularOperatorException	(	): Creates a new instance of this class.
org.apache.commons.math4.linear.SingularValueDecomposition: Calculates the compact Singular Value Decomposition of a matrix.  The Singular Value Decomposition of matrix A is a set of three matrices: U, Σ and V such that A = U × Σ × VT. Let A be a m × n matrix, then U is a m × p orthogonal matrix, Σ is a p × p diagonal matrix with positive or null elements, V is a p × n orthogonal matrix (hence VT is also orthogonal) where p=min(m,n).  This class is similar to the class with similar name from the JAMA library, with the following changes:  the norm2 method which has been renamed as getNorm() , the cond method which has been renamed as getConditionNumber(), the rank method which has been renamed as getRank() , a getUT() method has been added, a getVT() method has been added, a getSolver() method has been added, a getCovariance() method has been added. 
org.apache.commons.math4.linear.SingularValueDecomposition.SingularValueDecomposition	(	RealMatrix	): Calculates the compact Singular Value Decomposition of the given matrix.
org.apache.commons.math4.linear.SingularValueDecomposition.Solver: Specialized solver. 
org.apache.commons.math4.linear.SingularValueDecomposition.Solver.Solver	(	double[]	RealMatrix	RealMatrix	boolean	double	): Build a solver from decomposed matrix.
org.apache.commons.math4.linear.SingularValueDecomposition.Solver.getInverse	(	): Get the pseudo-inverse of the decomposed matrix.
org.apache.commons.math4.linear.SingularValueDecomposition.Solver.isNonSingular	(	): Check if the decomposed matrix is non-singular.
org.apache.commons.math4.linear.SingularValueDecomposition.Solver.solve	(	RealMatrix	): Solve the linear equation A × X = B in least square sense.  The m×n matrix A may not be square, the solution X is such that ||A × X - B|| is minimal. 
org.apache.commons.math4.linear.SingularValueDecomposition.Solver.solve	(	RealVector	): Solve the linear equation A × X = B in least square sense.  The m×n matrix A may not be square, the solution X is such that ||A × X - B|| is minimal. 
org.apache.commons.math4.linear.SingularValueDecomposition.getConditionNumber	(	): Return the condition number of the matrix.
org.apache.commons.math4.linear.SingularValueDecomposition.getCovariance	(	double	): Returns the n × n covariance matrix. The covariance matrix is V × J × VT where J is the diagonal matrix of the inverse of the squares of the singular values.
org.apache.commons.math4.linear.SingularValueDecomposition.getInverseConditionNumber	(	): Computes the inverse of the condition number. In cases of rank deficiency, the getConditionNumber() condition number will become undefined.
org.apache.commons.math4.linear.SingularValueDecomposition.getNorm	(	): Returns the L2 norm of the matrix. The L2 norm is max(|A × u|2 / |u|2), where |.|2 denotes the vectorial 2-norm (i.e. the traditional euclidian norm).
org.apache.commons.math4.linear.SingularValueDecomposition.getRank	(	): Return the effective numerical matrix rank. The effective numerical rank is the number of non-negligible singular values. The threshold used to identify non-negligible terms is max(m,n) × ulp(s1) where ulp(s1) is the least significant bit of the largest singular value.
org.apache.commons.math4.linear.SingularValueDecomposition.getS	(	): Returns the diagonal matrix Σ of the decomposition. Σ is a diagonal matrix. The singular values are provided in non-increasing order, for compatibility with Jama.
org.apache.commons.math4.linear.SingularValueDecomposition.getSingularValues	(	): Returns the diagonal elements of the matrix Σ of the decomposition. The singular values are provided in non-increasing order, for compatibility with Jama.
org.apache.commons.math4.linear.SingularValueDecomposition.getSolver	(	): Get a solver for finding the A × X = B solution in least square sense.
org.apache.commons.math4.linear.SingularValueDecomposition.getU	(	): Returns the matrix U of the decomposition. U is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.SingularValueDecomposition.getUT	(	): Returns the transpose of the matrix U of the decomposition. U is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.SingularValueDecomposition.getV	(	): Returns the matrix V of the decomposition. V is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.SingularValueDecomposition.getVT	(	): Returns the transpose of the matrix V of the decomposition. V is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.SingularValueDecompositionTest.testAEqualUSVt	(	): test A = USVt 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testConditionNumber	(	): test condition number 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testHadamard	(	): Test based on a dimension 4 Hadamard matrix. 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testMatricesValues1	(	): test matrices values 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testRank	(	): test MATH-465 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testStability1	(	): test MATH-583 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testStability2	(	): test MATH-327 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testUOrthogonal	(	): test that U is orthogonal 
org.apache.commons.math4.linear.SingularValueDecompositionTest.testVOrthogonal	(	): test that V is orthogonal 
org.apache.commons.math4.linear.SingularValueDecompositionTest.useless_testMatricesValues2	(	): test matrices values 
org.apache.commons.math4.linear.SingularValueSolverTest.testConditionNumber	(	): test condition number 
org.apache.commons.math4.linear.SingularValueSolverTest.testLeastSquareSolve	(	): test least square solve 
org.apache.commons.math4.linear.SingularValueSolverTest.testSolve	(	): test solve 
org.apache.commons.math4.linear.SingularValueSolverTest.testSolveDimensionErrors	(	): test solve dimension errors 
org.apache.commons.math4.linear.SparseFieldMatrix: Sparse matrix implementation based on an open addressed map.  Caveat: This implementation assumes that, for any x, the equality x * 0d == 0d holds. But it is is not true for NaN. Moreover, zero entries will lose their sign. Some operations (that involve NaN and/or infinities) may thus give incorrect results. 
org.apache.commons.math4.linear.SparseFieldMatrix.SparseFieldMatrix	(	Field	): Create a matrix with no data.
org.apache.commons.math4.linear.SparseFieldMatrix.SparseFieldMatrix	(	Field	int	int	): Create a new SparseFieldMatrix with the supplied row and column dimensions.
org.apache.commons.math4.linear.SparseFieldMatrix.SparseFieldMatrix	(	FieldMatrix	): Generic copy constructor.
org.apache.commons.math4.linear.SparseFieldMatrix.SparseFieldMatrix	(	SparseFieldMatrix	): Copy constructor.
org.apache.commons.math4.linear.SparseFieldMatrix.addToEntry	(	int	int	T	): Change an entry in the specified row and column.  
org.apache.commons.math4.linear.SparseFieldMatrix.computeKey	(	int	int	): Compute the key to access a matrix element.
org.apache.commons.math4.linear.SparseFieldMatrix.copy	(	): Make a (deep) copy of this.  
org.apache.commons.math4.linear.SparseFieldMatrix.createMatrix	(	int	int	): Create a new FieldMatrix of the same type as the instance with the supplied row and column dimensions.  
org.apache.commons.math4.linear.SparseFieldMatrix.getColumnDimension	(	): Returns the number of columns in the matrix.  
org.apache.commons.math4.linear.SparseFieldMatrix.getEntry	(	int	int	): Returns the entry in the specified row and column.  
org.apache.commons.math4.linear.SparseFieldMatrix.getRowDimension	(	): Returns the number of rows in the matrix.  
org.apache.commons.math4.linear.SparseFieldMatrix.multiplyEntry	(	int	int	T	): Change an entry in the specified row and column.  
org.apache.commons.math4.linear.SparseFieldMatrix.setEntry	(	int	int	T	): Set the entry in the specified row and column.  
org.apache.commons.math4.linear.SparseFieldMatrixTest: Test cases for the SparseFieldMatrix class.
org.apache.commons.math4.linear.SparseFieldMatrixTest.assertClose	(	String	FieldMatrix	FieldMatrix	double	): verifies that two matrices are close (1-norm) 
org.apache.commons.math4.linear.SparseFieldMatrixTest.assertClose	(	String	Fraction[]	Fraction[]	double	): verifies that two vectors are close (sup norm) 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testAdd	(	): test add 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testAddFail	(	): test add failure 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testCopyFunctions	(	): test copy functions 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testExamples	(	): test examples in user guide 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testMath209	(	): test issue MATH-209 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testMultiply	(	): test multiply 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testOperate	(	): test operate 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testPlusMinus	(	): test m-n = m + -n 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testPremultiplyVector	(	): test preMultiply by vector 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testScalarAdd	(	): test sclarAdd 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testTrace	(	): test trace 
org.apache.commons.math4.linear.SparseFieldMatrixTest.testTranspose	(	): test transpose 
org.apache.commons.math4.linear.SparseFieldVector: This class implements the FieldVector interface with a OpenIntToFieldHashMap backing store.  Caveat: This implementation assumes that, for any x, the equality x * 0d == 0d holds. But it is is not true for NaN. Moreover, zero entries will lose their sign. Some operations (that involve NaN and/or infinities) may thus give incorrect results. 
org.apache.commons.math4.linear.SparseFieldVector.SparseFieldVector	(	Field	): Build a 0-length vector. Zero-length vectors may be used to initialize construction of vectors by data gathering. We start with zero-length and use either the SparseFieldVector() constructor or one of the append method (append() or append()) to gather data into this vector.
org.apache.commons.math4.linear.SparseFieldVector.SparseFieldVector	(	Field	T[]	): Create from a Field array. Only non-zero entries will be stored.
org.apache.commons.math4.linear.SparseFieldVector.SparseFieldVector	(	Field	int	): Construct a vector of zeroes.
org.apache.commons.math4.linear.SparseFieldVector.SparseFieldVector	(	Field	int	int	): Build a vector with known the sparseness (for advanced use only).
org.apache.commons.math4.linear.SparseFieldVector.SparseFieldVector	(	SparseFieldVector	): Copy constructor.
org.apache.commons.math4.linear.SparseFieldVector.SparseFieldVector	(	SparseFieldVector	int	): Build a resized vector, for use with append.
org.apache.commons.math4.linear.SparseFieldVector.add	(	FieldVector	): Compute the sum of this and v. 
org.apache.commons.math4.linear.SparseFieldVector.add	(	SparseFieldVector	): Optimized method to add sparse vectors.
org.apache.commons.math4.linear.SparseFieldVector.append	(	FieldVector	): Construct a vector by appending a vector to this vector. 
org.apache.commons.math4.linear.SparseFieldVector.append	(	SparseFieldVector	): Construct a vector by appending a vector to this vector.
org.apache.commons.math4.linear.SparseFieldVector.append	(	T	): Construct a vector by appending a T to this vector.
org.apache.commons.math4.linear.SparseFieldVector.checkIndex	(	int	): Check whether an index is valid.
org.apache.commons.math4.linear.SparseFieldVector.checkIndices	(	int	int	): Checks that the indices of a subvector are valid.
org.apache.commons.math4.linear.SparseFieldVector.checkVectorDimensions	(	int	): Check if instance dimension is equal to some expected value.
org.apache.commons.math4.linear.SparseFieldVector.copy	(	): Returns a (deep) copy of this. 
org.apache.commons.math4.linear.SparseFieldVector.dotProduct	(	FieldVector	): Compute the dot product. 
org.apache.commons.math4.linear.SparseFieldVector.ebeDivide	(	FieldVector	): Element-by-element division. 
org.apache.commons.math4.linear.SparseFieldVector.ebeMultiply	(	FieldVector	): Element-by-element multiplication. 
org.apache.commons.math4.linear.SparseFieldVector.equals	(	Object	):  
org.apache.commons.math4.linear.SparseFieldVector.getDimension	(	): Returns the size of the vector. 
org.apache.commons.math4.linear.SparseFieldVector.getEntries	(	): Get the entries of this instance.
org.apache.commons.math4.linear.SparseFieldVector.getEntry	(	int	): Returns the entry in the specified index. 
org.apache.commons.math4.linear.SparseFieldVector.getField	(	): Get the type of field elements of the vector. 
org.apache.commons.math4.linear.SparseFieldVector.getSubVector	(	int	int	): Get a subvector from consecutive elements. 
org.apache.commons.math4.linear.SparseFieldVector.hashCode	(	):  
org.apache.commons.math4.linear.SparseFieldVector.mapAdd	(	T	): Map an addition operation to each entry. 
org.apache.commons.math4.linear.SparseFieldVector.mapAddToSelf	(	T	): Map an addition operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.SparseFieldVector.mapDivide	(	T	): Map a division operation to each entry. 
org.apache.commons.math4.linear.SparseFieldVector.mapDivideToSelf	(	T	): Map a division operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.SparseFieldVector.mapInv	(	): Map the 1/x function to each entry. 
org.apache.commons.math4.linear.SparseFieldVector.mapInvToSelf	(	): Map the 1/x function to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.SparseFieldVector.mapMultiply	(	T	): Map a multiplication operation to each entry. 
org.apache.commons.math4.linear.SparseFieldVector.mapMultiplyToSelf	(	T	): Map a multiplication operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.SparseFieldVector.mapSubtract	(	T	): Map a subtraction operation to each entry. 
org.apache.commons.math4.linear.SparseFieldVector.mapSubtractToSelf	(	T	): Map a subtraction operation to each entry. The instance is changed by this method. 
org.apache.commons.math4.linear.SparseFieldVector.outerProduct	(	FieldVector	): Compute the outer product. 
org.apache.commons.math4.linear.SparseFieldVector.outerProduct	(	SparseFieldVector	): Optimized method to compute outer product when both vectors are sparse.
org.apache.commons.math4.linear.SparseFieldVector.projection	(	FieldVector	): Find the orthogonal projection of this vector onto another vector. 
org.apache.commons.math4.linear.SparseFieldVector.set	(	T	): Set all elements to a single value.
org.apache.commons.math4.linear.SparseFieldVector.setEntry	(	int	T	): Set a single element.
org.apache.commons.math4.linear.SparseFieldVector.setSubVector	(	int	FieldVector	): Set a set of consecutive elements. 
org.apache.commons.math4.linear.SparseFieldVector.subtract	(	FieldVector	): Compute this minus v. 
org.apache.commons.math4.linear.SparseFieldVector.subtract	(	SparseFieldVector	): Optimized method to compute this minus v.
org.apache.commons.math4.linear.SparseFieldVector.toArray	(	): Convert the vector to a T array. The array is independent from vector data, it's elements are copied. 
org.apache.commons.math4.linear.SparseFieldVector.walkInDefaultOrder	(	FieldVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.SparseFieldVector.walkInDefaultOrder	(	FieldVectorChangingVisitor	int	int	): Visits (and possibly alters) some entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.SparseFieldVector.walkInDefaultOrder	(	FieldVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.SparseFieldVector.walkInDefaultOrder	(	FieldVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in default order (increasing index).
org.apache.commons.math4.linear.SparseFieldVector.walkInOptimizedOrder	(	FieldVectorChangingVisitor	): Visits (and possibly alters) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.SparseFieldVector.walkInOptimizedOrder	(	FieldVectorChangingVisitor	int	int	): Visits (and possibly change) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.SparseFieldVector.walkInOptimizedOrder	(	FieldVectorPreservingVisitor	): Visits (but does not alter) all entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.SparseFieldVector.walkInOptimizedOrder	(	FieldVectorPreservingVisitor	int	int	): Visits (but does not alter) some entries of this vector in optimized order. The order in which the entries are visited is selected so as to lead to the most efficient implementation; it might depend on the concrete implementation of this abstract class.
org.apache.commons.math4.linear.SparseFieldVectorTest: Test cases for the SparseFieldVector class.
org.apache.commons.math4.linear.SparseFieldVectorTest.assertClose	(	String	Fraction[]	Fraction[]	double	): verifies that two vectors are close (sup norm) 
org.apache.commons.math4.linear.SparseFieldVectorTest.assertEquals	(	String	Fraction[]	Fraction[]	): verifies that two vectors are close (sup norm) 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInDefaultOrderChangingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInDefaultOrderChangingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInDefaultOrderChangingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInDefaultOrderPreservingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInDefaultOrderPreservingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInDefaultOrderPreservingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInOptimizedOrderChangingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInOptimizedOrderChangingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInOptimizedOrderChangingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInOptimizedOrderPreservingVisitor1	(	): The whole vector is visited. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInOptimizedOrderPreservingVisitor2	(	): Visiting an invalid subvector. 
org.apache.commons.math4.linear.SparseFieldVectorTest.testWalkInOptimizedOrderPreservingVisitor3	(	): Visiting a valid subvector. 
org.apache.commons.math4.linear.SparseRealMatrix: Marker interface for RealMatrix implementations that require sparse backing storage  Caveat: Implementation are allowed to assume that, for any x, the equality x * 0d == 0d holds. But it is is not true for NaN. Moreover, zero entries will lose their sign. Some operations (that involve NaN and/or infinities) may thus give incorrect results. 
org.apache.commons.math4.linear.SparseRealMatrixTest: Test cases for the OpenMapRealMatrix class.
org.apache.commons.math4.linear.SparseRealMatrixTest.assertClose	(	String	RealMatrix	RealMatrix	double	): verifies that two matrices are close (1-norm) 
org.apache.commons.math4.linear.SparseRealMatrixTest.assertClose	(	String	double[]	double[]	double	): verifies that two vectors are close (sup norm) 
org.apache.commons.math4.linear.SparseRealMatrixTest.testAdd	(	): test add 
org.apache.commons.math4.linear.SparseRealMatrixTest.testAddFail	(	): test add failure 
org.apache.commons.math4.linear.SparseRealMatrixTest.testCopyFunctions	(	): test copy functions 
org.apache.commons.math4.linear.SparseRealMatrixTest.testDimensions	(	): test dimensions 
org.apache.commons.math4.linear.SparseRealMatrixTest.testExamples	(	): test examples in user guide 
org.apache.commons.math4.linear.SparseRealMatrixTest.testMath209	(	): test issue MATH-209 
org.apache.commons.math4.linear.SparseRealMatrixTest.testMultiply	(	): test multiply 
org.apache.commons.math4.linear.SparseRealMatrixTest.testNorm	(	): test norm 
org.apache.commons.math4.linear.SparseRealMatrixTest.testOperate	(	): test operate 
org.apache.commons.math4.linear.SparseRealMatrixTest.testPlusMinus	(	): test m-n = m + -n 
org.apache.commons.math4.linear.SparseRealMatrixTest.testPremultiplyVector	(	): test preMultiply by vector 
org.apache.commons.math4.linear.SparseRealMatrixTest.testScalarAdd	(	): test sclarAdd 
org.apache.commons.math4.linear.SparseRealMatrixTest.testTrace	(	): test trace 
org.apache.commons.math4.linear.SparseRealMatrixTest.testTranspose	(	): test transpose 
org.apache.commons.math4.linear.SparseRealVector: Marker class for RealVectors that require sparse backing storage  Caveat: Implementation are allowed to assume that, for any x, the equality x * 0d == 0d holds. But it is is not true for NaN. Moreover, zero entries will lose their sign. Some operations (that involve NaN and/or infinities) may thus give incorrect results, like multiplications, divisions or functions mapping. 
org.apache.commons.math4.linear.SparseRealVectorTest: Test cases for the OpenMapRealVector class.
org.apache.commons.math4.linear.SymmLQ:  Implementation of the SYMMLQ iterative linear solver proposed by Paige and Saunders (1975). This implementation is largely based on the FORTRAN code by Pr. Michael A. Saunders, available here.   SYMMLQ is designed to solve the system of linear equations A · x = b where A is an n × n self-adjoint linear operator (defined as a RealLinearOperator), and b is a given vector. The operator A is not required to be positive definite. If A is known to be definite, the method of conjugate gradients might be preferred, since it will require about the same number of iterations as SYMMLQ but slightly less work per iteration.   SYMMLQ is designed to solve the system (A - shift · I) · x = b, where shift is a specified scalar value. If shift and b are suitably chosen, the computed vector x may approximate an (unnormalized) eigenvector of A, as in the methods of inverse iteration and/or Rayleigh-quotient iteration. Again, the linear operator (A - shift · I) need not be positive definite (but must be self-adjoint). The work per iteration is very slightly less if shift = 0.  Preconditioning  Preconditioning may reduce the number of iterations required. The solver may be provided with a positive definite preconditioner M = PT · P that is known to approximate (A - shift · I)-1 in some sense, where matrix-vector products of the form M · y = x can be computed efficiently. Then SYMMLQ will implicitly solve the system of equations P · (A - shift · I) · PT · xhat = P · b, i.e. Ahat · xhat = bhat, where Ahat = P · (A - shift · I) · PT, bhat = P · b, and return the solution x = PT · xhat. The associated residual is rhat = bhat - Ahat · xhat = P · [b - (A - shift · I) · x] = P · r.   In the case of preconditioning, the IterativeLinearSolverEvents that this solver fires are such that getNormOfResidual() returns the norm of the preconditioned, updated residual, ||P · r||, not the norm of the true residual ||r||.  Default stopping criterion  A default stopping criterion is implemented. The iterations stop when || rhat || ≤ δ || Ahat || || xhat ||, where xhat is the current estimate of the solution of the transformed system, rhat the current estimate of the corresponding residual, and δ a user-specified tolerance.  Iteration count  In the present context, an iteration should be understood as one evaluation of the matrix-vector product A · x. The initialization phase therefore counts as one iteration. If the user requires checks on the symmetry of A, this entails one further matrix-vector product in the initial phase. This further product is not accounted for in the iteration count. In other words, the number of iterations required to reach convergence will be identical, whether checks have been required or not.   The present definition of the iteration count differs from that adopted in the original FOTRAN code, where the initialization phase was not taken into account.  Initial guess of the solution  The x parameter in  solve(), solve()}, solveInPlace(), solveInPlace(), solveInPlace(),  should not be considered as an initial guess, as it is set to zero in the initial phase. If x0 is known to be a good approximation to x, one should compute r0 = b - A · x, solve A · dx = r0, and set x = x0 + dx. Exception context  Besides standard DimensionMismatchException, this class might throw NonSelfAdjointOperatorException if the linear operator or the preconditioner are not symmetric. In this case, the ExceptionContext provides more information  key "operator" points to the offending linear operator, say L, key "vector1" points to the first offending vector, say x, key "vector2" points to the second offending vector, say y, such that xT · L · y ≠ yT · L · x (within a certain accuracy).   NonPositiveDefiniteOperatorException might also be thrown in case the preconditioner is not positive definite. The relevant keys to the ExceptionContext are  key "operator", which points to the offending linear operator, say L, key "vector", which points to the offending vector, say x, such that xT · L · x < 0.  References  Paige and Saunders (1975) C. C. Paige and M. A. Saunders,  Solution of Sparse Indefinite Systems of Linear Equations, SIAM Journal on Numerical Analysis 12(4): 617-629, 1975 
org.apache.commons.math4.linear.SymmLQ.State:  A simple container holding the non-final variables used in the iterations. Making the current state of the solver visible from the outside is necessary, because during the iterations, x does not exactly hold the current estimate of the solution. Indeed, x needs in general to be moved from the LQ point to the CG point. Besides, additional upudates must be carried out in case goodb is set to true.   In all subsequent comments, the description of the state variables refer to their value after a call to update(). In these comments, k is the current number of evaluations of matrix-vector products. 
org.apache.commons.math4.linear.SymmLQ.State.State	(	RealLinearOperator	RealLinearOperator	RealVector	boolean	double	double	boolean	): Creates and inits to k = 1 a new instance of this class.
org.apache.commons.math4.linear.SymmLQ.State.bEqualsNullVector	(	): Returns true if the right-hand side vector is zero exactly.
org.apache.commons.math4.linear.SymmLQ.State.betaEqualsZero	(	): Returns true if beta is essentially zero. This method is used to check for early stop of the iterations.
org.apache.commons.math4.linear.SymmLQ.State.checkSymmetry	(	RealLinearOperator	RealVector	RealVector	RealVector	): Performs a symmetry check on the specified linear operator, and throws an exception in case this check fails. Given a linear operator L, and a vector x, this method checks that x' · L · y = y' · L · x (within a given accuracy), where y = L · x.
org.apache.commons.math4.linear.SymmLQ.State.daxpbypz	(	double	RealVector	double	RealVector	RealVector	): A BLAS-like function, for the operation z ← a · x + b · y + z. This is for internal use only: no dimension checks are provided.
org.apache.commons.math4.linear.SymmLQ.State.daxpy	(	double	RealVector	RealVector	): A clone of the BLAS DAXPY function, which carries out the operation y ← a · x + y. This is for internal use only: no dimension checks are provided.
org.apache.commons.math4.linear.SymmLQ.State.getNormOfResidual	(	): Returns the norm of the updated, preconditioned residual.
org.apache.commons.math4.linear.SymmLQ.State.hasConverged	(	): Returns true if the default stopping criterion is fulfilled.
org.apache.commons.math4.linear.SymmLQ.State.init	(	): Performs the initial phase of the SYMMLQ algorithm. On return, the value of the state variables of this object correspond to k = 1.
org.apache.commons.math4.linear.SymmLQ.State.refineSolution	(	RealVector	):  Move to the CG point if it seems better. In this version of SYMMLQ, the convergence tests involve only cgnorm, so we're unlikely to stop at an LQ point, except if the iteration limit interferes.   Additional upudates are also carried out in case goodb is set to true. 
org.apache.commons.math4.linear.SymmLQ.State.throwNPDLOException	(	RealLinearOperator	RealVector	): Throws a new NonPositiveDefiniteOperatorException with appropriate context.
org.apache.commons.math4.linear.SymmLQ.State.update	(	): Performs the next iteration of the algorithm. The iteration count should be incremented prior to calling this method. On return, the value of the state variables of this object correspond to the current iteration count k.
org.apache.commons.math4.linear.SymmLQ.State.updateNorms	(	): Computes the norms of the residuals, and checks for convergence. Updates lqnorm and cgnorm.
org.apache.commons.math4.linear.SymmLQ.SymmLQ	(	IterationManager	double	boolean	): Creates a new instance of this class, with default stopping criterion and custom iteration manager. Note that setting check to true entails an extra matrix-vector product in the initial phase.
org.apache.commons.math4.linear.SymmLQ.SymmLQ	(	int	double	boolean	): Creates a new instance of this class, with default stopping criterion. Note that setting check to true entails an extra matrix-vector product in the initial phase.
org.apache.commons.math4.linear.SymmLQ.getCheck	(	): Returns true if symmetry of the matrix, and symmetry as well as positive definiteness of the preconditioner should be checked.
org.apache.commons.math4.linear.SymmLQ.solve	(	RealLinearOperator	RealLinearOperator	RealVector	): Returns an estimate of the solution to the linear system A · x = b.
org.apache.commons.math4.linear.SymmLQ.solve	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b.
org.apache.commons.math4.linear.SymmLQ.solve	(	RealLinearOperator	RealLinearOperator	RealVector	boolean	double	): Returns an estimate of the solution to the linear system (A - shift · I) · x = b.  If the solution x is expected to contain a large multiple of b (as in Rayleigh-quotient iteration), then better precision may be achieved with goodb set to true; this however requires an extra call to the preconditioner.   shift should be zero if the system A · x = b is to be solved. Otherwise, it could be an approximation to an eigenvalue of A, such as the Rayleigh quotient bT · A · b / (bT · b) corresponding to the vector b. If b is sufficiently like an eigenvector corresponding to an eigenvalue near shift, then the computed x may have very large components. When normalized, x may be closer to an eigenvector than b. 
org.apache.commons.math4.linear.SymmLQ.solve	(	RealLinearOperator	RealVector	): Returns an estimate of the solution to the linear system A · x = b. 
org.apache.commons.math4.linear.SymmLQ.solve	(	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. 
org.apache.commons.math4.linear.SymmLQ.solve	(	RealLinearOperator	RealVector	boolean	double	): Returns the solution to the system (A - shift · I) · x = b.  If the solution x is expected to contain a large multiple of b (as in Rayleigh-quotient iteration), then better precision may be achieved with goodb set to true.   shift should be zero if the system A · x = b is to be solved. Otherwise, it could be an approximation to an eigenvalue of A, such as the Rayleigh quotient bT · A · b / (bT · b) corresponding to the vector b. If b is sufficiently like an eigenvector corresponding to an eigenvalue near shift, then the computed x may have very large components. When normalized, x may be closer to an eigenvector than b. 
org.apache.commons.math4.linear.SymmLQ.solveInPlace	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. The solution is computed in-place (initial guess is modified).
org.apache.commons.math4.linear.SymmLQ.solveInPlace	(	RealLinearOperator	RealLinearOperator	RealVector	RealVector	boolean	double	): Returns an estimate of the solution to the linear system (A - shift · I) · x = b. The solution is computed in-place.  If the solution x is expected to contain a large multiple of b (as in Rayleigh-quotient iteration), then better precision may be achieved with goodb set to true; this however requires an extra call to the preconditioner.   shift should be zero if the system A · x = b is to be solved. Otherwise, it could be an approximation to an eigenvalue of A, such as the Rayleigh quotient bT · A · b / (bT · b) corresponding to the vector b. If b is sufficiently like an eigenvector corresponding to an eigenvalue near shift, then the computed x may have very large components. When normalized, x may be closer to an eigenvector than b. 
org.apache.commons.math4.linear.SymmLQ.solveInPlace	(	RealLinearOperator	RealVector	RealVector	): Returns an estimate of the solution to the linear system A · x = b. The solution is computed in-place (initial guess is modified). 
org.apache.commons.math4.linear.TriDiagonalTransformer: Class transforming a symmetrical matrix to tridiagonal shape. A symmetrical m × m matrix A can be written as the product of three matrices: A = Q × T × QT with Q an orthogonal matrix and T a symmetrical tridiagonal matrix. Both Q and T are m × m matrices. This implementation only uses the upper part of the matrix, the part below the diagonal is not accessed at all. Transformation to tridiagonal shape is often not a goal by itself, but it is an intermediate step in more general decomposition algorithms like EigenDecomposition eigen decomposition. This class is therefore intended for internal use by the library and is not public. As a consequence of this explicitly limited scope, many methods directly returns references to internal arrays, not copies.
org.apache.commons.math4.linear.TriDiagonalTransformer.TriDiagonalTransformer	(	RealMatrix	): Build the transformation to tridiagonal shape of a symmetrical matrix. The specified matrix is assumed to be symmetrical without any check. Only the upper triangular part of the matrix is used.
org.apache.commons.math4.linear.TriDiagonalTransformer.getHouseholderVectorsRef	(	): Get the Householder vectors of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.TriDiagonalTransformer.getMainDiagonalRef	(	): Get the main diagonal elements of the matrix T of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.TriDiagonalTransformer.getQ	(	): Returns the matrix Q of the transform. Q is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.TriDiagonalTransformer.getQT	(	): Returns the transpose of the matrix Q of the transform. Q is an orthogonal matrix, i.e. its transpose is also its inverse.
org.apache.commons.math4.linear.TriDiagonalTransformer.getSecondaryDiagonalRef	(	): Get the secondary diagonal elements of the matrix T of the transform. Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.
org.apache.commons.math4.linear.TriDiagonalTransformer.getT	(	): Returns the tridiagonal matrix T of the transform.
org.apache.commons.math4.linear.TriDiagonalTransformer.transform	(	): Transform original matrix to tridiagonal form. Transformation is done using Householder transforms.
org.apache.commons.math4.linear.UnmodifiableArrayRealVectorTest: This is an implementation of UnmodifiableRealVectorAbstractTest for unmodifiable views of ArrayRealVectorTest.
org.apache.commons.math4.linear.UnmodifiableArrayRealVectorTest.createVector	(	): Returns a random vector of type ArrayRealVector.
org.apache.commons.math4.linear.UnmodifiableOpenMapRealVectorTest: This is an implementation of UnmodifiableRealVectorAbstractTest for unmodifiable views of OpenMapRealVector.
org.apache.commons.math4.linear.UnmodifiableOpenMapRealVectorTest.createVector	(	): Returns a random vector of type ArrayRealVector.
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest: This is an abstract test of the unmodifiableRealVector() unmodifiable vector implementation. These unmodifiable vectors decorate a (modifiable) RealVector; therefore, a new implementation of this abstract test should be considered for each implementation of RealVector.
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.callMethod	(	Method	RealVector	Object	): This is the general test of most methods in the unmodifiableRealVector() unmodifiable vector. It works as follows. First, an unmodifiable view of a copy of the specified random vector u is created: this defines v. Then the same method m is invoked on u and v, with randomly generated parameters args. If it turns out that u has changed after the call of method m, then this test checks that the call of this method on v resulted in a MathUnsupportedOperationException. If u was not modified, then this test checks that the results returned by the call of method m on u and v returned the same result.
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.createParameter	(	Class	): Creates a new random object of the specified type.
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.createVector	(	): Creates a new random vector of a specified type. This vector is then to be wrapped in an unmodifiable vector.
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.equals	(	Object	Object	): Returns true if the specified Object are equal.
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.equals	(	RealMatrix	RealMatrix	): Returns true if the specified RealMatrix are equal (within a given tolerance).
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.equals	(	RealVector	RealVector	): Returns true if the specified RealVector are equal (within a given tolerance).
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.equals	(	RealVector	double[]	): Returns true if the specified RealVector is equal to the specified double array (within a given tolerance).
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.equals	(	double	double	): Returns true if the specified double are equal (within a given tolerance).
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.equals	(	double[]	double[]	): Returns true if the specified double arrays are equal (within a given tolerance).
org.apache.commons.math4.linear.UnmodifiableRealVectorAbstractTest.testAllButExcluded	(	): This test calls callMethod() on every method defined in interface RealVector. It generates the appropriate random arguments. Some methods are manually excluded (see EXCLUDE), they must be handled by separate tests.
org.apache.commons.math4.ml.clustering.CentroidCluster: A Cluster used by centroid-based clustering algorithms.  Defines additionally a cluster center which may not necessarily be a member of the original data set.
org.apache.commons.math4.ml.clustering.CentroidCluster.CentroidCluster	(	Clusterable	): Build a cluster centered at a specified point.
org.apache.commons.math4.ml.clustering.CentroidCluster.getCenter	(	): Get the point chosen to be the center of this cluster.
org.apache.commons.math4.ml.clustering.Cluster: Cluster holding a set of Clusterable points.
org.apache.commons.math4.ml.clustering.Cluster.Cluster	(	): Build a cluster centered at a specified point.
org.apache.commons.math4.ml.clustering.Cluster.addPoint	(	T	): Add a point to this cluster.
org.apache.commons.math4.ml.clustering.Cluster.getPoints	(	): Get the points contained in the cluster.
org.apache.commons.math4.ml.clustering.Clusterable: Interface for n-dimensional points that can be clustered together.
org.apache.commons.math4.ml.clustering.Clusterable.getPoint	(	): Gets the n-dimensional point.
org.apache.commons.math4.ml.clustering.Clusterer: Base class for clustering algorithms.
org.apache.commons.math4.ml.clustering.Clusterer.Clusterer	(	DistanceMeasure	): Build a new clusterer with the given DistanceMeasure.
org.apache.commons.math4.ml.clustering.Clusterer.cluster	(	Collection	): Perform a cluster analysis on the given set of Clusterable instances.
org.apache.commons.math4.ml.clustering.Clusterer.distance	(	Clusterable	Clusterable	): Calculates the distance between two Clusterable instances with the configured DistanceMeasure.
org.apache.commons.math4.ml.clustering.Clusterer.getDistanceMeasure	(	): Returns the DistanceMeasure instance used by this clusterer.
org.apache.commons.math4.ml.clustering.DBSCANClusterer: DBSCAN (density-based spatial clustering of applications with noise) algorithm.  The DBSCAN algorithm forms clusters based on the idea of density connectivity, i.e. a point p is density connected to another point q, if there exists a chain of points pi, with i = 1 .. n and p1 = p and pn = q, such that each pair <pi, pi+1> is directly density-reachable. A point q is directly density-reachable from point p if it is in the ε-neighborhood of this point.  Any point that is not density-reachable from a formed cluster is treated as noise, and will thus not be present in the result.  The algorithm requires two parameters:  eps: the distance that defines the ε-neighborhood of a point minPoints: the minimum number of density-connected points required to form a cluster 
org.apache.commons.math4.ml.clustering.DBSCANClusterer.DBSCANClusterer	(	double	int	): Creates a new instance of a DBSCANClusterer.  The euclidean distance will be used as default distance measure.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.DBSCANClusterer	(	double	int	DistanceMeasure	): Creates a new instance of a DBSCANClusterer.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.cluster	(	Collection	): Performs DBSCAN cluster analysis.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.expandCluster	(	Cluster	T	List	Collection	Map	): Expands the cluster to include density-reachable items.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.getEps	(	): Returns the maximum radius of the neighborhood to be considered.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.getMinPts	(	): Returns the minimum number of points needed for a cluster.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.getNeighbors	(	T	Collection	): Returns a list of density-reachable neighbors of a point.
org.apache.commons.math4.ml.clustering.DBSCANClusterer.merge	(	List	List	): Merges two lists together.
org.apache.commons.math4.ml.clustering.DoublePoint: A simple implementation of Clusterable for points with double coordinates.
org.apache.commons.math4.ml.clustering.DoublePoint.DoublePoint	(	double[]	): Build an instance wrapping an double array.  The wrapped array is referenced, it is not copied.
org.apache.commons.math4.ml.clustering.DoublePoint.DoublePoint	(	int[]	): Build an instance wrapping an integer array.  The wrapped array is copied to an internal double array.
org.apache.commons.math4.ml.clustering.DoublePoint.equals	(	Object	):  
org.apache.commons.math4.ml.clustering.DoublePoint.getPoint	(	): Gets the n-dimensional point. 
org.apache.commons.math4.ml.clustering.DoublePoint.hashCode	(	):  
org.apache.commons.math4.ml.clustering.DoublePoint.toString	(	):  
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer: Fuzzy K-Means clustering algorithm.  The Fuzzy K-Means algorithm is a variation of the classical K-Means algorithm, with the major difference that a single data point is not uniquely assigned to a single cluster. Instead, each point i has a set of weights uij which indicate the degree of membership to the cluster j.  The algorithm then tries to minimize the objective function:  J = ∑i=1..C∑k=1..N uikmdik2  with dik being the distance between data point i and the cluster center k.  The algorithm requires two parameters:  k: the number of clusters fuzziness: determines the level of cluster fuzziness, larger values lead to fuzzier clusters  Additional, optional parameters:  maxIterations: the maximum number of iterations epsilon: the convergence criteria, default is 1e-3   The fuzzy variant of the K-Means algorithm is more robust with regard to the selection of the initial cluster centers.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.FuzzyKMeansClusterer	(	int	double	): Creates a new instance of a FuzzyKMeansClusterer.  The euclidean distance will be used as default distance measure.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.FuzzyKMeansClusterer	(	int	double	int	DistanceMeasure	): Creates a new instance of a FuzzyKMeansClusterer.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.FuzzyKMeansClusterer	(	int	double	int	DistanceMeasure	double	UniformRandomProvider	): Creates a new instance of a FuzzyKMeansClusterer.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.calculateMaxMembershipChange	(	double[][]	): Calculate the maximum element-by-element change of the membership matrix for the current iteration.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.cluster	(	Collection	): Performs Fuzzy K-Means cluster analysis.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getClusters	(	): Returns the list of clusters resulting from the last call to cluster().
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getDataPoints	(	): Returns an unmodifiable list of the data points used in the last call to cluster().
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getEpsilon	(	): Returns the convergence criteria used by this instance.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getFuzziness	(	): Returns the fuzziness factor used by this instance.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getK	(	): Return the number of clusters this instance will use.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getMaxIterations	(	): Returns the maximum number of iterations this instance will use.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getMembershipMatrix	(	): Returns the nxk membership matrix, where n is the number of data points and k the number of clusters.  The element Ui,j represents the membership value for data point i to cluster j.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getObjectiveFunctionValue	(	): Get the value of the objective function.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.getRandomGenerator	(	): Returns the random generator this instance will use.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.initializeMembershipMatrix	(	): Initialize the membership matrix with random values.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.saveMembershipMatrix	(	double[][]	): Copy the membership matrix into the provided matrix.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.updateClusterCenters	(	): Update the cluster centers.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClusterer.updateMembershipMatrix	(	): Updates the membership matrix and assigns the points to the cluster with the highest membership.
org.apache.commons.math4.ml.clustering.FuzzyKMeansClustererTest: Test cases for FuzzyKMeansClusterer.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer: Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer	(	int	): Build a clusterer.  The default strategy for handling empty clusters that may appear during algorithm iterations is to split the cluster with largest distance variance.  The euclidean distance will be used as default distance measure.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer	(	int	int	): Build a clusterer.  The default strategy for handling empty clusters that may appear during algorithm iterations is to split the cluster with largest distance variance.  The euclidean distance will be used as default distance measure.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer	(	int	int	DistanceMeasure	): Build a clusterer.  The default strategy for handling empty clusters that may appear during algorithm iterations is to split the cluster with largest distance variance.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer	(	int	int	DistanceMeasure	UniformRandomProvider	): Build a clusterer.  The default strategy for handling empty clusters that may appear during algorithm iterations is to split the cluster with largest distance variance.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer	(	int	int	DistanceMeasure	UniformRandomProvider	EmptyClusterStrategy	): Build a clusterer.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.assignPointsToClusters	(	List	Collection	int[]	): Adds the given points to the closest Cluster.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.centroidOf	(	Collection	int	): Computes the centroid for a set of points.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.chooseInitialCenters	(	Collection	): Use K-means++ to choose the initial centers.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.cluster	(	Collection	): Runs the K-means++ clustering algorithm.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getEmptyClusterStrategy	(	): Returns the EmptyClusterStrategy used by this instance.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getFarthestPoint	(	Collection	): Get the point farthest to its cluster center
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getK	(	): Return the number of clusters this instance will use.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getMaxIterations	(	): Returns the maximum number of iterations this instance will use.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getNearestCluster	(	Collection	T	): Returns the nearest Cluster to the given point
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getPointFromLargestNumberCluster	(	Collection	): Get a random point from the Cluster with the largest number of points
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getPointFromLargestVarianceCluster	(	Collection	): Get a random point from the Cluster with the largest distance variance.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClusterer.getRandomGenerator	(	): Returns the random generator this instance will use.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClustererTest.CloseDistance: A helper class for testSmallDistances(). This class is similar to DoublePoint, but it defines a different distanceFrom() method that tends to return distances less than 1.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClustererTest.testPerformClusterAnalysisDegenerate	(	): JIRA: MATH-305 Two points, one cluster, one iteration
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClustererTest.testPerformClusterAnalysisToManyClusters	(	): 2 variables cannot be clustered into 3 clusters. See issue MATH-436.
org.apache.commons.math4.ml.clustering.KMeansPlusPlusClustererTest.testSmallDistances	(	): Test points that are very close together. See issue MATH-546.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer: A wrapper around a k-means++ clustering algorithm which performs multiple trials and returns the best solution.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer.MultiKMeansPlusPlusClusterer	(	KMeansPlusPlusClusterer	int	): Build a clusterer.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer.MultiKMeansPlusPlusClusterer	(	KMeansPlusPlusClusterer	int	ClusterEvaluator	): Build a clusterer.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer.cluster	(	Collection	): Runs the K-means++ clustering algorithm.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer.getClusterEvaluator	(	): Returns the ClusterEvaluator used to determine the "best" clustering.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer.getClusterer	(	): Returns the embedded k-means clusterer used by this instance.
org.apache.commons.math4.ml.clustering.MultiKMeansPlusPlusClusterer.getNumTrials	(	): Returns the number of trials this instance will do.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator: Base class for cluster evaluation methods.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator.ClusterEvaluator	(	): Creates a new cluster evaluator with an EuclideanDistance as distance measure.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator.ClusterEvaluator	(	DistanceMeasure	): Creates a new cluster evaluator with the given distance measure.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator.centroidOf	(	Cluster	): Computes the centroid for a cluster.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator.distance	(	Clusterable	Clusterable	): Calculates the distance between two Clusterable instances with the configured DistanceMeasure.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator.isBetterScore	(	double	double	): Returns whether the first evaluation score is considered to be better than the second one by this evaluator.  Specific implementations shall override this method if the returned scores do not follow the same ordering, i.e. smaller score is better.
org.apache.commons.math4.ml.clustering.evaluation.ClusterEvaluator.score	(	List	): Computes the evaluation score for the given list of clusters.
org.apache.commons.math4.ml.clustering.evaluation.SumOfClusterVariances: Computes the sum of intra-cluster distance variances according to the formula:  \( score = \sum\limits_{i=1}^n \sigma_i^2 \)  where n is the number of clusters and \( \sigma_i^2 \) is the variance of intra-cluster distances of cluster \( c_i \).
org.apache.commons.math4.ml.clustering.evaluation.SumOfClusterVariances.SumOfClusterVariances	(	DistanceMeasure	): 
org.apache.commons.math4.ml.clustering.evaluation.SumOfClusterVariances.score	(	List	): Computes the evaluation score for the given list of clusters. 
org.apache.commons.math4.ml.distance.CanberraDistance: Calculates the Canberra distance between two points.
org.apache.commons.math4.ml.distance.CanberraDistance.compute	(	double[]	double[]	): Compute the distance between two n-dimensional vectors.  The two vectors are required to have the same dimension. 
org.apache.commons.math4.ml.distance.CanberraDistanceTest: Tests for CanberraDistance class.
org.apache.commons.math4.ml.distance.ChebyshevDistance: Calculates the L∞ (max of abs) distance between two points.
org.apache.commons.math4.ml.distance.ChebyshevDistance.compute	(	double[]	double[]	): Compute the distance between two n-dimensional vectors.  The two vectors are required to have the same dimension. 
org.apache.commons.math4.ml.distance.ChebyshevDistanceTest: Tests for ChebyshevDistance class.
org.apache.commons.math4.ml.distance.DistanceMeasure: Interface for distance measures of n-dimensional vectors.
org.apache.commons.math4.ml.distance.DistanceMeasure.compute	(	double[]	double[]	): Compute the distance between two n-dimensional vectors.  The two vectors are required to have the same dimension.
org.apache.commons.math4.ml.distance.EarthMoversDistance: Calculates the Earh Mover's distance (also known as Wasserstein metric) between two distributions.
org.apache.commons.math4.ml.distance.EarthMoversDistance.compute	(	double[]	double[]	): Compute the distance between two n-dimensional vectors.  The two vectors are required to have the same dimension. 
org.apache.commons.math4.ml.distance.EarthMoversDistanceTest: Tests for EarthMoversDistance class.
org.apache.commons.math4.ml.distance.EuclideanDistance: Calculates the L2 (Euclidean) distance between two points.
org.apache.commons.math4.ml.distance.EuclideanDistance.compute	(	double[]	double[]	): Compute the distance between two n-dimensional vectors.  The two vectors are required to have the same dimension. 
org.apache.commons.math4.ml.distance.EuclideanDistanceTest: Tests for EuclideanDistance class.
org.apache.commons.math4.ml.distance.ManhattanDistance: Calculates the L1 (sum of abs) distance between two points.
org.apache.commons.math4.ml.distance.ManhattanDistance.compute	(	double[]	double[]	): Compute the distance between two n-dimensional vectors.  The two vectors are required to have the same dimension. 
org.apache.commons.math4.ml.distance.ManhattanDistanceTest: Tests for ManhattanDistance class.
org.apache.commons.math4.ml.neuralnet.FeatureInitializer: Defines how to assign the first value of a neuron's feature.
org.apache.commons.math4.ml.neuralnet.FeatureInitializer.value	(	): Selects the initial value.
org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory: Creates functions that will select the initial values of a neuron's features.
org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory.FeatureInitializerFactory	(	): Class contains only static methods. 
org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory.function	(	UnivariateFunction	double	double	): Creates an initializer from a univariate function f(x). The argument x is set to init at the first call and will be incremented at each call.
org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory.randomize	(	RealDistribution.Sampler	FeatureInitializer	): Adds some amount of random data to the given initializer.
org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory.uniform	(	UniformRandomProvider	double	double	): Uniform sampling of the given range.
org.apache.commons.math4.ml.neuralnet.FeatureInitializerFactory.uniform	(	double	double	): Uniform sampling of the given range.
org.apache.commons.math4.ml.neuralnet.MapUtils: Utilities for network maps.
org.apache.commons.math4.ml.neuralnet.MapUtils.MapUtils	(	): Class contains only static methods.
org.apache.commons.math4.ml.neuralnet.MapUtils.PairNeuronDouble: Helper data structure holding a (Neuron, double) pair.
org.apache.commons.math4.ml.neuralnet.MapUtils.PairNeuronDouble.PairNeuronDouble	(	Neuron	double	): 
org.apache.commons.math4.ml.neuralnet.MapUtils.PairNeuronDouble.getNeuron	(	): 
org.apache.commons.math4.ml.neuralnet.MapUtils.computeHitHistogram	(	Iterable	NeuronSquareMesh2D	DistanceMeasure	): Computes the "hit" histogram of a two-dimensional map.
org.apache.commons.math4.ml.neuralnet.MapUtils.computeQuantizationError	(	Iterable	Iterable	DistanceMeasure	): Computes the quantization error. The quantization error is the average distance between a feature vector and its "best matching unit" (closest neuron).
org.apache.commons.math4.ml.neuralnet.MapUtils.computeTopographicError	(	Iterable	Network	DistanceMeasure	): Computes the topographic error. The topographic error is the proportion of data for which first and second best matching units are not adjacent in the map.
org.apache.commons.math4.ml.neuralnet.MapUtils.computeU	(	NeuronSquareMesh2D	DistanceMeasure	): Computes the  U-matrix of a two-dimensional map.
org.apache.commons.math4.ml.neuralnet.MapUtils.findBest	(	double[]	Iterable	DistanceMeasure	): Finds the neuron that best matches the given features.
org.apache.commons.math4.ml.neuralnet.MapUtils.findBestAndSecondBest	(	double[]	Iterable	DistanceMeasure	): Finds the two neurons that best match the given features.
org.apache.commons.math4.ml.neuralnet.MapUtils.sort	(	double[]	Iterable	DistanceMeasure	): Creates a list of neurons sorted in increased order of the distance to the given features.
org.apache.commons.math4.ml.neuralnet.MapUtilsTest: Tests for MapUtils class.
org.apache.commons.math4.ml.neuralnet.Network: Neural network, composed of Neuron instances and the links between them. Although updating a neuron's state is thread-safe, modifying the network's topology (adding or removing links) is not.
org.apache.commons.math4.ml.neuralnet.Network.Network	(	long	int	): 
org.apache.commons.math4.ml.neuralnet.Network.Network	(	long	int	Neuron[]	long[][]	): Constructor with restricted access, solely used for deserialization.
org.apache.commons.math4.ml.neuralnet.Network.NeuronIdentifierComparator: Comparator that prescribes an order of the neurons according to the increasing order of their identifier.
org.apache.commons.math4.ml.neuralnet.Network.NeuronIdentifierComparator.compare	(	Neuron	Neuron	):  
org.apache.commons.math4.ml.neuralnet.Network.SerializationProxy: Serialization.
org.apache.commons.math4.ml.neuralnet.Network.SerializationProxy.SerializationProxy	(	long	int	Neuron[]	long[][]	): 
org.apache.commons.math4.ml.neuralnet.Network.SerializationProxy.readResolve	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.Network.addLink	(	Neuron	Neuron	): Adds a link from neuron a to neuron b. Note: the link is not bi-directional; if a bi-directional link is required, an additional call must be made with a and b exchanged in the argument list.
org.apache.commons.math4.ml.neuralnet.Network.addLinkToLinkSet	(	Set	long	): Adds a link to neuron id in given linkSet. Note: no check verifies that the identifier indeed belongs to this network.
org.apache.commons.math4.ml.neuralnet.Network.copy	(	): Performs a deep copy of this instance. Upon return, the copied and original instances will be independent: Updating one will not affect the other.
org.apache.commons.math4.ml.neuralnet.Network.createNeuron	(	double[]	): Creates a neuron and assigns it a unique identifier.
org.apache.commons.math4.ml.neuralnet.Network.createNextId	(	): Creates a neuron identifier.
org.apache.commons.math4.ml.neuralnet.Network.deleteLink	(	Neuron	Neuron	): Deletes the link between neurons a and b.
org.apache.commons.math4.ml.neuralnet.Network.deleteLinkFromLinkSet	(	Set	long	): Deletes a link to neuron id in given linkSet. Note: no check verifies that the identifier indeed belongs to this network.
org.apache.commons.math4.ml.neuralnet.Network.deleteNeuron	(	Neuron	): Deletes a neuron. Links from all neighbours to the removed neuron will also be deleteLink() deleted.
org.apache.commons.math4.ml.neuralnet.Network.getFeaturesSize	(	): Gets the size of the neurons' features set.
org.apache.commons.math4.ml.neuralnet.Network.getNeighbours	(	Iterable	): Retrieves the neurons in the neighbourhood of any neuron in the neurons list.
org.apache.commons.math4.ml.neuralnet.Network.getNeighbours	(	Iterable	Iterable	): Retrieves the neurons in the neighbourhood of any neuron in the neurons list. The exclude list allows to retrieve the "concentric" neighbourhoods by removing the neurons that belong to the inner "circles".
org.apache.commons.math4.ml.neuralnet.Network.getNeighbours	(	Neuron	): Retrieves the neighbours of the given neuron.
org.apache.commons.math4.ml.neuralnet.Network.getNeighbours	(	Neuron	Iterable	): Retrieves the neighbours of the given neuron.
org.apache.commons.math4.ml.neuralnet.Network.getNeuron	(	long	): Retrieves the neuron with the given (unique) id.
org.apache.commons.math4.ml.neuralnet.Network.getNeurons	(	Comparator	): Creates a list of the neurons, sorted in a custom order.
org.apache.commons.math4.ml.neuralnet.Network.iterator	(	): 
org.apache.commons.math4.ml.neuralnet.Network.readObject	(	ObjectInputStream	): Prevents proxy bypass.
org.apache.commons.math4.ml.neuralnet.Network.writeReplace	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.NetworkTest: Tests for Network.
org.apache.commons.math4.ml.neuralnet.Neuron: Describes a neuron element of a neural network. This class aims to be thread-safe.
org.apache.commons.math4.ml.neuralnet.Neuron.Neuron	(	long	double[]	): Creates a neuron. The size of the feature set is fixed to the length of the given argument.  Constructor is package-private: Neurons must be createNeuron() created by the network instance to which they will belong.
org.apache.commons.math4.ml.neuralnet.Neuron.SerializationProxy: Serialization.
org.apache.commons.math4.ml.neuralnet.Neuron.SerializationProxy.SerializationProxy	(	long	double[]	): 
org.apache.commons.math4.ml.neuralnet.Neuron.SerializationProxy.readResolve	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.Neuron.compareAndSetFeatures	(	double[]	double[]	): Tries to atomically update the neuron's features. Update will be performed only if the expected values match the current values. In effect, when concurrent threads call this method, the state could be modified by one, so that it does not correspond to the the state assumed by another. Typically, a caller getFeatures() retrieves the current state, and uses it to compute the new state. During this computation, another thread might have done the same thing, and updated the state: If the current thread were to proceed with its own update, it would overwrite the new state (which might already have been used by yet other threads). To prevent this, the method does not perform the update when a concurrent modification has been detected, and returns false. When this happens, the caller should fetch the new current state, redo its computation, and call this method again.
org.apache.commons.math4.ml.neuralnet.Neuron.containSameValues	(	double[]	double[]	): Checks whether the contents of both arrays is the same.
org.apache.commons.math4.ml.neuralnet.Neuron.copy	(	): Performs a deep copy of this instance. Upon return, the copied and original instances will be independent: Updating one will not affect the other.
org.apache.commons.math4.ml.neuralnet.Neuron.getFeatures	(	): Gets the neuron's features.
org.apache.commons.math4.ml.neuralnet.Neuron.getIdentifier	(	): Gets the neuron's identifier.
org.apache.commons.math4.ml.neuralnet.Neuron.getNumberOfAttemptedUpdates	(	): Retrieves the number of calls to the compareAndSetFeatures() method. Note that if the caller wants to use this method in combination with getNumberOfSuccessfulUpdates(), additional synchronization may be required to ensure consistency.
org.apache.commons.math4.ml.neuralnet.Neuron.getNumberOfSuccessfulUpdates	(	): Retrieves the number of successful calls to the compareAndSetFeatures() method. Note that if the caller wants to use this method in combination with getNumberOfAttemptedUpdates(), additional synchronization may be required to ensure consistency.
org.apache.commons.math4.ml.neuralnet.Neuron.getSize	(	): Gets the length of the feature set.
org.apache.commons.math4.ml.neuralnet.Neuron.readObject	(	ObjectInputStream	): Prevents proxy bypass.
org.apache.commons.math4.ml.neuralnet.Neuron.writeReplace	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.NeuronTest: Tests for Neuron.
org.apache.commons.math4.ml.neuralnet.OffsetFeatureInitializer: Wraps a given initializer.
org.apache.commons.math4.ml.neuralnet.OffsetFeatureInitializer.OffsetFeatureInitializer	(	FeatureInitializer	): Creates a new initializer whose value() method will return orig.value() + offset, where offset is automatically incremented by one at each call.
org.apache.commons.math4.ml.neuralnet.OffsetFeatureInitializer.value	(	): Selects the initial value. 
org.apache.commons.math4.ml.neuralnet.UpdateAction: Describes how to update the network in response to a training sample.
org.apache.commons.math4.ml.neuralnet.UpdateAction.update	(	Network	double[]	): Updates the network in response to the sample features.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString: Neural network with the topology of a one-dimensional line. Each neuron defines one point on the line.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.NeuronString	(	boolean	double[][]	): Constructor with restricted access, solely used for deserialization.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.NeuronString	(	int	boolean	FeatureInitializer[]	): Creates a one-dimensional network: Each neuron not located on the border of the mesh has two neurons linked to it.  The links are bi-directional. Neurons created successively are neighbours (i.e. there are links between them).  The topology of the network can also be a circle (if the dimension is wrapped).
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.SerializationProxy: Serialization.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.SerializationProxy.SerializationProxy	(	boolean	double[][]	): 
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.SerializationProxy.readResolve	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.createLinks	(	): Creates the neighbour relationships between neurons.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.getFeatures	(	int	): Retrieves the features set from the neuron at location i in the map.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.getNetwork	(	): Retrieves the underlying network. A reference is returned (enabling, for example, the network to be trained). This also implies that calling methods that modify the Network topology may cause this class to become inconsistent.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.getSize	(	): Gets the number of neurons.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.readObject	(	ObjectInputStream	): Prevents proxy bypass.
org.apache.commons.math4.ml.neuralnet.oned.NeuronString.writeReplace	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.oned.NeuronStringTest: Tests for NeuronString and Network functionality for a one-dimensional network.
org.apache.commons.math4.ml.neuralnet.sofm.City: A city, represented by a name and two-dimensional coordinates.
org.apache.commons.math4.ml.neuralnet.sofm.City.City	(	String	double	double	): 
org.apache.commons.math4.ml.neuralnet.sofm.City.distance	(	double	double	): Computes the distance between this city and the given point.
org.apache.commons.math4.ml.neuralnet.sofm.City.equals	(	Object	):  
org.apache.commons.math4.ml.neuralnet.sofm.City.getCoordinates	(	): 
org.apache.commons.math4.ml.neuralnet.sofm.City.getName	(	): 
org.apache.commons.math4.ml.neuralnet.sofm.City.hashCode	(	):  
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTask: Trainer for Kohonen's Self-Organizing Map.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTask.KohonenTrainingTask	(	Network	Iterator	KohonenUpdateAction	): Creates a (sequential) trainer for the given network.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTask.run	(	): 
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTaskTest: Tests for KohonenTrainingTask
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTaskTest.computeTravelDistance	(	City[]	): Compute the distance covered by the salesman, including the trip back (from the last to first city).
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTaskTest.printSummary	(	String	TravellingSalesmanSolver	): Prints a summary of the current state of the solver to the given filename.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTaskTest.travelCoordinatesTable	(	TravellingSalesmanSolver	): Creates a map of the travel suggested by the solver.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTaskTest.uniqueCities	(	City[]	): Compute the distance covered by the salesman, including the trip back (from the last to first city).
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction: Update formula for  Kohonen's Self-Organizing Map.  The update() method modifies the features w of the "winning" neuron and its neighbours according to the following rule:  wnew = wold + α e(-d / σ) * (sample - wold)  where  α is the current learning rate,  σ is the current neighbourhood size, and d is the number of links to traverse in order to reach the neuron from the winning neuron.   This class is thread-safe as long as the arguments passed to the KohonenUpdateAction() constructor are instances of thread-safe classes.  Each call to the update() method will increment the internal counter used to compute the current values for  the learning rate, and the neighbourhood size.  Consequently, the function instances that compute those values (passed to the constructor of this class) must take into account whether this class's instance will be shared by multiple threads, as this will impact the training process.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.KohonenUpdateAction	(	DistanceMeasure	LearningFactorFunction	NeighbourhoodSizeFunction	): 
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.attemptNeuronUpdate	(	Neuron	double[]	double	): Tries to update a neuron.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.computeFeatures	(	double[]	double[]	double	): Computes the new value of the features set.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.findAndUpdateBestNeuron	(	Network	double[]	double	): Searches for the neuron whose features are closest to the given sample, and atomically updates its features.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.getNumberOfCalls	(	): Retrieves the number of calls to the update() method.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.update	(	Network	double[]	): Updates the network in response to the sample features.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateAction.updateNeighbouringNeuron	(	Neuron	double[]	double	): Atomically updates the given neuron.
org.apache.commons.math4.ml.neuralnet.sofm.KohonenUpdateActionTest: Tests for KohonenUpdateAction class.
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunction: Provides the learning rate as a function of the number of calls already performed during the learning task.
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunction.value	(	long	): Computes the learning rate at the current call.
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunctionFactory: Factory for creating instances of LearningFactorFunction.
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunctionFactory.LearningFactorFunctionFactory	(	): Class contains only static methods. 
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunctionFactory.exponentialDecay	(	double	double	long	): Creates an exponential decay LearningFactorFunction function. It will compute a e-x / b, where x is the (integer) independent variable and  a = initValue b = -numCall / ln(valueAtNumCall / initValue) 
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunctionFactory.quasiSigmoidDecay	(	double	double	long	): Creates an sigmoid-like LearningFactorFunction function. The function f will have the following properties:  f(0) = initValue numCall is the inflexion point slope = f'(numCall) 
org.apache.commons.math4.ml.neuralnet.sofm.LearningFactorFunctionFactoryTest: Tests for LearningFactorFunctionFactory class.
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunction: Provides the network neighbourhood's size as a function of the number of calls already performed during the learning task. The "neighbourhood" is the set of neurons that can be reached by traversing at most the number of links returned by this function.
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunction.value	(	long	): Computes the neighbourhood size at the current call.
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunctionFactory: Factory for creating instances of NeighbourhoodSizeFunction.
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunctionFactory.NeighbourhoodSizeFunctionFactory	(	): Class contains only static methods. 
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunctionFactory.exponentialDecay	(	double	double	long	): Creates an exponential decay NeighbourhoodSizeFunction function. It will compute a e-x / b, where x is the (integer) independent variable and  a = initValue b = -numCall / ln(valueAtNumCall / initValue) 
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunctionFactory.quasiSigmoidDecay	(	double	double	long	): Creates an sigmoid-like NeighbourhoodSizeFunction function. The function f will have the following properties:  f(0) = initValue numCall is the inflexion point slope = f'(numCall) 
org.apache.commons.math4.ml.neuralnet.sofm.NeighbourhoodSizeFunctionFactoryTest: Tests for NeighbourhoodSizeFunctionFactory class.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver: Solves the "Travelling Salesman's Problem" (i.e. trying to find the sequence of cities that minimizes the travel distance) using a 1D SOFM.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.TravellingSalesmanSolver	(	City[]	double	): 
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.TravellingSalesmanSolver	(	City[]	double	long	): 
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.barycentre	(	Set	): Computes the barycentre of all city locations.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.computeUpdateRatio	(	Network	): Measures the network's concurrent update performance.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.createParallelTasks	(	int	long	): Creates training tasks.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.createRandomIterator	(	long	): Creates an iterator that will present a series of city's coordinates in a random order.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.createSequentialTask	(	long	): Creates a training task.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.getCityList	(	): Returns the travel proposed by the solver. Note: cities can be missing or duplicated.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.getClosestCity	(	double	double	): 
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.getCoordinatesList	(	): 
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.getNeuronList	(	): 
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.getUpdateRatio	(	): Measures the network's concurrent update performance.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.largestDistance	(	double	double	Set	): Computes the largest distance between the point at coordinates (x, y) and any of the cities.
org.apache.commons.math4.ml.neuralnet.sofm.TravellingSalesmanSolver.makeInitializers	(	): Creates the features' initializers: an approximate circle around the barycentre of the cities.
org.apache.commons.math4.ml.neuralnet.sofm.util.ExponentialDecayFunction: Exponential decay function: a e-x / b, where x is the (integer) independent variable.  Class is immutable.
org.apache.commons.math4.ml.neuralnet.sofm.util.ExponentialDecayFunction.ExponentialDecayFunction	(	double	double	long	): Creates an instance. It will be such that  a = initValue b = -numCall / ln(valueAtNumCall / initValue) 
org.apache.commons.math4.ml.neuralnet.sofm.util.ExponentialDecayFunction.value	(	long	): Computes a e-numCall / b.
org.apache.commons.math4.ml.neuralnet.sofm.util.ExponentialDecayFunctionTest: Tests for ExponentialDecayFunction class
org.apache.commons.math4.ml.neuralnet.sofm.util.QuasiSigmoidDecayFunction: Decay function whose shape is similar to a sigmoid.  Class is immutable.
org.apache.commons.math4.ml.neuralnet.sofm.util.QuasiSigmoidDecayFunction.QuasiSigmoidDecayFunction	(	double	double	long	): Creates an instance. The function f will have the following properties:  f(0) = initValue numCall is the inflexion point slope = f'(numCall) 
org.apache.commons.math4.ml.neuralnet.sofm.util.QuasiSigmoidDecayFunction.value	(	long	): Computes the value of the learning factor.
org.apache.commons.math4.ml.neuralnet.sofm.util.QuasiSigmoidDecayFunctionTest: Tests for QuasiSigmoidDecayFunction class
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D: Neural network with the topology of a two-dimensional surface. Each neuron defines one surface element.  This network is primarily intended to represent a  Self Organizing Feature Map.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.NeuronSquareMesh2D	(	boolean	boolean	SquareNeighbourhood	Network	long[][]	): Constructor with restricted access, solely used for making a copy() deep copy.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.NeuronSquareMesh2D	(	boolean	boolean	SquareNeighbourhood	double[][][]	): Constructor with restricted access, solely used for deserialization.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.NeuronSquareMesh2D	(	int	boolean	int	boolean	SquareNeighbourhood	FeatureInitializer[]	): Creates a two-dimensional network composed of square cells: Each neuron not located on the border of the mesh has four neurons linked to it.  The links are bi-directional.  The topology of the network can also be a cylinder (if one of the dimensions is wrapped) or a torus (if both dimensions are wrapped).
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.SerializationProxy: Serialization.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.SerializationProxy.SerializationProxy	(	boolean	boolean	SquareNeighbourhood	double[][][]	): 
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.SerializationProxy.readResolve	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.copy	(	): Performs a deep copy of this instance. Upon return, the copied and original instances will be independent: Updating one will not affect the other.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.createLinks	(	): Creates the neighbour relationships between neurons.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.getLocation	(	int	int	HorizontalDirection	VerticalDirection	): Computes the location of a neighbouring neuron. Returns null if the resulting location is not part of the map. Position (0, 0) is at the upper-left corner of the map.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.getNetwork	(	): Retrieves the underlying network. A reference is returned (enabling, for example, the network to be trained). This also implies that calling methods that modify the Network topology may cause this class to become inconsistent.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.getNeuron	(	int	int	): Retrieves the neuron at location (i, j) in the map. The neuron at position (0, 0) is located at the upper-left corner of the map.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.getNeuron	(	int	int	HorizontalDirection	VerticalDirection	): Retrieves the requested neuron relative to the given (row, col) position. The neuron at position (0, 0) is located at the upper-left corner of the map.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.getNumberOfColumns	(	): Gets the number of neurons in each column of this map.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.getNumberOfRows	(	): Gets the number of neurons in each row of this map.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.iterator	(	):  
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.readObject	(	ObjectInputStream	): Prevents proxy bypass.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2D.writeReplace	(	): Custom serialization.
org.apache.commons.math4.ml.neuralnet.twod.NeuronSquareMesh2DTest: Tests for NeuronSquareMesh2D and Network functionality for a two-dimensional network.
org.apache.commons.math4.ml.neuralnet.twod.util.HitHistogram: Computes the hit histogram. Each bin will contain the number of data for which the corresponding neuron is the best matching unit.
org.apache.commons.math4.ml.neuralnet.twod.util.HitHistogram.HitHistogram	(	boolean	DistanceMeasure	): 
org.apache.commons.math4.ml.neuralnet.twod.util.HitHistogram.computeImage	(	NeuronSquareMesh2D	Iterable	): Creates an image of the data metrics when represented by the map. 
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder: Helper class to find the grid coordinates of a neuron.
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder.Location: Container holding a (row, column) pair.
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder.Location.Location	(	int	int	): 
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder.Location.getColumn	(	): 
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder.Location.getRow	(	): 
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder.LocationFinder	(	NeuronSquareMesh2D	): Builds a finder to retrieve the locations of neurons that belong to the given map.
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinder.getLocation	(	Neuron	): Retrieves a neuron's grid coordinates.
org.apache.commons.math4.ml.neuralnet.twod.util.LocationFinderTest: Test for LocationFinder.
org.apache.commons.math4.ml.neuralnet.twod.util.MapDataVisualization: Interface for algorithms that compute some metrics of the projection of data on a 2D-map.
org.apache.commons.math4.ml.neuralnet.twod.util.MapDataVisualization.computeImage	(	NeuronSquareMesh2D	Iterable	): Creates an image of the data metrics when represented by the map.
org.apache.commons.math4.ml.neuralnet.twod.util.MapVisualization: Interface for algorithms that compute some property of a 2D-map.
org.apache.commons.math4.ml.neuralnet.twod.util.MapVisualization.computeImage	(	NeuronSquareMesh2D	): Creates an image of the map.
org.apache.commons.math4.ml.neuralnet.twod.util.QuantizationError: Computes the quantization error histogram. Each bin will contain the average of the distances between samples mapped to the corresponding unit and the weight vector of that unit.
org.apache.commons.math4.ml.neuralnet.twod.util.QuantizationError.QuantizationError	(	DistanceMeasure	): 
org.apache.commons.math4.ml.neuralnet.twod.util.QuantizationError.computeImage	(	NeuronSquareMesh2D	Iterable	): Creates an image of the data metrics when represented by the map. 
org.apache.commons.math4.ml.neuralnet.twod.util.SmoothedDataHistogram: Visualization of high-dimensional data projection on a 2D-map. The method is described in  Using Smoothed Data Histograms for Cluster Visualization in Self-Organizing Maps  by Elias Pampalk, Andreas Rauber and Dieter Merkl. 
org.apache.commons.math4.ml.neuralnet.twod.util.SmoothedDataHistogram.SmoothedDataHistogram	(	int	DistanceMeasure	): 
org.apache.commons.math4.ml.neuralnet.twod.util.SmoothedDataHistogram.computeImage	(	NeuronSquareMesh2D	Iterable	): Creates an image of the data metrics when represented by the map.
org.apache.commons.math4.ml.neuralnet.twod.util.TopographicErrorHistogram: Computes the topographic error histogram. Each bin will contain the number of data for which the first and second best matching units are not adjacent in the map.
org.apache.commons.math4.ml.neuralnet.twod.util.TopographicErrorHistogram.TopographicErrorHistogram	(	boolean	DistanceMeasure	): 
org.apache.commons.math4.ml.neuralnet.twod.util.TopographicErrorHistogram.computeImage	(	NeuronSquareMesh2D	Iterable	): Creates an image of the data metrics when represented by the map. 
org.apache.commons.math4.ml.neuralnet.twod.util.UnifiedDistanceMatrix: U-Matrix visualization of high-dimensional data projection.
org.apache.commons.math4.ml.neuralnet.twod.util.UnifiedDistanceMatrix.UnifiedDistanceMatrix	(	boolean	DistanceMeasure	): Simple constructor.
org.apache.commons.math4.ml.neuralnet.twod.util.UnifiedDistanceMatrix.averageDistances	(	NeuronSquareMesh2D	): Computes the distances between a unit of the map and its neighbours.
org.apache.commons.math4.ml.neuralnet.twod.util.UnifiedDistanceMatrix.computeImage	(	NeuronSquareMesh2D	): Creates an image of the map. 
org.apache.commons.math4.ml.neuralnet.twod.util.UnifiedDistanceMatrix.individualDistances	(	NeuronSquareMesh2D	): Computes the distances between a unit of the map and its neighbours. The image will contain more pixels than the number of neurons in the given map because each neuron has 8 neighbours. The value zero will be stored in the pixels corresponding to the location of a map unit.
org.apache.commons.math4.ode.AbstractFieldIntegrator: Base class managing common boilerplate for all integrators.
org.apache.commons.math4.ode.AbstractFieldIntegrator.AbstractFieldIntegrator	(	Field	String	): Build an instance.
org.apache.commons.math4.ode.AbstractFieldIntegrator.acceptStep	(	AbstractFieldStepInterpolator	T	): Accept a step, triggering events and step handlers.
org.apache.commons.math4.ode.AbstractFieldIntegrator.addEventHandler	(	FieldEventHandler	double	double	int	): Add an event handler to the integrator.  The default solver is a 5th order org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver.  
org.apache.commons.math4.ode.AbstractFieldIntegrator.addEventHandler	(	FieldEventHandler	double	double	int	BracketedRealFieldUnivariateSolver	): Add an event handler to the integrator. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.addStepHandler	(	FieldStepHandler	): Add a step handler to this integrator. The handler will be called by the integrator for each accepted step. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.clearEventHandlers	(	): Remove all the event handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.clearStepHandlers	(	): Remove all the step handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.computeDerivatives	(	T	T[]	): Compute the derivatives and check the number of evaluations.
org.apache.commons.math4.ode.AbstractFieldIntegrator.getCurrentSignedStepsize	(	): Get the current signed value of the integration stepsize. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the signed value of the current stepsize that is tried is needed. The result is undefined if the method is called outside of calls to integrate. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.getCurrentStepStart	(	): Get the current value of the step start time ti. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the value of the current step that is attempted is needed. The result is undefined if the method is called outside of calls to integrate. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.getEquations	(	): Get the differential equations to integrate.
org.apache.commons.math4.ode.AbstractFieldIntegrator.getEvaluations	(	): Get the number of evaluations of the differential equations function.  The number of evaluations corresponds to the last call to the integrate method. It is 0 if the method has not been called yet.  
org.apache.commons.math4.ode.AbstractFieldIntegrator.getEvaluationsCounter	(	): Get the evaluations counter.
org.apache.commons.math4.ode.AbstractFieldIntegrator.getEventHandlers	(	): Get all the event handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.getField	(	): Get the field to which state vector elements belong.
org.apache.commons.math4.ode.AbstractFieldIntegrator.getMaxEvaluations	(	): Get the maximal number of functions evaluations. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.getName	(	): Get the name of the method. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.getStepHandlers	(	): Get all the step handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.getStepSize	(	): Get the current step size.
org.apache.commons.math4.ode.AbstractFieldIntegrator.getStepStart	(	): Getcurrent step start.
org.apache.commons.math4.ode.AbstractFieldIntegrator.initIntegration	(	FieldExpandableODE	T	T[]	T	): Prepare the start of an integration.
org.apache.commons.math4.ode.AbstractFieldIntegrator.isLastStep	(	): Check if this step is the last one.
org.apache.commons.math4.ode.AbstractFieldIntegrator.resetOccurred	(	): Check if a reset occurred while last step was accepted.
org.apache.commons.math4.ode.AbstractFieldIntegrator.sanityChecks	(	FieldODEState	T	): Check the integration span.
org.apache.commons.math4.ode.AbstractFieldIntegrator.setIsLastStep	(	boolean	): Set the last state flag.
org.apache.commons.math4.ode.AbstractFieldIntegrator.setMaxEvaluations	(	int	): Set the maximal number of differential equations function evaluations. The purpose of this method is to avoid infinite loops which can occur for example when stringent error constraints are set or when lots of discrete events are triggered, thus leading to many rejected steps. 
org.apache.commons.math4.ode.AbstractFieldIntegrator.setStateInitialized	(	boolean	): Set the stateInitialized flag. This method must be called by integrators with the value false before they start integration, so a proper lazy initialization is done automatically on the first step.
org.apache.commons.math4.ode.AbstractFieldIntegrator.setStepSize	(	T	): Set the current step size.
org.apache.commons.math4.ode.AbstractFieldIntegrator.setStepStart	(	FieldODEStateAndDerivative	): Set current step start.
org.apache.commons.math4.ode.AbstractIntegrator: Base class managing common boilerplate for all integrators.
org.apache.commons.math4.ode.AbstractIntegrator.AbstractIntegrator	(	): Build an instance with a null name.
org.apache.commons.math4.ode.AbstractIntegrator.AbstractIntegrator	(	String	): Build an instance.
org.apache.commons.math4.ode.AbstractIntegrator.acceptStep	(	AbstractStepInterpolator	double[]	double[]	double	): Accept a step, triggering events and step handlers.
org.apache.commons.math4.ode.AbstractIntegrator.addEventHandler	(	EventHandler	double	double	int	): Add an event handler to the integrator. Uses a default UnivariateSolver with an absolute accuracy equal to the given convergence threshold, as root-finding algorithm to detect the state events. 
org.apache.commons.math4.ode.AbstractIntegrator.addEventHandler	(	EventHandler	double	double	int	UnivariateSolver	): Add an event handler to the integrator. 
org.apache.commons.math4.ode.AbstractIntegrator.addStepHandler	(	StepHandler	): Add a step handler to this integrator. The handler will be called by the integrator for each accepted step. 
org.apache.commons.math4.ode.AbstractIntegrator.clearEventHandlers	(	): Remove all the event handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractIntegrator.clearStepHandlers	(	): Remove all the step handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractIntegrator.computeDerivatives	(	double	double[]	double[]	): Compute the derivatives and check the number of evaluations.
org.apache.commons.math4.ode.AbstractIntegrator.getCounter	(	): Get the evaluations counter.
org.apache.commons.math4.ode.AbstractIntegrator.getCurrentSignedStepsize	(	): Get the current signed value of the integration stepsize. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the signed value of the current stepsize that is tried is needed. The result is undefined if the method is called outside of calls to integrate. 
org.apache.commons.math4.ode.AbstractIntegrator.getCurrentStepStart	(	): Get the current value of the step start time ti. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the value of the current step that is attempted is needed. The result is undefined if the method is called outside of calls to integrate. 
org.apache.commons.math4.ode.AbstractIntegrator.getEvaluations	(	): Get the number of evaluations of the differential equations function.  The number of evaluations corresponds to the last call to the integrate method. It is 0 if the method has not been called yet.  
org.apache.commons.math4.ode.AbstractIntegrator.getEventHandlers	(	): Get all the event handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractIntegrator.getExpandable	(	): Get the differential equations to integrate.
org.apache.commons.math4.ode.AbstractIntegrator.getMaxEvaluations	(	): Get the maximal number of functions evaluations. 
org.apache.commons.math4.ode.AbstractIntegrator.getName	(	): Get the name of the method. 
org.apache.commons.math4.ode.AbstractIntegrator.getStepHandlers	(	): Get all the step handlers that have been added to the integrator. 
org.apache.commons.math4.ode.AbstractIntegrator.initIntegration	(	double	double[]	double	): Prepare the start of an integration.
org.apache.commons.math4.ode.AbstractIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.
org.apache.commons.math4.ode.AbstractIntegrator.integrate	(	FirstOrderDifferentialEquations	double	double[]	double	double[]	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe. 
org.apache.commons.math4.ode.AbstractIntegrator.sanityChecks	(	ExpandableStatefulODE	double	): Check the integration span.
org.apache.commons.math4.ode.AbstractIntegrator.setEquations	(	ExpandableStatefulODE	): Set the equations.
org.apache.commons.math4.ode.AbstractIntegrator.setMaxEvaluations	(	int	): Set the maximal number of differential equations function evaluations. The purpose of this method is to avoid infinite loops which can occur for example when stringent error constraints are set or when lots of discrete events are triggered, thus leading to many rejected steps. 
org.apache.commons.math4.ode.AbstractIntegrator.setStateInitialized	(	boolean	): Set the stateInitialized flag. This method must be called by integrators with the value false before they start integration, so a proper lazy initialization is done automatically on the first step.
org.apache.commons.math4.ode.AbstractParameterizable: This abstract class provides boilerplate parameters list.
org.apache.commons.math4.ode.AbstractParameterizable.AbstractParameterizable	(	Collection	): Simple constructor.
org.apache.commons.math4.ode.AbstractParameterizable.AbstractParameterizable	(	String	): Simple constructor.
org.apache.commons.math4.ode.AbstractParameterizable.complainIfNotSupported	(	String	): Check if a parameter is supported and throw an IllegalArgumentException if not.
org.apache.commons.math4.ode.AbstractParameterizable.getParametersNames	(	): Get the names of the supported parameters. 
org.apache.commons.math4.ode.AbstractParameterizable.isSupported	(	String	): Check if a parameter is supported. Supported parameters are those listed by getParametersNames(). 
org.apache.commons.math4.ode.ContinuousOutputFieldModel: This class stores all information provided by an ODE integrator during the integration process and build a continuous model of the solution from this. This class act as a step handler from the integrator point of view. It is called iteratively during the integration process and stores a copy of all steps information in a sorted collection for later use. Once the integration process is over, the user can use the getInterpolatedState() method to retrieve this information at any time. It is important to wait for the integration to be over before attempting to call getInterpolatedState() because some internal variables are set only once the last step has been handled. This is useful for example if the main loop of the user application should remain independent from the integration process or if one needs to mimic the behaviour of an analytical model despite a numerical model is used (i.e. one needs the ability to get the model value at any time or to navigate through the data). If problem modeling is done with several separate integration phases for contiguous intervals, the same ContinuousOutputModel can be used as step handler for all integration phases as long as they are performed in order and in the same direction. As an example, one can extrapolate the trajectory of a satellite with one model (i.e. one set of differential equations) up to the beginning of a maneuver, use another more complex model including thrusters modeling and accurate attitude control during the maneuver, and revert to the first model after the end of the maneuver. If the same continuous output model handles the steps of all integration phases, the user do not need to bother when the maneuver begins or ends, he has all the data available in a transparent manner. One should be aware that the amount of data stored in a ContinuousOutputFieldModel instance can be important if the state vector is large, if the integration interval is long or if the steps are small (which can result from small tolerance settings in org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator adaptive step size integrators).
org.apache.commons.math4.ode.ContinuousOutputFieldModel.ContinuousOutputFieldModel	(	): Simple constructor. Build an empty continuous output model.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.append	(	ContinuousOutputFieldModel	): Append another model at the end of the instance.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.checkDimensionsEquality	(	int	int	): Check dimensions equality.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.getFinalTime	(	): Get the final integration time.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.getInitialTime	(	): Get the initial integration time.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.getInterpolatedState	(	T	): Get the state at interpolated time.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.handleStep	(	FieldStepInterpolator	boolean	): Handle the last accepted step. A copy of the information provided by the last step is stored in the instance for later use.
org.apache.commons.math4.ode.ContinuousOutputFieldModel.init	(	FieldODEStateAndDerivative	T	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.ContinuousOutputFieldModel.locatePoint	(	T	FieldStepInterpolator	): Compare a step interval and a double.
org.apache.commons.math4.ode.ContinuousOutputModel: This class stores all information provided by an ODE integrator during the integration process and build a continuous model of the solution from this. This class act as a step handler from the integrator point of view. It is called iteratively during the integration process and stores a copy of all steps information in a sorted collection for later use. Once the integration process is over, the user can use the setInterpolatedTime and getInterpolatedState to retrieve this information at any time. It is important to wait for the integration to be over before attempting to call setInterpolatedTime because some internal variables are set only once the last step has been handled. This is useful for example if the main loop of the user application should remain independent from the integration process or if one needs to mimic the behaviour of an analytical model despite a numerical model is used (i.e. one needs the ability to get the model value at any time or to navigate through the data). If problem modeling is done with several separate integration phases for contiguous intervals, the same ContinuousOutputModel can be used as step handler for all integration phases as long as they are performed in order and in the same direction. As an example, one can extrapolate the trajectory of a satellite with one model (i.e. one set of differential equations) up to the beginning of a maneuver, use another more complex model including thrusters modeling and accurate attitude control during the maneuver, and revert to the first model after the end of the maneuver. If the same continuous output model handles the steps of all integration phases, the user do not need to bother when the maneuver begins or ends, he has all the data available in a transparent manner. An important feature of this class is that it implements the Serializable interface. This means that the result of an integration can be serialized and reused later (if stored into a persistent medium like a filesystem or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. One should be aware that the amount of data stored in a ContinuousOutputModel instance can be important if the state vector is large, if the integration interval is long or if the steps are small (which can result from small tolerance settings in org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator adaptive step size integrators).
org.apache.commons.math4.ode.ContinuousOutputModel.ContinuousOutputModel	(	): Simple constructor. Build an empty continuous output model.
org.apache.commons.math4.ode.ContinuousOutputModel.append	(	ContinuousOutputModel	): Append another model at the end of the instance.
org.apache.commons.math4.ode.ContinuousOutputModel.getFinalTime	(	): Get the final integration time.
org.apache.commons.math4.ode.ContinuousOutputModel.getInitialTime	(	): Get the initial integration time.
org.apache.commons.math4.ode.ContinuousOutputModel.getInterpolatedDerivatives	(	): Get the derivatives of the state vector of the interpolated point. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.ContinuousOutputModel.getInterpolatedSecondaryDerivatives	(	int	): Get the interpolated secondary derivatives corresponding to the secondary equations. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.ContinuousOutputModel.getInterpolatedSecondaryState	(	int	): Get the interpolated secondary state corresponding to the secondary equations. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.ContinuousOutputModel.getInterpolatedState	(	): Get the state vector of the interpolated point. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.ContinuousOutputModel.getInterpolatedTime	(	): Get the time of the interpolated point. If setInterpolatedTime has not been called, it returns the final integration time.
org.apache.commons.math4.ode.ContinuousOutputModel.handleStep	(	StepInterpolator	boolean	): Handle the last accepted step. A copy of the information provided by the last step is stored in the instance for later use.
org.apache.commons.math4.ode.ContinuousOutputModel.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.ContinuousOutputModel.locatePoint	(	double	StepInterpolator	): Compare a step interval and a double.
org.apache.commons.math4.ode.ContinuousOutputModel.setInterpolatedTime	(	double	): Set the time of the interpolated point. This method should not be called before the integration is over because some internal variables are set only once the last step has been handled. Setting the time outside of the integration interval is now allowed, but should be used with care since the accuracy of the interpolator will probably be very poor far from this interval. This allowance has been added to simplify implementation of search algorithms near the interval endpoints. Note that each time this method is called, the internal arrays returned in getInterpolatedState(), getInterpolatedDerivatives() and getInterpolatedSecondaryState() will be overwritten. So if their content must be preserved across several calls, user must copy them.
org.apache.commons.math4.ode.EquationsMapper: Class mapping the part of a complete state or derivative that pertains to a specific differential equation.  Instances of this class are guaranteed to be immutable. 
org.apache.commons.math4.ode.EquationsMapper.EquationsMapper	(	int	int	): simple constructor.
org.apache.commons.math4.ode.EquationsMapper.extractEquationData	(	double[]	double[]	): Extract equation data from a complete state or derivative array.
org.apache.commons.math4.ode.EquationsMapper.getDimension	(	): Get the dimension of the secondary state parameters.
org.apache.commons.math4.ode.EquationsMapper.getFirstIndex	(	): Get the index of the first equation element in complete state arrays.
org.apache.commons.math4.ode.EquationsMapper.insertEquationData	(	double[]	double[]	): Insert equation data into a complete state or derivative array.
org.apache.commons.math4.ode.ExpandableStatefulODE: This class represents a combined set of first order differential equations, with at least a primary set of equations expandable by some sets of secondary equations.  One typical use case is the computation of the Jacobian matrix for some ODE. In this case, the primary set of equations corresponds to the raw ODE, and we add to this set another bunch of secondary equations which represent the Jacobian matrix of the primary set.   We want the integrator to use only the primary set to estimate the errors and hence the step sizes. It should not use the secondary equations in this computation. The AbstractIntegrator integrator will be able to know where the primary set ends and so where the secondary sets begin. 
org.apache.commons.math4.ode.ExpandableStatefulODE.ExpandableStatefulODE	(	FirstOrderDifferentialEquations	): Build an expandable set from its primary ODE set.
org.apache.commons.math4.ode.ExpandableStatefulODE.SecondaryComponent: Components of the compound stateful ODE. 
org.apache.commons.math4.ode.ExpandableStatefulODE.SecondaryComponent.SecondaryComponent	(	SecondaryEquations	int	): Simple constructor.
org.apache.commons.math4.ode.ExpandableStatefulODE.addSecondaryEquations	(	SecondaryEquations	): Add a set of secondary equations to be integrated along with the primary set.
org.apache.commons.math4.ode.ExpandableStatefulODE.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the complete state vector.
org.apache.commons.math4.ode.ExpandableStatefulODE.getCompleteState	(	): Get the complete current state.
org.apache.commons.math4.ode.ExpandableStatefulODE.getPrimary	(	): Get the primary set of differential equations.
org.apache.commons.math4.ode.ExpandableStatefulODE.getPrimaryMapper	(	): Get an equations mapper for the primary equations set.
org.apache.commons.math4.ode.ExpandableStatefulODE.getPrimaryState	(	): Get primary part of the current state.
org.apache.commons.math4.ode.ExpandableStatefulODE.getPrimaryStateDot	(	): Get primary part of the current state derivative.
org.apache.commons.math4.ode.ExpandableStatefulODE.getSecondaryMappers	(	): Get the equations mappers for the secondary equations sets.
org.apache.commons.math4.ode.ExpandableStatefulODE.getSecondaryState	(	int	): Get secondary part of the current state.
org.apache.commons.math4.ode.ExpandableStatefulODE.getSecondaryStateDot	(	int	): Get secondary part of the current state derivative.
org.apache.commons.math4.ode.ExpandableStatefulODE.getTime	(	): Get current time.
org.apache.commons.math4.ode.ExpandableStatefulODE.getTotalDimension	(	): Return the dimension of the complete set of equations.  The complete set of equations correspond to the primary set plus all secondary sets. 
org.apache.commons.math4.ode.ExpandableStatefulODE.setCompleteState	(	double[]	): Set the complete current state.
org.apache.commons.math4.ode.ExpandableStatefulODE.setPrimaryState	(	double[]	): Set primary part of the current state.
org.apache.commons.math4.ode.ExpandableStatefulODE.setSecondaryState	(	int	double[]	): Set secondary part of the current state.
org.apache.commons.math4.ode.ExpandableStatefulODE.setTime	(	double	): Set current time.
org.apache.commons.math4.ode.FieldEquationsMapper: Class mapping the part of a complete state or derivative that pertains to a set of differential equations.  Instances of this class are guaranteed to be immutable. 
org.apache.commons.math4.ode.FieldEquationsMapper.FieldEquationsMapper	(	FieldEquationsMapper	int	): Create a mapper by adding a new equation to another mapper.  The new equation will have index mapper.getNumberOfEquations(), or 0 if mapper is null. 
org.apache.commons.math4.ode.FieldEquationsMapper.checkIndex	(	int	): Check equation index.
org.apache.commons.math4.ode.FieldEquationsMapper.extractEquationData	(	int	T[]	): Extract equation data from a complete state or derivative array.
org.apache.commons.math4.ode.FieldEquationsMapper.getNumberOfEquations	(	): Get the number of equations mapped.
org.apache.commons.math4.ode.FieldEquationsMapper.getTotalDimension	(	): Return the dimension of the complete set of equations.  The complete set of equations correspond to the primary set plus all secondary sets. 
org.apache.commons.math4.ode.FieldEquationsMapper.insertEquationData	(	int	T[]	T[]	): Insert equation data into a complete state or derivative array.
org.apache.commons.math4.ode.FieldEquationsMapper.mapDerivative	(	FieldODEStateAndDerivative	): Map a state derivative to a complete flat array.
org.apache.commons.math4.ode.FieldEquationsMapper.mapState	(	FieldODEState	): Map a state to a complete flat array.
org.apache.commons.math4.ode.FieldEquationsMapper.mapStateAndDerivative	(	T	T[]	T[]	): Map flat arrays to a state and derivative.
org.apache.commons.math4.ode.FieldExpandableODE: This class represents a combined set of first order differential equations, with at least a primary set of equations expandable by some sets of secondary equations.  One typical use case is the computation of the Jacobian matrix for some ODE. In this case, the primary set of equations corresponds to the raw ODE, and we add to this set another bunch of secondary equations which represent the Jacobian matrix of the primary set.   We want the integrator to use only the primary set to estimate the errors and hence the step sizes. It should not use the secondary equations in this computation. The FirstOrderFieldIntegrator integrator will be able to know where the primary set ends and so where the secondary sets begin. 
org.apache.commons.math4.ode.FieldExpandableODE.FieldExpandableODE	(	FirstOrderFieldDifferentialEquations	): Build an expandable set from its primary ODE set.
org.apache.commons.math4.ode.FieldExpandableODE.addSecondaryEquations	(	FieldSecondaryEquations	): Add a set of secondary equations to be integrated along with the primary set.
org.apache.commons.math4.ode.FieldExpandableODE.computeDerivatives	(	T	T[]	): Get the current time derivative of the complete state vector.
org.apache.commons.math4.ode.FieldExpandableODE.getMapper	(	): Get the mapper for the set of equations.
org.apache.commons.math4.ode.FieldExpandableODE.init	(	T	T[]	T	): Initialize equations at the start of an ODE integration.
org.apache.commons.math4.ode.FieldODEState: Container for time, main and secondary state vectors.
org.apache.commons.math4.ode.FieldODEState.FieldODEState	(	T	T[]	): Simple constructor. Calling this constructor is equivalent to call FieldODEState() FieldODEState(time, state, null).
org.apache.commons.math4.ode.FieldODEState.FieldODEState	(	T	T[]	T[][]	): Simple constructor.
org.apache.commons.math4.ode.FieldODEState.copy	(	Field	T[][]	): Copy a two-dimensions array.
org.apache.commons.math4.ode.FieldODEState.getNumberOfSecondaryStates	(	): Get the number of secondary states.
org.apache.commons.math4.ode.FieldODEState.getSecondaryState	(	int	): Get secondary state at time.
org.apache.commons.math4.ode.FieldODEState.getSecondaryStateDimension	(	int	): Get secondary state dimension.
org.apache.commons.math4.ode.FieldODEState.getState	(	): Get main state at time.
org.apache.commons.math4.ode.FieldODEState.getStateDimension	(	): Get main state dimension.
org.apache.commons.math4.ode.FieldODEState.getTime	(	): Get time.
org.apache.commons.math4.ode.FieldODEStateAndDerivative: Container for time, main and secondary state vectors as well as their derivatives.
org.apache.commons.math4.ode.FieldODEStateAndDerivative.FieldODEStateAndDerivative	(	T	T[]	T[]	): Simple constructor. Calling this constructor is equivalent to call FieldODEStateAndDerivative() FieldODEStateAndDerivative(time, state, derivative, null, null).
org.apache.commons.math4.ode.FieldODEStateAndDerivative.FieldODEStateAndDerivative	(	T	T[]	T[]	T[][]	T[][]	): Simple constructor.
org.apache.commons.math4.ode.FieldODEStateAndDerivative.getDerivative	(	): Get derivative of the main state at time.
org.apache.commons.math4.ode.FieldODEStateAndDerivative.getSecondaryDerivative	(	int	): Get derivative of the secondary state at time.
org.apache.commons.math4.ode.FieldSecondaryEquations: This interface allows users to add secondary differential equations to a primary set of differential equations.  In some cases users may need to integrate some problem-specific equations along with a primary set of differential equations. One example is optimal control where adjoined parameters linked to the minimized Hamiltonian must be integrated.   This interface allows users to add such equations to a primary set of FirstOrderFieldDifferentialEquations first order differential equations thanks to the addSecondaryEquations() method. 
org.apache.commons.math4.ode.FieldSecondaryEquations.computeDerivatives	(	T	T[]	T[]	T[]	): Compute the derivatives related to the secondary state parameters.
org.apache.commons.math4.ode.FieldSecondaryEquations.getDimension	(	): Get the dimension of the secondary state parameters.
org.apache.commons.math4.ode.FieldSecondaryEquations.init	(	T	T[]	T[]	T	): Initialize equations at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the equations to initialize some internal data if needed. 
org.apache.commons.math4.ode.FirstOrderConverter: This class converts second order differential equations to first order ones. This class is a wrapper around a SecondOrderDifferentialEquations which allow to use a FirstOrderIntegrator to integrate it. The transformation is done by changing the n dimension state vector to a 2n dimension vector, where the first n components are the initial state variables and the n last components are their first time derivative. The first time derivative of this state vector then really contains both the first and second time derivative of the initial state vector, which can be handled by the underlying second order equations set. One should be aware that the data is duplicated during the transformation process and that for each call to computeDerivatives, this wrapper does copy 4n scalars : 2n before the call to computeSecondDerivatives in order to dispatch the y state vector into z and zDot, and 2n after the call to gather zDot and zDDot into yDot. Since the underlying problem by itself perhaps also needs to copy data and dispatch the arrays into domain objects, this has an impact on both memory and CPU usage. The only way to avoid this duplication is to perform the transformation at the problem level, i.e. to implement the problem as a first order one and then avoid using this class.
org.apache.commons.math4.ode.FirstOrderConverter.FirstOrderConverter	(	SecondOrderDifferentialEquations	): Simple constructor. Build a converter around a second order equations set.
org.apache.commons.math4.ode.FirstOrderConverter.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the state vector.
org.apache.commons.math4.ode.FirstOrderConverter.getDimension	(	): Get the dimension of the problem. The dimension of the first order problem is twice the dimension of the underlying second order problem.
org.apache.commons.math4.ode.FirstOrderDifferentialEquations: This interface represents a first order differential equations set. This interface should be implemented by all real first order differential equation problems before they can be handled by the integrators integrate method. A first order differential equations problem, as seen by an integrator is the time derivative dY/dt of a state vector Y, both being one dimensional arrays. From the integrator point of view, this derivative depends only on the current time t and on the state vector Y. For real problems, the derivative depends also on parameters that do not belong to the state vector (dynamical model constants for example). These constants are completely outside of the scope of this interface, the classes that implement it are allowed to handle them as they want.
org.apache.commons.math4.ode.FirstOrderDifferentialEquations.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the state vector.
org.apache.commons.math4.ode.FirstOrderDifferentialEquations.getDimension	(	): Get the dimension of the problem.
org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations: This interface represents a first order differential equations set. This interface should be implemented by all real first order differential equation problems before they can be handled by the integrators integrate method. A first order differential equations problem, as seen by an integrator is the time derivative dY/dt of a state vector Y, both being one dimensional arrays. From the integrator point of view, this derivative depends only on the current time t and on the state vector Y. For real problems, the derivative depends also on parameters that do not belong to the state vector (dynamical model constants for example). These constants are completely outside of the scope of this interface, the classes that implement it are allowed to handle them as they want.
org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations.computeDerivatives	(	T	T[]	): Get the current time derivative of the state vector.
org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations.getDimension	(	): Get the dimension of the problem.
org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations.init	(	T	T[]	T	): Initialize equations at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the equations to initialize some internal data if needed. 
org.apache.commons.math4.ode.FirstOrderFieldIntegrator: This interface represents a first order integrator for differential equations. The classes which are devoted to solve first order differential equations should implement this interface. The problems which can be handled should implement the FirstOrderDifferentialEquations interface.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.addEventHandler	(	FieldEventHandler	double	double	int	): Add an event handler to the integrator.  The default solver is a 5th order org.apache.commons.math4.analysis.solvers.FieldBracketingNthOrderBrentSolver. 
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.addEventHandler	(	FieldEventHandler	double	double	int	BracketedRealFieldUnivariateSolver	): Add an event handler to the integrator.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.addStepHandler	(	FieldStepHandler	): Add a step handler to this integrator. The handler will be called by the integrator for each accepted step.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.clearEventHandlers	(	): Remove all the event handlers that have been added to the integrator.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.clearStepHandlers	(	): Remove all the step handlers that have been added to the integrator.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getCurrentSignedStepsize	(	): Get the current signed value of the integration stepsize. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the signed value of the current stepsize that is tried is needed. The result is undefined if the method is called outside of calls to integrate.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getCurrentStepStart	(	): Get the current value of the step start time ti. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the value of the current step that is attempted is needed. The result is undefined if the method is called outside of calls to integrate.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getEvaluations	(	): Get the number of evaluations of the differential equations function.  The number of evaluations corresponds to the last call to the integrate method. It is 0 if the method has not been called yet. 
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getEventHandlers	(	): Get all the event handlers that have been added to the integrator.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getMaxEvaluations	(	): Get the maximal number of functions evaluations.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getName	(	): Get the name of the method.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.getStepHandlers	(	): Get all the step handlers that have been added to the integrator.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.integrate	(	FieldExpandableODE	FieldODEState	T	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.
org.apache.commons.math4.ode.FirstOrderFieldIntegrator.setMaxEvaluations	(	int	): Set the maximal number of differential equations function evaluations. The purpose of this method is to avoid infinite loops which can occur for example when stringent error constraints are set or when lots of discrete events are triggered, thus leading to many rejected steps.
org.apache.commons.math4.ode.FirstOrderIntegrator: This interface represents a first order integrator for differential equations. The classes which are devoted to solve first order differential equations should implement this interface. The problems which can be handled should implement the FirstOrderDifferentialEquations interface.
org.apache.commons.math4.ode.FirstOrderIntegrator.integrate	(	FirstOrderDifferentialEquations	double	double[]	double	double[]	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.
org.apache.commons.math4.ode.JacobianMatrices: This class defines a set of SecondaryEquations secondary equations to compute the Jacobian matrices with respect to the initial state vector and, if any, to some parameters of the primary ODE set.  It is intended to be packed into an ExpandableStatefulODE in conjunction with a primary set of ODE, which may be:  a FirstOrderDifferentialEquations a MainStateJacobianProvider  In order to compute Jacobian matrices with respect to some parameters of the primary ODE set, the following parameter Jacobian providers may be set:  a ParameterJacobianProvider a ParameterizedODE 
org.apache.commons.math4.ode.JacobianMatrices.JacobianMatrices	(	FirstOrderDifferentialEquations	double[]	String	): Simple constructor for a secondary equations set computing Jacobian matrices.  Parameters must belong to the supported ones given by getParametersNames(), so the primary set of differential equations must be Parameterizable.  Note that each selection clears the previous selected parameters.
org.apache.commons.math4.ode.JacobianMatrices.JacobianMatrices	(	MainStateJacobianProvider	String	): Simple constructor for a secondary equations set computing Jacobian matrices.  Parameters must belong to the supported ones given by getParametersNames(), so the primary set of differential equations must be Parameterizable.  Note that each selection clears the previous selected parameters.
org.apache.commons.math4.ode.JacobianMatrices.JacobiansSecondaryEquations: Local implementation of secondary equations.  This class is an inner class to ensure proper scheduling of calls by forcing the use of registerVariationalEquations(). 
org.apache.commons.math4.ode.JacobianMatrices.JacobiansSecondaryEquations.computeDerivatives	(	double	double[]	double[]	double[]	double[]	): Compute the derivatives related to the secondary state parameters. 
org.apache.commons.math4.ode.JacobianMatrices.JacobiansSecondaryEquations.getDimension	(	): Get the dimension of the secondary state parameters. 
org.apache.commons.math4.ode.JacobianMatrices.MainStateJacobianWrapper: Wrapper class to compute jacobian matrices by finite differences for ODE which do not compute them by themselves.
org.apache.commons.math4.ode.JacobianMatrices.MainStateJacobianWrapper.MainStateJacobianWrapper	(	FirstOrderDifferentialEquations	double[]	): Wrap a FirstOrderDifferentialEquations into a MainStateJacobianProvider.
org.apache.commons.math4.ode.JacobianMatrices.MainStateJacobianWrapper.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the state vector. 
org.apache.commons.math4.ode.JacobianMatrices.MainStateJacobianWrapper.computeMainStateJacobian	(	double	double[]	double[]	double[][]	): Compute the jacobian matrix of ODE with respect to main state. 
org.apache.commons.math4.ode.JacobianMatrices.MainStateJacobianWrapper.getDimension	(	): Get the dimension of the problem. 
org.apache.commons.math4.ode.JacobianMatrices.MismatchedEquations: Special exception for equations mismatch.
org.apache.commons.math4.ode.JacobianMatrices.MismatchedEquations.MismatchedEquations	(	): Simple constructor. 
org.apache.commons.math4.ode.JacobianMatrices.addParameterJacobianProvider	(	ParameterJacobianProvider	): Add a parameter Jacobian provider.
org.apache.commons.math4.ode.JacobianMatrices.checkDimension	(	int	Object	): Check array dimensions.
org.apache.commons.math4.ode.JacobianMatrices.getCurrentMainSetJacobian	(	double[][]	): Get the current value of the Jacobian matrix with respect to state.
org.apache.commons.math4.ode.JacobianMatrices.getCurrentParameterJacobian	(	String	double[]	): Get the current value of the Jacobian matrix with respect to one parameter.
org.apache.commons.math4.ode.JacobianMatrices.registerVariationalEquations	(	ExpandableStatefulODE	): Register the variational equations for the Jacobians matrices to the expandable set.
org.apache.commons.math4.ode.JacobianMatrices.setInitialMainStateJacobian	(	double[][]	): Set the initial value of the Jacobian matrix with respect to state.  If this method is not called, the initial value of the Jacobian matrix with respect to state is set to identity. 
org.apache.commons.math4.ode.JacobianMatrices.setInitialParameterJacobian	(	String	double[]	): Set the initial value of a column of the Jacobian matrix with respect to one parameter.  If this method is not called for some parameter, the initial value of the column of the Jacobian matrix with respect to this parameter is set to zero. 
org.apache.commons.math4.ode.JacobianMatrices.setParameterStep	(	String	double	): Set the step associated to a parameter in order to compute by finite difference the Jacobian matrix.  Needed if and only if the primary ODE set is a ParameterizedODE.   Given a non zero parameter value pval for the parameter, a reasonable value for such a step is pval * FastMath.sqrt(Precision.EPSILON).   A zero value for such a step doesn't enable to compute the parameter Jacobian matrix. 
org.apache.commons.math4.ode.JacobianMatrices.setParameterizedODE	(	ParameterizedODE	): Set a parameter Jacobian provider.
org.apache.commons.math4.ode.JacobianMatricesTest.Circle: ODE representing a point moving on a circle with provided center and angular rate. 
org.apache.commons.math4.ode.JacobianMatricesTest.ParamBrusselator.getParameter	(	String	): Get parameter value from its name. 
org.apache.commons.math4.ode.JacobianMatricesTest.ParamBrusselator.setParameter	(	String	double	): Set the value for a given parameter. 
org.apache.commons.math4.ode.JacobianMatricesTest.ParameterizedCircle: ODE representing a point moving on a circle with provided center and angular rate. 
org.apache.commons.math4.ode.MainStateJacobianProvider: Interface expanding FirstOrderDifferentialEquations first order differential equations in order to compute exactly the main state jacobian matrix for JacobianMatrices partial derivatives equations.
org.apache.commons.math4.ode.MainStateJacobianProvider.computeMainStateJacobian	(	double	double[]	double[]	double[][]	): Compute the jacobian matrix of ODE with respect to main state.
org.apache.commons.math4.ode.MultistepFieldIntegrator: This class is the base class for multistep integrators for Ordinary Differential Equations. We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  Rather than storing several previous steps separately, this implementation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step (yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (we omit the k index in the notation for clarity)  Multistep integrators with Nordsieck representation are highly sensitive to large step changes because when the step is multiplied by factor a, the kth component of the Nordsieck vector is multiplied by ak and the last components are the least accurate ones. The default max growth factor is therefore set to a quite low value: 21/order. 
org.apache.commons.math4.ode.MultistepFieldIntegrator.FieldNordsieckInitializer: Specialized step handler storing the first step.
org.apache.commons.math4.ode.MultistepFieldIntegrator.FieldNordsieckInitializer.FieldNordsieckInitializer	(	FieldEquationsMapper	int	): Simple constructor.
org.apache.commons.math4.ode.MultistepFieldIntegrator.FieldNordsieckInitializer.handleStep	(	FieldStepInterpolator	boolean	): Handle the last accepted step 
org.apache.commons.math4.ode.MultistepFieldIntegrator.FieldNordsieckInitializer.init	(	FieldODEStateAndDerivative	T	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.MultistepFieldIntegrator.InitializationCompletedMarkerException: Marker exception used ONLY to stop the starter integrator after first step. 
org.apache.commons.math4.ode.MultistepFieldIntegrator.InitializationCompletedMarkerException.InitializationCompletedMarkerException	(	): Simple constructor. 
org.apache.commons.math4.ode.MultistepFieldIntegrator.MultistepFieldIntegrator	(	Field	String	int	int	double	double	double	double	): Build a multistep integrator with the given stepsize bounds. The default starter integrator is set to the DormandPrince853FieldIntegrator Dormand-Prince 8(5,3) integrator with some defaults settings.  The default max growth factor is set to a quite low value: 21/order. 
org.apache.commons.math4.ode.MultistepFieldIntegrator.MultistepFieldIntegrator	(	Field	String	int	int	double	double	double[]	double[]	): Build a multistep integrator with the given stepsize bounds. The default starter integrator is set to the DormandPrince853FieldIntegrator Dormand-Prince 8(5,3) integrator with some defaults settings.  The default max growth factor is set to a quite low value: 21/order. 
org.apache.commons.math4.ode.MultistepFieldIntegrator.computeStepGrowShrinkFactor	(	T	): Compute step grow/shrink factor according to normalized error.
org.apache.commons.math4.ode.MultistepFieldIntegrator.getMaxGrowth	(	): Get the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.MultistepFieldIntegrator.getMinReduction	(	): Get the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.MultistepFieldIntegrator.getNSteps	(	): Get the number of steps of the multistep method (excluding the one being computed).
org.apache.commons.math4.ode.MultistepFieldIntegrator.getSafety	(	): Get the safety factor for stepsize control.
org.apache.commons.math4.ode.MultistepFieldIntegrator.getStarterIntegrator	(	): Get the starter integrator.
org.apache.commons.math4.ode.MultistepFieldIntegrator.initializeHighOrderDerivatives	(	T	T[]	T[][]	T[][]	): Initialize the high order scaled derivatives at step start.
org.apache.commons.math4.ode.MultistepFieldIntegrator.rescale	(	T	): Rescale the instance. Since the scaled and Nordsieck arrays are shared with the caller, this method has the side effect of rescaling this arrays in the caller too.
org.apache.commons.math4.ode.MultistepFieldIntegrator.setMaxGrowth	(	double	): Set the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.MultistepFieldIntegrator.setMinReduction	(	double	): Set the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.MultistepFieldIntegrator.setSafety	(	double	): Set the safety factor for stepsize control.
org.apache.commons.math4.ode.MultistepFieldIntegrator.setStarterIntegrator	(	FirstOrderFieldIntegrator	): Set the starter integrator. The various step and event handlers for this starter integrator will be managed automatically by the multi-step integrator. Any user configuration for these elements will be cleared before use.
org.apache.commons.math4.ode.MultistepFieldIntegrator.start	(	FieldExpandableODE	FieldODEState	T	): Start the integration. This method computes one step using the underlying starter integrator, and initializes the Nordsieck vector at step start. The starter integrator purpose is only to establish initial conditions, it does not really change time by itself. The top level multistep integrator remains in charge of handling time propagation and events handling as it will starts its own computation right from the beginning. In a sense, the starter integrator can be seen as a dummy one and so it will never trigger any user event nor call any user step handler.
org.apache.commons.math4.ode.MultistepIntegrator: This class is the base class for multistep integrators for Ordinary Differential Equations. We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  Rather than storing several previous steps separately, this implementation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step (yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (we omit the k index in the notation for clarity)  Multistep integrators with Nordsieck representation are highly sensitive to large step changes because when the step is multiplied by factor a, the kth component of the Nordsieck vector is multiplied by ak and the last components are the least accurate ones. The default max growth factor is therefore set to a quite low value: 21/order. 
org.apache.commons.math4.ode.MultistepIntegrator.InitializationCompletedMarkerException: Marker exception used ONLY to stop the starter integrator after first step. 
org.apache.commons.math4.ode.MultistepIntegrator.InitializationCompletedMarkerException.InitializationCompletedMarkerException	(	): Simple constructor. 
org.apache.commons.math4.ode.MultistepIntegrator.MultistepIntegrator	(	String	int	int	double	double	double	double	): Build a multistep integrator with the given stepsize bounds. The default starter integrator is set to the DormandPrince853Integrator Dormand-Prince 8(5,3) integrator with some defaults settings.  The default max growth factor is set to a quite low value: 21/order. 
org.apache.commons.math4.ode.MultistepIntegrator.MultistepIntegrator	(	String	int	int	double	double	double[]	double[]	): Build a multistep integrator with the given stepsize bounds. The default starter integrator is set to the DormandPrince853Integrator Dormand-Prince 8(5,3) integrator with some defaults settings.  The default max growth factor is set to a quite low value: 21/order. 
org.apache.commons.math4.ode.MultistepIntegrator.NordsieckInitializer: Specialized step handler storing the first step. 
org.apache.commons.math4.ode.MultistepIntegrator.NordsieckInitializer.NordsieckInitializer	(	int	int	): Simple constructor.
org.apache.commons.math4.ode.MultistepIntegrator.NordsieckInitializer.handleStep	(	StepInterpolator	boolean	): Handle the last accepted step 
org.apache.commons.math4.ode.MultistepIntegrator.NordsieckInitializer.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.MultistepIntegrator.NordsieckTransformer: Transformer used to convert the first step to Nordsieck representation.
org.apache.commons.math4.ode.MultistepIntegrator.NordsieckTransformer.initializeHighOrderDerivatives	(	double	double[]	double[][]	double[][]	): Initialize the high order scaled derivatives at step start.
org.apache.commons.math4.ode.MultistepIntegrator.computeStepGrowShrinkFactor	(	double	): Compute step grow/shrink factor according to normalized error.
org.apache.commons.math4.ode.MultistepIntegrator.getMaxGrowth	(	): Get the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.MultistepIntegrator.getMinReduction	(	): Get the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.MultistepIntegrator.getNSteps	(	): Get the number of steps of the multistep method (excluding the one being computed).
org.apache.commons.math4.ode.MultistepIntegrator.getSafety	(	): Get the safety factor for stepsize control.
org.apache.commons.math4.ode.MultistepIntegrator.getStarterIntegrator	(	): Get the starter integrator.
org.apache.commons.math4.ode.MultistepIntegrator.initializeHighOrderDerivatives	(	double	double[]	double[][]	double[][]	): Initialize the high order scaled derivatives at step start.
org.apache.commons.math4.ode.MultistepIntegrator.setMaxGrowth	(	double	): Set the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.MultistepIntegrator.setMinReduction	(	double	): Set the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.MultistepIntegrator.setSafety	(	double	): Set the safety factor for stepsize control.
org.apache.commons.math4.ode.MultistepIntegrator.setStarterIntegrator	(	FirstOrderIntegrator	): Set the starter integrator. The various step and event handlers for this starter integrator will be managed automatically by the multi-step integrator. Any user configuration for these elements will be cleared before use.
org.apache.commons.math4.ode.MultistepIntegrator.start	(	double	double[]	double	): Start the integration. This method computes one step using the underlying starter integrator, and initializes the Nordsieck vector at step start. The starter integrator purpose is only to establish initial conditions, it does not really change time by itself. The top level multistep integrator remains in charge of handling time propagation and events handling as it will starts its own computation right from the beginning. In a sense, the starter integrator can be seen as a dummy one and so it will never trigger any user event nor call any user step handler.
org.apache.commons.math4.ode.ODEIntegrator: This interface defines the common parts shared by integrators for first and second order differential equations.
org.apache.commons.math4.ode.ODEIntegrator.addEventHandler	(	EventHandler	double	double	int	): Add an event handler to the integrator. Uses a default UnivariateSolver with an absolute accuracy equal to the given convergence threshold, as root-finding algorithm to detect the state events.
org.apache.commons.math4.ode.ODEIntegrator.addEventHandler	(	EventHandler	double	double	int	UnivariateSolver	): Add an event handler to the integrator.
org.apache.commons.math4.ode.ODEIntegrator.addStepHandler	(	StepHandler	): Add a step handler to this integrator. The handler will be called by the integrator for each accepted step.
org.apache.commons.math4.ode.ODEIntegrator.clearEventHandlers	(	): Remove all the event handlers that have been added to the integrator.
org.apache.commons.math4.ode.ODEIntegrator.clearStepHandlers	(	): Remove all the step handlers that have been added to the integrator.
org.apache.commons.math4.ode.ODEIntegrator.getCurrentSignedStepsize	(	): Get the current signed value of the integration stepsize. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the signed value of the current stepsize that is tried is needed. The result is undefined if the method is called outside of calls to integrate.
org.apache.commons.math4.ode.ODEIntegrator.getCurrentStepStart	(	): Get the current value of the step start time ti. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the value of the current step that is attempted is needed. The result is undefined if the method is called outside of calls to integrate.
org.apache.commons.math4.ode.ODEIntegrator.getEvaluations	(	): Get the number of evaluations of the differential equations function.  The number of evaluations corresponds to the last call to the integrate method. It is 0 if the method has not been called yet. 
org.apache.commons.math4.ode.ODEIntegrator.getEventHandlers	(	): Get all the event handlers that have been added to the integrator.
org.apache.commons.math4.ode.ODEIntegrator.getMaxEvaluations	(	): Get the maximal number of functions evaluations.
org.apache.commons.math4.ode.ODEIntegrator.getName	(	): Get the name of the method.
org.apache.commons.math4.ode.ODEIntegrator.getStepHandlers	(	): Get all the step handlers that have been added to the integrator.
org.apache.commons.math4.ode.ODEIntegrator.setMaxEvaluations	(	int	): Set the maximal number of differential equations function evaluations. The purpose of this method is to avoid infinite loops which can occur for example when stringent error constraints are set or when lots of discrete events are triggered, thus leading to many rejected steps.
org.apache.commons.math4.ode.ParameterConfiguration: Simple container pairing a parameter name with a step in order to compute the associated Jacobian matrix by finite difference.
org.apache.commons.math4.ode.ParameterConfiguration.ParameterConfiguration	(	String	double	): Parameter name and step pair constructor.
org.apache.commons.math4.ode.ParameterConfiguration.getHP	(	): Get parameter step.
org.apache.commons.math4.ode.ParameterConfiguration.getParameterName	(	): Get parameter name.
org.apache.commons.math4.ode.ParameterConfiguration.setHP	(	double	): Set parameter step.
org.apache.commons.math4.ode.ParameterJacobianProvider: Interface to compute exactly Jacobian matrix for some parameter when computing JacobianMatrices partial derivatives equations.
org.apache.commons.math4.ode.ParameterJacobianProvider.computeParameterJacobian	(	double	double[]	double[]	String	double[]	): Compute the Jacobian matrix of ODE with respect to one parameter. If the parameter does not belong to the collection returned by getParametersNames(), the Jacobian will be set to 0, but no errors will be triggered.
org.apache.commons.math4.ode.ParameterJacobianWrapper: Wrapper class to compute Jacobian matrices by finite differences for ODE which do not compute them by themselves.
org.apache.commons.math4.ode.ParameterJacobianWrapper.ParameterJacobianWrapper	(	FirstOrderDifferentialEquations	ParameterizedODE	ParameterConfiguration[]	): Wrap a ParameterizedODE into a ParameterJacobianProvider.
org.apache.commons.math4.ode.ParameterJacobianWrapper.computeParameterJacobian	(	double	double[]	double[]	String	double[]	): Compute the Jacobian matrix of ODE with respect to one parameter. If the parameter does not belong to the collection returned by getParametersNames(), the Jacobian will be set to 0, but no errors will be triggered. 
org.apache.commons.math4.ode.ParameterJacobianWrapper.getParametersNames	(	): Get the names of the supported parameters. 
org.apache.commons.math4.ode.ParameterJacobianWrapper.isSupported	(	String	): Check if a parameter is supported. Supported parameters are those listed by getParametersNames(). 
org.apache.commons.math4.ode.Parameterizable: This interface enables to process any parameterizable object.
org.apache.commons.math4.ode.Parameterizable.getParametersNames	(	): Get the names of the supported parameters.
org.apache.commons.math4.ode.Parameterizable.isSupported	(	String	): Check if a parameter is supported. Supported parameters are those listed by getParametersNames().
org.apache.commons.math4.ode.ParameterizedODE: Interface to compute by finite difference Jacobian matrix for some parameter when computing JacobianMatrices partial derivatives equations.
org.apache.commons.math4.ode.ParameterizedODE.getParameter	(	String	): Get parameter value from its name.
org.apache.commons.math4.ode.ParameterizedODE.setParameter	(	String	double	): Set the value for a given parameter.
org.apache.commons.math4.ode.ParameterizedWrapper: Wrapper class enabling FirstOrderDifferentialEquations basic simple ODE instances to be used when processing JacobianMatrices.
org.apache.commons.math4.ode.ParameterizedWrapper.ParameterizedWrapper	(	FirstOrderDifferentialEquations	): Simple constructor.
org.apache.commons.math4.ode.ParameterizedWrapper.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the state vector of the underlying FODE.
org.apache.commons.math4.ode.ParameterizedWrapper.getDimension	(	): Get the dimension of the underlying FODE.
org.apache.commons.math4.ode.ParameterizedWrapper.getParameter	(	String	): Get parameter value from its name. 
org.apache.commons.math4.ode.ParameterizedWrapper.getParametersNames	(	): Get the names of the supported parameters. 
org.apache.commons.math4.ode.ParameterizedWrapper.isSupported	(	String	): Check if a parameter is supported. Supported parameters are those listed by getParametersNames(). 
org.apache.commons.math4.ode.ParameterizedWrapper.setParameter	(	String	double	): Set the value for a given parameter. 
org.apache.commons.math4.ode.SecondOrderDifferentialEquations: This interface represents a second order differential equations set. This interface should be implemented by all real second order differential equation problems before they can be handled by the integrators integrate method. A second order differential equations problem, as seen by an integrator is the second time derivative d2Y/dt^2 of a state vector Y, both being one dimensional arrays. From the integrator point of view, this derivative depends only on the current time t, on the state vector Y and on the first time derivative of the state vector. For real problems, the derivative depends also on parameters that do not belong to the state vector (dynamical model constants for example). These constants are completely outside of the scope of this interface, the classes that implement it are allowed to handle them as they want.
org.apache.commons.math4.ode.SecondOrderDifferentialEquations.computeSecondDerivatives	(	double	double[]	double[]	double[]	): Get the current time derivative of the state vector.
org.apache.commons.math4.ode.SecondOrderDifferentialEquations.getDimension	(	): Get the dimension of the problem.
org.apache.commons.math4.ode.SecondOrderIntegrator: This interface represents a second order integrator for differential equations. The classes which are devoted to solve second order differential equations should implement this interface. The problems which can be handled should implement the SecondOrderDifferentialEquations interface.
org.apache.commons.math4.ode.SecondOrderIntegrator.integrate	(	SecondOrderDifferentialEquations	double	double[]	double[]	double	double[]	double[]	): Integrate the differential equations up to the given time
org.apache.commons.math4.ode.SecondaryEquations: This interface allows users to add secondary differential equations to a primary set of differential equations.  In some cases users may need to integrate some problem-specific equations along with a primary set of differential equations. One example is optimal control where adjoined parameters linked to the minimized hamiltonian must be integrated.   This interface allows users to add such equations to a primary set of FirstOrderDifferentialEquations first order differential equations thanks to the addSecondaryEquations() method. 
org.apache.commons.math4.ode.SecondaryEquations.computeDerivatives	(	double	double[]	double[]	double[]	double[]	): Compute the derivatives related to the secondary state parameters.
org.apache.commons.math4.ode.SecondaryEquations.getDimension	(	): Get the dimension of the secondary state parameters.
org.apache.commons.math4.ode.TestFieldProblem1: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y' = -y  the solution of this equation is a simple exponential function :  y (t) = y (t0) exp (t0-t)  
org.apache.commons.math4.ode.TestFieldProblem1.TestFieldProblem1	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblem2: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y' = t^3 - t y  with the initial condition y (0) = 0. The solution of this equation is the following function :  y (t) = t^2 + 2 (exp (- t^2 / 2) - 1)  
org.apache.commons.math4.ode.TestFieldProblem2.TestFieldProblem2	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblem3: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y1'' = -y1/r^3 y1 (0) = 1-e y1' (0) = 0 y2'' = -y2/r^3 y2 (0) = 0 y2' (0) =sqrt((1+e)/(1-e)) r = sqrt (y1^2 + y2^2), e = 0.9  This is a two-body problem in the plane which can be solved by Kepler's equation  y1 (t) = ...  
org.apache.commons.math4.ode.TestFieldProblem3.TestFieldProblem3	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblem3.TestFieldProblem3	(	Field	T	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblem4: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  x'' = -x  And when x decreases down to 0, the state should be changed as follows :  x' -> -x'  The theoretical solution of this problem is x = |sin(t+a)| 
org.apache.commons.math4.ode.TestFieldProblem4.TestFieldProblem4	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblem4.getTheoreticalEventsTimes	(	): Get the theoretical events times.
org.apache.commons.math4.ode.TestFieldProblem5: This class is used in the junit tests for the ODE integrators. This is the same as problem 1 except integration is done backward in time
org.apache.commons.math4.ode.TestFieldProblem5.TestFieldProblem5	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblem6: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y' = 3x^5 - y  when the initial condition is y(0) = -360, the solution of this equation degenerates to a simple quintic polynomial function :  y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360  
org.apache.commons.math4.ode.TestFieldProblem6.TestFieldProblem6	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblemAbstract: This class is used as the base class of the problems that are integrated during the junit tests for the ODE integrators.
org.apache.commons.math4.ode.TestFieldProblemAbstract.TestFieldProblemAbstract	(	Field	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblemAbstract.computeDerivatives	(	T	T[]	): Get the current time derivative of the state vector. 
org.apache.commons.math4.ode.TestFieldProblemAbstract.computeTheoreticalState	(	T	): Compute the theoretical state at the specified time.
org.apache.commons.math4.ode.TestFieldProblemAbstract.convert	(	double	): Convert a one dimension array.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getCalls	(	): Get the number of calls.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getDimension	(	): Get the problem dimension.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getErrorScale	(	): Get the error scale.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getEventsHandlers	(	): Get the events handlers.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getField	(	): get the filed to which elements belong.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getFinalTime	(	): Get the final time.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getInitialState	(	): Get the initial state.
org.apache.commons.math4.ode.TestFieldProblemAbstract.getTheoreticalEventsTimes	(	): Get the theoretical events times.
org.apache.commons.math4.ode.TestFieldProblemAbstract.init	(	T	T[]	T	): Initialize equations at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the equations to initialize some internal data if needed.  
org.apache.commons.math4.ode.TestFieldProblemAbstract.setErrorScale	(	T[]	): Set the error scale
org.apache.commons.math4.ode.TestFieldProblemAbstract.setFinalConditions	(	T	): Set the final conditions.
org.apache.commons.math4.ode.TestFieldProblemAbstract.setInitialConditions	(	T	T[]	): Set the initial conditions
org.apache.commons.math4.ode.TestFieldProblemHandler: This class is used to handle steps for the test problems integrated during the junit tests for the ODE integrators.
org.apache.commons.math4.ode.TestFieldProblemHandler.TestFieldProblemHandler	(	TestFieldProblemAbstract	FirstOrderFieldIntegrator	): Simple constructor.
org.apache.commons.math4.ode.TestFieldProblemHandler.getLastError	(	): Get the error at the end of the integration.
org.apache.commons.math4.ode.TestFieldProblemHandler.getLastTime	(	): Get the time at the end of the integration.
org.apache.commons.math4.ode.TestFieldProblemHandler.getMaximalTimeError	(	): Get the maximal time error encountered during integration.
org.apache.commons.math4.ode.TestFieldProblemHandler.getMaximalValueError	(	): Get the maximal value error encountered during integration.
org.apache.commons.math4.ode.TestProblem1: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y' = -y  the solution of this equation is a simple exponential function :  y (t) = y (t0) exp (t0-t)  
org.apache.commons.math4.ode.TestProblem1.TestProblem1	(	): Simple constructor.
org.apache.commons.math4.ode.TestProblem2: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y' = t^3 - t y  with the initial condition y (0) = 0. The solution of this equation is the following function :  y (t) = t^2 + 2 (exp (- t^2 / 2) - 1)  
org.apache.commons.math4.ode.TestProblem2.TestProblem2	(	): Simple constructor.
org.apache.commons.math4.ode.TestProblem3: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y1'' = -y1/r^3 y1 (0) = 1-e y1' (0) = 0 y2'' = -y2/r^3 y2 (0) = 0 y2' (0) =sqrt((1+e)/(1-e)) r = sqrt (y1^2 + y2^2), e = 0.9  This is a two-body problem in the plane which can be solved by Kepler's equation  y1 (t) = ...  
org.apache.commons.math4.ode.TestProblem3.TestProblem3	(	): Simple constructor.
org.apache.commons.math4.ode.TestProblem3.TestProblem3	(	double	): Simple constructor.
org.apache.commons.math4.ode.TestProblem4: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  x'' = -x  And when x decreases down to 0, the state should be changed as follows :  x' -> -x'  The theoretical solution of this problem is x = |sin(t+a)| 
org.apache.commons.math4.ode.TestProblem4.TestProblem4	(	): Simple constructor. 
org.apache.commons.math4.ode.TestProblem4.getTheoreticalEventsTimes	(	): Get the theoretical events times.
org.apache.commons.math4.ode.TestProblem5: This class is used in the junit tests for the ODE integrators. This is the same as problem 1 except integration is done backward in time
org.apache.commons.math4.ode.TestProblem5.TestProblem5	(	): Simple constructor.
org.apache.commons.math4.ode.TestProblem6: This class is used in the junit tests for the ODE integrators. This specific problem is the following differential equation :  y' = 3x^5 - y  when the initial condition is y(0) = -360, the solution of this equation degenerates to a simple quintic polynomial function :  y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360  
org.apache.commons.math4.ode.TestProblem6.TestProblem6	(	): Simple constructor.
org.apache.commons.math4.ode.TestProblemAbstract: This class is used as the base class of the problems that are integrated during the junit tests for the ODE integrators.
org.apache.commons.math4.ode.TestProblemAbstract.TestProblemAbstract	(	): Simple constructor.
org.apache.commons.math4.ode.TestProblemAbstract.computeTheoreticalState	(	double	): Compute the theoretical state at the specified time.
org.apache.commons.math4.ode.TestProblemAbstract.getCalls	(	): Get the number of calls.
org.apache.commons.math4.ode.TestProblemAbstract.getErrorScale	(	): Get the error scale.
org.apache.commons.math4.ode.TestProblemAbstract.getEventsHandlers	(	): Get the events handlers.
org.apache.commons.math4.ode.TestProblemAbstract.getFinalTime	(	): Get the final time.
org.apache.commons.math4.ode.TestProblemAbstract.getInitialState	(	): Get the initial state vector.
org.apache.commons.math4.ode.TestProblemAbstract.getInitialTime	(	): Get the initial time.
org.apache.commons.math4.ode.TestProblemAbstract.getTheoreticalEventsTimes	(	): Get the theoretical events times.
org.apache.commons.math4.ode.TestProblemAbstract.setErrorScale	(	double[]	): Set the error scale
org.apache.commons.math4.ode.TestProblemAbstract.setFinalConditions	(	double	): Set the final conditions.
org.apache.commons.math4.ode.TestProblemAbstract.setInitialConditions	(	double	double[]	): Set the initial conditions
org.apache.commons.math4.ode.TestProblemHandler: This class is used to handle steps for the test problems integrated during the junit tests for the ODE integrators.
org.apache.commons.math4.ode.TestProblemHandler.TestProblemHandler	(	TestProblemAbstract	ODEIntegrator	): Simple constructor.
org.apache.commons.math4.ode.TestProblemHandler.getLastError	(	): Get the error at the end of the integration.
org.apache.commons.math4.ode.TestProblemHandler.getLastTime	(	): Get the time at the end of the integration.
org.apache.commons.math4.ode.TestProblemHandler.getMaximalTimeError	(	): Get the maximal time error encountered during integration.
org.apache.commons.math4.ode.TestProblemHandler.getMaximalValueError	(	): Get the maximal value error encountered during integration.
org.apache.commons.math4.ode.UnknownParameterException: Exception to be thrown when a parameter is unknown.
org.apache.commons.math4.ode.UnknownParameterException.UnknownParameterException	(	String	): Construct an exception from the unknown parameter.
org.apache.commons.math4.ode.UnknownParameterException.getName	(	): 
org.apache.commons.math4.ode.events.CloseEventsTest: Check events are detected correctly when the event times are close.
org.apache.commons.math4.ode.events.CloseEventsTest.Equation: Some basic equations to integrate. 
org.apache.commons.math4.ode.events.CloseEventsTest.TimeDetector: Trigger an event at a particular time. 
org.apache.commons.math4.ode.events.CloseEventsTest.TimeDetector.TimeDetector	(	double	): Create a new detector.
org.apache.commons.math4.ode.events.CloseEventsTest.TimeDetector.getActualT	(	): Get the actual time the event occurred. 
org.apache.commons.math4.ode.events.EventFilter: Wrapper used to detect only increasing or decreasing events. General EventHandler events are defined implicitly by a g() g function crossing zero. This function needs to be continuous in the event neighborhood, and its sign must remain consistent between events. This implies that during an ODE integration, events triggered are alternately events for which the function increases from negative to positive values, and events for which the function decreases from positive to negative values.  Sometimes, users are only interested in one type of event (say increasing events for example) and not in the other type. In these cases, looking precisely for all events location and triggering events that will later be ignored is a waste of computing time. Users can wrap a regular EventHandler event handler in an instance of this class and provide this wrapping instance to the org.apache.commons.math4.ode.FirstOrderIntegrator ODE solver in order to avoid wasting time looking for uninteresting events. The wrapper will intercept the calls to the g() g function and to the eventOccurred() method in order to ignore uninteresting events. The wrapped regular EventHandler event handler will the see only the interesting events, i.e. either only increasing events or decreasing events. the number of calls to the g() g function will also be reduced.
org.apache.commons.math4.ode.events.EventFilter.EventFilter	(	EventHandler	FilterType	): Wrap an EventHandler event handler.
org.apache.commons.math4.ode.events.EventFilter.eventOccurred	(	double	double[]	boolean	): Handle an event and choose what to do next. This method is called when the integrator has accepted a step ending exactly on a sign change of the function, just before the step handler itself is called (see below for scheduling). It allows the user to update his internal data to acknowledge the fact the event has been handled (for example setting a flag in the org.apache.commons.math4.ode.FirstOrderDifferentialEquations differential equations to switch the derivatives computation in case of discontinuity), or to direct the integrator to either stop or continue integration, possibly with a reset state or derivatives.  if STOP is returned, the step handler will be called with the isLast flag of the handleStep method set to true and the integration will be stopped, if RESET_STATE is returned, the resetState method will be called once the step handler has finished its task, and the integrator will also recompute the derivatives, if RESET_DERIVATIVES is returned, the integrator will recompute the derivatives, if CONTINUE is returned, no specific action will be taken (apart from having called this method) and integration will continue.  The scheduling between this method and the org.apache.commons.math4.ode.sampling.StepHandler StepHandler method handleStep() handleStep(interpolator, isLast) is to call this method first and handleStep afterwards. This scheduling allows the integrator to pass true as the isLast parameter to the step handler to make it aware the step will be the last one if this method returns STOP. As the interpolator may be used to navigate back throughout the last step (as org.apache.commons.math4.ode.sampling.StepNormalizer StepNormalizer does for example), user code called by this method and user code called by step handlers may experience apparently out of order values of the independent time variable. As an example, if the same user object implements both this EventHandler EventHandler interface and the org.apache.commons.math4.ode.sampling.FixedStepHandler FixedStepHandler interface, a forward integration may call its eventOccurred method with t = 10 first and call its handleStep method with t = 9 afterwards. Such out of order calls are limited to the size of the integration step for org.apache.commons.math4.ode.sampling.StepHandler variable step handlers and to the size of the fixed step for org.apache.commons.math4.ode.sampling.FixedStepHandler fixed step handlers. 
org.apache.commons.math4.ode.events.EventFilter.g	(	double	double[]	): Compute the value of the switching function. The discrete events are generated when the sign of this switching function changes. The integrator will take care to change the stepsize in such a way these events occur exactly at step boundaries. The switching function must be continuous in its roots neighborhood (but not necessarily smooth), as the integrator will need to find its roots to locate precisely the events. Also note that the integrator expect that once an event has occurred, the sign of the switching function at the start of the next step (i.e. just after the event) is the opposite of the sign just before the event. This consistency between the steps must be preserved, otherwise org.apache.commons.math4.exception.NoBracketingException exceptions related to root not being bracketed will occur. This need for consistency is sometimes tricky to achieve. A typical example is using an event to model a ball bouncing on the floor. The first idea to represent this would be to have g(t) = h(t) where h is the height above the floor at time t. When g(t) reaches 0, the ball is on the floor, so it should bounce and the typical way to do this is to reverse its vertical velocity. However, this would mean that before the event g(t) was decreasing from positive values to 0, and after the event g(t) would be increasing from 0 to positive values again. Consistency is broken here! The solution here is to have g(t) = sign * h(t), where sign is a variable with initial value set to +1. Each time eventOccurred() is called, sign is reset to -sign. This allows the g(t) function to remain continuous (and even smooth) even across events, despite h(t) is not. Basically, the event is used to fold h(t) at bounce points, and sign is used to unfold it back, so the solvers sees a g(t) function which behaves smoothly even across events. 
org.apache.commons.math4.ode.events.EventFilter.init	(	double	double[]	double	): Initialize event handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the event handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.events.EventFilter.resetState	(	double	double[]	): Reset the state prior to continue the integration. This method is called after the step handler has returned and before the next step is started, but only when eventOccurred has itself returned the RESET_STATE indicator. It allows the user to reset the state vector for the next step, without perturbing the step handler of the finishing step. If the eventOccurred never returns the RESET_STATE indicator, this function will never be called, and it is safe to leave its body empty. 
org.apache.commons.math4.ode.events.EventFilterTest.Event: State events for this unit test. 
org.apache.commons.math4.ode.events.EventHandler: This interface represents a handler for discrete events triggered during ODE integration. Some events can be triggered at discrete times as an ODE problem is solved. This occurs for example when the integration process should be stopped as some state is reached (G-stop facility) when the precise date is unknown a priori, or when the derivatives have discontinuities, or simply when the user wants to monitor some states boundaries crossings.  These events are defined as occurring when a g switching function sign changes. Since events are only problem-dependent and are triggered by the independent time variable and the state vector, they can occur at virtually any time, unknown in advance. The integrators will take care to avoid sign changes inside the steps, they will reduce the step size when such an event is detected in order to put this event exactly at the end of the current step. This guarantees that step interpolation (which always has a one step scope) is relevant even in presence of discontinuities. This is independent from the stepsize control provided by integrators that monitor the local error (this event handling feature is available for all integrators, including fixed step ones).
org.apache.commons.math4.ode.events.EventHandler.eventOccurred	(	double	double[]	boolean	): Handle an event and choose what to do next. This method is called when the integrator has accepted a step ending exactly on a sign change of the function, just before the step handler itself is called (see below for scheduling). It allows the user to update his internal data to acknowledge the fact the event has been handled (for example setting a flag in the org.apache.commons.math4.ode.FirstOrderDifferentialEquations differential equations to switch the derivatives computation in case of discontinuity), or to direct the integrator to either stop or continue integration, possibly with a reset state or derivatives.  if STOP is returned, the step handler will be called with the isLast flag of the handleStep method set to true and the integration will be stopped, if RESET_STATE is returned, the resetState method will be called once the step handler has finished its task, and the integrator will also recompute the derivatives, if RESET_DERIVATIVES is returned, the integrator will recompute the derivatives, if CONTINUE is returned, no specific action will be taken (apart from having called this method) and integration will continue.  The scheduling between this method and the org.apache.commons.math4.ode.sampling.StepHandler StepHandler method handleStep() handleStep(interpolator, isLast) is to call this method first and handleStep afterwards. This scheduling allows the integrator to pass true as the isLast parameter to the step handler to make it aware the step will be the last one if this method returns STOP. As the interpolator may be used to navigate back throughout the last step (as org.apache.commons.math4.ode.sampling.StepNormalizer StepNormalizer does for example), user code called by this method and user code called by step handlers may experience apparently out of order values of the independent time variable. As an example, if the same user object implements both this EventHandler EventHandler interface and the org.apache.commons.math4.ode.sampling.FixedStepHandler FixedStepHandler interface, a forward integration may call its eventOccurred method with t = 10 first and call its handleStep method with t = 9 afterwards. Such out of order calls are limited to the size of the integration step for org.apache.commons.math4.ode.sampling.StepHandler variable step handlers and to the size of the fixed step for org.apache.commons.math4.ode.sampling.FixedStepHandler fixed step handlers.
org.apache.commons.math4.ode.events.EventHandler.g	(	double	double[]	): Compute the value of the switching function. The discrete events are generated when the sign of this switching function changes. The integrator will take care to change the stepsize in such a way these events occur exactly at step boundaries. The switching function must be continuous in its roots neighborhood (but not necessarily smooth), as the integrator will need to find its roots to locate precisely the events. Also note that the integrator expect that once an event has occurred, the sign of the switching function at the start of the next step (i.e. just after the event) is the opposite of the sign just before the event. This consistency between the steps must be preserved, otherwise org.apache.commons.math4.exception.NoBracketingException exceptions related to root not being bracketed will occur. This need for consistency is sometimes tricky to achieve. A typical example is using an event to model a ball bouncing on the floor. The first idea to represent this would be to have g(t) = h(t) where h is the height above the floor at time t. When g(t) reaches 0, the ball is on the floor, so it should bounce and the typical way to do this is to reverse its vertical velocity. However, this would mean that before the event g(t) was decreasing from positive values to 0, and after the event g(t) would be increasing from 0 to positive values again. Consistency is broken here! The solution here is to have g(t) = sign * h(t), where sign is a variable with initial value set to +1. Each time eventOccurred() is called, sign is reset to -sign. This allows the g(t) function to remain continuous (and even smooth) even across events, despite h(t) is not. Basically, the event is used to fold h(t) at bounce points, and sign is used to unfold it back, so the solvers sees a g(t) function which behaves smoothly even across events.
org.apache.commons.math4.ode.events.EventHandler.init	(	double	double[]	double	): Initialize event handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the event handler to initialize some internal data if needed. 
org.apache.commons.math4.ode.events.EventHandler.resetState	(	double	double[]	): Reset the state prior to continue the integration. This method is called after the step handler has returned and before the next step is started, but only when eventOccurred has itself returned the RESET_STATE indicator. It allows the user to reset the state vector for the next step, without perturbing the step handler of the finishing step. If the eventOccurred never returns the RESET_STATE indicator, this function will never be called, and it is safe to leave its body empty.
org.apache.commons.math4.ode.events.EventState: This class handles the state for one EventHandler event handler during integration steps. Each time the integrator proposes a step, the event handler switching function should be checked. This class handles the state of one handler during one integration step, with references to the state at the end of the preceding step. This information is used to decide if the handler should trigger an event or not during the proposed step.
org.apache.commons.math4.ode.events.EventState.EventState	(	EventHandler	double	double	int	UnivariateSolver	): Simple constructor.
org.apache.commons.math4.ode.events.EventState.LocalMaxCountExceededException: Local wrapper to propagate exceptions. 
org.apache.commons.math4.ode.events.EventState.LocalMaxCountExceededException.LocalMaxCountExceededException	(	MaxCountExceededException	): Simple constructor.
org.apache.commons.math4.ode.events.EventState.LocalMaxCountExceededException.getException	(	): Get the wrapped exception.
org.apache.commons.math4.ode.events.EventState.evaluateStep	(	StepInterpolator	): Evaluate the impact of the proposed step on the event handler.
org.apache.commons.math4.ode.events.EventState.getCompleteState	(	StepInterpolator	): Get the complete state (primary and secondary).
org.apache.commons.math4.ode.events.EventState.getConvergence	(	): Get the convergence threshold for event localization.
org.apache.commons.math4.ode.events.EventState.getEventHandler	(	): Get the underlying event handler.
org.apache.commons.math4.ode.events.EventState.getEventTime	(	): Get the occurrence time of the event triggered in the current step.
org.apache.commons.math4.ode.events.EventState.getMaxCheckInterval	(	): Get the maximal time interval between events handler checks.
org.apache.commons.math4.ode.events.EventState.getMaxIterationCount	(	): Get the upper limit in the iteration count for event localization.
org.apache.commons.math4.ode.events.EventState.reinitializeBegin	(	StepInterpolator	): Reinitialize the beginning of the step.
org.apache.commons.math4.ode.events.EventState.reset	(	double	double[]	): Let the event handler reset the state if it wants.
org.apache.commons.math4.ode.events.EventState.setExpandable	(	ExpandableStatefulODE	): Set the equation.
org.apache.commons.math4.ode.events.EventState.stepAccepted	(	double	double[]	): Acknowledge the fact the step has been accepted by the integrator.
org.apache.commons.math4.ode.events.EventState.stop	(	): Check if the integration should be stopped at the end of the current step.
org.apache.commons.math4.ode.events.FieldEventHandler: This interface represents a handler for discrete events triggered during ODE integration. Some events can be triggered at discrete times as an ODE problem is solved. This occurs for example when the integration process should be stopped as some state is reached (G-stop facility) when the precise date is unknown a priori, or when the derivatives have discontinuities, or simply when the user wants to monitor some states boundaries crossings.  These events are defined as occurring when a g switching function sign changes. Since events are only problem-dependent and are triggered by the independent time variable and the state vector, they can occur at virtually any time, unknown in advance. The integrators will take care to avoid sign changes inside the steps, they will reduce the step size when such an event is detected in order to put this event exactly at the end of the current step. This guarantees that step interpolation (which always has a one step scope) is relevant even in presence of discontinuities. This is independent from the stepsize control provided by integrators that monitor the local error (this event handling feature is available for all integrators, including fixed step ones).
org.apache.commons.math4.ode.events.FieldEventHandler.eventOccurred	(	FieldODEStateAndDerivative	boolean	): Handle an event and choose what to do next. This method is called when the integrator has accepted a step ending exactly on a sign change of the function, just before the step handler itself is called (see below for scheduling). It allows the user to update his internal data to acknowledge the fact the event has been handled (for example setting a flag in the org.apache.commons.math4.ode.FirstOrderDifferentialEquations differential equations to switch the derivatives computation in case of discontinuity), or to direct the integrator to either stop or continue integration, possibly with a reset state or derivatives.  if STOP is returned, the step handler will be called with the isLast flag of the handleStep method set to true and the integration will be stopped, if RESET_STATE is returned, the resetState method will be called once the step handler has finished its task, and the integrator will also recompute the derivatives, if RESET_DERIVATIVES is returned, the integrator will recompute the derivatives, if CONTINUE is returned, no specific action will be taken (apart from having called this method) and integration will continue.  The scheduling between this method and the org.apache.commons.math4.ode.sampling.FieldStepHandler FieldStepHandler method handleStep() handleStep(interpolator, isLast) is to call this method first and handleStep afterwards. This scheduling allows the integrator to pass true as the isLast parameter to the step handler to make it aware the step will be the last one if this method returns STOP. As the interpolator may be used to navigate back throughout the last step, user code called by this method and user code called by step handlers may experience apparently out of order values of the independent time variable. As an example, if the same user object implements both this FieldEventHandler FieldEventHandler interface and the org.apache.commons.math4.ode.sampling.FieldStepHandler FieldStepHandler interface, a forward integration may call its {code eventOccurred} method with t = 10 first and call its {code handleStep} method with t = 9 afterwards. Such out of order calls are limited to the size of the integration step for org.apache.commons.math4.ode.sampling.FieldStepHandler variable step handlers.
org.apache.commons.math4.ode.events.FieldEventHandler.g	(	FieldODEStateAndDerivative	): Compute the value of the switching function. The discrete events are generated when the sign of this switching function changes. The integrator will take care to change the stepsize in such a way these events occur exactly at step boundaries. The switching function must be continuous in its roots neighborhood (but not necessarily smooth), as the integrator will need to find its roots to locate precisely the events. Also note that the integrator expect that once an event has occurred, the sign of the switching function at the start of the next step (i.e. just after the event) is the opposite of the sign just before the event. This consistency between the steps must be preserved, otherwise org.apache.commons.math4.exception.NoBracketingException exceptions related to root not being bracketed will occur. This need for consistency is sometimes tricky to achieve. A typical example is using an event to model a ball bouncing on the floor. The first idea to represent this would be to have g(t) = h(t) where h is the height above the floor at time t. When g(t) reaches 0, the ball is on the floor, so it should bounce and the typical way to do this is to reverse its vertical velocity. However, this would mean that before the event g(t) was decreasing from positive values to 0, and after the event g(t) would be increasing from 0 to positive values again. Consistency is broken here! The solution here is to have g(t) = sign * h(t), where sign is a variable with initial value set to +1. Each time eventOccurred() method is called, sign is reset to -sign. This allows the g(t) function to remain continuous (and even smooth) even across events, despite h(t) is not. Basically, the event is used to fold h(t) at bounce points, and sign is used to unfold it back, so the solvers sees a g(t) function which behaves smoothly even across events.
org.apache.commons.math4.ode.events.FieldEventHandler.init	(	FieldODEStateAndDerivative	T	): Initialize event handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the event handler to initialize some internal data if needed. 
org.apache.commons.math4.ode.events.FieldEventHandler.resetState	(	FieldODEStateAndDerivative	): Reset the state prior to continue the integration. This method is called after the step handler has returned and before the next step is started, but only when eventOccurred() has itself returned the RESET_STATE indicator. It allows the user to reset the state vector for the next step, without perturbing the step handler of the finishing step. If the eventOccurred() never returns the RESET_STATE indicator, this function will never be called, and it is safe to leave its body empty.
org.apache.commons.math4.ode.events.FieldEventState: This class handles the state for one EventHandler event handler during integration steps. Each time the integrator proposes a step, the event handler switching function should be checked. This class handles the state of one handler during one integration step, with references to the state at the end of the preceding step. This information is used to decide if the handler should trigger an event or not during the proposed step.
org.apache.commons.math4.ode.events.FieldEventState.FieldEventState	(	FieldEventHandler	double	T	int	BracketedRealFieldUnivariateSolver	): Simple constructor.
org.apache.commons.math4.ode.events.FieldEventState.evaluateStep	(	FieldStepInterpolator	): Evaluate the impact of the proposed step on the event handler.
org.apache.commons.math4.ode.events.FieldEventState.getConvergence	(	): Get the convergence threshold for event localization.
org.apache.commons.math4.ode.events.FieldEventState.getEventHandler	(	): Get the underlying event handler.
org.apache.commons.math4.ode.events.FieldEventState.getEventTime	(	): Get the occurrence time of the event triggered in the current step.
org.apache.commons.math4.ode.events.FieldEventState.getMaxCheckInterval	(	): Get the maximal time interval between events handler checks.
org.apache.commons.math4.ode.events.FieldEventState.getMaxIterationCount	(	): Get the upper limit in the iteration count for event localization.
org.apache.commons.math4.ode.events.FieldEventState.reinitializeBegin	(	FieldStepInterpolator	): Reinitialize the beginning of the step.
org.apache.commons.math4.ode.events.FieldEventState.reset	(	FieldODEStateAndDerivative	): Let the event handler reset the state if it wants.
org.apache.commons.math4.ode.events.FieldEventState.stepAccepted	(	FieldODEStateAndDerivative	): Acknowledge the fact the step has been accepted by the integrator.
org.apache.commons.math4.ode.events.FieldEventState.stop	(	): Check if the integration should be stopped at the end of the current step.
org.apache.commons.math4.ode.events.OverlappingEventsTest: Tests for overlapping state events. Also tests an event function that does not converge to zero, but does have values of opposite sign around its root.
org.apache.commons.math4.ode.events.OverlappingEventsTest.Event: State events for this unit test. 
org.apache.commons.math4.ode.events.OverlappingEventsTest.Event.Event	(	int	int	): Constructor for the Event class.
org.apache.commons.math4.ode.events.OverlappingEventsTest.Event.eventOccurred	(	double	double[]	boolean	): Handle an event and choose what to do next. This method is called when the integrator has accepted a step ending exactly on a sign change of the function, just before the step handler itself is called (see below for scheduling). It allows the user to update his internal data to acknowledge the fact the event has been handled (for example setting a flag in the org.apache.commons.math4.ode.FirstOrderDifferentialEquations differential equations to switch the derivatives computation in case of discontinuity), or to direct the integrator to either stop or continue integration, possibly with a reset state or derivatives.  if STOP is returned, the step handler will be called with the isLast flag of the handleStep method set to true and the integration will be stopped, if RESET_STATE is returned, the resetState method will be called once the step handler has finished its task, and the integrator will also recompute the derivatives, if RESET_DERIVATIVES is returned, the integrator will recompute the derivatives, if CONTINUE is returned, no specific action will be taken (apart from having called this method) and integration will continue.  The scheduling between this method and the org.apache.commons.math4.ode.sampling.StepHandler StepHandler method handleStep() handleStep(interpolator, isLast) is to call this method first and handleStep afterwards. This scheduling allows the integrator to pass true as the isLast parameter to the step handler to make it aware the step will be the last one if this method returns STOP. As the interpolator may be used to navigate back throughout the last step (as org.apache.commons.math4.ode.sampling.StepNormalizer StepNormalizer does for example), user code called by this method and user code called by step handlers may experience apparently out of order values of the independent time variable. As an example, if the same user object implements both this EventHandler EventHandler interface and the org.apache.commons.math4.ode.sampling.FixedStepHandler FixedStepHandler interface, a forward integration may call its eventOccurred method with t = 10 first and call its handleStep method with t = 9 afterwards. Such out of order calls are limited to the size of the integration step for org.apache.commons.math4.ode.sampling.StepHandler variable step handlers and to the size of the fixed step for org.apache.commons.math4.ode.sampling.FixedStepHandler fixed step handlers. 
org.apache.commons.math4.ode.events.OverlappingEventsTest.Event.g	(	double	double[]	): Compute the value of the switching function. The discrete events are generated when the sign of this switching function changes. The integrator will take care to change the stepsize in such a way these events occur exactly at step boundaries. The switching function must be continuous in its roots neighborhood (but not necessarily smooth), as the integrator will need to find its roots to locate precisely the events. Also note that the integrator expect that once an event has occurred, the sign of the switching function at the start of the next step (i.e. just after the event) is the opposite of the sign just before the event. This consistency between the steps must be preserved, otherwise org.apache.commons.math4.exception.NoBracketingException exceptions related to root not being bracketed will occur. This need for consistency is sometimes tricky to achieve. A typical example is using an event to model a ball bouncing on the floor. The first idea to represent this would be to have g(t) = h(t) where h is the height above the floor at time t. When g(t) reaches 0, the ball is on the floor, so it should bounce and the typical way to do this is to reverse its vertical velocity. However, this would mean that before the event g(t) was decreasing from positive values to 0, and after the event g(t) would be increasing from 0 to positive values again. Consistency is broken here! The solution here is to have g(t) = sign * h(t), where sign is a variable with initial value set to +1. Each time eventOccurred() is called, sign is reset to -sign. This allows the g(t) function to remain continuous (and even smooth) even across events, despite h(t) is not. Basically, the event is used to fold h(t) at bounce points, and sign is used to unfold it back, so the solvers sees a g(t) function which behaves smoothly even across events. 
org.apache.commons.math4.ode.events.OverlappingEventsTest.Event.init	(	double	double[]	double	): Initialize event handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the event handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.events.OverlappingEventsTest.Event.resetState	(	double	double[]	): Reset the state prior to continue the integration. This method is called after the step handler has returned and before the next step is started, but only when eventOccurred has itself returned the RESET_STATE indicator. It allows the user to reset the state vector for the next step, without perturbing the step handler of the finishing step. If the eventOccurred never returns the RESET_STATE indicator, this function will never be called, and it is safe to leave its body empty. 
org.apache.commons.math4.ode.events.OverlappingEventsTest.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the state vector. 
org.apache.commons.math4.ode.events.OverlappingEventsTest.getDimension	(	): Get the dimension of the problem. 
org.apache.commons.math4.ode.events.OverlappingEventsTest.test	(	int	): Test for events that occur at the exact same time, but due to numerical calculations occur very close together instead.
org.apache.commons.math4.ode.events.OverlappingEventsTest.testOverlappingEvents0	(	): Test for events that occur at the exact same time, but due to numerical calculations occur very close together instead. Uses event type 0. See g() EventHandler.g(double, double[]).
org.apache.commons.math4.ode.events.OverlappingEventsTest.testOverlappingEvents1	(	): Test for events that occur at the exact same time, but due to numerical calculations occur very close together instead. Uses event type 1. See g() EventHandler.g(double, double[]).
org.apache.commons.math4.ode.events.ReappearingEventTest.Event: State events for this unit test. 
org.apache.commons.math4.ode.nonstiff.AdamsBashforthFieldIntegrator: This class implements explicit Adams-Bashforth integrators for Ordinary Differential Equations. Adams-Bashforth methods (in fact due to Adams alone) are explicit multistep ODE solvers. This implementation is a variation of the classical one: it uses adaptive stepsize to implement error control, whereas classical implementations are fixed step size. The value of state vector at step n+1 is a simple combination of the value at step n and of the derivatives at steps n, n-1, n-2 ... Depending on the number k of previous steps one wants to use for computing the next value, different formulas are available:  k = 1: yn+1 = yn + h y'n k = 2: yn+1 = yn + h (3y'n-y'n-1)/2 k = 3: yn+1 = yn + h (23y'n-16y'n-1+5y'n-2)/12 k = 4: yn+1 = yn + h (55y'n-59y'n-1+37y'n-2-9y'n-3)/24 ...  A k-steps Adams-Bashforth method is of order k. Implementation details We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  The definitions above use the classical representation with several previous first derivatives. Lets define  qn = [ s1(n-1) s1(n-2) ... s1(n-(k-1)) ]T  (we omit the k index in the notation for clarity). With these definitions, Adams-Bashforth methods can be written:  k = 1: yn+1 = yn + s1(n) k = 2: yn+1 = yn + 3/2 s1(n) + [ -1/2 ] qn k = 3: yn+1 = yn + 23/12 s1(n) + [ -16/12 5/12 ] qn k = 4: yn+1 = yn + 55/24 s1(n) + [ -59/24 37/24 -9/24 ] qn ...  Instead of using the classical representation with first derivatives only (yn, s1(n) and qn), our implementation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step (yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (here again we omit the k index in the notation for clarity) Taylor series formulas show that for any index offset i, s1(n-i) can be computed from s1(n), s2(n) ... sk(n), the formula being exact for degree k polynomials.  s1(n-i) = s1(n) + ∑j>0 (j+1) (-i)j sj+1(n)  The previous formula can be used with several values for i to compute the transform between classical representation and Nordsieck vector. The transform between rn and qn resulting from the Taylor series formulas above is:  qn = s1(n) u + P rn  where u is the [ 1 1 ... 1 ]T vector and P is the (k-1)×(k-1) matrix built with the (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ]  Using the Nordsieck vector has several advantages:  it greatly simplifies step interpolation as the interpolator mainly applies Taylor series formulas, it simplifies step changes that occur when discrete events that truncate the step are triggered, it allows to extend the methods in order to support adaptive stepsize.  The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  yn+1 = yn + s1(n) + uT rn s1(n+1) = h f(tn+1, yn+1) rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  where A is a rows shifting matrix (the lower left part is an identity matrix):  [ 0 0 ... 0 0 | 0 ] [ ---------------+---] [ 1 0 ... 0 0 | 0 ] A = [ 0 1 ... 0 0 | 0 ] [ ... | 0 ] [ 0 0 ... 1 0 | 0 ] [ 0 0 ... 0 1 | 0 ]  The P-1u vector and the P-1 A P matrix do not depend on the state, they only depend on k and therefore are precomputed once for all.
org.apache.commons.math4.ode.nonstiff.AdamsBashforthFieldIntegrator.AdamsBashforthFieldIntegrator	(	Field	int	double	double	double	double	): Build an Adams-Bashforth integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsBashforthFieldIntegrator.AdamsBashforthFieldIntegrator	(	Field	int	double	double	double[]	double[]	): Build an Adams-Bashforth integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsBashforthFieldIntegrator.errorEstimation	(	T[]	T[]	T[]	FieldMatrix	): Estimate error.  Error is estimated by interpolating back to previous state using the state Taylor expansion and comparing to real previous state. 
org.apache.commons.math4.ode.nonstiff.AdamsBashforthFieldIntegrator.integrate	(	FieldExpandableODE	FieldODEState	T	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.  
org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegrator: This class implements explicit Adams-Bashforth integrators for Ordinary Differential Equations. Adams-Bashforth methods (in fact due to Adams alone) are explicit multistep ODE solvers. This implementation is a variation of the classical one: it uses adaptive stepsize to implement error control, whereas classical implementations are fixed step size. The value of state vector at step n+1 is a simple combination of the value at step n and of the derivatives at steps n, n-1, n-2 ... Depending on the number k of previous steps one wants to use for computing the next value, different formulas are available:  k = 1: yn+1 = yn + h y'n k = 2: yn+1 = yn + h (3y'n-y'n-1)/2 k = 3: yn+1 = yn + h (23y'n-16y'n-1+5y'n-2)/12 k = 4: yn+1 = yn + h (55y'n-59y'n-1+37y'n-2-9y'n-3)/24 ...  A k-steps Adams-Bashforth method is of order k. Implementation details We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  The definitions above use the classical representation with several previous first derivatives. Lets define  qn = [ s1(n-1) s1(n-2) ... s1(n-(k-1)) ]T  (we omit the k index in the notation for clarity). With these definitions, Adams-Bashforth methods can be written:  k = 1: yn+1 = yn + s1(n) k = 2: yn+1 = yn + 3/2 s1(n) + [ -1/2 ] qn k = 3: yn+1 = yn + 23/12 s1(n) + [ -16/12 5/12 ] qn k = 4: yn+1 = yn + 55/24 s1(n) + [ -59/24 37/24 -9/24 ] qn ...  Instead of using the classical representation with first derivatives only (yn, s1(n) and qn), our implementation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step (yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (here again we omit the k index in the notation for clarity) Taylor series formulas show that for any index offset i, s1(n-i) can be computed from s1(n), s2(n) ... sk(n), the formula being exact for degree k polynomials.  s1(n-i) = s1(n) + ∑j>0 (j+1) (-i)j sj+1(n)  The previous formula can be used with several values for i to compute the transform between classical representation and Nordsieck vector. The transform between rn and qn resulting from the Taylor series formulas above is:  qn = s1(n) u + P rn  where u is the [ 1 1 ... 1 ]T vector and P is the (k-1)×(k-1) matrix built with the (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ]  Using the Nordsieck vector has several advantages:  it greatly simplifies step interpolation as the interpolator mainly applies Taylor series formulas, it simplifies step changes that occur when discrete events that truncate the step are triggered, it allows to extend the methods in order to support adaptive stepsize.  The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  yn+1 = yn + s1(n) + uT rn s1(n+1) = h f(tn+1, yn+1) rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  where A is a rows shifting matrix (the lower left part is an identity matrix):  [ 0 0 ... 0 0 | 0 ] [ ---------------+---] [ 1 0 ... 0 0 | 0 ] A = [ 0 1 ... 0 0 | 0 ] [ ... | 0 ] [ 0 0 ... 1 0 | 0 ] [ 0 0 ... 0 1 | 0 ]  The P-1u vector and the P-1 A P matrix do not depend on the state, they only depend on k and therefore are precomputed once for all.
org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegrator.AdamsBashforthIntegrator	(	int	double	double	double	double	): Build an Adams-Bashforth integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegrator.AdamsBashforthIntegrator	(	int	double	double	double[]	double[]	): Build an Adams-Bashforth integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegrator.errorEstimation	(	double[]	double[]	double[]	RealMatrix	): Estimate error.  Error is estimated by interpolating back to previous state using the state Taylor expansion and comparing to real previous state. 
org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.   
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator: Base class for AdamsBashforthFieldIntegrator Adams-Bashforth and AdamsMoultonFieldIntegrator Adams-Moulton integrators.
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator.AdamsFieldIntegrator	(	Field	String	int	int	double	double	double	double	): Build an Adams integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator.AdamsFieldIntegrator	(	Field	String	int	int	double	double	double[]	double[]	): Build an Adams integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator.initializeHighOrderDerivatives	(	T	T[]	T[][]	T[][]	): Initialize the high order scaled derivatives at step start. 
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator.integrate	(	FieldExpandableODE	FieldODEState	T	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe. 
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator.updateHighOrderDerivativesPhase1	(	Array2DRowFieldMatrix	): Update the high order scaled derivatives for Adams integrators (phase 1). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the P-1 A P rn part.
org.apache.commons.math4.ode.nonstiff.AdamsFieldIntegrator.updateHighOrderDerivativesPhase2	(	T[]	T[]	Array2DRowFieldMatrix	): Update the high order scaled derivatives Adams integrators (phase 2). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the (s1(n) - s1(n+1)) P-1 u part. Phase 1 of the update must already have been performed.
org.apache.commons.math4.ode.nonstiff.AdamsFieldStepInterpolator: This class implements an interpolator for Adams integrators using Nordsieck representation. This interpolator computes dense output around the current point. The interpolation equation is based on Taylor series formulas.
org.apache.commons.math4.ode.nonstiff.AdamsFieldStepInterpolator.AdamsFieldStepInterpolator	(	T	FieldODEStateAndDerivative	T[]	Array2DRowFieldMatrix	boolean	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.AdamsFieldStepInterpolator.AdamsFieldStepInterpolator	(	T	FieldODEStateAndDerivative	T[]	Array2DRowFieldMatrix	boolean	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.AdamsFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.AdamsFieldStepInterpolator.create	(	boolean	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance.
org.apache.commons.math4.ode.nonstiff.AdamsFieldStepInterpolator.taylor	(	FieldODEStateAndDerivative	S	S	S[]	Array2DRowFieldMatrix	): Estimate state by applying Taylor formula.
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator: Base class for AdamsBashforthIntegrator Adams-Bashforth and AdamsMoultonIntegrator Adams-Moulton integrators.
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator.AdamsIntegrator	(	String	int	int	double	double	double	double	): Build an Adams integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator.AdamsIntegrator	(	String	int	int	double	double	double[]	double[]	): Build an Adams integrator with the given order and step control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator.initializeHighOrderDerivatives	(	double	double[]	double[][]	double[][]	): Initialize the high order scaled derivatives at step start. 
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.  
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator.updateHighOrderDerivativesPhase1	(	Array2DRowRealMatrix	): Update the high order scaled derivatives for Adams integrators (phase 1). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the P-1 A P rn part.
org.apache.commons.math4.ode.nonstiff.AdamsIntegrator.updateHighOrderDerivativesPhase2	(	double[]	double[]	Array2DRowRealMatrix	): Update the high order scaled derivatives Adams integrators (phase 2). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the (s1(n) - s1(n+1)) P-1 u part. Phase 1 of the update must already have been performed.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator: This class implements implicit Adams-Moulton integrators for Ordinary Differential Equations. Adams-Moulton methods (in fact due to Adams alone) are implicit multistep ODE solvers. This implementation is a variation of the classical one: it uses adaptive stepsize to implement error control, whereas classical implementations are fixed step size. The value of state vector at step n+1 is a simple combination of the value at step n and of the derivatives at steps n+1, n, n-1 ... Since y'n+1 is needed to compute yn+1, another method must be used to compute a first estimate of yn+1, then compute y'n+1, then compute a final estimate of yn+1 using the following formulas. Depending on the number k of previous steps one wants to use for computing the next value, different formulas are available for the final estimate:  k = 1: yn+1 = yn + h y'n+1 k = 2: yn+1 = yn + h (y'n+1+y'n)/2 k = 3: yn+1 = yn + h (5y'n+1+8y'n-y'n-1)/12 k = 4: yn+1 = yn + h (9y'n+1+19y'n-5y'n-1+y'n-2)/24 ...  A k-steps Adams-Moulton method is of order k+1. Implementation details We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  The definitions above use the classical representation with several previous first derivatives. Lets define  qn = [ s1(n-1) s1(n-2) ... s1(n-(k-1)) ]T  (we omit the k index in the notation for clarity). With these definitions, Adams-Moulton methods can be written:  k = 1: yn+1 = yn + s1(n+1) k = 2: yn+1 = yn + 1/2 s1(n+1) + [ 1/2 ] qn+1 k = 3: yn+1 = yn + 5/12 s1(n+1) + [ 8/12 -1/12 ] qn+1 k = 4: yn+1 = yn + 9/24 s1(n+1) + [ 19/24 -5/24 1/24 ] qn+1 ...  Instead of using the classical representation with first derivatives only (yn, s1(n+1) and qn+1), our implementation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step (yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (here again we omit the k index in the notation for clarity) Taylor series formulas show that for any index offset i, s1(n-i) can be computed from s1(n), s2(n) ... sk(n), the formula being exact for degree k polynomials.  s1(n-i) = s1(n) + ∑j>0 (j+1) (-i)j sj+1(n)  The previous formula can be used with several values for i to compute the transform between classical representation and Nordsieck vector. The transform between rn and qn resulting from the Taylor series formulas above is:  qn = s1(n) u + P rn  where u is the [ 1 1 ... 1 ]T vector and P is the (k-1)×(k-1) matrix built with the (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ]  Using the Nordsieck vector has several advantages:  it greatly simplifies step interpolation as the interpolator mainly applies Taylor series formulas, it simplifies step changes that occur when discrete events that truncate the step are triggered, it allows to extend the methods in order to support adaptive stepsize.  The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  Yn+1 = yn + s1(n) + uT rn S1(n+1) = h f(tn+1, Yn+1) Rn+1 = (s1(n) - S1(n+1)) P-1 u + P-1 A P rn  where A is a rows shifting matrix (the lower left part is an identity matrix):  [ 0 0 ... 0 0 | 0 ] [ ---------------+---] [ 1 0 ... 0 0 | 0 ] A = [ 0 1 ... 0 0 | 0 ] [ ... | 0 ] [ 0 0 ... 1 0 | 0 ] [ 0 0 ... 0 1 | 0 ]  From this predicted vector, the corrected vector is computed as follows:  yn+1 = yn + S1(n+1) + [ -1 +1 -1 +1 ... ±1 ] rn+1 s1(n+1) = h f(tn+1, yn+1) rn+1 = Rn+1 + (s1(n+1) - S1(n+1)) P-1 u  where the upper case Yn+1, S1(n+1) and Rn+1 represent the predicted states whereas the lower case yn+1, sn+1 and rn+1 represent the corrected states. The P-1u vector and the P-1 A P matrix do not depend on the state, they only depend on k and therefore are precomputed once for all.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.AdamsMoultonFieldIntegrator	(	Field	int	double	double	double	double	): Build an Adams-Moulton integrator with the given order and error control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.AdamsMoultonFieldIntegrator	(	Field	int	double	double	double[]	double[]	): Build an Adams-Moulton integrator with the given order and error control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.Corrector: Corrector for current state in Adams-Moulton method.  This visitor implements the Taylor series formula:  Yn+1 = yn + s1(n+1) + [ -1 +1 -1 +1 ... ±1 ] rn+1  
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.Corrector.Corrector	(	T[]	T[]	T[]	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.Corrector.end	(	): End visiting the Nordsieck vector. The correction is used to control stepsize. So its amplitude is considered to be an error, which must be normalized according to error control settings. If the normalized value is greater than 1, the correction was too large and the step must be rejected.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.Corrector.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited. 
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.Corrector.visit	(	int	int	T	): Visit one matrix entry. 
org.apache.commons.math4.ode.nonstiff.AdamsMoultonFieldIntegrator.integrate	(	FieldExpandableODE	FieldODEState	T	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.  
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator: This class implements implicit Adams-Moulton integrators for Ordinary Differential Equations. Adams-Moulton methods (in fact due to Adams alone) are implicit multistep ODE solvers. This implementation is a variation of the classical one: it uses adaptive stepsize to implement error control, whereas classical implementations are fixed step size. The value of state vector at step n+1 is a simple combination of the value at step n and of the derivatives at steps n+1, n, n-1 ... Since y'n+1 is needed to compute yn+1, another method must be used to compute a first estimate of yn+1, then compute y'n+1, then compute a final estimate of yn+1 using the following formulas. Depending on the number k of previous steps one wants to use for computing the next value, different formulas are available for the final estimate:  k = 1: yn+1 = yn + h y'n+1 k = 2: yn+1 = yn + h (y'n+1+y'n)/2 k = 3: yn+1 = yn + h (5y'n+1+8y'n-y'n-1)/12 k = 4: yn+1 = yn + h (9y'n+1+19y'n-5y'n-1+y'n-2)/24 ...  A k-steps Adams-Moulton method is of order k+1. Implementation details We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  The definitions above use the classical representation with several previous first derivatives. Lets define  qn = [ s1(n-1) s1(n-2) ... s1(n-(k-1)) ]T  (we omit the k index in the notation for clarity). With these definitions, Adams-Moulton methods can be written:  k = 1: yn+1 = yn + s1(n+1) k = 2: yn+1 = yn + 1/2 s1(n+1) + [ 1/2 ] qn+1 k = 3: yn+1 = yn + 5/12 s1(n+1) + [ 8/12 -1/12 ] qn+1 k = 4: yn+1 = yn + 9/24 s1(n+1) + [ 19/24 -5/24 1/24 ] qn+1 ...  Instead of using the classical representation with first derivatives only (yn, s1(n+1) and qn+1), our implementation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step (yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (here again we omit the k index in the notation for clarity) Taylor series formulas show that for any index offset i, s1(n-i) can be computed from s1(n), s2(n) ... sk(n), the formula being exact for degree k polynomials.  s1(n-i) = s1(n) + ∑j>0 (j+1) (-i)j sj+1(n)  The previous formula can be used with several values for i to compute the transform between classical representation and Nordsieck vector. The transform between rn and qn resulting from the Taylor series formulas above is:  qn = s1(n) u + P rn  where u is the [ 1 1 ... 1 ]T vector and P is the (k-1)×(k-1) matrix built with the (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ]  Using the Nordsieck vector has several advantages:  it greatly simplifies step interpolation as the interpolator mainly applies Taylor series formulas, it simplifies step changes that occur when discrete events that truncate the step are triggered, it allows to extend the methods in order to support adaptive stepsize.  The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  Yn+1 = yn + s1(n) + uT rn S1(n+1) = h f(tn+1, Yn+1) Rn+1 = (s1(n) - S1(n+1)) P-1 u + P-1 A P rn  where A is a rows shifting matrix (the lower left part is an identity matrix):  [ 0 0 ... 0 0 | 0 ] [ ---------------+---] [ 1 0 ... 0 0 | 0 ] A = [ 0 1 ... 0 0 | 0 ] [ ... | 0 ] [ 0 0 ... 1 0 | 0 ] [ 0 0 ... 0 1 | 0 ]  From this predicted vector, the corrected vector is computed as follows:  yn+1 = yn + S1(n+1) + [ -1 +1 -1 +1 ... ±1 ] rn+1 s1(n+1) = h f(tn+1, yn+1) rn+1 = Rn+1 + (s1(n+1) - S1(n+1)) P-1 u  where the upper case Yn+1, S1(n+1) and Rn+1 represent the predicted states whereas the lower case yn+1, sn+1 and rn+1 represent the corrected states. The P-1u vector and the P-1 A P matrix do not depend on the state, they only depend on k and therefore are precomputed once for all.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.AdamsMoultonIntegrator	(	int	double	double	double	double	): Build an Adams-Moulton integrator with the given order and error control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.AdamsMoultonIntegrator	(	int	double	double	double[]	double[]	): Build an Adams-Moulton integrator with the given order and error control parameters.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.Corrector: Corrector for current state in Adams-Moulton method.  This visitor implements the Taylor series formula:  Yn+1 = yn + s1(n+1) + [ -1 +1 -1 +1 ... ±1 ] rn+1  
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.Corrector.Corrector	(	double[]	double[]	double[]	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.Corrector.end	(	): End visiting the Nordsieck vector. The correction is used to control stepsize. So its amplitude is considered to be an error, which must be normalized according to error control settings. If the normalized value is greater than 1, the correction was too large and the step must be rejected.
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.Corrector.start	(	int	int	int	int	int	int	): Start visiting a matrix. This method is called once before any entry of the matrix is visited. 
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.Corrector.visit	(	int	int	double	): Visit one matrix entry. 
org.apache.commons.math4.ode.nonstiff.AdamsMoultonIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.   
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer: Transformer to Nordsieck vectors for Adams integrators. This class is used by AdamsBashforthIntegrator Adams-Bashforth and AdamsMoultonIntegrator Adams-Moulton integrators to convert between classical representation with several previous first derivatives and Nordsieck representation with higher order scaled derivatives. We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  With the previous definition, the classical representation of multistep methods uses first derivatives only, i.e. it handles yn, s1(n) and qn where qn is defined as:  qn = [ s1(n-1) s1(n-2) ... s1(n-(k-1)) ]T  (we omit the k index in the notation for clarity). Another possible representation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step, i.e it handles yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (here again we omit the k index in the notation for clarity) Taylor series formulas show that for any index offset i, s1(n-i) can be computed from s1(n), s2(n) ... sk(n), the formula being exact for degree k polynomials.  s1(n-i) = s1(n) + ∑j>0 (j+1) (-i)j sj+1(n)  The previous formula can be used with several values for i to compute the transform between classical representation and Nordsieck vector at step end. The transform between rn and qn resulting from the Taylor series formulas above is:  qn = s1(n) u + P rn  where u is the [ 1 1 ... 1 ]T vector and P is the (k-1)×(k-1) matrix built with the (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ]  Changing -i into +i in the formula above can be used to compute a similar transform between classical representation and Nordsieck vector at step start. The resulting matrix is simply the absolute value of matrix P. For AdamsBashforthIntegrator Adams-Bashforth method, the Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  yn+1 = yn + s1(n) + uT rn s1(n+1) = h f(tn+1, yn+1) rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  where A is a rows shifting matrix (the lower left part is an identity matrix):  [ 0 0 ... 0 0 | 0 ] [ ---------------+---] [ 1 0 ... 0 0 | 0 ] A = [ 0 1 ... 0 0 | 0 ] [ ... | 0 ] [ 0 0 ... 1 0 | 0 ] [ 0 0 ... 0 1 | 0 ]  For AdamsMoultonIntegrator Adams-Moulton method, the predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  Yn+1 = yn + s1(n) + uT rn S1(n+1) = h f(tn+1, Yn+1) Rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  From this predicted vector, the corrected vector is computed as follows:  yn+1 = yn + S1(n+1) + [ -1 +1 -1 +1 ... ±1 ] rn+1 s1(n+1) = h f(tn+1, yn+1) rn+1 = Rn+1 + (s1(n+1) - S1(n+1)) P-1 u  where the upper case Yn+1, S1(n+1) and Rn+1 represent the predicted states whereas the lower case yn+1, sn+1 and rn+1 represent the corrected states. We observe that both methods use similar update formulas. In both cases a P-1u vector and a P-1 A P matrix are used that do not depend on the state, they only depend on k. This class handles these transformations.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer.AdamsNordsieckFieldTransformer	(	Field	int	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer.buildP	(	int	): Build the P matrix. The P matrix general terms are shifted (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ] 
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer.getInstance	(	Field	int	): Get the Nordsieck transformer for a given field and number of steps.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer.initializeHighOrderDerivatives	(	T	T[]	T[][]	T[][]	): Initialize the high order scaled derivatives at step start.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer.updateHighOrderDerivativesPhase1	(	Array2DRowFieldMatrix	): Update the high order scaled derivatives for Adams integrators (phase 1). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the P-1 A P rn part.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckFieldTransformer.updateHighOrderDerivativesPhase2	(	T[]	T[]	Array2DRowFieldMatrix	): Update the high order scaled derivatives Adams integrators (phase 2). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the (s1(n) - s1(n+1)) P-1 u part. Phase 1 of the update must already have been performed.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer: Transformer to Nordsieck vectors for Adams integrators. This class is used by AdamsBashforthIntegrator Adams-Bashforth and AdamsMoultonIntegrator Adams-Moulton integrators to convert between classical representation with several previous first derivatives and Nordsieck representation with higher order scaled derivatives. We define scaled derivatives si(n) at step n as:  s1(n) = h y'n for first derivative s2(n) = h2/2 y''n for second derivative s3(n) = h3/6 y'''n for third derivative ... sk(n) = hk/k! y(k)n for kth derivative  With the previous definition, the classical representation of multistep methods uses first derivatives only, i.e. it handles yn, s1(n) and qn where qn is defined as:  qn = [ s1(n-1) s1(n-2) ... s1(n-(k-1)) ]T  (we omit the k index in the notation for clarity). Another possible representation uses the Nordsieck vector with higher degrees scaled derivatives all taken at the same step, i.e it handles yn, s1(n) and rn) where rn is defined as:  rn = [ s2(n), s3(n) ... sk(n) ]T  (here again we omit the k index in the notation for clarity) Taylor series formulas show that for any index offset i, s1(n-i) can be computed from s1(n), s2(n) ... sk(n), the formula being exact for degree k polynomials.  s1(n-i) = s1(n) + ∑j>0 (j+1) (-i)j sj+1(n)  The previous formula can be used with several values for i to compute the transform between classical representation and Nordsieck vector at step end. The transform between rn and qn resulting from the Taylor series formulas above is:  qn = s1(n) u + P rn  where u is the [ 1 1 ... 1 ]T vector and P is the (k-1)×(k-1) matrix built with the (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ]  Changing -i into +i in the formula above can be used to compute a similar transform between classical representation and Nordsieck vector at step start. The resulting matrix is simply the absolute value of matrix P. For AdamsBashforthIntegrator Adams-Bashforth method, the Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  yn+1 = yn + s1(n) + uT rn s1(n+1) = h f(tn+1, yn+1) rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  where A is a rows shifting matrix (the lower left part is an identity matrix):  [ 0 0 ... 0 0 | 0 ] [ ---------------+---] [ 1 0 ... 0 0 | 0 ] A = [ 0 1 ... 0 0 | 0 ] [ ... | 0 ] [ 0 0 ... 1 0 | 0 ] [ 0 0 ... 0 1 | 0 ]  For AdamsMoultonIntegrator Adams-Moulton method, the predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:  Yn+1 = yn + s1(n) + uT rn S1(n+1) = h f(tn+1, Yn+1) Rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  From this predicted vector, the corrected vector is computed as follows:  yn+1 = yn + S1(n+1) + [ -1 +1 -1 +1 ... ±1 ] rn+1 s1(n+1) = h f(tn+1, yn+1) rn+1 = Rn+1 + (s1(n+1) - S1(n+1)) P-1 u  where the upper case Yn+1, S1(n+1) and Rn+1 represent the predicted states whereas the lower case yn+1, sn+1 and rn+1 represent the corrected states. We observe that both methods use similar update formulas. In both cases a P-1u vector and a P-1 A P matrix are used that do not depend on the state, they only depend on k. This class handles these transformations.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.AdamsNordsieckTransformer	(	int	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.buildP	(	int	): Build the P matrix. The P matrix general terms are shifted (j+1) (-i)j terms with i being the row number starting from 1 and j being the column number starting from 1:  [ -2 3 -4 5 ... ] [ -4 12 -32 80 ... ] P = [ -6 27 -108 405 ... ] [ -8 48 -256 1280 ... ] [ ... ] 
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.getInstance	(	int	): Get the Nordsieck transformer for a given number of steps.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.getNSteps	(	): Get the number of steps of the method (excluding the one being computed).
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.initializeHighOrderDerivatives	(	double	double[]	double[][]	double[][]	): Initialize the high order scaled derivatives at step start.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.updateHighOrderDerivativesPhase1	(	Array2DRowRealMatrix	): Update the high order scaled derivatives for Adams integrators (phase 1). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the P-1 A P rn part.
org.apache.commons.math4.ode.nonstiff.AdamsNordsieckTransformer.updateHighOrderDerivativesPhase2	(	double[]	double[]	Array2DRowRealMatrix	): Update the high order scaled derivatives Adams integrators (phase 2). The complete update of high order derivatives has a form similar to:  rn+1 = (s1(n) - s1(n+1)) P-1 u + P-1 A P rn  this method computes the (s1(n) - s1(n+1)) P-1 u part. Phase 1 of the update must already have been performed.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator: This abstract class holds the common part of all adaptive stepsize integrators for Ordinary Differential Equations. These algorithms perform integration with stepsize control, which means the user does not specify the integration step but rather a tolerance on error. The error threshold is computed as  threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))  where absTol_i is the absolute tolerance for component i of the state vector and relTol_i is the relative tolerance for the same component. The user can also use only two scalar values absTol and relTol which will be used for all components.  Note that only the getState() main part of the state vector is used for stepsize control. The getSecondaryState() secondary parts of the state vector are explicitly ignored for stepsize control.  If the estimated error for ym+1 is such that  sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1  (where n is the main set dimension) then the step is accepted, otherwise the step is rejected and a new attempt is made with a new stepsize.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.AdaptiveStepsizeFieldIntegrator	(	Field	String	double	double	double	double	): Build an integrator with the given stepsize bounds. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.AdaptiveStepsizeFieldIntegrator	(	Field	String	double	double	double[]	double[]	): Build an integrator with the given stepsize bounds. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.filterStep	(	T	boolean	boolean	): Filter the integration step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.getMaxStep	(	): Get the maximal step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.getMinStep	(	): Get the minimal step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.initializeStep	(	boolean	int	T[]	FieldODEStateAndDerivative	FieldEquationsMapper	): Initialize the integration step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.resetInternalState	(	): Reset internal state to dummy values. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.sanityChecks	(	FieldODEState	T	): Check the integration span. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.setInitialStepSize	(	T	): Set the initial step size. This method allows the user to specify an initial positive step size instead of letting the integrator guess it by itself. If this method is not called before integration is started, the initial step size will be estimated by the integrator.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.setStepSizeControl	(	double	double	double	double	): Set the adaptive step size control parameters.  A side effect of this method is to also reset the initial step so it will be automatically computed by the integrator if setInitialStepSize() is not called by the user. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeFieldIntegrator.setStepSizeControl	(	double	double	double[]	double[]	): Set the adaptive step size control parameters.  A side effect of this method is to also reset the initial step so it will be automatically computed by the integrator if setInitialStepSize() is not called by the user. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator: This abstract class holds the common part of all adaptive stepsize integrators for Ordinary Differential Equations. These algorithms perform integration with stepsize control, which means the user does not specify the integration step but rather a tolerance on error. The error threshold is computed as  threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))  where absTol_i is the absolute tolerance for component i of the state vector and relTol_i is the relative tolerance for the same component. The user can also use only two scalar values absTol and relTol which will be used for all components.  If the Ordinary Differential Equations is an ExpandableStatefulODE extended ODE rather than a org.apache.commons.math4.ode.FirstOrderDifferentialEquations basic ODE, then only the getPrimaryState() primary part of the state vector is used for stepsize control, not the complete state vector.  If the estimated error for ym+1 is such that  sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1  (where n is the main set dimension) then the step is accepted, otherwise the step is rejected and a new attempt is made with a new stepsize.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator	(	String	double	double	double	double	): Build an integrator with the given stepsize bounds. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator	(	String	double	double	double[]	double[]	): Build an integrator with the given stepsize bounds. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.filterStep	(	double	boolean	boolean	): Filter the integration step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.getCurrentStepStart	(	): Get the current value of the step start time ti. This method can be called during integration (typically by the object implementing the FirstOrderDifferentialEquations differential equations problem) if the value of the current step that is attempted is needed. The result is undefined if the method is called outside of calls to integrate.  
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.getMaxStep	(	): Get the maximal step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.getMinStep	(	): Get the minimal step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.initializeStep	(	boolean	int	double[]	double	double[]	double[]	double[]	double[]	): Initialize the integration step.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.resetInternalState	(	): Reset internal state to dummy values. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.sanityChecks	(	ExpandableStatefulODE	double	): Check the integration span. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.setInitialStepSize	(	double	): Set the initial step size. This method allows the user to specify an initial positive step size instead of letting the integrator guess it by itself. If this method is not called before integration is started, the initial step size will be estimated by the integrator.
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.setStepSizeControl	(	double	double	double	double	): Set the adaptive step size control parameters.  A side effect of this method is to also reset the initial step so it will be automatically computed by the integrator if setInitialStepSize() is not called by the user. 
org.apache.commons.math4.ode.nonstiff.AdaptiveStepsizeIntegrator.setStepSizeControl	(	double	double	double[]	double[]	): Set the adaptive step size control parameters.  A side effect of this method is to also reset the initial step so it will be automatically computed by the integrator if setInitialStepSize() is not called by the user. 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldIntegrator: This class implements the classical fourth order Runge-Kutta integrator for Ordinary Differential Equations (it is the most often used Runge-Kutta method). This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 1/2 | 1/2 0 0 0 1/2 | 0 1/2 0 0 1 | 0 0 1 0 |-------------------- | 1/6 1/3 1/3 1/6 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldIntegrator.ClassicalRungeKuttaFieldIntegrator	(	Field	T	): Simple constructor. Build a fourth-order Runge-Kutta integrator with the given step.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldStepInterpolator: This class implements a step interpolator for the classical fourth order Runge-Kutta integrator. This interpolator allows to compute dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ (h/6) [ (6 - 9 θ + 4 θ2) y'1 + ( 6 θ - 4 θ2) (y'2 + y'3) + ( -3 θ + 4 θ2) y'4 ]  Using reference point at step end: y(tn + θ h) = y (tn + h) + (1 - θ) (h/6) [ (-4 θ^2 + 5 θ - 1) y'1 +(4 θ^2 - 2 θ - 2) (y'2 + y'3) -(4 θ^2 + θ + 1) y'4 ]   where θ belongs to [0 ; 1] and where y'1 to y'4 are the four evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldStepInterpolator.ClassicalRungeKuttaFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaIntegrator: This class implements the classical fourth order Runge-Kutta integrator for Ordinary Differential Equations (it is the most often used Runge-Kutta method). This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 1/2 | 1/2 0 0 0 1/2 | 0 1/2 0 0 1 | 0 0 1 0 |-------------------- | 1/6 1/3 1/3 1/6 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaIntegrator.ClassicalRungeKuttaIntegrator	(	double	): Simple constructor. Build a fourth-order Runge-Kutta integrator with the given step.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaStepInterpolator: This class implements a step interpolator for the classical fourth order Runge-Kutta integrator. This interpolator allows to compute dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ (h/6) [ (6 - 9 θ + 4 θ2) y'1 + ( 6 θ - 4 θ2) (y'2 + y'3) + ( -3 θ + 4 θ2) y'4 ]  Using reference point at step end: y(tn + θ h) = y (tn + h) + (1 - θ) (h/6) [ (-4 θ^2 + 5 θ - 1) y'1 +(4 θ^2 - 2 θ - 2) (y'2 + y'3) -(4 θ^2 + θ + 1) y'4 ]   where θ belongs to [0 ; 1] and where y'1 to y'4 are the four evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaStepInterpolator.ClassicalRungeKuttaStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaStepInterpolator.ClassicalRungeKuttaStepInterpolator	(	ClassicalRungeKuttaStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.ClassicalRungeKuttaStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator: This class implements the 5(4) Dormand-Prince integrator for Ordinary Differential Equations. This integrator is an embedded Runge-Kutta integrator of order 5(4) used in local extrapolation mode (i.e. the solution is computed using the high order formula) with stepsize control (and automatic step initialization) and continuous output. This method uses 7 functions evaluations per step. However, since this is an fsal, the last evaluation of one step is the same as the first evaluation of the next step and hence can be avoided. So the cost is really 6 functions evaluations per step. This method has been published (whithout the continuous output that was added by Shampine in 1986) in the following article :  A family of embedded Runge-Kutta formulae J. R. Dormand and P. J. Prince Journal of Computational and Applied Mathematics volume 6, no 1, 1980, pp. 19-26 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.DormandPrince54FieldIntegrator	(	Field	double	double	double	double	): Simple constructor. Build a fifth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.DormandPrince54FieldIntegrator	(	Field	double	double	double[]	double[]	): Simple constructor. Build a fifth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.estimateError	(	T[][]	T[]	T[]	T	): Compute the error ratio. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldIntegrator.getOrder	(	): Get the order of the method. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldStepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 5(4) Dormand-Prince integrator.
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldStepInterpolator.DormandPrince54FieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54FieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator: This class implements the 5(4) Dormand-Prince integrator for Ordinary Differential Equations. This integrator is an embedded Runge-Kutta integrator of order 5(4) used in local extrapolation mode (i.e. the solution is computed using the high order formula) with stepsize control (and automatic step initialization) and continuous output. This method uses 7 functions evaluations per step. However, since this is an fsal, the last evaluation of one step is the same as the first evaluation of the next step and hence can be avoided. So the cost is really 6 functions evaluations per step. This method has been published (whithout the continuous output that was added by Shampine in 1986) in the following article :  A family of embedded Runge-Kutta formulae J. R. Dormand and P. J. Prince Journal of Computational and Applied Mathematics volume 6, no 1, 1980, pp. 19-26 
org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator.DormandPrince54Integrator	(	double	double	double	double	): Simple constructor. Build a fifth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator.DormandPrince54Integrator	(	double	double	double[]	double[]	): Simple constructor. Build a fifth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator.estimateError	(	double[][]	double[]	double[]	double	): Compute the error ratio. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54Integrator.getOrder	(	): Get the order of the method. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 5(4) Dormand-Prince integrator.
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator.DormandPrince54StepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The EmbeddedRungeKuttaIntegrator uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy.
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator.DormandPrince54StepInterpolator	(	DormandPrince54StepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator.reinitialize	(	AbstractIntegrator	double[]	double[][]	boolean	EquationsMapper	EquationsMapper[]	): Reinitialize the instance Some Runge-Kutta integrators need fewer functions evaluations than their counterpart step interpolators. So the interpolator should perform the last evaluations they need by themselves. The RungeKuttaIntegrator RungeKuttaIntegrator and EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator abstract classes call this method in order to let the step interpolator perform the evaluations it needs. These evaluations will be performed during the call to doFinalize if any, i.e. only if the step handler either calls the finalizeStep method or the getInterpolatedState method (for an interpolator which needs a finalization) or if it clones the step interpolator. 
org.apache.commons.math4.ode.nonstiff.DormandPrince54StepInterpolator.storeTime	(	double	): Store the current step time. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator: This class implements the 8(5,3) Dormand-Prince integrator for Ordinary Differential Equations. This integrator is an embedded Runge-Kutta integrator of order 8(5,3) used in local extrapolation mode (i.e. the solution is computed using the high order formula) with stepsize control (and automatic step initialization) and continuous output. This method uses 12 functions evaluations per step for integration and 4 evaluations for interpolation. However, since the first interpolation evaluation is the same as the first integration evaluation of the next step, we have included it in the integrator rather than in the interpolator and specified the method was an fsal. Hence, despite we have 13 stages here, the cost is really 12 evaluations per step even if no interpolation is done, and the overcost of interpolation is only 3 evaluations. This method is based on an 8(6) method by Dormand and Prince (i.e. order 8 for the integration and order 6 for error estimation) modified by Hairer and Wanner to use a 5th order error estimator with 3rd order correction. This modification was introduced because the original method failed in some cases (wrong steps can be accepted when step size is too large, for example in the Brusselator problem) and also had severe difficulties when applied to problems with discontinuities. This modification is explained in the second edition of the first volume (Nonstiff Problems) of the reference book by Hairer, Norsett and Wanner: Solving Ordinary Differential Equations (Springer-Verlag, ISBN 3-540-56670-8).
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.DormandPrince853FieldIntegrator	(	Field	double	double	double	double	): Simple constructor. Build an eighth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.DormandPrince853FieldIntegrator	(	Field	double	double	double[]	double[]	): Simple constructor. Build an eighth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.estimateError	(	T[][]	T[]	T[]	T	): Compute the error ratio. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldIntegrator.getOrder	(	): Get the order of the method. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldStepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 8(5,3) Dormand-Prince integrator.
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldStepInterpolator.DormandPrince853FieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853FieldStepInterpolator.fraction	(	Field	double	double	): Create a fraction.
org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator: This class implements the 8(5,3) Dormand-Prince integrator for Ordinary Differential Equations. This integrator is an embedded Runge-Kutta integrator of order 8(5,3) used in local extrapolation mode (i.e. the solution is computed using the high order formula) with stepsize control (and automatic step initialization) and continuous output. This method uses 12 functions evaluations per step for integration and 4 evaluations for interpolation. However, since the first interpolation evaluation is the same as the first integration evaluation of the next step, we have included it in the integrator rather than in the interpolator and specified the method was an fsal. Hence, despite we have 13 stages here, the cost is really 12 evaluations per step even if no interpolation is done, and the overcost of interpolation is only 3 evaluations. This method is based on an 8(6) method by Dormand and Prince (i.e. order 8 for the integration and order 6 for error estimation) modified by Hairer and Wanner to use a 5th order error estimator with 3rd order correction. This modification was introduced because the original method failed in some cases (wrong steps can be accepted when step size is too large, for example in the Brusselator problem) and also had severe difficulties when applied to problems with discontinuities. This modification is explained in the second edition of the first volume (Nonstiff Problems) of the reference book by Hairer, Norsett and Wanner: Solving Ordinary Differential Equations (Springer-Verlag, ISBN 3-540-56670-8).
org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator.DormandPrince853Integrator	(	double	double	double	double	): Simple constructor. Build an eighth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator.DormandPrince853Integrator	(	double	double	double[]	double[]	): Simple constructor. Build an eighth order Dormand-Prince integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator.estimateError	(	double[][]	double[]	double[]	double	): Compute the error ratio. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853Integrator.getOrder	(	): Get the order of the method. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 8(5,3) Dormand-Prince integrator.
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The EmbeddedRungeKuttaIntegrator uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy.
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator	(	DormandPrince853StepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.doFinalize	(	): Really finalize the step. The default implementation of this method does nothing. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.readExternal	(	ObjectInput	):    
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.reinitialize	(	AbstractIntegrator	double[]	double[][]	boolean	EquationsMapper	EquationsMapper[]	): Reinitialize the instance Some Runge-Kutta integrators need fewer functions evaluations than their counterpart step interpolators. So the interpolator should perform the last evaluations they need by themselves. The RungeKuttaIntegrator RungeKuttaIntegrator and EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator abstract classes call this method in order to let the step interpolator perform the evaluations it needs. These evaluations will be performed during the call to doFinalize if any, i.e. only if the step handler either calls the finalizeStep method or the getInterpolatedState method (for an interpolator which needs a finalization) or if it clones the step interpolator. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.storeTime	(	double	): Store the current step time. 
org.apache.commons.math4.ode.nonstiff.DormandPrince853StepInterpolator.writeExternal	(	ObjectOutput	):    
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator: This class implements the common part of all embedded Runge-Kutta integrators for Ordinary Differential Equations. These methods are embedded explicit Runge-Kutta methods with two sets of coefficients allowing to estimate the error, their Butcher arrays are as follows :  0 | c2 | a21 c3 | a31 a32 ... | ... cs | as1 as2 ... ass-1 |-------------------------- | b1 b2 ... bs-1 bs | b'1 b'2 ... b's-1 b's  In fact, we rather use the array defined by ej = bj - b'j to compute directly the error rather than computing two estimates and then comparing them. Some methods are qualified as fsal (first same as last) methods. This means the last evaluation of the derivatives in one step is the same as the first in the next step. Then, this evaluation can be reused from one step to the next one and the cost of such a method is really s-1 evaluations despite the method still has s stages. This behaviour is true only for successful steps, if the step is rejected after the error estimation phase, no evaluation is saved. For an fsal method, we have cs = 1 and asi = bi for all i.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.EmbeddedRungeKuttaFieldIntegrator	(	Field	String	int	double	double	double	double	): Build a Runge-Kutta integrator with the given Butcher array.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.EmbeddedRungeKuttaFieldIntegrator	(	Field	String	int	double	double	double[]	double[]	): Build a Runge-Kutta integrator with the given Butcher array.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.estimateError	(	T[][]	T[]	T[]	T	): Compute the error ratio.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.fraction	(	double	double	): Create a fraction.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.fraction	(	int	int	): Create a fraction.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.getMaxGrowth	(	): Get the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.getMinReduction	(	): Get the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.getOrder	(	): Get the order of the method.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.getSafety	(	): Get the safety factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.integrate	(	FieldExpandableODE	FieldODEState	T	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe. 
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.setMaxGrowth	(	T	): Set the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.setMinReduction	(	T	): Set the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaFieldIntegrator.setSafety	(	T	): Set the safety factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator: This class implements the common part of all embedded Runge-Kutta integrators for Ordinary Differential Equations. These methods are embedded explicit Runge-Kutta methods with two sets of coefficients allowing to estimate the error, their Butcher arrays are as follows :  0 | c2 | a21 c3 | a31 a32 ... | ... cs | as1 as2 ... ass-1 |-------------------------- | b1 b2 ... bs-1 bs | b'1 b'2 ... b's-1 b's  In fact, we rather use the array defined by ej = bj - b'j to compute directly the error rather than computing two estimates and then comparing them. Some methods are qualified as fsal (first same as last) methods. This means the last evaluation of the derivatives in one step is the same as the first in the next step. Then, this evaluation can be reused from one step to the next one and the cost of such a method is really s-1 evaluations despite the method still has s stages. This behaviour is true only for successful steps, if the step is rejected after the error estimation phase, no evaluation is saved. For an fsal method, we have cs = 1 and asi = bi for all i.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator	(	String	boolean	double[]	double[][]	double[]	RungeKuttaStepInterpolator	double	double	double	double	): Build a Runge-Kutta integrator with the given Butcher array.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator	(	String	boolean	double[]	double[][]	double[]	RungeKuttaStepInterpolator	double	double	double[]	double[]	): Build a Runge-Kutta integrator with the given Butcher array.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.estimateError	(	double[][]	double[]	double[]	double	): Compute the error ratio.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.getMaxGrowth	(	): Get the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.getMinReduction	(	): Get the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.getOrder	(	): Get the order of the method.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.getSafety	(	): Get the safety factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.  
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMaxGrowth	(	double	): Set the maximal growth factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMinReduction	(	double	): Set the minimal reduction factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setSafety	(	double	): Set the safety factor for stepsize control.
org.apache.commons.math4.ode.nonstiff.EulerFieldIntegrator: This class implements a simple Euler integrator for Ordinary Differential Equations. The Euler algorithm is the simplest one that can be used to integrate ordinary differential equations. It is a simple inversion of the forward difference expression : f'=(f(t+h)-f(t))/h which leads to f(t+h)=f(t)+hf'. The interpolation scheme used for dense output is the linear scheme already used for integration. This algorithm looks cheap because it needs only one function evaluation per step. However, as it uses linear estimates, it needs very small steps to achieve high accuracy, and small steps lead to numerical errors and instabilities. This algorithm is almost never used and has been included in this package only as a comparison reference for more useful integrators.
org.apache.commons.math4.ode.nonstiff.EulerFieldIntegrator.EulerFieldIntegrator	(	Field	T	): Simple constructor. Build an Euler integrator with the given step.
org.apache.commons.math4.ode.nonstiff.EulerFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.EulerFieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.EulerFieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.EulerFieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.EulerFieldStepInterpolator: This class implements a linear interpolator for step. This interpolator computes dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ h y'  Using reference point at step end: y(tn + θ h) = y (tn + h) - (1-θ) h y'   where θ belongs to [0 ; 1] and where y' is the evaluation of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.EulerFieldStepInterpolator.EulerFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.EulerFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.EulerFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.EulerIntegrator: This class implements a simple Euler integrator for Ordinary Differential Equations. The Euler algorithm is the simplest one that can be used to integrate ordinary differential equations. It is a simple inversion of the forward difference expression : f'=(f(t+h)-f(t))/h which leads to f(t+h)=f(t)+hf'. The interpolation scheme used for dense output is the linear scheme already used for integration. This algorithm looks cheap because it needs only one function evaluation per step. However, as it uses linear estimates, it needs very small steps to achieve high accuracy, and small steps lead to numerical errors and instabilities. This algorithm is almost never used and has been included in this package only as a comparison reference for more useful integrators.
org.apache.commons.math4.ode.nonstiff.EulerIntegrator.EulerIntegrator	(	double	): Simple constructor. Build an Euler integrator with the given step.
org.apache.commons.math4.ode.nonstiff.EulerStepInterpolator: This class implements a linear interpolator for step. This interpolator computes dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ h y'  Using reference point at step end: y(tn + θ h) = y (tn + h) - (1-θ) h y'   where θ belongs to [0 ; 1] and where y' is the evaluation of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.EulerStepInterpolator.EulerStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and later initializing the copy.
org.apache.commons.math4.ode.nonstiff.EulerStepInterpolator.EulerStepInterpolator	(	EulerStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.EulerStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.EulerStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.FieldButcherArrayProvider: This interface represents an integrator based on Butcher arrays.
org.apache.commons.math4.ode.nonstiff.FieldButcherArrayProvider.getA	(	): Get the internal weights from Butcher array (without the first empty row).
org.apache.commons.math4.ode.nonstiff.FieldButcherArrayProvider.getB	(	): Get the external weights for the high order method from Butcher array.
org.apache.commons.math4.ode.nonstiff.FieldButcherArrayProvider.getC	(	): Get the time steps from Butcher array (without the first zero).
org.apache.commons.math4.ode.nonstiff.GillFieldIntegrator: This class implements the Gill fourth order Runge-Kutta integrator for Ordinary Differential Equations . This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 1/2 | 1/2 0 0 0 1/2 | (q-1)/2 (2-q)/2 0 0 1 | 0 -q/2 (2+q)/2 0 |------------------------------- | 1/6 (2-q)/6 (2+q)/6 1/6  where q = sqrt(2)
org.apache.commons.math4.ode.nonstiff.GillFieldIntegrator.GillFieldIntegrator	(	Field	T	): Simple constructor. Build a fourth-order Gill integrator with the given step.
org.apache.commons.math4.ode.nonstiff.GillFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.GillFieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.GillFieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.GillFieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.GillFieldStepInterpolator: This class implements a step interpolator for the Gill fourth order Runge-Kutta integrator. This interpolator allows to compute dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ (h/6) [ (6 - 9 θ + 4 θ2) y'1 + ( 6 θ - 4 θ2) ((1-1/√2) y'2 + (1+1/√2)) y'3) + ( - 3 θ + 4 θ2) y'4 ]  Using reference point at step start: y(tn + θ h) = y (tn + h) - (1 - θ) (h/6) [ (1 - 5 θ + 4 θ2) y'1 + (2 + 2 θ - 4 θ2) ((1-1/√2) y'2 + (1+1/√2)) y'3) + (1 + θ + 4 θ2) y'4 ]   where θ belongs to [0 ; 1] and where y'1 to y'4 are the four evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.GillFieldStepInterpolator.GillFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.GillFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.GillFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.GillIntegrator: This class implements the Gill fourth order Runge-Kutta integrator for Ordinary Differential Equations . This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 1/2 | 1/2 0 0 0 1/2 | (q-1)/2 (2-q)/2 0 0 1 | 0 -q/2 (2+q)/2 0 |------------------------------- | 1/6 (2-q)/6 (2+q)/6 1/6  where q = sqrt(2)
org.apache.commons.math4.ode.nonstiff.GillIntegrator.GillIntegrator	(	double	): Simple constructor. Build a fourth-order Gill integrator with the given step.
org.apache.commons.math4.ode.nonstiff.GillStepInterpolator: This class implements a step interpolator for the Gill fourth order Runge-Kutta integrator. This interpolator allows to compute dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ (h/6) [ (6 - 9 θ + 4 θ2) y'1 + ( 6 θ - 4 θ2) ((1-1/√2) y'2 + (1+1/√2)) y'3) + ( - 3 θ + 4 θ2) y'4 ]  Using reference point at step start: y(tn + θ h) = y (tn + h) - (1 - θ) (h/6) [ (1 - 5 θ + 4 θ2) y'1 + (2 + 2 θ - 4 θ2) ((1-1/√2) y'2 + (1+1/√2)) y'3) + (1 + θ + 4 θ2) y'4 ]   where θ belongs to [0 ; 1] and where y'1 to y'4 are the four evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.GillStepInterpolator.GillStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and later initializing the copy.
org.apache.commons.math4.ode.nonstiff.GillStepInterpolator.GillStepInterpolator	(	GillStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.GillStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.GillStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator: This class implements a Gragg-Bulirsch-Stoer integrator for Ordinary Differential Equations. The Gragg-Bulirsch-Stoer algorithm is one of the most efficient ones currently available for smooth problems. It uses Richardson extrapolation to estimate what would be the solution if the step size could be decreased down to zero.  This method changes both the step size and the order during integration, in order to minimize computation cost. It is particularly well suited when a very high precision is needed. The limit where this method becomes more efficient than high-order embedded Runge-Kutta methods like DormandPrince853Integrator Dormand-Prince 8(5,3) depends on the problem. Results given in the Hairer, Norsett and Wanner book show for example that this limit occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz equations (the authors note this problem is extremely sensitive to the errors in the first integration steps), and around 1e-11 for a two dimensional celestial mechanics problems with seven bodies (pleiades problem, involving quasi-collisions for which automatic step size control is essential).   This implementation is basically a reimplementation in Java of the odex fortran code by E. Hairer and G. Wanner. The redistribution policy for this code is available here, for convenience, it is reproduced below.  Copyright (c) 2004, Ernst Hairer Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.GraggBulirschStoerIntegrator	(	double	double	double	double	): Simple constructor. Build a Gragg-Bulirsch-Stoer integrator with the given step bounds. All tuning parameters are set to their default values. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.GraggBulirschStoerIntegrator	(	double	double	double[]	double[]	): Simple constructor. Build a Gragg-Bulirsch-Stoer integrator with the given step bounds. All tuning parameters are set to their default values. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.addEventHandler	(	EventHandler	double	double	int	UnivariateSolver	): Add an event handler to the integrator.  
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.addStepHandler	(	StepHandler	): Add a step handler to this integrator. The handler will be called by the integrator for each accepted step.  
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.extrapolate	(	int	int	double[][]	double[]	): Extrapolate a vector.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.initializeArrays	(	): Initialize the integrator internal arrays. 
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe.  
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.rescale	(	double[]	double[]	double[]	): Update scaling array.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.setControlFactors	(	double	double	double	double	): Set the step size control factors. The new step size hNew is computed from the old one h by:  hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))  where err is the scaled error and k the iteration number of the extrapolation scheme (counting from 0). The default values are 0.65 for stepControl1 and 0.94 for stepControl2. The step size is subject to the restriction:  stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))  The default values are 0.02 for stepControl3 and 4.0 for stepControl4.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.setInterpolationControl	(	boolean	int	): Set the interpolation order control parameter. The interpolation order for dense output is 2k - mudif + 1. The default value for mudif is 4 and the interpolation error is used in stepsize control by default.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.setOrderControl	(	int	double	double	): Set the order control parameters. The Gragg-Bulirsch-Stoer method changes both the step size and the order during integration, in order to minimize computation cost. Each extrapolation step increases the order by 2, so the maximal order that will be used is always even, it is twice the maximal number of columns in the extrapolation table.  order is decreased if w(k-1) <= w(k) * orderControl1 order is increased if w(k) <= w(k-1) * orderControl2  where w is the table of work per unit step for each order (number of function calls divided by the step length), and k is the current order. The default maximal order after construction is 18 (i.e. the maximal number of columns is 9). The default values are 0.8 for orderControl1 and 0.9 for orderControl2.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.setStabilityCheck	(	boolean	int	int	double	): Set the stability check controls. The stability check is performed on the first few iterations of the extrapolation scheme. If this test fails, the step is rejected and the stepsize is reduced. By default, the test is performed, at most during two iterations at each step, and at most once for each of these iterations. The default stepsize reduction factor is 0.5.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerIntegrator.tryStep	(	double	double[]	double	int	double[]	double[][]	double[]	double[]	double[]	): Perform integration over one step using substeps of a modified midpoint method.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator: This class implements an interpolator for the Gragg-Bulirsch-Stoer integrator. This interpolator compute dense output inside the last step produced by a Gragg-Bulirsch-Stoer integrator.  This implementation is basically a reimplementation in Java of the odex fortran code by E. Hairer and G. Wanner. The redistribution policy for this code is available here, for convenience, it is reproduced below.  Copyright (c) 2004, Ernst Hairer Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.GraggBulirschStoerStepInterpolator	(	): Simple constructor. This constructor should not be used directly, it is only intended for the serialization process.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.GraggBulirschStoerStepInterpolator	(	GraggBulirschStoerStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.GraggBulirschStoerStepInterpolator	(	double[]	double[]	double[]	double[]	double[][]	boolean	EquationsMapper	EquationsMapper[]	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.computeCoefficients	(	int	double	): Compute the interpolation coefficients for dense output.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.estimateError	(	double[]	): Estimate interpolation error.
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.readExternal	(	ObjectInput	):   
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.resetTables	(	int	): Reallocate the internal tables. Reallocate the internal tables in order to be able to handle interpolation polynomials up to the given degree
org.apache.commons.math4.ode.nonstiff.GraggBulirschStoerStepInterpolator.writeExternal	(	ObjectOutput	):   
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator: This class implements the 5(4) Higham and Hall integrator for Ordinary Differential Equations. This integrator is an embedded Runge-Kutta integrator of order 5(4) used in local extrapolation mode (i.e. the solution is computed using the high order formula) with stepsize control (and automatic step initialization) and continuous output. This method uses 7 functions evaluations per step.
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.HighamHall54FieldIntegrator	(	Field	double	double	double	double	): Simple constructor. Build a fifth order Higham and Hall integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.HighamHall54FieldIntegrator	(	Field	double	double	double[]	double[]	): Simple constructor. Build a fifth order Higham and Hall integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.estimateError	(	T[][]	T[]	T[]	T	): Compute the error ratio. 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldIntegrator.getOrder	(	): Get the order of the method. 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldStepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 5(4) Higham and Hall integrator.
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldStepInterpolator.HighamHall54FieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.HighamHall54FieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.HighamHall54Integrator: This class implements the 5(4) Higham and Hall integrator for Ordinary Differential Equations. This integrator is an embedded Runge-Kutta integrator of order 5(4) used in local extrapolation mode (i.e. the solution is computed using the high order formula) with stepsize control (and automatic step initialization) and continuous output. This method uses 7 functions evaluations per step.
org.apache.commons.math4.ode.nonstiff.HighamHall54Integrator.HighamHall54Integrator	(	double	double	double	double	): Simple constructor. Build a fifth order Higham and Hall integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.HighamHall54Integrator.HighamHall54Integrator	(	double	double	double[]	double[]	): Simple constructor. Build a fifth order Higham and Hall integrator with the given step bounds
org.apache.commons.math4.ode.nonstiff.HighamHall54Integrator.estimateError	(	double[][]	double[]	double[]	double	): Compute the error ratio. 
org.apache.commons.math4.ode.nonstiff.HighamHall54Integrator.getOrder	(	): Get the order of the method. 
org.apache.commons.math4.ode.nonstiff.HighamHall54StepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 5(4) Higham and Hall integrator.
org.apache.commons.math4.ode.nonstiff.HighamHall54StepInterpolator.HighamHall54StepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The EmbeddedRungeKuttaIntegrator uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and later initializing the copy.
org.apache.commons.math4.ode.nonstiff.HighamHall54StepInterpolator.HighamHall54StepInterpolator	(	HighamHall54StepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.HighamHall54StepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.HighamHall54StepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.LutherFieldIntegrator: This class implements the Luther sixth order Runge-Kutta integrator for Ordinary Differential Equations.  This method is described in H. A. Luther 1968 paper  An explicit Sixth-Order Runge-Kutta Formula.  This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 0 0 1 | 1 0 0 0 0 0 1/2 | 3/8 1/8 0 0 0 0 2/3 | 8/27 2/27 8/27 0 0 0 (7-q)/14 | ( -21 + 9q)/392 ( -56 + 8q)/392 ( 336 - 48q)/392 ( -63 + 3q)/392 0 0 (7+q)/14 | (-1155 - 255q)/1960 ( -280 - 40q)/1960 ( 0 - 320q)/1960 ( 63 + 363q)/1960 ( 2352 + 392q)/1960 0 1 | ( 330 + 105q)/180 ( 120 + 0q)/180 ( -200 + 280q)/180 ( 126 - 189q)/180 ( -686 - 126q)/180 ( 490 - 70q)/180 |-------------------------------------------------------------------------------------------------------------------------------------------------- | 1/20 0 16/45 0 49/180 49/180 1/20  where q = √21
org.apache.commons.math4.ode.nonstiff.LutherFieldIntegrator.LutherFieldIntegrator	(	Field	T	): Simple constructor. Build a fourth-order Luther integrator with the given step.
org.apache.commons.math4.ode.nonstiff.LutherFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.LutherFieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.LutherFieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.LutherFieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.LutherFieldStepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 6th order Luther integrator. This interpolator computes dense output inside the last step computed. The interpolation equation is consistent with the integration scheme.
org.apache.commons.math4.ode.nonstiff.LutherFieldStepInterpolator.LutherFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.LutherFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.LutherFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.LutherIntegrator: This class implements the Luther sixth order Runge-Kutta integrator for Ordinary Differential Equations.  This method is described in H. A. Luther 1968 paper  An explicit Sixth-Order Runge-Kutta Formula.  This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 0 0 1 | 1 0 0 0 0 0 1/2 | 3/8 1/8 0 0 0 0 2/3 | 8/27 2/27 8/27 0 0 0 (7-q)/14 | ( -21 + 9q)/392 ( -56 + 8q)/392 ( 336 - 48q)/392 ( -63 + 3q)/392 0 0 (7+q)/14 | (-1155 - 255q)/1960 ( -280 - 40q)/1960 ( 0 - 320q)/1960 ( 63 + 363q)/1960 ( 2352 + 392q)/1960 0 1 | ( 330 + 105q)/180 ( 120 + 0q)/180 ( -200 + 280q)/180 ( 126 - 189q)/180 ( -686 - 126q)/180 ( 490 - 70q)/180 |-------------------------------------------------------------------------------------------------------------------------------------------------- | 1/20 0 16/45 0 49/180 49/180 1/20  where q = √21
org.apache.commons.math4.ode.nonstiff.LutherIntegrator.LutherIntegrator	(	double	): Simple constructor. Build a fourth-order Luther integrator with the given step.
org.apache.commons.math4.ode.nonstiff.LutherStepInterpolator: This class represents an interpolator over the last step during an ODE integration for the 6th order Luther integrator. This interpolator computes dense output inside the last step computed. The interpolation equation is consistent with the integration scheme.
org.apache.commons.math4.ode.nonstiff.LutherStepInterpolator.LutherStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and later initializing the copy.
org.apache.commons.math4.ode.nonstiff.LutherStepInterpolator.LutherStepInterpolator	(	LutherStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.LutherStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.LutherStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.MidpointFieldIntegrator: This class implements a second order Runge-Kutta integrator for Ordinary Differential Equations. This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 1/2 | 1/2 0 |---------- | 0 1 
org.apache.commons.math4.ode.nonstiff.MidpointFieldIntegrator.MidpointFieldIntegrator	(	Field	T	): Simple constructor. Build a midpoint integrator with the given step.
org.apache.commons.math4.ode.nonstiff.MidpointFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.MidpointFieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.MidpointFieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.MidpointFieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.MidpointFieldStepInterpolator: This class implements a step interpolator for second order Runge-Kutta integrator. This interpolator computes dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ h [(1 - θ) y'1 + θ y'2]  Using reference point at step end: y(tn + θ h) = y (tn + h) + (1-θ) h [θ y'1 - (1+θ) y'2]   where θ belongs to [0 ; 1] and where y'1 and y'2 are the two evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.MidpointFieldStepInterpolator.MidpointFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.MidpointFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.MidpointFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.MidpointIntegrator: This class implements a second order Runge-Kutta integrator for Ordinary Differential Equations. This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 1/2 | 1/2 0 |---------- | 0 1 
org.apache.commons.math4.ode.nonstiff.MidpointIntegrator.MidpointIntegrator	(	double	): Simple constructor. Build a midpoint integrator with the given step.
org.apache.commons.math4.ode.nonstiff.MidpointStepInterpolator: This class implements a step interpolator for second order Runge-Kutta integrator. This interpolator computes dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ h [(1 - θ) y'1 + θ y'2]  Using reference point at step end: y(tn + θ h) = y (tn + h) + (1-θ) h [θ y'1 - (1+θ) y'2]   where θ belongs to [0 ; 1] and where y'1 and y'2 are the two evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.MidpointStepInterpolator.MidpointStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and later initializing the copy.
org.apache.commons.math4.ode.nonstiff.MidpointStepInterpolator.MidpointStepInterpolator	(	MidpointStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.MidpointStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.MidpointStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldIntegrator: This class implements the common part of all fixed step Runge-Kutta integrators for Ordinary Differential Equations. These methods are explicit Runge-Kutta methods, their Butcher arrays are as follows :  0 | c2 | a21 c3 | a31 a32 ... | ... cs | as1 as2 ... ass-1 |-------------------------- | b1 b2 ... bs-1 bs 
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldIntegrator.RungeKuttaFieldIntegrator	(	Field	String	T	): Simple constructor. Build a Runge-Kutta integrator with the given step. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldIntegrator.fraction	(	int	int	): Create a fraction.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldIntegrator.integrate	(	FieldExpandableODE	FieldODEState	T	): Integrate the differential equations up to the given time. This method solves an Initial Value Problem (IVP). Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe. 
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldIntegrator.singleStep	(	FirstOrderFieldDifferentialEquations	T	T[]	T	): Fast computation of a single step of ODE integration. This method is intended for the limited use case of very fast computation of only one step without using any of the rich features of general integrators that may take some time to set up (i.e. no step handlers, no events handlers, no additional states, no interpolators, no error control, no evaluations count, no sanity checks ...). It handles the strict minimum of computation, so it can be embedded in outer loops.  This method is not used at all by the integrate() method. It also completely ignores the step set at construction time, and uses only a single step to go from t0 to t.   As this method does not use any of the state-dependent features of the integrator, it should be reasonably thread-safe if and only if the provided differential equations are themselves thread-safe. 
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator: This class represents an interpolator over the last step during an ODE integration for Runge-Kutta and embedded Runge-Kutta integrators.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.RungeKuttaFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.combine	(	T[]	T	): Linearly combine arrays.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.create	(	boolean	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.currentStateLinearCombination	(	T	): Compute a state by linear combination added to current state.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.derivativeLinearCombination	(	T	): Compute a state derivative by linear combination.
org.apache.commons.math4.ode.nonstiff.RungeKuttaFieldStepInterpolator.previousStateLinearCombination	(	T	): Compute a state by linear combination added to previous state.
org.apache.commons.math4.ode.nonstiff.RungeKuttaIntegrator: This class implements the common part of all fixed step Runge-Kutta integrators for Ordinary Differential Equations. These methods are explicit Runge-Kutta methods, their Butcher arrays are as follows :  0 | c2 | a21 c3 | a31 a32 ... | ... cs | as1 as2 ... ass-1 |-------------------------- | b1 b2 ... bs-1 bs 
org.apache.commons.math4.ode.nonstiff.RungeKuttaIntegrator.RungeKuttaIntegrator	(	String	double[]	double[][]	double[]	RungeKuttaStepInterpolator	double	): Simple constructor. Build a Runge-Kutta integrator with the given step. The default step handler does nothing.
org.apache.commons.math4.ode.nonstiff.RungeKuttaIntegrator.integrate	(	ExpandableStatefulODE	double	): Integrate a set of differential equations up to the given time. This method solves an Initial Value Problem (IVP). The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object. Since this method stores some internal state variables made available in its public interface during integration (getCurrentSignedStepsize()), it is not thread-safe. 
org.apache.commons.math4.ode.nonstiff.RungeKuttaIntegrator.singleStep	(	FirstOrderDifferentialEquations	double	double[]	double	): Fast computation of a single step of ODE integration. This method is intended for the limited use case of very fast computation of only one step without using any of the rich features of general integrators that may take some time to set up (i.e. no step handlers, no events handlers, no additional states, no interpolators, no error control, no evaluations count, no sanity checks ...). It handles the strict minimum of computation, so it can be embedded in outer loops.  This method is not used at all by the integrate() method. It also completely ignores the step set at construction time, and uses only a single step to go from t0 to t.   As this method does not use any of the state-dependent features of the integrator, it should be reasonably thread-safe if and only if the provided differential equations are themselves thread-safe. 
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator: This class represents an interpolator over the last step during an ODE integration for Runge-Kutta and embedded Runge-Kutta integrators.
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator and EmbeddedRungeKuttaIntegrator classes use the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy.
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator	(	RungeKuttaStepInterpolator	): Copy constructor. The copied interpolator should have been finalized before the copy, otherwise the copy will not be able to perform correctly any interpolation and will throw a NullPointerException later. Since we don't want this constructor to throw the exceptions finalization may involve and since we don't want this method to modify the state of the copied interpolator, finalization is not done automatically, it remains under user control. The copy is a deep copy: its arrays are separated from the original arrays of the instance.
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator.readExternal	(	ObjectInput	):   
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator.reinitialize	(	AbstractIntegrator	double[]	double[][]	boolean	EquationsMapper	EquationsMapper[]	): Reinitialize the instance Some Runge-Kutta integrators need fewer functions evaluations than their counterpart step interpolators. So the interpolator should perform the last evaluations they need by themselves. The RungeKuttaIntegrator RungeKuttaIntegrator and EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator abstract classes call this method in order to let the step interpolator perform the evaluations it needs. These evaluations will be performed during the call to doFinalize if any, i.e. only if the step handler either calls the finalizeStep method or the getInterpolatedState method (for an interpolator which needs a finalization) or if it clones the step interpolator.
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator.shift	(	): Shift one step forward. Copy the current time into the previous time, hence preparing the interpolator for future calls to storeTime 
org.apache.commons.math4.ode.nonstiff.RungeKuttaStepInterpolator.writeExternal	(	ObjectOutput	):   
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldIntegrator: This class implements the 3/8 fourth order Runge-Kutta integrator for Ordinary Differential Equations. This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 1/3 | 1/3 0 0 0 2/3 |-1/3 1 0 0 1 | 1 -1 1 0 |-------------------- | 1/8 3/8 3/8 1/8 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldIntegrator.ThreeEighthesFieldIntegrator	(	Field	T	): Simple constructor. Build a 3/8 integrator with the given step.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldIntegrator.createInterpolator	(	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create an interpolator. 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldIntegrator.getA	(	): Get the internal weights from Butcher array (without the first empty row). 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldIntegrator.getB	(	): Get the external weights for the high order method from Butcher array. 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldIntegrator.getC	(	): Get the time steps from Butcher array (without the first zero). 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldStepInterpolator: This class implements a step interpolator for the 3/8 fourth order Runge-Kutta integrator. This interpolator allows to compute dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ (h/8) [ (8 - 15 θ + 8 θ2) y'1 + 3 * (15 θ - 12 θ2) y'2 + 3 θ y'3 + (-3 θ + 4 θ2) y'4 ]  Using reference point at step end: y(tn + θ h) = y (tn + h) - (1 - θ) (h/8) [(1 - 7 θ + 8 θ2) y'1 + 3 (1 + θ - 4 θ2) y'2 + 3 (1 + θ) y'3 + (1 + θ + 4 θ2) y'4 ]   where θ belongs to [0 ; 1] and where y'1 to y'4 are the four evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldStepInterpolator.ThreeEighthesFieldStepInterpolator	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesFieldStepInterpolator.create	(	Field	boolean	T[][]	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance. 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesIntegrator: This class implements the 3/8 fourth order Runge-Kutta integrator for Ordinary Differential Equations. This method is an explicit Runge-Kutta method, its Butcher-array is the following one :  0 | 0 0 0 0 1/3 | 1/3 0 0 0 2/3 |-1/3 1 0 0 1 | 1 -1 1 0 |-------------------- | 1/8 3/8 3/8 1/8 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesIntegrator.ThreeEighthesIntegrator	(	double	): Simple constructor. Build a 3/8 integrator with the given step.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesStepInterpolator: This class implements a step interpolator for the 3/8 fourth order Runge-Kutta integrator. This interpolator allows to compute dense output inside the last step computed. The interpolation equation is consistent with the integration scheme :  Using reference point at step start: y(tn + θ h) = y (tn) + θ (h/8) [ (8 - 15 θ + 8 θ2) y'1 + 3 * (15 θ - 12 θ2) y'2 + 3 θ y'3 + (-3 θ + 4 θ2) y'4 ]  Using reference point at step end: y(tn + θ h) = y (tn + h) - (1 - θ) (h/8) [(1 - 7 θ + 8 θ2) y'1 + 3 (1 + θ - 4 θ2) y'2 + 3 (1 + θ) y'3 + (1 + θ + 4 θ2) y'4 ]   where θ belongs to [0 ; 1] and where y'1 to y'4 are the four evaluations of the derivatives already computed during the step.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesStepInterpolator.ThreeEighthesStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The RungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and later initializing the copy.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesStepInterpolator.ThreeEighthesStepInterpolator	(	ThreeEighthesStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.nonstiff.ThreeEighthesStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.nonstiff.ThreeEighthesStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator: This abstract class represents an interpolator over the last step during an ODE integration. The various ODE integrators provide objects extending this class to the step handlers. The handlers can use these objects to retrieve the state vector at intermediate times between the previous and the current grid points (dense output).
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.AbstractFieldStepInterpolator	(	boolean	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Simple constructor.
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.computeInterpolatedStateAndDerivatives	(	FieldEquationsMapper	T	T	T	T	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation.
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.create	(	boolean	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldODEStateAndDerivative	FieldEquationsMapper	): Create a new instance.
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.getCurrentState	(	): Get the state at current grid point time. 
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.getGlobalCurrentState	(	): Get the current global grid point state.
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.getGlobalPreviousState	(	): Get the previous global grid point state.
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.getInterpolatedState	(	T	): Get the state at interpolated time. Setting the time outside of the current step is allowed, but should be used with care since the accuracy of the interpolator will probably be very poor far from this step. This allowance has been added to simplify implementation of search algorithms near the step endpoints. 
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.getPreviousState	(	): Get the state at previous grid point time. 
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.isForward	(	): Check if the natural integration direction is forward. This method provides the integration direction as specified by the integrator itself, it avoid some nasty problems in degenerated cases like null steps due to cancellation at step initialization, step control or discrete events triggering. 
org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator.restrictStep	(	FieldODEStateAndDerivative	FieldODEStateAndDerivative	): Create a new restricted version of the instance.  The instance is not changed at all. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator: This abstract class represents an interpolator over the last step during an ODE integration. The various ODE integrators provide objects extending this class to the step handlers. The handlers can use these objects to retrieve the state vector at intermediate times between the previous and the current grid points (dense output).
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. As an example, the org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator	(	AbstractStepInterpolator	): Copy constructor. The copied interpolator should have been finalized before the copy, otherwise the copy will not be able to perform correctly any derivative computation and will throw a NullPointerException later. Since we don't want this constructor to throw the exceptions finalization may involve and since we don't want this method to modify the state of the copied interpolator, finalization is not done automatically, it remains under user control. The copy is a deep copy: its arrays are separated from the original arrays of the instance.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator	(	double[]	boolean	EquationsMapper	EquationsMapper[]	): Simple constructor.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.allocateInterpolatedArrays	(	int	): Allocate the various interpolated states arrays.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.copy	(	): Copy the instance. The copied instance is guaranteed to be independent from the original one. Both can be used with different settings for interpolated time without any side effect. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.doFinalize	(	): Really finalize the step. The default implementation of this method does nothing.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.evaluateCompleteInterpolatedState	(	): Lazy evaluation of complete interpolated state.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.finalizeStep	(	): Finalize the step. Some embedded Runge-Kutta integrators need fewer functions evaluations than their counterpart step interpolators. These interpolators should perform the last evaluations they need by themselves only if they need them. This method triggers these extra evaluations. It can be called directly by the user step handler and it is called automatically if setInterpolatedTime is called. Once this method has been called, no other evaluation will be performed on this step. If there is a need to have some side effects between the step handler and the differential equations (for example update some data in the equations once the step has been done), it is advised to call this method explicitly from the step handler before these side effects are set up. If the step handler induces no side effect, then this method can safely be ignored, it will be called transparently as needed. Warning: since the step interpolator provided to the step handler as a parameter of the handleStep is valid only for the duration of the handleStep call, one cannot simply store a reference and reuse it later. One should first finalize the instance, then copy this finalized instance into a new object that can be kept. This method calls the protected doFinalize method if it has never been called during this step and set a flag indicating that it has been called once. It is the  doFinalize method which should perform the evaluations. This wrapping prevents from calling doFinalize several times and hence evaluating the differential equations too often. Therefore, subclasses are not allowed not reimplement it, they should rather reimplement doFinalize.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getCurrentTime	(	): Get the current soft grid point time.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getGlobalCurrentTime	(	): Get the current global grid point time.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getGlobalPreviousTime	(	): Get the previous global grid point time.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getInterpolatedDerivatives	(	): Get the derivatives of the state vector of the interpolated point. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getInterpolatedSecondaryDerivatives	(	int	): Get the interpolated secondary derivatives corresponding to the secondary equations. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getInterpolatedSecondaryState	(	int	): Get the interpolated secondary state corresponding to the secondary equations. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getInterpolatedState	(	): Get the state vector of the interpolated point. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getInterpolatedTime	(	): Get the time of the interpolated point. If setInterpolatedTime has not been called, it returns the current grid point time. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.getPreviousTime	(	): Get the previous soft grid point time.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.isForward	(	): Check if the natural integration direction is forward. This method provides the integration direction as specified by the integrator itself, it avoid some nasty problems in degenerated cases like null steps due to cancellation at step initialization, step control or discrete events triggering. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.readBaseExternal	(	ObjectInput	): Read the base state of the instance. This method does neither set the interpolated time nor state. It is up to the derived class to reset it properly calling the setInterpolatedTime method later, once all rest of the object state has been set up properly.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.readExternal	(	ObjectInput	):  
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.reinitialize	(	double[]	boolean	EquationsMapper	EquationsMapper[]	): Reinitialize the instance
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.setInterpolatedTime	(	double	): Set the time of the interpolated point. Setting the time outside of the current step is now allowed, but should be used with care since the accuracy of the interpolator will probably be very poor far from this step. This allowance has been added to simplify implementation of search algorithms near the step endpoints. Setting the time changes the instance internal state. This includes the internal arrays returned in getInterpolatedState(), getInterpolatedDerivatives(), getInterpolatedSecondaryState() and getInterpolatedSecondaryDerivatives(). So if their content must be preserved across several calls, user must copy them. 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.setSoftCurrentTime	(	double	): Restrict step range to a limited part of the global step.  This method can be used to restrict a step and make it appear as if the original step was smaller. Calling this method only changes the value returned by getCurrentTime(), it does not change any other property 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.setSoftPreviousTime	(	double	): Restrict step range to a limited part of the global step.  This method can be used to restrict a step and make it appear as if the original step was smaller. Calling this method only changes the value returned by getPreviousTime(), it does not change any other property 
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.shift	(	): Shift one step forward. Copy the current time into the previous time, hence preparing the interpolator for future calls to storeTime
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.storeTime	(	double	): Store the current step time.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.writeBaseExternal	(	ObjectOutput	): Save the base state of the instance. This method performs step finalization if it has not been done before.
org.apache.commons.math4.ode.sampling.AbstractStepInterpolator.writeExternal	(	ObjectOutput	):  
org.apache.commons.math4.ode.sampling.DummyStepHandler: This class is a step handler that does nothing. This class is provided as a convenience for users who are only interested in the final state of an integration and not in the intermediate steps. Its handleStep method does nothing. Since this class has no internal state, it is implemented using the Singleton design pattern. This means that only one instance is ever created, which can be retrieved using the getInstance method. This explains why there is no public constructor.
org.apache.commons.math4.ode.sampling.DummyStepHandler.DummyStepHandler	(	): Private constructor. The constructor is private to prevent users from creating instances (Singleton design-pattern).
org.apache.commons.math4.ode.sampling.DummyStepHandler.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.ode.sampling.DummyStepHandler.getInstance	(	): Get the only instance.
org.apache.commons.math4.ode.sampling.DummyStepHandler.handleStep	(	StepInterpolator	boolean	): Handle the last accepted step. This method does nothing in this class.
org.apache.commons.math4.ode.sampling.DummyStepHandler.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.sampling.DummyStepHandler.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator: This class is a step interpolator that does nothing. This class is used when the StepHandler "step handler" set up by the user does not need step interpolation. It does not recompute the state when setInterpolatedTime is called. This implies the interpolated state is always the state at the end of the current step.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.DummyStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the AbstractStepInterpolator.reinitialize protected method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. As an example, the org.apache.commons.math4.ode.nonstiff.EmbeddedRungeKuttaIntegrator uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.DummyStepInterpolator	(	DummyStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.DummyStepInterpolator	(	double[]	double[]	boolean	): Simple constructor.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state at the interpolated time. In this class, this method does nothing: the interpolated state is always the state at the end of the current step.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.doCopy	(	): Really copy the finalized instance.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.readExternal	(	ObjectInput	): Read the instance from an input channel.
org.apache.commons.math4.ode.sampling.DummyStepInterpolator.writeExternal	(	ObjectOutput	): Write the instance to an output channel.
org.apache.commons.math4.ode.sampling.FieldFixedStepHandler: This interface represents a handler that should be called after each successful fixed step. This interface should be implemented by anyone who is interested in getting the solution of an ordinary differential equation at fixed time steps. Objects implementing this interface should be wrapped within an instance of FieldStepNormalizer that itself is used as the general FieldStepHandler by the integrator. The FieldStepNormalizer object is called according to the integrator internal algorithms and it calls objects implementing this interface as necessary at fixed time steps.
org.apache.commons.math4.ode.sampling.FieldFixedStepHandler.handleStep	(	FieldODEStateAndDerivative	boolean	): Handle the last accepted step
org.apache.commons.math4.ode.sampling.FieldFixedStepHandler.init	(	FieldODEStateAndDerivative	T	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed. 
org.apache.commons.math4.ode.sampling.FieldStepHandler: This interface represents a handler that should be called after each successful step. The ODE integrators compute the evolution of the state vector at some grid points that depend on their own internal algorithm. Once they have found a new grid point (possibly after having computed several evaluation of the derivative at intermediate points), they provide it to objects implementing this interface. These objects typically either ignore the intermediate steps and wait for the last one, store the points in an ephemeris, or forward them to specialized processing or output methods.
org.apache.commons.math4.ode.sampling.FieldStepHandler.handleStep	(	FieldStepInterpolator	boolean	): Handle the last accepted step
org.apache.commons.math4.ode.sampling.FieldStepHandler.init	(	FieldODEStateAndDerivative	T	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed. 
org.apache.commons.math4.ode.sampling.FieldStepInterpolator: This interface represents an interpolator over the last step during an ODE integration. The various ODE integrators provide objects implementing this interface to the step handlers. These objects are often custom objects tightly bound to the integrator internal algorithms. The handlers can use these objects to retrieve the state vector at intermediate times between the previous and the current grid points (this feature is often called dense output).
org.apache.commons.math4.ode.sampling.FieldStepInterpolator.getCurrentState	(	): Get the state at current grid point time.
org.apache.commons.math4.ode.sampling.FieldStepInterpolator.getInterpolatedState	(	T	): Get the state at interpolated time. Setting the time outside of the current step is allowed, but should be used with care since the accuracy of the interpolator will probably be very poor far from this step. This allowance has been added to simplify implementation of search algorithms near the step endpoints.
org.apache.commons.math4.ode.sampling.FieldStepInterpolator.getPreviousState	(	): Get the state at previous grid point time.
org.apache.commons.math4.ode.sampling.FieldStepInterpolator.isForward	(	): Check if the natural integration direction is forward. This method provides the integration direction as specified by the integrator itself, it avoid some nasty problems in degenerated cases like null steps due to cancellation at step initialization, step control or discrete events triggering.
org.apache.commons.math4.ode.sampling.FieldStepNormalizer: This class wraps an object implementing FieldFixedStepHandler into a FieldStepHandler. This wrapper allows to use fixed step handlers with general integrators which cannot guaranty their integration steps will remain constant and therefore only accept general step handlers. The stepsize used is selected at construction time. The handleStep method of the underlying FieldFixedStepHandler object is called at normalized times. The normalized times can be influenced by the StepNormalizerMode and StepNormalizerBounds. There is no constraint on the integrator, it can use any time step it needs (time steps longer or shorter than the fixed time step and non-integer ratios are all allowed).  Examples (step size = 0.5) Start timeEnd time DirectionStepNormalizerMode Mode StepNormalizerBounds BoundsOutput 0.33.1forwardINCREMENTNEITHER0.8, 1.3, 1.8, 2.3, 2.8 0.33.1forwardINCREMENTFIRST0.3, 0.8, 1.3, 1.8, 2.3, 2.8 0.33.1forwardINCREMENTLAST0.8, 1.3, 1.8, 2.3, 2.8, 3.1 0.33.1forwardINCREMENTBOTH0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.1 0.33.1forwardMULTIPLESNEITHER0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.33.1forwardMULTIPLESFIRST0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.33.1forwardMULTIPLESLAST0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1 0.33.1forwardMULTIPLESBOTH0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1 0.03.0forwardINCREMENTNEITHER0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardINCREMENTFIRST0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardINCREMENTLAST0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardINCREMENTBOTH0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESNEITHER0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESFIRST0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESLAST0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESBOTH0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 3.10.3backwardINCREMENTNEITHER2.6, 2.1, 1.6, 1.1, 0.6 3.10.3backwardINCREMENTFIRST3.1, 2.6, 2.1, 1.6, 1.1, 0.6 3.10.3backwardINCREMENTLAST2.6, 2.1, 1.6, 1.1, 0.6, 0.3 3.10.3backwardINCREMENTBOTH3.1, 2.6, 2.1, 1.6, 1.1, 0.6, 0.3 3.10.3backwardMULTIPLESNEITHER3.0, 2.5, 2.0, 1.5, 1.0, 0.5 3.10.3backwardMULTIPLESFIRST3.1, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5 3.10.3backwardMULTIPLESLAST3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3 3.10.3backwardMULTIPLESBOTH3.1, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3 3.00.0backwardINCREMENTNEITHER2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardINCREMENTFIRST3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardINCREMENTLAST2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardINCREMENTBOTH3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESNEITHER2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESFIRST3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESLAST2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESBOTH3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.FieldStepNormalizer	(	double	FieldFixedStepHandler	): Simple constructor. Uses INCREMENT mode, and FIRST bounds setting, for backwards compatibility.
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.FieldStepNormalizer	(	double	FieldFixedStepHandler	StepNormalizerBounds	): Simple constructor. Uses INCREMENT mode.
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.FieldStepNormalizer	(	double	FieldFixedStepHandler	StepNormalizerMode	): Simple constructor. Uses FIRST bounds setting.
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.FieldStepNormalizer	(	double	FieldFixedStepHandler	StepNormalizerMode	StepNormalizerBounds	): Simple constructor.
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.doNormalizedStep	(	boolean	): Invokes the underlying step handler for the current normalized step.
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.handleStep	(	FieldStepInterpolator	boolean	): Handle the last accepted step
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.init	(	FieldODEStateAndDerivative	T	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.sampling.FieldStepNormalizer.isNextInStep	(	T	FieldStepInterpolator	): Returns a value indicating whether the next normalized time is in the current step.
org.apache.commons.math4.ode.sampling.FixedStepHandler: This interface represents a handler that should be called after each successful fixed step. This interface should be implemented by anyone who is interested in getting the solution of an ordinary differential equation at fixed time steps. Objects implementing this interface should be wrapped within an instance of StepNormalizer that itself is used as the general StepHandler by the integrator. The StepNormalizer object is called according to the integrator internal algorithms and it calls objects implementing this interface as necessary at fixed time steps.
org.apache.commons.math4.ode.sampling.FixedStepHandler.handleStep	(	double	double[]	double[]	boolean	): Handle the last accepted step
org.apache.commons.math4.ode.sampling.FixedStepHandler.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed. 
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator: This class implements an interpolator for integrators using Nordsieck representation. This interpolator computes dense output around the current point. The interpolation equation is based on Taylor series formulas.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.NordsieckStepInterpolator	(	): Simple constructor. This constructor builds an instance that is not usable yet, the reinitialize method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.NordsieckStepInterpolator	(	NordsieckStepInterpolator	): Copy constructor.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.computeInterpolatedStateAndDerivatives	(	double	double	): Compute the state and derivatives at the interpolated time. This is the main processing method that should be implemented by the derived classes to perform the interpolation. 
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.doCopy	(	): Really copy the finalized instance. This method is called by copy() after the step has been finalized. It must perform a deep copy to have an new instance completely independent for the original instance. 
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.getInterpolatedStateVariation	(	): Get the state vector variation from current to interpolated state. This method is aimed at computing y(tinterpolation) -y(tcurrent) accurately by avoiding the cancellation errors that would occur if the subtraction were performed explicitly. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.readExternal	(	ObjectInput	):   
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.reinitialize	(	double	double	double[]	Array2DRowRealMatrix	): Reinitialize the instance. Beware that all arrays must be references to integrator arrays, in order to ensure proper update without copy.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.reinitialize	(	double[]	boolean	EquationsMapper	EquationsMapper[]	): Reinitialize the instance. Beware that all arrays must be references to integrator arrays, in order to ensure proper update without copy.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.rescale	(	double	): Rescale the instance. Since the scaled and Nordsieck arrays are shared with the caller, this method has the side effect of rescaling this arrays in the caller too.
org.apache.commons.math4.ode.sampling.NordsieckStepInterpolator.writeExternal	(	ObjectOutput	):   
org.apache.commons.math4.ode.sampling.StepHandler: This interface represents a handler that should be called after each successful step. The ODE integrators compute the evolution of the state vector at some grid points that depend on their own internal algorithm. Once they have found a new grid point (possibly after having computed several evaluation of the derivative at intermediate points), they provide it to objects implementing this interface. These objects typically either ignore the intermediate steps and wait for the last one, store the points in an ephemeris, or forward them to specialized processing or output methods.
org.apache.commons.math4.ode.sampling.StepHandler.handleStep	(	StepInterpolator	boolean	): Handle the last accepted step
org.apache.commons.math4.ode.sampling.StepHandler.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed. 
org.apache.commons.math4.ode.sampling.StepInterpolator: This interface represents an interpolator over the last step during an ODE integration. The various ODE integrators provide objects implementing this interface to the step handlers. These objects are often custom objects tightly bound to the integrator internal algorithms. The handlers can use these objects to retrieve the state vector at intermediate times between the previous and the current grid points (this feature is often called dense output). One important thing to note is that the step handlers may be so tightly bound to the integrators that they often share some internal state arrays. This imply that one should never use a direct reference to a step interpolator outside of the step handler, either for future use or for use in another thread. If such a need arise, the step interpolator must be copied using the dedicated copy() method. 
org.apache.commons.math4.ode.sampling.StepInterpolator.copy	(	): Copy the instance. The copied instance is guaranteed to be independent from the original one. Both can be used with different settings for interpolated time without any side effect.
org.apache.commons.math4.ode.sampling.StepInterpolator.getCurrentTime	(	): Get the current grid point time.
org.apache.commons.math4.ode.sampling.StepInterpolator.getInterpolatedDerivatives	(	): Get the derivatives of the state vector of the interpolated point. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.sampling.StepInterpolator.getInterpolatedSecondaryDerivatives	(	int	): Get the interpolated secondary derivatives corresponding to the secondary equations. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls.
org.apache.commons.math4.ode.sampling.StepInterpolator.getInterpolatedSecondaryState	(	int	): Get the interpolated secondary state corresponding to the secondary equations. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.sampling.StepInterpolator.getInterpolatedState	(	): Get the state vector of the interpolated point. The returned vector is a reference to a reused array, so it should not be modified and it should be copied if it needs to be preserved across several calls to the associated setInterpolatedTime() method.
org.apache.commons.math4.ode.sampling.StepInterpolator.getInterpolatedTime	(	): Get the time of the interpolated point. If setInterpolatedTime has not been called, it returns the current grid point time.
org.apache.commons.math4.ode.sampling.StepInterpolator.getPreviousTime	(	): Get the previous grid point time.
org.apache.commons.math4.ode.sampling.StepInterpolator.isForward	(	): Check if the natural integration direction is forward. This method provides the integration direction as specified by the integrator itself, it avoid some nasty problems in degenerated cases like null steps due to cancellation at step initialization, step control or discrete events triggering.
org.apache.commons.math4.ode.sampling.StepInterpolator.setInterpolatedTime	(	double	): Set the time of the interpolated point. Setting the time outside of the current step is now allowed, but should be used with care since the accuracy of the interpolator will probably be very poor far from this step. This allowance has been added to simplify implementation of search algorithms near the step endpoints. Setting the time changes the instance internal state. This includes the internal arrays returned in getInterpolatedState(), getInterpolatedDerivatives(), getInterpolatedSecondaryState() and getInterpolatedSecondaryDerivatives(). So if their content must be preserved across several calls, user must copy them.
org.apache.commons.math4.ode.sampling.StepNormalizer: This class wraps an object implementing FixedStepHandler into a StepHandler. This wrapper allows to use fixed step handlers with general integrators which cannot guaranty their integration steps will remain constant and therefore only accept general step handlers. The stepsize used is selected at construction time. The handleStep method of the underlying FixedStepHandler object is called at normalized times. The normalized times can be influenced by the StepNormalizerMode and StepNormalizerBounds. There is no constraint on the integrator, it can use any time step it needs (time steps longer or shorter than the fixed time step and non-integer ratios are all allowed).  Examples (step size = 0.5) Start timeEnd time DirectionStepNormalizerMode Mode StepNormalizerBounds BoundsOutput 0.33.1forwardINCREMENTNEITHER0.8, 1.3, 1.8, 2.3, 2.8 0.33.1forwardINCREMENTFIRST0.3, 0.8, 1.3, 1.8, 2.3, 2.8 0.33.1forwardINCREMENTLAST0.8, 1.3, 1.8, 2.3, 2.8, 3.1 0.33.1forwardINCREMENTBOTH0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.1 0.33.1forwardMULTIPLESNEITHER0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.33.1forwardMULTIPLESFIRST0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.33.1forwardMULTIPLESLAST0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1 0.33.1forwardMULTIPLESBOTH0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1 0.03.0forwardINCREMENTNEITHER0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardINCREMENTFIRST0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardINCREMENTLAST0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardINCREMENTBOTH0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESNEITHER0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESFIRST0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESLAST0.5, 1.0, 1.5, 2.0, 2.5, 3.0 0.03.0forwardMULTIPLESBOTH0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 3.10.3backwardINCREMENTNEITHER2.6, 2.1, 1.6, 1.1, 0.6 3.10.3backwardINCREMENTFIRST3.1, 2.6, 2.1, 1.6, 1.1, 0.6 3.10.3backwardINCREMENTLAST2.6, 2.1, 1.6, 1.1, 0.6, 0.3 3.10.3backwardINCREMENTBOTH3.1, 2.6, 2.1, 1.6, 1.1, 0.6, 0.3 3.10.3backwardMULTIPLESNEITHER3.0, 2.5, 2.0, 1.5, 1.0, 0.5 3.10.3backwardMULTIPLESFIRST3.1, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5 3.10.3backwardMULTIPLESLAST3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3 3.10.3backwardMULTIPLESBOTH3.1, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3 3.00.0backwardINCREMENTNEITHER2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardINCREMENTFIRST3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardINCREMENTLAST2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardINCREMENTBOTH3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESNEITHER2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESFIRST3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESLAST2.5, 2.0, 1.5, 1.0, 0.5, 0.0 3.00.0backwardMULTIPLESBOTH3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 
org.apache.commons.math4.ode.sampling.StepNormalizer.StepNormalizer	(	double	FixedStepHandler	): Simple constructor. Uses INCREMENT mode, and FIRST bounds setting, for backwards compatibility.
org.apache.commons.math4.ode.sampling.StepNormalizer.StepNormalizer	(	double	FixedStepHandler	StepNormalizerBounds	): Simple constructor. Uses INCREMENT mode.
org.apache.commons.math4.ode.sampling.StepNormalizer.StepNormalizer	(	double	FixedStepHandler	StepNormalizerMode	): Simple constructor. Uses FIRST bounds setting.
org.apache.commons.math4.ode.sampling.StepNormalizer.StepNormalizer	(	double	FixedStepHandler	StepNormalizerMode	StepNormalizerBounds	): Simple constructor.
org.apache.commons.math4.ode.sampling.StepNormalizer.doNormalizedStep	(	boolean	): Invokes the underlying step handler for the current normalized step.
org.apache.commons.math4.ode.sampling.StepNormalizer.handleStep	(	StepInterpolator	boolean	): Handle the last accepted step
org.apache.commons.math4.ode.sampling.StepNormalizer.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.ode.sampling.StepNormalizer.isNextInStep	(	double	StepInterpolator	): Returns a value indicating whether the next normalized time is in the current step.
org.apache.commons.math4.ode.sampling.StepNormalizer.storeStep	(	StepInterpolator	double	): Stores the interpolated information for the given time in the current state.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputOverlapTest: Step normalizer output tests, for problems where the first and last points are overlap fixed points.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTest: Step normalizer output tests, for problems where the first and last points are not fixed points.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase: Base class for step normalizer output tests. 
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.computeDerivatives	(	double	double[]	double[]	): Get the current time derivative of the state vector. 
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.doTest	(	StepNormalizerMode	StepNormalizerBounds	double[]	boolean	): The actual step normalizer output test code, shared by all the unit tests.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getArray	(	double[]	int	int	): Get the array, given left and right offsets.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getDimension	(	): Get the dimension of the problem. 
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getEnd	(	): Returns the end time.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getExpInc	(	): Returns the expected normalized output time values for increment mode.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getExpIncRev	(	): Returns the expected reversed normalized output time values for increment mode.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getExpMul	(	): Returns the expected normalized output time values for multiples mode.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getExpMulRev	(	): Returns the expected reversed normalized output time values for multiples mode.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getO	(	): Returns the offsets for the unit tests below, in the order they are given below. For each test, the left and right offsets are returned.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.getStart	(	): Returns the start time.
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.handleStep	(	double	double[]	double[]	boolean	): Handle the last accepted step 
org.apache.commons.math4.ode.sampling.StepNormalizerOutputTestBase.init	(	double	double[]	double	): Initialize step handler at the start of an ODE integration.  This method is called once at the start of the integration. It may be used by the step handler to initialize some internal data if needed.  
org.apache.commons.math4.optim.AbstractConvergenceChecker: Base class for all convergence checker implementations.
org.apache.commons.math4.optim.AbstractConvergenceChecker.AbstractConvergenceChecker	(	double	double	): Build an instance with a specified thresholds.
org.apache.commons.math4.optim.AbstractConvergenceChecker.converged	(	int	PAIR	PAIR	): Check if the optimization algorithm has converged.
org.apache.commons.math4.optim.AbstractConvergenceChecker.getAbsoluteThreshold	(	): 
org.apache.commons.math4.optim.AbstractConvergenceChecker.getRelativeThreshold	(	): 
org.apache.commons.math4.optim.AbstractOptimizationProblem: Base class for implementing optimization problems. It contains the boiler-plate code for counting the number of evaluations of the objective function and the number of iterations of the algorithm, and storing the convergence checker.
org.apache.commons.math4.optim.AbstractOptimizationProblem.AbstractOptimizationProblem	(	int	int	ConvergenceChecker	): Create an AbstractOptimizationProblem from the given data.
org.apache.commons.math4.optim.AbstractOptimizationProblem.MaxEvalCallback: Defines the action to perform when reaching the maximum number of evaluations. 
org.apache.commons.math4.optim.AbstractOptimizationProblem.MaxEvalCallback.trigger	(	int	): Function called when the maximal count has been reached.
org.apache.commons.math4.optim.AbstractOptimizationProblem.MaxIterCallback: Defines the action to perform when reaching the maximum number of evaluations. 
org.apache.commons.math4.optim.AbstractOptimizationProblem.MaxIterCallback.trigger	(	int	): Function called when the maximal count has been reached.
org.apache.commons.math4.optim.AbstractOptimizationProblem.getConvergenceChecker	(	): Gets the convergence checker. 
org.apache.commons.math4.optim.AbstractOptimizationProblem.getEvaluationCounter	(	): Get a independent Incrementor that counts up to the maximum number of evaluations and then throws an exception. 
org.apache.commons.math4.optim.AbstractOptimizationProblem.getIterationCounter	(	): Get a independent Incrementor that counts up to the maximum number of iterations and then throws an exception. 
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer: Base class multi-start optimizer for a multivariate function.  This class wraps an optimizer in order to use it several times in turn with different starting points (trying to avoid being trapped in a local extremum when looking for a global one). It is not a "user" class.
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.BaseMultiStartMultivariateOptimizer	(	BaseMultivariateOptimizer	int	RandomVectorGenerator	): Create a multi-start optimizer from a single-start optimizer.  Note that if there are bounds constraints (see getLowerBound() and getUpperBound()), then a simple rejection algorithm is used at each restart. This implies that the random vector generator should have a good probability to generate vectors in the bounded domain, otherwise the rejection algorithm will hit the getMaxEvaluations() count without generating a proper restart point. Users must be take great care of the curse of dimensionality. 
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.clear	(	): Method that will called in order to clear all stored optima.
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.getEvaluations	(	): Gets the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet. 
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.getOptima	(	): Gets all the optima found during the last call to optimize. The optimizer stores all the optima found during a set of restarts. The optimize method returns the best point only. This method returns all the points found at the end of each starts, including the best one already returned by the optimize method.  The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by null elements corresponding to the runs that did not converge. This means all elements will be null if the optimize method did throw an exception. This also means that if the first element is not null, it is the best point found across all starts.  The behaviour is undefined if this method is called before optimize; it will likely throw NullPointerException.
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.BaseMultiStartMultivariateOptimizer.store	(	PAIR	): Method that will be called in order to store each found optimum.
org.apache.commons.math4.optim.BaseMultivariateOptimizer: Base class for implementing optimizers for multivariate functions. It contains the boiler-plate code for initial guess and bounds specifications. It is not a "user" class.
org.apache.commons.math4.optim.BaseMultivariateOptimizer.BaseMultivariateOptimizer	(	ConvergenceChecker	): 
org.apache.commons.math4.optim.BaseMultivariateOptimizer.checkParameters	(	): Check parameters consistency.
org.apache.commons.math4.optim.BaseMultivariateOptimizer.getLowerBound	(	): 
org.apache.commons.math4.optim.BaseMultivariateOptimizer.getStartPoint	(	): Gets the initial guess.
org.apache.commons.math4.optim.BaseMultivariateOptimizer.getUpperBound	(	): 
org.apache.commons.math4.optim.BaseMultivariateOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.BaseMultivariateOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.BaseOptimizer: Base class for implementing optimizers. It contains the boiler-plate code for counting the number of evaluations of the objective function and the number of iterations of the algorithm, and storing the convergence checker. It is not a "user" class.
org.apache.commons.math4.optim.BaseOptimizer.BaseOptimizer	(	ConvergenceChecker	): 
org.apache.commons.math4.optim.BaseOptimizer.BaseOptimizer	(	ConvergenceChecker	int	int	): 
org.apache.commons.math4.optim.BaseOptimizer.MaxEvalCallback: Defines the action to perform when reaching the maximum number of evaluations.
org.apache.commons.math4.optim.BaseOptimizer.MaxEvalCallback.trigger	(	int	): Function called when the maximal count has been reached.
org.apache.commons.math4.optim.BaseOptimizer.MaxIterCallback: Defines the action to perform when reaching the maximum number of evaluations.
org.apache.commons.math4.optim.BaseOptimizer.MaxIterCallback.trigger	(	int	): Function called when the maximal count has been reached.
org.apache.commons.math4.optim.BaseOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm.
org.apache.commons.math4.optim.BaseOptimizer.getConvergenceChecker	(	): Gets the convergence checker.
org.apache.commons.math4.optim.BaseOptimizer.getEvaluations	(	): Gets the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet.
org.apache.commons.math4.optim.BaseOptimizer.getIterations	(	): Gets the number of iterations performed by the algorithm. The number iterations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet.
org.apache.commons.math4.optim.BaseOptimizer.getMaxEvaluations	(	): Gets the maximal number of function evaluations.
org.apache.commons.math4.optim.BaseOptimizer.getMaxIterations	(	): Gets the maximal number of iterations.
org.apache.commons.math4.optim.BaseOptimizer.incrementEvaluationCount	(	): Increment the evaluation count.
org.apache.commons.math4.optim.BaseOptimizer.incrementIterationCount	(	): Increment the iteration count.
org.apache.commons.math4.optim.BaseOptimizer.optimize	(	): Performs the optimization.
org.apache.commons.math4.optim.BaseOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.BaseOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.ConvergenceChecker: This interface specifies how to check if an optimization algorithm has converged.  Deciding if convergence has been reached is a problem-dependent issue. The user should provide a class implementing this interface to allow the optimization algorithm to stop its search according to the problem at hand.  For convenience, three implementations that fit simple needs are already provided: SimpleValueChecker, SimpleVectorValueChecker and SimplePointChecker. The first two consider that convergence is reached when the objective function value does not change much anymore, it does not use the point set at all. The third one considers that convergence is reached when the input point set does not change much anymore, it does not use objective function value at all.
org.apache.commons.math4.optim.ConvergenceChecker.converged	(	int	PAIR	PAIR	): Check if the optimization algorithm has converged.
org.apache.commons.math4.optim.InitialGuess: Starting point (first guess) of the optimization procedure.  Immutable class.
org.apache.commons.math4.optim.InitialGuess.InitialGuess	(	double[]	): 
org.apache.commons.math4.optim.InitialGuess.getInitialGuess	(	): Gets the initial guess.
org.apache.commons.math4.optim.MaxEval: Maximum number of evaluations of the function to be optimized.
org.apache.commons.math4.optim.MaxEval.MaxEval	(	int	): 
org.apache.commons.math4.optim.MaxEval.getMaxEval	(	): Gets the maximum number of evaluations.
org.apache.commons.math4.optim.MaxEval.unlimited	(	): Factory method that creates instance of this class that represents a virtually unlimited number of evaluations.
org.apache.commons.math4.optim.MaxIter: Maximum number of iterations performed by an (iterative) algorithm.
org.apache.commons.math4.optim.MaxIter.MaxIter	(	int	): 
org.apache.commons.math4.optim.MaxIter.getMaxIter	(	): Gets the maximum number of evaluations.
org.apache.commons.math4.optim.MaxIter.unlimited	(	): Factory method that creates instance of this class that represents a virtually unlimited number of iterations.
org.apache.commons.math4.optim.OptimizationData: Marker interface. Implementations will provide functionality (optional or required) needed by the optimizers, and those will need to check the actual type of the arguments and perform the appropriate cast in order to access the data they need.
org.apache.commons.math4.optim.OptimizationProblem: Common settings for all optimization problems. Includes divergence and convergence criteria.
org.apache.commons.math4.optim.OptimizationProblem.getConvergenceChecker	(	): Gets the convergence checker.
org.apache.commons.math4.optim.OptimizationProblem.getEvaluationCounter	(	): Get a independent Incrementor that counts up to the maximum number of evaluations and then throws an exception.
org.apache.commons.math4.optim.OptimizationProblem.getIterationCounter	(	): Get a independent Incrementor that counts up to the maximum number of iterations and then throws an exception.
org.apache.commons.math4.optim.PointValuePair: This class holds a point and the value of an objective function at that point.
org.apache.commons.math4.optim.PointValuePair.DataTransferObject: Internal class used only for serialization. 
org.apache.commons.math4.optim.PointValuePair.DataTransferObject.DataTransferObject	(	double[]	double	): Simple constructor.
org.apache.commons.math4.optim.PointValuePair.DataTransferObject.readResolve	(	): Replace the deserialized data transfer object with a PointValuePair.
org.apache.commons.math4.optim.PointValuePair.PointValuePair	(	double[]	double	): Builds a point/objective function value pair.
org.apache.commons.math4.optim.PointValuePair.PointValuePair	(	double[]	double	boolean	): Builds a point/objective function value pair.
org.apache.commons.math4.optim.PointValuePair.getPoint	(	): Gets the point.
org.apache.commons.math4.optim.PointValuePair.getPointRef	(	): Gets a reference to the point.
org.apache.commons.math4.optim.PointValuePair.writeReplace	(	): Replace the instance with a data transfer object for serialization.
org.apache.commons.math4.optim.PointVectorValuePair: This class holds a point and the vectorial value of an objective function at that point.
org.apache.commons.math4.optim.PointVectorValuePair.DataTransferObject: Internal class used only for serialization. 
org.apache.commons.math4.optim.PointVectorValuePair.DataTransferObject.DataTransferObject	(	double[]	double[]	): Simple constructor.
org.apache.commons.math4.optim.PointVectorValuePair.DataTransferObject.readResolve	(	): Replace the deserialized data transfer object with a PointValuePair.
org.apache.commons.math4.optim.PointVectorValuePair.PointVectorValuePair	(	double[]	double[]	): Builds a point/objective function value pair.
org.apache.commons.math4.optim.PointVectorValuePair.PointVectorValuePair	(	double[]	double[]	boolean	): Build a point/objective function value pair.
org.apache.commons.math4.optim.PointVectorValuePair.getPoint	(	): Gets the point.
org.apache.commons.math4.optim.PointVectorValuePair.getPointRef	(	): Gets a reference to the point.
org.apache.commons.math4.optim.PointVectorValuePair.getValue	(	): Gets the value of the objective function.
org.apache.commons.math4.optim.PointVectorValuePair.getValueRef	(	): Gets a reference to the value of the objective function.
org.apache.commons.math4.optim.PointVectorValuePair.writeReplace	(	): Replace the instance with a data transfer object for serialization.
org.apache.commons.math4.optim.SimpleBounds: Simple optimization constraints: lower and upper bounds. The valid range of the parameters is an interval that can be infinite (in one or both directions).  Immutable class.
org.apache.commons.math4.optim.SimpleBounds.SimpleBounds	(	double[]	double[]	): 
org.apache.commons.math4.optim.SimpleBounds.getLower	(	): Gets the lower bounds.
org.apache.commons.math4.optim.SimpleBounds.getUpper	(	): Gets the upper bounds.
org.apache.commons.math4.optim.SimpleBounds.unbounded	(	int	): Factory method that creates instance of this class that represents unbounded ranges.
org.apache.commons.math4.optim.SimplePointChecker: Simple implementation of the ConvergenceChecker interface using only point coordinates. Convergence is considered to have been reached if either the relative difference between each point coordinate are smaller than a threshold or if either the absolute difference between the point coordinates are smaller than another threshold.  The converged() method will also return true if the number of iterations has been set (see SimplePointChecker() this constructor).
org.apache.commons.math4.optim.SimplePointChecker.SimplePointChecker	(	double	double	): Build an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.SimplePointChecker.SimplePointChecker	(	double	double	int	): Builds an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.SimplePointChecker.converged	(	int	PAIR	PAIR	): Check if the optimization algorithm has converged considering the last two points. This method may be called several times from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.
org.apache.commons.math4.optim.SimpleValueChecker: Simple implementation of the ConvergenceChecker interface using only objective function values. Convergence is considered to have been reached if either the relative difference between the objective function values is smaller than a threshold or if either the absolute difference between the objective function values is smaller than another threshold.  The converged() method will also return true if the number of iterations has been set (see SimpleValueChecker() this constructor).
org.apache.commons.math4.optim.SimpleValueChecker.SimpleValueChecker	(	double	double	): Build an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.SimpleValueChecker.SimpleValueChecker	(	double	double	int	): Builds an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.SimpleValueChecker.converged	(	int	PointValuePair	PointValuePair	): Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.
org.apache.commons.math4.optim.SimpleVectorValueChecker: Simple implementation of the ConvergenceChecker interface using only objective function values. Convergence is considered to have been reached if either the relative difference between the objective function values is smaller than a threshold or if either the absolute difference between the objective function values is smaller than another threshold for all vectors elements.  The converged() method will also return true if the number of iterations has been set (see SimpleVectorValueChecker() this constructor).
org.apache.commons.math4.optim.SimpleVectorValueChecker.SimpleVectorValueChecker	(	double	double	): Build an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.SimpleVectorValueChecker.SimpleVectorValueChecker	(	double	double	int	): Builds an instance with specified tolerance thresholds and iteration count. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.SimpleVectorValueChecker.converged	(	int	PointVectorValuePair	PointVectorValuePair	): Check if the optimization algorithm has converged considering the last two points. This method may be called several times from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.
org.apache.commons.math4.optim.linear.LinearConstraint: A linear constraint for a linear optimization problem.  A linear constraint has one of the forms:  c1x1 + ... cnxn = v c1x1 + ... cnxn <= v c1x1 + ... cnxn >= v l1x1 + ... lnxn + lcst = r1x1 + ... rnxn + rcst l1x1 + ... lnxn + lcst <= r1x1 + ... rnxn + rcst l1x1 + ... lnxn + lcst >= r1x1 + ... rnxn + rcst  The ci, li or ri are the coefficients of the constraints, the xi are the coordinates of the current point and v is the value of the constraint.
org.apache.commons.math4.optim.linear.LinearConstraint.LinearConstraint	(	RealVector	Relationship	double	): Build a constraint involving a single linear equation.  A linear constraint with a single linear equation has one of the forms:  c1x1 + ... cnxn = v c1x1 + ... cnxn <= v c1x1 + ... cnxn >= v 
org.apache.commons.math4.optim.linear.LinearConstraint.LinearConstraint	(	RealVector	double	Relationship	RealVector	double	): Build a constraint involving two linear equations.  A linear constraint with two linear equation has one of the forms:  l1x1 + ... lnxn + lcst = r1x1 + ... rnxn + rcst l1x1 + ... lnxn + lcst <= r1x1 + ... rnxn + rcst l1x1 + ... lnxn + lcst >= r1x1 + ... rnxn + rcst 
org.apache.commons.math4.optim.linear.LinearConstraint.LinearConstraint	(	double[]	Relationship	double	): Build a constraint involving a single linear equation.  A linear constraint with a single linear equation has one of the forms:  c1x1 + ... cnxn = v c1x1 + ... cnxn <= v c1x1 + ... cnxn >= v 
org.apache.commons.math4.optim.linear.LinearConstraint.LinearConstraint	(	double[]	double	Relationship	double[]	double	): Build a constraint involving two linear equations.  A linear constraint with two linear equation has one of the forms:  l1x1 + ... lnxn + lcst = r1x1 + ... rnxn + rcst l1x1 + ... lnxn + lcst <= r1x1 + ... rnxn + rcst l1x1 + ... lnxn + lcst >= r1x1 + ... rnxn + rcst 
org.apache.commons.math4.optim.linear.LinearConstraint.equals	(	Object	):  
org.apache.commons.math4.optim.linear.LinearConstraint.getCoefficients	(	): Gets the coefficients of the constraint (left hand side).
org.apache.commons.math4.optim.linear.LinearConstraint.getRelationship	(	): Gets the relationship between left and right hand sides.
org.apache.commons.math4.optim.linear.LinearConstraint.getValue	(	): Gets the value of the constraint (right hand side).
org.apache.commons.math4.optim.linear.LinearConstraint.hashCode	(	):  
org.apache.commons.math4.optim.linear.LinearConstraint.readObject	(	ObjectInputStream	): Deserialize the instance.
org.apache.commons.math4.optim.linear.LinearConstraint.writeObject	(	ObjectOutputStream	): Serialize the instance.
org.apache.commons.math4.optim.linear.LinearConstraintSet: Class that represents a set of LinearConstraint linear constraints.
org.apache.commons.math4.optim.linear.LinearConstraintSet.LinearConstraintSet	(	Collection	): Creates a set containing the given constraints.
org.apache.commons.math4.optim.linear.LinearConstraintSet.LinearConstraintSet	(	LinearConstraint	): Creates a set containing the given constraints.
org.apache.commons.math4.optim.linear.LinearConstraintSet.getConstraints	(	): Gets the set of linear constraints.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction: An objective function for a linear optimization problem.  A linear objective function has one the form:  c1x1 + ... cnxn + d  The ci and d are the coefficients of the equation, the xi are the coordinates of the current point.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.LinearObjectiveFunction	(	RealVector	double	): 
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.LinearObjectiveFunction	(	double[]	double	): 
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.equals	(	Object	):  
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.getCoefficients	(	): Gets the coefficients of the linear equation being optimized.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.getConstantTerm	(	): Gets the constant of the linear equation being optimized.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.hashCode	(	):  
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.readObject	(	ObjectInputStream	): Deserialize the instance.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.value	(	RealVector	): Computes the value of the linear equation at the current point.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.value	(	double[]	): Computes the value of the linear equation at the current point.
org.apache.commons.math4.optim.linear.LinearObjectiveFunction.writeObject	(	ObjectOutputStream	): Serialize the instance.
org.apache.commons.math4.optim.linear.LinearOptimizer: Base class for implementing linear optimizers.
org.apache.commons.math4.optim.linear.LinearOptimizer.LinearOptimizer	(	): Simple constructor with default settings.
org.apache.commons.math4.optim.linear.LinearOptimizer.getConstraints	(	): 
org.apache.commons.math4.optim.linear.LinearOptimizer.getFunction	(	): 
org.apache.commons.math4.optim.linear.LinearOptimizer.isRestrictedToNonNegative	(	): 
org.apache.commons.math4.optim.linear.LinearOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.linear.LinearOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.linear.NoFeasibleSolutionException: This class represents exceptions thrown by optimizers when no solution fulfills the constraints.
org.apache.commons.math4.optim.linear.NoFeasibleSolutionException.NoFeasibleSolutionException	(	): Simple constructor using a default message.
org.apache.commons.math4.optim.linear.NonNegativeConstraint: A constraint for a linear optimization problem indicating whether all variables must be restricted to non-negative values.
org.apache.commons.math4.optim.linear.NonNegativeConstraint.NonNegativeConstraint	(	boolean	): 
org.apache.commons.math4.optim.linear.NonNegativeConstraint.isRestrictedToNonNegative	(	): Indicates whether all the variables must be restricted to non-negative values.
org.apache.commons.math4.optim.linear.SimplexSolver: Solves a linear problem using the "Two-Phase Simplex" method.  The SimplexSolver supports the following OptimizationData data provided as arguments to optimize():  objective function: LinearObjectiveFunction - mandatory linear constraints LinearConstraintSet - mandatory type of optimization: org.apache.commons.math4.optim.nonlinear.scalar.GoalType GoalType - optional, default: MINIMIZE whether to allow negative values as solution: NonNegativeConstraint - optional, default: true pivot selection rule: PivotSelectionRule - optional, default DANTZIG callback for the best solution: SolutionCallback - optional maximum number of iterations: org.apache.commons.math4.optim.MaxIter - optional, default: MAX_VALUE   Note: Depending on the problem definition, the default convergence criteria may be too strict, resulting in NoFeasibleSolutionException or TooManyIterationsException. In such a case it is advised to adjust these criteria with more appropriate values, e.g. relaxing the epsilon value.  Default convergence criteria:  Algorithm convergence: 1e-6 Floating-point comparisons: 10 ulp Cut-Off value: 1e-10   The cut-off value has been introduced to handle the case of very small pivot elements in the Simplex tableau, as these may lead to numerical instabilities and degeneracy. Potential pivot elements smaller than this value will be treated as if they were zero and are thus not considered by the pivot selection mechanism. The default value is safe for many problems, but may need to be adjusted in case of very small coefficients used in either the LinearConstraint or LinearObjectiveFunction.
org.apache.commons.math4.optim.linear.SimplexSolver.SimplexSolver	(	): Builds a simplex solver with default settings.
org.apache.commons.math4.optim.linear.SimplexSolver.SimplexSolver	(	double	): Builds a simplex solver with a specified accepted amount of error.
org.apache.commons.math4.optim.linear.SimplexSolver.SimplexSolver	(	double	int	): Builds a simplex solver with a specified accepted amount of error.
org.apache.commons.math4.optim.linear.SimplexSolver.SimplexSolver	(	double	int	double	): Builds a simplex solver with a specified accepted amount of error.
org.apache.commons.math4.optim.linear.SimplexSolver.doIteration	(	SimplexTableau	): Runs one iteration of the Simplex method on the given model.
org.apache.commons.math4.optim.linear.SimplexSolver.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.linear.SimplexSolver.getPivotColumn	(	SimplexTableau	): Returns the column with the most negative coefficient in the objective function row.
org.apache.commons.math4.optim.linear.SimplexSolver.getPivotRow	(	SimplexTableau	int	): Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
org.apache.commons.math4.optim.linear.SimplexSolver.isValidPivotColumn	(	SimplexTableau	int	): Checks whether the given column is valid pivot column, i.e. will result in a valid pivot row.  When applying Bland's rule to select the pivot column, it may happen that there is no corresponding pivot row. This method will check if the selected pivot column will return a valid pivot row.
org.apache.commons.math4.optim.linear.SimplexSolver.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.linear.SimplexSolver.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.linear.SimplexSolver.solvePhase1	(	SimplexTableau	): Solves Phase 1 of the Simplex method.
org.apache.commons.math4.optim.linear.SimplexSolverTest.equationFromString	(	int	String	): Converts a test string to a LinearConstraint. Ex: x0 + x1 + x2 + x3 - x12 = 0
org.apache.commons.math4.optim.linear.SimplexSolverTest.testModelWithNoArtificialVars	(	): With no artificial variables needed (no equals and no greater than constraints) we can go straight to Phase 2.
org.apache.commons.math4.optim.linear.SimplexTableau: A tableau for use in the Simplex method.  Example:  W | Z | x1 | x2 | x- | s1 | s2 | a1 | RHS --------------------------------------------------- -1 0 0 0 0 0 0 1 0 <= phase 1 objective 0 1 -15 -10 0 0 0 0 0 <= phase 2 objective 0 0 1 0 0 1 0 0 2 <= constraint 1 0 0 0 1 0 0 1 0 3 <= constraint 2 0 0 1 1 0 0 0 1 4 <= constraint 3  W: Phase 1 objective function Z: Phase 2 objective function x1 & x2: Decision variables x-: Extra decision variable to allow for negative values s1 & s2: Slack/Surplus variables a1: Artificial variable RHS: Right hand side
org.apache.commons.math4.optim.linear.SimplexTableau.SimplexTableau	(	LinearObjectiveFunction	Collection	GoalType	boolean	double	): Builds a tableau for a linear problem.
org.apache.commons.math4.optim.linear.SimplexTableau.SimplexTableau	(	LinearObjectiveFunction	Collection	GoalType	boolean	double	int	): Build a tableau for a linear problem.
org.apache.commons.math4.optim.linear.SimplexTableau.checkDimensions	(	LinearObjectiveFunction	Collection	): Checks that the dimensions of the objective function and the constraints match.
org.apache.commons.math4.optim.linear.SimplexTableau.copyArray	(	double[]	double[]	): 
org.apache.commons.math4.optim.linear.SimplexTableau.createTableau	(	boolean	): Create the tableau by itself.
org.apache.commons.math4.optim.linear.SimplexTableau.divideRow	(	int	double	): Divides one row by a given divisor.  After application of this operation, the following will hold: dividendRow = dividendRow / divisor
org.apache.commons.math4.optim.linear.SimplexTableau.dropPhase1Objective	(	): Removes the phase 1 objective function, positive cost non-artificial variables, and the non-basic artificial variables from this tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.equals	(	Object	):  
org.apache.commons.math4.optim.linear.SimplexTableau.findBasicRow	(	int	): Returns the row in which the given column is basic.
org.apache.commons.math4.optim.linear.SimplexTableau.getArtificialVariableOffset	(	): Get the offset of the first artificial variable.
org.apache.commons.math4.optim.linear.SimplexTableau.getBasicRow	(	int	): Checks whether the given column is basic.
org.apache.commons.math4.optim.linear.SimplexTableau.getBasicVariable	(	int	): Returns the variable that is basic in this row.
org.apache.commons.math4.optim.linear.SimplexTableau.getConstraintTypeCounts	(	Relationship	): Get a count of constraints corresponding to a specified relationship.
org.apache.commons.math4.optim.linear.SimplexTableau.getData	(	): Get the tableau data.
org.apache.commons.math4.optim.linear.SimplexTableau.getEntry	(	int	int	): Get an entry of the tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.getHeight	(	): Get the height of the tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.getInvertedCoefficientSum	(	RealVector	): Get the -1 times the sum of all coefficients in the given array.
org.apache.commons.math4.optim.linear.SimplexTableau.getNumArtificialVariables	(	): Get the number of artificial variables.
org.apache.commons.math4.optim.linear.SimplexTableau.getNumDecisionVariables	(	): Get the number of decision variables.  If variables are not restricted to positive values, this will include 1 extra decision variable to represent the absolute value of the most negative variable.
org.apache.commons.math4.optim.linear.SimplexTableau.getNumObjectiveFunctions	(	): Get the number of objective functions in this tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.getNumSlackVariables	(	): Get the number of slack variables.
org.apache.commons.math4.optim.linear.SimplexTableau.getOriginalNumDecisionVariables	(	): Get the original number of decision variables.
org.apache.commons.math4.optim.linear.SimplexTableau.getRhsOffset	(	): Get the offset of the right hand side.
org.apache.commons.math4.optim.linear.SimplexTableau.getRow	(	int	): Get the row from the tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.getSlackVariableOffset	(	): Get the offset of the first slack variable.
org.apache.commons.math4.optim.linear.SimplexTableau.getSolution	(	): Get the current solution.
org.apache.commons.math4.optim.linear.SimplexTableau.getWidth	(	): Get the width of the tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.hashCode	(	):  
org.apache.commons.math4.optim.linear.SimplexTableau.initializeBasicVariables	(	int	): Initializes the basic variable / row mapping.
org.apache.commons.math4.optim.linear.SimplexTableau.initializeColumnLabels	(	): Initialize the labels for the columns.
org.apache.commons.math4.optim.linear.SimplexTableau.isOptimal	(	): Returns whether the problem is at an optimal state.
org.apache.commons.math4.optim.linear.SimplexTableau.normalize	(	LinearConstraint	): Get a new equation equivalent to this one with a positive right hand side.
org.apache.commons.math4.optim.linear.SimplexTableau.normalizeConstraints	(	Collection	): Get new versions of the constraints which have positive right hand sides.
org.apache.commons.math4.optim.linear.SimplexTableau.performRowOperations	(	int	int	): Perform the row operations of the simplex algorithm with the selected pivot column and row.
org.apache.commons.math4.optim.linear.SimplexTableau.readObject	(	ObjectInputStream	): Deserialize the instance.
org.apache.commons.math4.optim.linear.SimplexTableau.setEntry	(	int	int	double	): Set an entry of the tableau.
org.apache.commons.math4.optim.linear.SimplexTableau.subtractRow	(	int	int	double	): Subtracts a multiple of one row from another.  After application of this operation, the following will hold: minuendRow = minuendRow - multiple * subtrahendRow
org.apache.commons.math4.optim.linear.SimplexTableau.writeObject	(	ObjectOutputStream	): Serialize the instance.
org.apache.commons.math4.optim.linear.SolutionCallback: A callback object that can be provided to a linear optimizer to keep track of the best solution found.
org.apache.commons.math4.optim.linear.SolutionCallback.getSolution	(	): Retrieve the best solution found so far.  Note: the returned solution may not be optimal, e.g. in case the optimizer did reach the iteration limits.
org.apache.commons.math4.optim.linear.SolutionCallback.isSolutionOptimal	(	): Returns if the found solution is optimal.
org.apache.commons.math4.optim.linear.SolutionCallback.setTableau	(	SimplexTableau	): Set the simplex tableau used during the optimization once a feasible solution has been found.
org.apache.commons.math4.optim.linear.UnboundedSolutionException: This class represents exceptions thrown by optimizers when a solution escapes to infinity.
org.apache.commons.math4.optim.linear.UnboundedSolutionException.UnboundedSolutionException	(	): Simple constructor using a default message.
org.apache.commons.math4.optim.nonlinear.scalar.GradientMultivariateOptimizer: Base class for implementing optimizers for multivariate scalar differentiable functions. It contains boiler-plate code for dealing with gradient evaluation.
org.apache.commons.math4.optim.nonlinear.scalar.GradientMultivariateOptimizer.GradientMultivariateOptimizer	(	ConvergenceChecker	): 
org.apache.commons.math4.optim.nonlinear.scalar.GradientMultivariateOptimizer.computeObjectiveGradient	(	double[]	): Compute the gradient vector.
org.apache.commons.math4.optim.nonlinear.scalar.GradientMultivariateOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.nonlinear.scalar.GradientMultivariateOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.nonlinear.scalar.LeastSquaresConverter: This class converts MultivariateVectorFunction vectorial objective functions to MultivariateFunction scalar objective functions when the goal is to minimize them.  This class is mostly used when the vectorial objective function represents a theoretical result computed from a point set applied to a model and the models point must be adjusted to fit the theoretical result to some reference observations. The observations may be obtained for example from physical measurements whether the model is built from theoretical considerations.  This class computes a possibly weighted squared sum of the residuals, which is a scalar value. The residuals are the difference between the theoretical model (i.e. the output of the vectorial objective function) and the observations. The class implements the MultivariateFunction interface and can therefore be minimized by any optimizer supporting scalar objectives functions.This is one way to perform a least square estimation. There are other ways to do this without using this converter, as some optimization algorithms directly support vectorial objective functions.  This class support combination of residuals with or without weights and correlations.
org.apache.commons.math4.optim.nonlinear.scalar.LeastSquaresConverter.LeastSquaresConverter	(	MultivariateVectorFunction	double[]	): Builds a simple converter for uncorrelated residuals with identical weights.
org.apache.commons.math4.optim.nonlinear.scalar.LeastSquaresConverter.LeastSquaresConverter	(	MultivariateVectorFunction	double[]	RealMatrix	): Builds a simple converter for correlated residuals with the specified weights.  The scalar objective function value is computed as:  objective = yTy with y = scale×(observation-objective)   The array computed by the objective function, the observations array and the the scaling matrix must have consistent sizes or a DimensionMismatchException will be triggered while computing the scalar objective. 
org.apache.commons.math4.optim.nonlinear.scalar.LeastSquaresConverter.LeastSquaresConverter	(	MultivariateVectorFunction	double[]	double[]	): Builds a simple converter for uncorrelated residuals with the specified weights.  The scalar objective function value is computed as:  objective = ∑weighti(observationi-objectivei)2   Weights can be used for example to combine residuals with different standard deviations. As an example, consider a residuals array in which even elements are angular measurements in degrees with a 0.01° standard deviation and odd elements are distance measurements in meters with a 15m standard deviation. In this case, the weights array should be initialized with value 1.0/(0.012) in the even elements and 1.0/(15.02) in the odd elements (i.e. reciprocals of variances).   The array computed by the objective function, the observations array and the weights array must have consistent sizes or a DimensionMismatchException will be triggered while computing the scalar objective. 
org.apache.commons.math4.optim.nonlinear.scalar.LeastSquaresConverter.value	(	double[]	): Compute the value for the function at the given point. 
org.apache.commons.math4.optim.nonlinear.scalar.LineSearch: Class for finding the minimum of the objective function along a given direction.
org.apache.commons.math4.optim.nonlinear.scalar.LineSearch.LineSearch	(	MultivariateOptimizer	double	double	double	): The BrentOptimizer default stopping criterion uses the tolerances to check the domain (point) values, not the function values. The relativeTolerance and absoluteTolerance arguments are thus passed to a SimpleUnivariateValueChecker custom checker that will use the function values.
org.apache.commons.math4.optim.nonlinear.scalar.LineSearch.search	(	double[]	double[]	): Finds the number alpha that optimizes f(startPoint + alpha * direction).
org.apache.commons.math4.optim.nonlinear.scalar.MultiStartMultivariateOptimizer: Multi-start optimizer. This class wraps an optimizer in order to use it several times in turn with different starting points (trying to avoid being trapped in a local extremum when looking for a global one).
org.apache.commons.math4.optim.nonlinear.scalar.MultiStartMultivariateOptimizer.MultiStartMultivariateOptimizer	(	MultivariateOptimizer	int	RandomVectorGenerator	): Create a multi-start optimizer from a single-start optimizer.
org.apache.commons.math4.optim.nonlinear.scalar.MultiStartMultivariateOptimizer.clear	(	): Method that will called in order to clear all stored optima.
org.apache.commons.math4.optim.nonlinear.scalar.MultiStartMultivariateOptimizer.getOptima	(	): Gets all the optima found during the last call to optimize. The optimizer stores all the optima found during a set of restarts. The optimize method returns the best point only. This method returns all the points found at the end of each starts, including the best one already returned by the optimize method.  The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by null elements corresponding to the runs that did not converge. This means all elements will be null if the optimize method did throw an exception. This also means that if the first element is not null, it is the best point found across all starts.  The behaviour is undefined if this method is called before optimize; it will likely throw NullPointerException.
org.apache.commons.math4.optim.nonlinear.scalar.MultiStartMultivariateOptimizer.getPairComparator	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.MultiStartMultivariateOptimizer.store	(	PointValuePair	): 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter: Adapter for mapping bounded MultivariateFunction to unbounded ones.  This adapter can be used to wrap functions subject to simple bounds on parameters so they can be used by optimizers that do not directly support simple bounds.   The principle is that the user function that will be wrapped will see its parameters bounded as required, i.e when its value method is called with argument array point, the elements array will fulfill requirement lower[i] <= point[i] <= upper[i] for all i. Some of the components may be unbounded or bounded only on one side if the corresponding bound is set to an infinite value. The optimizer will not manage the user function by itself, but it will handle this adapter and it is this adapter that will take care the bounds are fulfilled. The adapter value() method will be called by the optimizer with unbound parameters, and the adapter will map the unbounded value to the bounded range using appropriate functions like Sigmoid for double bounded elements for example.   As the optimizer sees only unbounded parameters, it should be noted that the start point or simplex expected by the optimizer should be unbounded, so the user is responsible for converting his bounded point to unbounded by calling boundedToUnbounded() before providing them to the optimizer. For the same reason, the point returned by the optimize() method is unbounded. So to convert this point to bounded, users must call unboundedToBounded() by themselves!  This adapter is only a poor man solution to simple bounds optimization constraints that can be used with simple optimizers like org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer SimplexOptimizer. A better solution is to use an optimizer that directly supports simple bounds like org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer CMAESOptimizer or org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer BOBYQAOptimizer. One caveat of this poor-man's solution is that behavior near the bounds may be numerically unstable as bounds are mapped from infinite values. Another caveat is that convergence values are evaluated by the optimizer with respect to unbounded variables, so there will be scales differences when converted to bounded variables. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerBoundMapper: Local class for lower bounds mapping. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerBoundMapper.LowerBoundMapper	(	double	): Simple constructor.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerBoundMapper.boundedToUnbounded	(	double	): Maps a value from bounded to unbounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerBoundMapper.unboundedToBounded	(	double	): Maps a value from unbounded to bounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerUpperBoundMapper: Local class for lower and bounds mapping. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerUpperBoundMapper.LowerUpperBoundMapper	(	double	double	): Simple constructor.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerUpperBoundMapper.boundedToUnbounded	(	double	): Maps a value from bounded to unbounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.LowerUpperBoundMapper.unboundedToBounded	(	double	): Maps a value from unbounded to bounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.Mapper: Mapping interface. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.Mapper.boundedToUnbounded	(	double	): Maps a value from bounded to unbounded.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.Mapper.unboundedToBounded	(	double	): Maps a value from unbounded to bounded.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.MultivariateFunctionMappingAdapter	(	MultivariateFunction	double[]	double[]	): Simple constructor.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.NoBoundsMapper: Local class for no bounds mapping. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.NoBoundsMapper.boundedToUnbounded	(	double	): Maps a value from bounded to unbounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.NoBoundsMapper.unboundedToBounded	(	double	): Maps a value from unbounded to bounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.UpperBoundMapper: Local class for upper bounds mapping. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.UpperBoundMapper.UpperBoundMapper	(	double	): Simple constructor.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.UpperBoundMapper.boundedToUnbounded	(	double	): Maps a value from bounded to unbounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.UpperBoundMapper.unboundedToBounded	(	double	): Maps a value from unbounded to bounded. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.boundedToUnbounded	(	double[]	): Maps an array from bounded to unbounded.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.unboundedToBounded	(	double[]	): Maps an array from unbounded to bounded.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter.value	(	double[]	): Compute the underlying function value from an unbounded point.  This method simply bounds the unbounded point using the mappings set up at construction and calls the underlying function using the bounded point. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter: Adapter extending bounded MultivariateFunction to an unbouded domain using a penalty function.  This adapter can be used to wrap functions subject to simple bounds on parameters so they can be used by optimizers that do not directly support simple bounds.   The principle is that the user function that will be wrapped will see its parameters bounded as required, i.e when its value method is called with argument array point, the elements array will fulfill requirement lower[i] <= point[i] <= upper[i] for all i. Some of the components may be unbounded or bounded only on one side if the corresponding bound is set to an infinite value. The optimizer will not manage the user function by itself, but it will handle this adapter and it is this adapter that will take care the bounds are fulfilled. The adapter value() method will be called by the optimizer with unbound parameters, and the adapter will check if the parameters is within range or not. If it is in range, then the underlying user function will be called, and if it is not the value of a penalty function will be returned instead.   This adapter is only a poor-man's solution to simple bounds optimization constraints that can be used with simple optimizers like org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer SimplexOptimizer. A better solution is to use an optimizer that directly supports simple bounds like org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer CMAESOptimizer or org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer BOBYQAOptimizer. One caveat of this poor-man's solution is that if start point or start simplex is completely outside of the allowed range, only the penalty function is used, and the optimizer may converge without ever entering the range. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter.MultivariateFunctionPenaltyAdapter	(	MultivariateFunction	double[]	double[]	double	double[]	): Simple constructor.  When the optimizer provided points are out of range, the value of the penalty function will be used instead of the value of the underlying function. In order for this penalty to be effective in rejecting this point during the optimization process, the penalty function value should be defined with care. This value is computed as:  penalty(point) = offset + ∑i[scale[i] * √|point[i]-boundary[i]|]  where indices i correspond to all the components that violates their boundaries.  So when attempting a function minimization, offset should be larger than the maximum expected value of the underlying function and scale components should all be positive. When attempting a function maximization, offset should be lesser than the minimum expected value of the underlying function and scale components should all be negative. minimization, and lesser than the minimum expected value of the underlying function when attempting maximization.   These choices for the penalty function have two properties. First, all out of range points will return a function value that is worse than the value returned by any in range point. Second, the penalty is worse for large boundaries violation than for small violations, so the optimizer has an hint about the direction in which it should search for acceptable points. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter.value	(	double[]	): Computes the underlying function value from an unbounded point.  This method simply returns the value of the underlying function if the unbounded point already fulfills the bounds, and compute a replacement value using the offset and scale if bounds are violated, without calling the function at all. 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer: Base class for a multivariate scalar function optimizer.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer.MultivariateOptimizer	(	ConvergenceChecker	): 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer.computeObjectiveValue	(	double[]	): Computes the objective function value. This method must be called by subclasses to enforce the evaluation counter limit.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer.getGoalType	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.nonlinear.scalar.MultivariateOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction: Scalar function to be optimized.
org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction.ObjectiveFunction	(	MultivariateFunction	): 
org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction.getObjectiveFunction	(	): Gets the function to be optimized.
org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient: Gradient of the scalar function to be optimized.
org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient.ObjectiveFunctionGradient	(	MultivariateVectorFunction	): 
org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunctionGradient.getObjectiveFunctionGradient	(	): Gets the gradient of the function to be optimized.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.CircleScalar: Class used in the tests.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer: Non-linear conjugate gradient optimizer.  This class supports both the Fletcher-Reeves and the Polak-Ribière update formulas for the conjugate search directions. It also supports optional preconditioning.  Constraints are not supported: the call to optimize() will throw MathUnsupportedOperationException if bounds are passed to it.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.IdentityPreconditioner: Default identity preconditioner. 
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.IdentityPreconditioner.precondition	(	double[]	double[]	): Precondition a search direction.  The returned preconditioned search direction must be computed fast or the algorithm performances will drop drastically. A classical approach is to compute only the diagonal elements of the hessian and to divide the raw search direction by these elements if they are all positive. If at least one of them is negative, it is safer to return a clone of the raw search direction as if the hessian was the identity matrix. The rationale for this simplified choice is that a negative diagonal element means the current point is far from the optimum and preconditioning will not be efficient anyway in this case.  
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer	(	Formula	ConvergenceChecker	): Constructor with default tolerances for the line search (1e-8) and IdentityPreconditioner preconditioner.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer	(	Formula	ConvergenceChecker	double	double	double	): Constructor with default IdentityPreconditioner preconditioner.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer	(	Formula	ConvergenceChecker	double	double	double	Preconditioner	): 
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.checkParameters	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest: Some of the unit tests are re-implementations of the MINPACK file17 and file22 test files. The redistribution policy for MINPACK is available here, for convenience, it is reproduced below.   Minpack Copyright Notice (1999) University of Chicago. All rights reserved   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. The end-user documentation included with the redistribution, if any, must include the following acknowledgment: This product includes software developed by the University of Chicago, as Operator of Argonne National Laboratory. Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES.  
org.apache.commons.math4.optim.nonlinear.scalar.gradient.Preconditioner: This interface represents a preconditioner for differentiable scalar objective function optimizers.
org.apache.commons.math4.optim.nonlinear.scalar.gradient.Preconditioner.precondition	(	double[]	double[]	): Precondition a search direction.  The returned preconditioned search direction must be computed fast or the algorithm performances will drop drastically. A classical approach is to compute only the diagonal elements of the hessian and to divide the raw search direction by these elements if they are all positive. If at least one of them is negative, it is safer to return a clone of the raw search direction as if the hessian was the identity matrix. The rationale for this simplified choice is that a negative diagonal element means the current point is far from the optimum and preconditioning will not be efficient anyway in this case. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex: This class implements the simplex concept. It is intended to be used in conjunction with SimplexOptimizer.  The initial configuration of the simplex is set by the constructors AbstractSimplex() or AbstractSimplex(). The other AbstractSimplex() constructor will set all steps to 1, thus building a default configuration from a unit hypercube.  Users must call the build() method in order to create the data structure that will be acted on by the other methods of this class.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.AbstractSimplex	(	double[]	): The start configuration for simplex is built from a box parallel to the canonical axes of the space. The simplex is the subset of vertices of a box parallel to the canonical axes. It is built as the path followed while traveling from one vertex of the box to the diagonally opposite vertex moving only along the box edges. The first vertex of the box will be located at the start point of the optimization. As an example, in dimension 3 a simplex has 4 vertices. Setting the steps to (1, 10, 2) and the start point to (1, 1, 1) would imply the start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }. The first vertex would be set to the start point at (1, 1, 1) and the last vertex would be set to the diagonally opposite vertex at (2, 11, 3).
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.AbstractSimplex	(	double[][]	): The real initial simplex will be set up by moving the reference simplex such that its first point is located at the start point of the optimization.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.AbstractSimplex	(	int	): Build a unit hypercube simplex.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.AbstractSimplex	(	int	double	): Build a hypercube simplex with the given side length.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.build	(	double[]	): Build an initial simplex.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.createHypercubeSteps	(	int	double	): Create steps for a unit hypercube.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.evaluate	(	MultivariateFunction	Comparator	): Evaluate all the non-evaluated points of the simplex.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.getDimension	(	): Get simplex dimension.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.getPoint	(	int	): Get the simplex point stored at the requested index.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.getPoints	(	): Get the points of the simplex.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.getSize	(	): Get simplex size. After calling the build() method, this method will will be equivalent to getDimension() + 1.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.iterate	(	MultivariateFunction	Comparator	): Compute the next simplex of the algorithm.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.replaceWorstPoint	(	PointValuePair	Comparator	): Replace the worst point of the simplex by a new point.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.setPoint	(	int	PointValuePair	): Store a new point at location index. Note that no deep-copy of point is performed.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.AbstractSimplex.setPoints	(	PointValuePair[]	): Replace all points. Note that no deep-copy of points is performed.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer: Powell's BOBYQA algorithm. This implementation is translated and adapted from the Fortran version available here. See  this paper for an introduction.  BOBYQA is particularly well suited for high dimensional problems where derivatives are not available. In most cases it outperforms the PowellOptimizer significantly. Stochastic algorithms like CMAESOptimizer succeed more often than BOBYQA, but are more expensive. BOBYQA could also be considered as a replacement of any derivative-based optimizer when the derivatives are approximated by finite differences.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.BOBYQAOptimizer	(	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.BOBYQAOptimizer	(	int	double	double	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.PathIsExploredException: Marker for code paths that are not explored with the current unit tests. If the path becomes explored, it should just be removed from the code.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.altmov	(	int	double	): The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have the same meanings as the corresponding arguments of BOBYQB. KOPT is the index of the optimal interpolation point. KNEW is the index of the interpolation point that is going to be moved. ADELT is the current trust region bound. XNEW will be set to a suitable new position for the interpolation point XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region bounds and it should provide a large denominator in the next call of UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the straight lines through XOPT and another interpolation point. XALT also provides a large value of the modulus of the KNEW-th Lagrange function subject to the constraints that have been mentioned, its main difference from XNEW being that XALT-XOPT is a constrained version of the Cauchy step within the trust region. An exception is that XALT is not calculated if all components of GLAG (see below) are zero. ALPHA will be set to the KNEW-th diagonal element of the H matrix. CAUCHY will be set to the square of the KNEW-th Lagrange function at the step XALT-XOPT from XOPT for the vector XALT that is returned, except that CAUCHY is set to zero if XALT is not calculated. GLAG is a working space vector of length N for the gradient of the KNEW-th Lagrange function at XOPT. HCOL is a working space vector of length NPT for the second derivative coefficients of the KNEW-th Lagrange function. W is a working space vector of length 2N that is going to hold the constrained Cauchy step from XOPT of the Lagrange function, followed by the downhill version of XALT when the uphill step is calculated. Set the first NPT components of W to the leading elements of the KNEW-th column of the H matrix.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.bobyqa	(	double[]	double[]	): This subroutine seeks the least value of a function of many variables, by applying a trust region method that forms quadratic models by interpolation. There is usually some freedom in the interpolation conditions, which is taken up by minimizing the Frobenius norm of the change to the second derivative of the model, beginning with the zero matrix. The values of the variables are constrained by upper and lower bounds. The arguments of the subroutine are as follows. N must be set to the number of variables and must be at least two. NPT is the number of interpolation conditions. Its value must be in the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not recommended. Initial values of the variables must be set in X(1),X(2),...,X(N). They will be changed to the values that give the least calculated F. For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper bounds, respectively, on X(I). The construction of quadratic models requires XL(I) to be strictly less than XU(I) for each I. Further, the contribution to a model from changes to the I-th variable is damaged severely by rounding errors if XU(I)-XL(I) is too small. RHOBEG and RHOEND must be set to the initial and final values of a trust region radius, so both must be positive with RHOEND no greater than RHOBEG. Typically, RHOBEG should be about one tenth of the greatest expected change to a variable, while RHOEND should indicate the accuracy that is required in the final values of the variables. An error return occurs if any of the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. MAXFUN must be set to an upper bound on the number of calls of CALFUN. The array W will be used for working space. Its length must be at least (NPT+5)*(NPT+N)+3*N*(N+5)/2.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.bobyqb	(	double[]	double[]	): The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN are identical to the corresponding arguments in SUBROUTINE BOBYQA. XBASE holds a shift of origin that should reduce the contributions from rounding errors to values of the model and Lagrange functions. XPT is a two-dimensional array that holds the coordinates of the interpolation points relative to XBASE. FVAL holds the values of F at the interpolation points. XOPT is set to the displacement from XBASE of the trust region centre. GOPT holds the gradient of the quadratic model at XBASE+XOPT. HQ holds the explicit second derivatives of the quadratic model. PQ contains the parameters of the implicit second derivatives of the quadratic model. BMAT holds the last N columns of H. ZMAT holds the factorization of the leading NPT by NPT submatrix of H, this factorization being ZMAT times ZMAT^T, which provides both the correct rank and positive semi-definiteness. NDIM is the first dimension of BMAT and has the value NPT+N. SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. All the components of every XOPT are going to satisfy the bounds SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when XOPT is on a constraint boundary. XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the vector of variables for the next call of CALFUN. XNEW also satisfies the SL and SU constraints in the way that has just been mentioned. XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW in order to increase the denominator in the updating of UPDATE. D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. VLAG contains the values of the Lagrange functions at a new point X. They are part of a product that requires VLAG to be of length NDIM. W is a one-dimensional array that is used for working space. Its length must be at least 3*NDIM = 3*(NPT+N).
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.prelim	(	double[]	double[]	): SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, BMAT and ZMAT for the first iteration, and it maintains the values of NF and KOPT. The vector X is also changed by PRELIM. The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the same as the corresponding arguments in SUBROUTINE BOBYQA. The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU are the same as the corresponding arguments in BOBYQB, the elements of SL and SU being set in BOBYQA. GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but it is set by PRELIM to the gradient of the quadratic model at XBASE. If XOPT is nonzero, BOBYQB will change it to its usual value later. NF is maintaned as the number of calls of CALFUN so far. KOPT will be such that the least calculated value of F so far is at the point XPT(KOPT,.)+XBASE in the space of the variables.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.setup	(	double[]	double[]	): Performs validity checks.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.trsbox	(	double	ArrayRealVector	ArrayRealVector	ArrayRealVector	ArrayRealVector	ArrayRealVector	): A version of the truncated conjugate gradient is applied. If a line search is restricted by a constraint, then the procedure is restarted, the values of the variables that are at their bounds being fixed. If the trust region boundary is reached, then further changes may be made to D, each one being in the two dimensional space that is spanned by the current D and the gradient of Q at XOPT+D, staying on the trust region boundary. Termination occurs when the reduction in Q seems to be close to the greatest reduction that can be achieved. The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same meanings as the corresponding arguments of BOBYQB. DELTA is the trust region radius for the present calculation, which seeks a small value of the quadratic model within distance DELTA of XOPT subject to the bounds on the variables. XNEW will be set to a new vector of variables that is approximately the one that minimizes the quadratic model within the trust region subject to the SL and SU constraints on the variables. It satisfies as equations the bounds that become active during the calculation. D is the calculated trial step from XOPT, generated iteratively from an initial value of zero. Thus XNEW is XOPT+D after the final iteration. GNEW holds the gradient of the quadratic model at XOPT+D. It is updated when D is updated. xbdi.get( is a working space vector. For I=1,2,...,N, the element xbdi.get((I) is set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the I-th variable has become fixed at a bound, the bound being SL(I) or SU(I) in the case xbdi.get((I)=-1.0 or xbdi.get((I)=1.0, respectively. This information is accumulated during the construction of XNEW. The arrays S, HS and HRED are also used for working space. They hold the current search direction, and the changes in the gradient of Q along S and the reduced D, respectively, where the reduced D is the same as D, except that the components of the fixed variables are zero. DSQ will be set to the square of the length of XNEW-XOPT. CRVMIN is set to zero if D reaches the trust region boundary. Otherwise it is set to the least curvature of H that occurs in the conjugate gradient searches that are not restricted by any constraints. The value CRVMIN=-1.0D0 is set, however, if all of these searches are constrained.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizer.update	(	double	double	int	): The arrays BMAT and ZMAT are updated, as required by the new position of the interpolation point that has the index KNEW. The vector VLAG has N+NPT components, set on entry to the first NPT and last N components of the product Hw in equation (4.11) of the Powell (2006) paper on NEWUOA. Further, BETA is set on entry to the value of the parameter with that name, and DENOM is set to the denominator of the updating formula. Elements of ZMAT may be treated as zero if their moduli are at most ZTEST. The first NDIM elements of W are used for working space.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizerTest: Test for BOBYQAOptimizer.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizerTest.doTest	(	MultivariateFunction	double[]	double[][]	GoalType	double	double	int	PointValuePair	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.BOBYQAOptimizerTest.doTest	(	MultivariateFunction	double[]	double[][]	GoalType	double	double	int	int	PointValuePair	String	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer: An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES) for non-linear, non-convex, non-smooth, global function minimization.  The CMA-Evolution Strategy (CMA-ES) is a reliable stochastic optimization method which should be applied if derivative-based methods, e.g. quasi-Newton BFGS or conjugate gradient, fail due to a rugged search landscape (e.g. noise, local optima, outlier, etc.) of the objective function. Like a quasi-Newton method, the CMA-ES learns and applies a variable metric on the underlying search space. Unlike a quasi-Newton method, the CMA-ES neither estimates nor uses gradients, making it considerably more reliable in terms of finding a good, or even close to optimal, solution.  In general, on smooth objective functions the CMA-ES is roughly ten times slower than BFGS (counting objective function evaluations, no gradients provided). For up to N=10 variables also the derivative-free simplex direct search method (Nelder and Mead) can be faster, but it is far less reliable than CMA-ES.  The CMA-ES is particularly well suited for non-separable and/or badly conditioned problems. To observe the advantage of CMA compared to a conventional evolution strategy, it will usually take about 30 N function evaluations. On difficult problems the complete optimization (a single run) is expected to take roughly between 30 N and 300 N2 function evaluations.  This implementation is translated and adapted from the Matlab version of the CMA-ES algorithm as implemented in module cmaes.m version 3.51.  For more information, please refer to the following links:  Matlab code Introduction to CMA-ES Wikipedia 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.CMAESOptimizer	(	int	double	boolean	int	int	UniformRandomProvider	boolean	ConvergenceChecker	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex: Used to sort fitness values. Sorting is always in lower value first order.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex.DoubleIndex	(	double	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex.compareTo	(	DoubleIndex	):  
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex.equals	(	Object	):  
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex.hashCode	(	):  
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction: Normalizes fitness values to the range [0,1]. Adds a penalty to the fitness value if out of range.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.FitnessFunction	(	): Simple constructor.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.isFeasible	(	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.penalty	(	double[]	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.repair	(	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.value	(	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.PopulationSize: Population size. The number of offspring is the primary strategy parameter. In the absence of better clues, a good default could be an integer close to 4 + 3 ln(n), where n is the number of optimized parameters. Increasing the population size improves global search properties at the expense of speed (which in general decreases at most linearly with increasing population size).
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.PopulationSize.PopulationSize	(	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.PopulationSize.getPopulationSize	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.Sigma: Input sigma values. They define the initial coordinate-wise standard deviations for sampling new search points around the initial guess. It is suggested to set them to the estimated distance from the initial to the desired optimum. Small values induce the search to be more local (and very small values are more likely to find a local optimum close to the initial guess). Too small values might however lead to early termination.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.Sigma.Sigma	(	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.Sigma.getSigma	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.ValuePenaltyPair: Stores the value and penalty (for repair of out of bounds point).
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.ValuePenaltyPair.ValuePenaltyPair	(	double	double	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.checkParameters	(	): Checks dimensions and values of boundaries and inputSigma if defined.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.copyColumn	(	RealMatrix	int	RealMatrix	int	): Copies a column from m1 to m2.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.diag	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.divide	(	RealMatrix	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.eye	(	int	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.getStatisticsDHistory	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.getStatisticsFitnessHistory	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.getStatisticsMeanHistory	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.getStatisticsSigmaHistory	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.initializeCMA	(	double[]	): Initialization of the dynamic search parameters
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.inverse	(	int[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.log	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max	(	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min	(	double[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.ones	(	int	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.push	(	double[]	double	): Pushes the current best fitness value in a history queue.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.randn	(	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.randn1	(	int	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.repmat	(	RealMatrix	int	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.reverse	(	int[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.selectColumns	(	RealMatrix	int[]	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sequence	(	double	double	double	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sortedIndices	(	double[]	): Sorts fitness values.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sqrt	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.square	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sumRows	(	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.times	(	RealMatrix	RealMatrix	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.triu	(	RealMatrix	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateBD	(	double	): Update B and D from C.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateCovariance	(	boolean	RealMatrix	RealMatrix	int[]	RealMatrix	): Update of the covariance matrix C.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateCovarianceDiagonalOnly	(	boolean	RealMatrix	): Update of the covariance matrix C for diagonalOnly > 0
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateEvolutionPaths	(	RealMatrix	RealMatrix	): Update of the evolution paths ps and pc.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.valueRange	(	ValuePenaltyPair[]	): Get range of values.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer.zeros	(	int	int	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest: Test for CMAESOptimizer.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.doTest	(	MultivariateFunction	double[]	double[]	double[][]	GoalType	int	boolean	int	double	double	double	int	PointValuePair	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest.testFitAccuracyDependsOnBoundary	(	): Cf. MATH-867
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex: This class implements the multi-directional direct search method.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	double[]	): Build a multi-directional simplex with default coefficients. The default values are 2.0 for khi and 0.5 for gamma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	double[]	double	double	): Build a multi-directional simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	double[][]	): Build a multi-directional simplex with default coefficients. The default values are 2.0 for khi and 0.5 for gamma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	double[][]	double	double	): Build a multi-directional simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	int	): Build a multi-directional simplex with default coefficients. The default values are 2.0 for khi and 0.5 for gamma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	int	double	): Build a multi-directional simplex with default coefficients. The default values are 2.0 for khi and 0.5 for gamma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	int	double	double	): Build a multi-directional simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex	(	int	double	double	double	): Build a multi-directional simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.evaluateNewSimplex	(	MultivariateFunction	PointValuePair[]	double	Comparator	): Compute and evaluate a new simplex.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.iterate	(	MultivariateFunction	Comparator	): Compute the next simplex of the algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex: This class implements the Nelder-Mead simplex algorithm.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	double[]	): Build a Nelder-Mead simplex with default coefficients. The default coefficients are 1.0 for rho, 2.0 for khi and 0.5 for both gamma and sigma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	double[]	double	double	double	double	): Build a Nelder-Mead simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	double[][]	): Build a Nelder-Mead simplex with default coefficients. The default coefficients are 1.0 for rho, 2.0 for khi and 0.5 for both gamma and sigma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	double[][]	double	double	double	double	): Build a Nelder-Mead simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	int	): Build a Nelder-Mead simplex with default coefficients. The default coefficients are 1.0 for rho, 2.0 for khi and 0.5 for both gamma and sigma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	int	double	): Build a Nelder-Mead simplex with default coefficients. The default coefficients are 1.0 for rho, 2.0 for khi and 0.5 for both gamma and sigma.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	int	double	double	double	double	): Build a Nelder-Mead simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex	(	int	double	double	double	double	double	): Build a Nelder-Mead simplex with specified coefficients.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.iterate	(	MultivariateFunction	Comparator	): Compute the next simplex of the algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer: Powell's algorithm. This code is translated and adapted from the Python version of this algorithm (as implemented in module optimize.py v0.5 of SciPy).  The default stopping criterion is based on the differences of the function value between two successive iterations. It is however possible to define a custom convergence checker that might terminate the algorithm earlier.  Line search is performed by the LineSearch class.  Constraints are not supported: the call to optimize() will throw MathUnsupportedOperationException if bounds are passed to it. In order to impose simple constraints, the objective function must be wrapped in an adapter like org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter MultivariateFunctionMappingAdapter or org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter MultivariateFunctionPenaltyAdapter.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer	(	double	double	): The parameters control the default convergence checking procedure.  The internal line search tolerances are set to the square-root of their corresponding value in the multivariate optimizer.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer	(	double	double	ConvergenceChecker	): This constructor allows to specify a user-defined convergence checker, in addition to the parameters that control the default convergence checking procedure.  The internal line search tolerances are set to the square-root of their corresponding value in the multivariate optimizer.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer	(	double	double	double	double	): Builds an instance with the default convergence checking procedure.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer	(	double	double	double	double	ConvergenceChecker	): This constructor allows to specify a user-defined convergence checker, in addition to the parameters that control the default convergence checking procedure and the line search tolerances.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.checkParameters	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizer.newPointAndDirection	(	double[]	double[]	double	): Compute a new point (in the original space) and a new direction vector, resulting from the line search.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizerTest: Test for PowellOptimizer.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.doTest	(	MultivariateFunction	double[]	double[]	GoalType	double	double	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.doTest	(	MultivariateFunction	double[]	double[]	GoalType	double	double	double	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.PowellOptimizerTest.testRelativeToleranceOnScaledValues	(	): Ensure that we do not increase the number of function evaluations when the function values are scaled up. Note that the tolerances parameters passed to the constructor must still hold sensible values because they are used to set the line search tolerances.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer: This class implements simplex-based direct search optimization.  Direct search methods only use objective function values, they do not need derivatives and don't either try to compute approximation of the derivatives. According to a 1996 paper by Margaret H. Wright (Direct Search Methods: Once Scorned, Now Respectable), they are used when either the computation of the derivative is impossible (noisy functions, unpredictable discontinuities) or difficult (complexity, computation cost). In the first cases, rather than an optimum, a not too bad point is desired. In the latter cases, an optimum is desired but cannot be reasonably found. In all cases direct search methods can be useful.   Simplex-based direct search methods are based on comparison of the objective function values at the vertices of a simplex (which is a set of n+1 points in dimension n) that is updated by the algorithms steps.   The simplex update procedure (NelderMeadSimplex or MultiDirectionalSimplex) must be passed to the optimize method.   Each call to optimize will re-use the start configuration of the current simplex and move it such that its first vertex is at the provided start point of the optimization. If the optimize method is called to solve a different problem and the number of parameters change, the simplex must be re-initialized to one with the appropriate dimensions.   Convergence is checked by providing the worst points of previous and current simplex to the convergence checker, not the best ones.   This simplex optimizer implementation does not directly support constrained optimization with simple bounds; so, for such optimizations, either a more dedicated algorithm must be used like CMAESOptimizer or BOBYQAOptimizer, or the objective function must be wrapped in an adapter like org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionMappingAdapter MultivariateFunctionMappingAdapter or org.apache.commons.math4.optim.nonlinear.scalar.MultivariateFunctionPenaltyAdapter MultivariateFunctionPenaltyAdapter.  The call to optimize() will throw MathUnsupportedOperationException if bounds are passed to it. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer.SimplexOptimizer	(	ConvergenceChecker	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer.SimplexOptimizer	(	double	double	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer.checkParameters	(	): 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.nonlinear.scalar.noderiv.SimplexOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.univariate.BracketFinder: Provide an interval that brackets a local optimum of a function. This code is based on a Python implementation (from SciPy, module optimize.py v0.5).
org.apache.commons.math4.optim.univariate.BracketFinder.BracketFinder	(	): Constructor with default values 100, 500 (see the BracketFinder() other constructor).
org.apache.commons.math4.optim.univariate.BracketFinder.BracketFinder	(	double	int	): Create a bracketing interval finder.
org.apache.commons.math4.optim.univariate.BracketFinder.FunctionEvaluator: Utility for incrementing a counter at each function evaluation.
org.apache.commons.math4.optim.univariate.BracketFinder.FunctionEvaluator.FunctionEvaluator	(	UnivariateFunction	): 
org.apache.commons.math4.optim.univariate.BracketFinder.FunctionEvaluator.value	(	double	): 
org.apache.commons.math4.optim.univariate.BracketFinder.getEvaluations	(	): 
org.apache.commons.math4.optim.univariate.BracketFinder.getFHi	(	): Get function value at getHi().
org.apache.commons.math4.optim.univariate.BracketFinder.getFLo	(	): Get function value at getLo().
org.apache.commons.math4.optim.univariate.BracketFinder.getFMid	(	): Get function value at getMid().
org.apache.commons.math4.optim.univariate.BracketFinder.getHi	(	): 
org.apache.commons.math4.optim.univariate.BracketFinder.getLo	(	): 
org.apache.commons.math4.optim.univariate.BracketFinder.getMaxEvaluations	(	): 
org.apache.commons.math4.optim.univariate.BracketFinder.getMid	(	): 
org.apache.commons.math4.optim.univariate.BracketFinder.search	(	UnivariateFunction	GoalType	double	double	): Search new points that bracket a local optimum of the function.
org.apache.commons.math4.optim.univariate.BracketFinderTest: Test for BracketFinder.
org.apache.commons.math4.optim.univariate.BrentOptimizer: For a function defined on some interval (lo, hi), this class finds an approximation x to the point at which the function attains its minimum. It implements Richard Brent's algorithm (from his book "Algorithms for Minimization without Derivatives", p. 79) for finding minima of real univariate functions.  This code is an adaptation, partly based on the Python code from SciPy (module "optimize.py" v0.5); the original algorithm is also modified  to use an initial guess provided by the user, to ensure that the best point encountered is the one returned. 
org.apache.commons.math4.optim.univariate.BrentOptimizer.BrentOptimizer	(	double	double	): The arguments are used for implementing the original stopping criterion of Brent's algorithm. abs and rel define a tolerance tol = rel |x| + abs. rel should be no smaller than 2 macheps and preferably not much less than sqrt(macheps), where macheps is the relative machine precision. abs must be positive.
org.apache.commons.math4.optim.univariate.BrentOptimizer.BrentOptimizer	(	double	double	ConvergenceChecker	): The arguments are used implement the original stopping criterion of Brent's algorithm. abs and rel define a tolerance tol = rel |x| + abs. rel should be no smaller than 2 macheps and preferably not much less than sqrt(macheps), where macheps is the relative machine precision. abs must be positive.
org.apache.commons.math4.optim.univariate.BrentOptimizer.best	(	UnivariatePointValuePair	UnivariatePointValuePair	boolean	): Selects the best of two points.
org.apache.commons.math4.optim.univariate.BrentOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.univariate.BrentOptimizerTest.testKeepInitIfBest	(	): Contrived example showing that prior to the resolution of MATH-855 (second revision), the algorithm would not return the best point if it happened to be the initial guess.
org.apache.commons.math4.optim.univariate.BrentOptimizerTest.testMath855	(	): Contrived example showing that prior to the resolution of MATH-855, the algorithm, by always returning the last evaluated point, would sometimes not report the best point it had found.
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer: Special implementation of the UnivariateOptimizer interface adding multi-start features to an existing optimizer.  This class wraps an optimizer in order to use it several times in turn with different starting points (trying to avoid being trapped in a local extremum when looking for a global one).
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer.MultiStartUnivariateOptimizer	(	UnivariateOptimizer	int	UniformRandomProvider	): Create a multi-start optimizer from a single-start optimizer.
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer.doOptimize	(	): Performs the bulk of the optimization algorithm. 
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer.getEvaluations	(	): Gets the number of evaluations of the objective function. The number of evaluations corresponds to the last call to the optimize method. It is 0 if the method has not been called yet. 
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer.getOptima	(	): Gets all the optima found during the last call to optimize. The optimizer stores all the optima found during a set of restarts. The optimize method returns the best point only. This method returns all the points found at the end of each starts, including the best one already returned by the optimize method.  The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by null elements corresponding to the runs that did not converge. This means all elements will be null if the optimize method did throw an exception. This also means that if the first element is not null, it is the best point found across all starts.
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.univariate.MultiStartUnivariateOptimizer.sortPairs	(	GoalType	): Sort the optima from best to worst, followed by null elements.
org.apache.commons.math4.optim.univariate.SearchInterval: Search interval and (optional) start value.  Immutable class.
org.apache.commons.math4.optim.univariate.SearchInterval.SearchInterval	(	double	double	): 
org.apache.commons.math4.optim.univariate.SearchInterval.SearchInterval	(	double	double	double	): 
org.apache.commons.math4.optim.univariate.SearchInterval.getMax	(	): Gets the upper bound.
org.apache.commons.math4.optim.univariate.SearchInterval.getMin	(	): Gets the lower bound.
org.apache.commons.math4.optim.univariate.SearchInterval.getStartValue	(	): Gets the start value.
org.apache.commons.math4.optim.univariate.SimpleUnivariateValueChecker: Simple implementation of the org.apache.commons.math4.optim.ConvergenceChecker interface that uses only objective function values. Convergence is considered to have been reached if either the relative difference between the objective function values is smaller than a threshold or if either the absolute difference between the objective function values is smaller than another threshold.  The converged() method will also return true if the number of iterations has been set (see SimpleUnivariateValueChecker() this constructor).
org.apache.commons.math4.optim.univariate.SimpleUnivariateValueChecker.SimpleUnivariateValueChecker	(	double	double	): Build an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.univariate.SimpleUnivariateValueChecker.SimpleUnivariateValueChecker	(	double	double	int	): Builds an instance with specified thresholds. In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.
org.apache.commons.math4.optim.univariate.SimpleUnivariateValueChecker.converged	(	int	UnivariatePointValuePair	UnivariatePointValuePair	): Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.
org.apache.commons.math4.optim.univariate.UnivariateObjectiveFunction: Scalar function to be optimized.
org.apache.commons.math4.optim.univariate.UnivariateObjectiveFunction.UnivariateObjectiveFunction	(	UnivariateFunction	): 
org.apache.commons.math4.optim.univariate.UnivariateObjectiveFunction.getObjectiveFunction	(	): Gets the function to be optimized.
org.apache.commons.math4.optim.univariate.UnivariateOptimizer: Base class for a univariate scalar function optimizer.
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.UnivariateOptimizer	(	ConvergenceChecker	): 
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.computeObjectiveValue	(	double	): Computes the objective function value. This method must be called by subclasses to enforce the evaluation counter limit.
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.getGoalType	(	): 
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.getMax	(	): 
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.getMin	(	): 
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.getStartValue	(	): 
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.optimize	(	OptimizationData	): Stores data and performs the optimization.  The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations.  When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls).  Important note: Subclasses must override parseOptimizationData() if they need to register their own options; but then, they must also call super.parseOptimizationData(optData) within that method.
org.apache.commons.math4.optim.univariate.UnivariateOptimizer.parseOptimizationData	(	OptimizationData	): Scans the list of (required and optional) optimization data that characterize the problem.
org.apache.commons.math4.optim.univariate.UnivariatePointValuePair: This class holds a point and the value of an objective function at this point. This is a simple immutable container.
org.apache.commons.math4.optim.univariate.UnivariatePointValuePair.UnivariatePointValuePair	(	double	double	): Build a point/objective function value pair.
org.apache.commons.math4.optim.univariate.UnivariatePointValuePair.getPoint	(	): Get the point.
org.apache.commons.math4.optim.univariate.UnivariatePointValuePair.getValue	(	): Get the value of the objective function.
org.apache.commons.math4.primes.Primes: Methods related to prime numbers in the range of int:  primality test prime number generation factorization 
org.apache.commons.math4.primes.Primes.Primes	(	): Hide utility class.
org.apache.commons.math4.primes.Primes.isPrime	(	int	): Primality test: tells if the argument is a (provable) prime or not.  It uses the Miller-Rabin probabilistic test in such a way that a result is guaranteed: it uses the firsts prime numbers as successive base (see Handbook of applied cryptography by Menezes, table 4.1).
org.apache.commons.math4.primes.Primes.nextPrime	(	int	): Return the smallest prime greater than or equal to n.
org.apache.commons.math4.primes.Primes.primeFactors	(	int	): Prime factors decomposition
org.apache.commons.math4.primes.SmallPrimes: Utility methods to work on primes within the int range.
org.apache.commons.math4.primes.SmallPrimes.SmallPrimes	(	): Hide utility class.
org.apache.commons.math4.primes.SmallPrimes.boundedTrialDivision	(	int	int	List	): Extract factors in the range PRIME_LAST+2 to maxFactors.
org.apache.commons.math4.primes.SmallPrimes.millerRabinPrimeTest	(	int	): Miller-Rabin probabilistic primality test for int type, used in such a way that a result is always guaranteed.  It uses the prime numbers as successive base therefore it is guaranteed to be always correct. (see Handbook of applied cryptography by Menezes, table 4.1)
org.apache.commons.math4.primes.SmallPrimes.smallTrialDivision	(	int	List	): Extract small factors.
org.apache.commons.math4.primes.SmallPrimes.trialDivision	(	int	): Factorization by trial division.
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator: A RandomVectorGenerator that generates vectors with with correlated components. Random vectors with correlated components are built by combining the uncorrelated components of another random vector in such a way that the resulting correlations are the ones specified by a positive definite covariance matrix. The main use for correlated random vector generation is for Monte-Carlo simulation of physical problems with several variables, for example to generate error vectors to be added to a nominal vector. A particularly interesting case is when the generated vector should be drawn from a  Multivariate Normal Distribution. The approach using a Cholesky decomposition is quite usual in this case. However, it can be extended to other cases as long as the underlying random generator provides NormalizedRandomGenerator normalized values like GaussianRandomGenerator or UniformRandomGenerator. Sometimes, the covariance matrix for a given simulation is not strictly positive definite. This means that the correlations are not all independent from each other. In this case, however, the non strictly positive elements found during the Cholesky decomposition of the covariance matrix should not be negative either, they should be null. Another non-conventional extension handling this case is used here. Rather than computing C = UT.U where C is the covariance matrix and U is an upper-triangular matrix, we compute C = B.BT where B is a rectangular matrix having more rows than columns. The number of columns of B is the rank of the covariance matrix, and it is the dimension of the uncorrelated random vector that is needed to compute the component of the correlated vector. This class handles this situation automatically.
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator.CorrelatedRandomVectorGenerator	(	RealMatrix	double	NormalizedRandomGenerator	): Builds a null mean random correlated vector generator from its covariance matrix.
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator.CorrelatedRandomVectorGenerator	(	double[]	RealMatrix	double	NormalizedRandomGenerator	): Builds a correlated random vector generator from its mean vector and covariance matrix.
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator.getGenerator	(	): Get the underlying normalized components generator.
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator.getRank	(	): Get the rank of the covariance matrix. The rank is the number of independent rows in the covariance matrix, it is also the number of columns of the root matrix.
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator.getRootMatrix	(	): Get the root of the covariance matrix. The root is the rectangular matrix B such that the covariance matrix is equal to B.BT
org.apache.commons.math4.random.CorrelatedRandomVectorGenerator.nextVector	(	): Generate a correlated random vector.
org.apache.commons.math4.random.GaussianRandomGenerator: Random generator that generates normally distributed samples.
org.apache.commons.math4.random.GaussianRandomGenerator.GaussianRandomGenerator	(	UniformRandomProvider	): Creates a new generator.
org.apache.commons.math4.random.GaussianRandomGenerator.nextNormalizedDouble	(	): Generates a random scalar with zero mean and unit standard deviation.
org.apache.commons.math4.random.HaltonSequenceGenerator: Implementation of a Halton sequence.  A Halton sequence is a low-discrepancy sequence generating points in the interval [0, 1] according to  H(n) = d_0 / b + d_1 / b^2 .... d_j / b^j+1 with n = d_j * b^j-1 + ... d_1 * b + d_0 * b^0  For higher dimensions, subsequent prime numbers are used as base, e.g. { 2, 3, 5 } for a Halton sequence in R^3.  Halton sequences are known to suffer from linear correlation for larger prime numbers, thus the individual digits are usually scrambled. This implementation already comes with support for up to 40 dimensions with optimal weight numbers from  H. Chi: Scrambled quasirandom sequences and their applications.  The generator supports two modes:  sequential generation of points: nextVector() random access to the i-th point in the sequence: skipTo() 
org.apache.commons.math4.random.HaltonSequenceGenerator.HaltonSequenceGenerator	(	int	): Construct a new Halton sequence generator for the given space dimension.
org.apache.commons.math4.random.HaltonSequenceGenerator.HaltonSequenceGenerator	(	int	int[]	int[]	): Construct a new Halton sequence generator with the given base numbers and weights for each dimension. The length of the bases array defines the space dimension and is required to be > 0.
org.apache.commons.math4.random.HaltonSequenceGenerator.getNextIndex	(	): Returns the index i of the next point in the Halton sequence that will be returned by calling nextVector().
org.apache.commons.math4.random.HaltonSequenceGenerator.nextVector	(	): Generate a random vector. 
org.apache.commons.math4.random.HaltonSequenceGenerator.scramble	(	int	int	int	int	): Performs scrambling of digit d_j according to the formula:  ( weight_i * d_j ) mod base  Implementations can override this method to do a different scrambling.
org.apache.commons.math4.random.HaltonSequenceGenerator.skipTo	(	int	): Skip to the i-th point in the Halton sequence.  This operation can be performed in O(1).
org.apache.commons.math4.random.NormalizedRandomGenerator: This interface represent a normalized random generator for scalars. Normalized generator provide null mean and unit standard deviation scalars.
org.apache.commons.math4.random.NormalizedRandomGenerator.nextNormalizedDouble	(	): Generate a random scalar with null mean and unit standard deviation. This method does not specify the shape of the distribution, it is the implementing class that provides it. The only contract here is to generate numbers with null mean and unit standard deviation.
org.apache.commons.math4.random.RandomGenerator: Interface extracted from java.util.Random.
org.apache.commons.math4.random.RandomGenerator.nextBoolean	(	): Returns the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence.
org.apache.commons.math4.random.RandomGenerator.nextBytes	(	byte[]	): Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array.
org.apache.commons.math4.random.RandomGenerator.nextDouble	(	): Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence.
org.apache.commons.math4.random.RandomGenerator.nextFloat	(	): Returns the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence.
org.apache.commons.math4.random.RandomGenerator.nextGaussian	(	): Returns the next pseudorandom, Gaussian ("normally") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence.
org.apache.commons.math4.random.RandomGenerator.nextInt	(	): Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. All 232 possible int values should be produced with (approximately) equal probability.
org.apache.commons.math4.random.RandomGenerator.nextInt	(	int	): Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence.
org.apache.commons.math4.random.RandomGenerator.nextLong	(	): Returns the next pseudorandom, uniformly distributed long value from this random number generator's sequence. All 264 possible long values should be produced with (approximately) equal probability.
org.apache.commons.math4.random.RandomGenerator.setSeed	(	int	): Sets the seed of the underlying random number generator using an int seed. Sequences of values generated starting with the same seeds should be identical. 
org.apache.commons.math4.random.RandomGenerator.setSeed	(	int[]	): Sets the seed of the underlying random number generator using an int array seed. Sequences of values generated starting with the same seeds should be identical. 
org.apache.commons.math4.random.RandomGenerator.setSeed	(	long	): Sets the seed of the underlying random number generator using a long seed. Sequences of values generated starting with the same seeds should be identical. 
org.apache.commons.math4.random.RandomUtils: Factory for creating generators of miscellaneous data.
org.apache.commons.math4.random.RandomUtils.DataGenerator: Various random data generation routines.
org.apache.commons.math4.random.RandomUtils.DataGenerator.DataGenerator	(	UniformRandomProvider	): 
org.apache.commons.math4.random.RandomUtils.DataGenerator.nextHexString	(	int	boolean	): Generates a random string of hex characters of length len. Algorithm Description: how hexadecimal strings are generated depends on the value of the useSha1 argument.  If useSha1 == false, a 2-step process is used:   len / 2 + 1 binary bytes are generated using the underlying generator.   Each binary byte is translated into 2 hex digits.     If useSha1 == true, hex strings are generated in 40-byte segments using a 3-step process:   20 random bytes are generated using the underlying generator.   SHA-1 hash is applied to yield a 20-byte binary digest.   Each byte of the binary digest is converted to 2 hex digits.    
org.apache.commons.math4.random.RandomUtils.DataGenerator.nextLong	(	long	long	): Generates a uniformly distributed random long integer between lower and upper (endpoints included).
org.apache.commons.math4.random.RandomUtils.DataGenerator.nextUniform	(	double	double	): Generates a uniformly distributed random value from the open interval (lower, upper) (i.e., endpoints excluded).  Definition:  Uniform Distribution lower and upper - lower are the  location and scale parameters, respectively.  Algorithm Description: scales the output of Random.nextDouble(), but rejects 0 values (i.e., will generate another random double if Random.nextDouble() returns 0). This is necessary to provide a symmetric output interval (both endpoints excluded). 
org.apache.commons.math4.random.RandomUtils.DataGenerator.nextUniform	(	double	double	boolean	): Generates a uniformly distributed random value from the interval (lower, upper) or the interval [lower, upper). The lower bound is thus optionally included, while the upper bound is always excluded.  Definition:  Uniform Distribution lower and upper - lower are the  location and scale parameters, respectively.  Algorithm Description: if the lower bound is excluded, scales the output of "nextDouble()", but rejects 0 values (i.e. it will generate another random double if "nextDouble()" returns 0). This is necessary to provide a symmetric output interval (both endpoints excluded). 
org.apache.commons.math4.random.RandomUtils.RandomUtils	(	): Class contains only static methods.
org.apache.commons.math4.random.RandomUtils.asUniformRandomProvider	(	Random	): Wraps a Random instance.
org.apache.commons.math4.random.RandomUtils.createDataGenerator	(	Random	): Wraps an instance of the JDK's Random class. The actual generation of random numbers will be delegated to that instance.  If cryptographically secure data is required, one can use this factory method, with an instance of the java.security.SecureRandom class as the argument. Note that data generation will be much slower in this case. 
org.apache.commons.math4.random.RandomUtils.createDataGenerator	(	UniformRandomProvider	): 
org.apache.commons.math4.random.RandomUtilsDataGeneratorAbstractTest: Test cases for the DataGenerator class.
org.apache.commons.math4.random.RandomUtilsDataGeneratorAbstractTest.RandomUtilsDataGeneratorAbstractTest	(	UniformRandomProvider	): 
org.apache.commons.math4.random.RandomUtilsDataGeneratorAbstractTest.checkNextHex	(	boolean	): 
org.apache.commons.math4.random.RandomUtilsDataGeneratorAbstractTest.testNextHexWithoutSha1	(	): Test dispersion and failure modes for "nextHex". 
org.apache.commons.math4.random.RandomUtilsDataGeneratorAbstractTest.testNextUniformExclusiveEndpoints	(	): test exclusive endpoints of nextUniform 
org.apache.commons.math4.random.RandomUtilsDataGeneratorJDKRandomTest: Test cases for the DataGenerator class, using Random as the underlying source of randomness.
org.apache.commons.math4.random.RandomVectorGenerator: This interface represents a random generator for whole vectors.
org.apache.commons.math4.random.RandomVectorGenerator.nextVector	(	): Generate a random vector.
org.apache.commons.math4.random.RngAdaptor: Adaptor that delegates to a org.apache.commons.rng.UniformRandomProvider instance.  It is provided for users who wish to test the new RNG implementations the current generators (up to version 3.6 of Commons Math) in codes that require the RandomGenerator interface.   Applications should upgrade to use the new generators ASAP. If problems are found that jeopardize the upgrade, please report them on the project's  issue tracking system.   Notes:   The setSeed() setSeed(int), setSeed() setSeed(int[]) and setSeed() setSeed(long) methods of the RandomGenerator are not part of the org.apache.commons.rng.UniformRandomProvider new API.   The new RNG implementations are not Serializable. Use saveState() instead.   nextGaussian() nextGaussian() is not part of the org.apache.commons.rng.UniformRandomProvider new API as it defines a "post-processing" of the output of a uniform RNG in order to follow a different distribution.  
org.apache.commons.math4.random.RngAdaptor.RngAdaptor	(	RandomSource	): Creates a new instance.
org.apache.commons.math4.random.RngAdaptor.RngAdaptor	(	RandomSource	Object	): Creates a new instance.
org.apache.commons.math4.random.RngAdaptor.clear	(	): Clears the cache used by the default implementation of nextGaussian.
org.apache.commons.math4.random.RngAdaptor.nextBoolean	(	): Returns the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence. 
org.apache.commons.math4.random.RngAdaptor.nextBytes	(	byte[]	): Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. 
org.apache.commons.math4.random.RngAdaptor.nextDouble	(	): Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence. 
org.apache.commons.math4.random.RngAdaptor.nextFloat	(	): Returns the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence. 
org.apache.commons.math4.random.RngAdaptor.nextGaussian	(	): Returns the next pseudorandom, Gaussian ("normally") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence. 
org.apache.commons.math4.random.RngAdaptor.nextInt	(	): Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. All 232 possible int values should be produced with (approximately) equal probability. 
org.apache.commons.math4.random.RngAdaptor.nextInt	(	int	): Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. 
org.apache.commons.math4.random.RngAdaptor.nextLong	(	): Returns the next pseudorandom, uniformly distributed long value from this random number generator's sequence. All 264 possible long values should be produced with (approximately) equal probability. 
org.apache.commons.math4.random.RngAdaptor.readObject	(	ObjectInputStream	): 
org.apache.commons.math4.random.RngAdaptor.setSeed	(	int	): Sets the seed of the underlying random number generator using an int seed. Sequences of values generated starting with the same seeds should be identical.  
org.apache.commons.math4.random.RngAdaptor.setSeed	(	int[]	): Sets the seed of the underlying random number generator using an int array seed. Sequences of values generated starting with the same seeds should be identical.  
org.apache.commons.math4.random.RngAdaptor.setSeed	(	long	): Sets the seed of the underlying random number generator using a long seed. Sequences of values generated starting with the same seeds should be identical.  
org.apache.commons.math4.random.RngAdaptor.writeObject	(	ObjectOutputStream	): 
org.apache.commons.math4.random.SobolSequenceGenerator: Implementation of a Sobol sequence.  A Sobol sequence is a low-discrepancy sequence with the property that for all values of N, its subsequence (x1, ... xN) has a low discrepancy. It can be used to generate pseudo-random points in a space S, which are equi-distributed.  The implementation already comes with support for up to 1000 dimensions with direction numbers calculated from Stephen Joe and Frances Kuo.  The generator supports two modes:  sequential generation of points: nextVector() random access to the i-th point in the sequence: skipTo() 
org.apache.commons.math4.random.SobolSequenceGenerator.SobolSequenceGenerator	(	int	): Construct a new Sobol sequence generator for the given space dimension.
org.apache.commons.math4.random.SobolSequenceGenerator.SobolSequenceGenerator	(	int	InputStream	): Construct a new Sobol sequence generator for the given space dimension with direction vectors loaded from the given stream.  The expected format is identical to the files available from Stephen Joe and Frances Kuo. The first line will be ignored as it is assumed to contain only the column headers. The columns are:  d: the dimension s: the degree of the primitive polynomial a: the number representing the coefficients m: the list of initial direction numbers  Example:  d s a m_i 2 1 0 1 3 2 1 1 3   The input stream must be an ASCII text containing one valid direction vector per line.
org.apache.commons.math4.random.SobolSequenceGenerator.getNextIndex	(	): Returns the index i of the next point in the Sobol sequence that will be returned by calling nextVector().
org.apache.commons.math4.random.SobolSequenceGenerator.initDirectionVector	(	int	int	int[]	): Calculate the direction numbers from the given polynomial.
org.apache.commons.math4.random.SobolSequenceGenerator.initFromStream	(	InputStream	): Load the direction vector for each dimension from the given stream.  The input stream must be an ASCII text containing one valid direction vector per line.
org.apache.commons.math4.random.SobolSequenceGenerator.nextVector	(	): Generate a random vector. 
org.apache.commons.math4.random.SobolSequenceGenerator.skipTo	(	int	): Skip to the i-th point in the Sobol sequence.  This operation can be performed in O(1).
org.apache.commons.math4.random.StableRandomGenerator: This class provides a stable normalized random generator. It samples from a stable distribution with location parameter 0 and scale 1. The implementation uses the Chambers-Mallows-Stuck method as described in Handbook of computational statistics: concepts and methods by James E. Gentle, Wolfgang Härdle, Yuichi Mori.
org.apache.commons.math4.random.StableRandomGenerator.StableRandomGenerator	(	UniformRandomProvider	double	double	): Create a new generator.
org.apache.commons.math4.random.StableRandomGenerator.nextNormalizedDouble	(	): Generate a random scalar with zero location and unit scale.
org.apache.commons.math4.random.StableRandomGeneratorTest: Tests for the class StableRandomGenerator.
org.apache.commons.math4.random.StableRandomGeneratorTest.testAlphaRangeBelowZero	(	): Input parameter range tests
org.apache.commons.math4.random.StableRandomGeneratorTest.testCauchyCase	(	): If alpha = 1, than it must be Cauchy distribution
org.apache.commons.math4.random.StableRandomGeneratorTest.testGaussianCase	(	): If alpha = 2, than it must be Gaussian distribution
org.apache.commons.math4.random.StableRandomGeneratorTest.testNextDouble	(	): Run the double nextDouble() method test Due to leptokurtic property the acceptance range is widened. TODO: verify that tolerance this wide is really OK
org.apache.commons.math4.random.SynchronizedRandomGenerator: Any RandomGenerator implementation can be thread-safe if it is used through an instance of this class. This is achieved by enclosing calls to the methods of the actual generator inside the overridden synchronized methods of this class.
org.apache.commons.math4.random.SynchronizedRandomGenerator.SynchronizedRandomGenerator	(	RandomGenerator	): Creates a synchronized wrapper for the given RandomGenerator instance.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextBoolean	(	): Returns the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextBytes	(	byte[]	): Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextDouble	(	): Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextFloat	(	): Returns the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextGaussian	(	): Returns the next pseudorandom, Gaussian ("normally") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextInt	(	): Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. All 232 possible int values should be produced with (approximately) equal probability.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextInt	(	int	): Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence.
org.apache.commons.math4.random.SynchronizedRandomGenerator.nextLong	(	): Returns the next pseudorandom, uniformly distributed long value from this random number generator's sequence. All 264 possible long values should be produced with (approximately) equal probability.
org.apache.commons.math4.random.SynchronizedRandomGenerator.setSeed	(	int	): Sets the seed of the underlying random number generator using an int seed. Sequences of values generated starting with the same seeds should be identical. 
org.apache.commons.math4.random.SynchronizedRandomGenerator.setSeed	(	int[]	): Sets the seed of the underlying random number generator using an int array seed. Sequences of values generated starting with the same seeds should be identical. 
org.apache.commons.math4.random.SynchronizedRandomGenerator.setSeed	(	long	): Sets the seed of the underlying random number generator using a long seed. Sequences of values generated starting with the same seeds should be identical. 
org.apache.commons.math4.random.SynchronizedRandomGeneratorTest.doTestMath899	(	boolean	int	int	int	): 
org.apache.commons.math4.random.UncorrelatedRandomVectorGenerator: A RandomVectorGenerator that generates vectors with uncorrelated components. Components of generated vectors follow (independent) Gaussian distributions, with parameters supplied in the constructor.
org.apache.commons.math4.random.UncorrelatedRandomVectorGenerator.UncorrelatedRandomVectorGenerator	(	double[]	double[]	NormalizedRandomGenerator	): Simple constructor. Build an uncorrelated random vector generator from its mean and standard deviation vectors.
org.apache.commons.math4.random.UncorrelatedRandomVectorGenerator.UncorrelatedRandomVectorGenerator	(	int	NormalizedRandomGenerator	): Simple constructor. Build a null mean random and unit standard deviation uncorrelated vector generator
org.apache.commons.math4.random.UncorrelatedRandomVectorGenerator.nextVector	(	): Generate an uncorrelated random vector.
org.apache.commons.math4.random.UniformRandomGenerator: This class implements a normalized uniform random generator.  It generates values from a uniform distribution with mean equal to 0 and standard deviation equal to 1. Generated values fall in the range \( [-\sqrt{3}, +\sqrt{3}] \). 
org.apache.commons.math4.random.UniformRandomGenerator.UniformRandomGenerator	(	UniformRandomProvider	): Creates a new generator.
org.apache.commons.math4.random.UniformRandomGenerator.nextNormalizedDouble	(	): Generates a random scalar with zero mean and unit standard deviation.
org.apache.commons.math4.random.UnitSphereRandomVectorGenerator: Generate random vectors isotropically located on the surface of a sphere.
org.apache.commons.math4.random.UnitSphereRandomVectorGenerator.UnitSphereRandomVectorGenerator	(	int	): Create an object that will use a MT_64 default RNG, in order to generate the individual components.
org.apache.commons.math4.random.UnitSphereRandomVectorGenerator.UnitSphereRandomVectorGenerator	(	int	UniformRandomProvider	): 
org.apache.commons.math4.random.UnitSphereRandomVectorGenerator.nextVector	(	): Generate a random vector. 
org.apache.commons.math4.random.UnitSphereRandomVectorGeneratorTest.length	(	double[]	): 
org.apache.commons.math4.random.UnitSphereRandomVectorGeneratorTest.test2DDistribution	(	): Test the distribution of points from nextVector() in two dimensions.
org.apache.commons.math4.special.BesselJ: This class provides computation methods related to Bessel functions of the first kind. Detailed descriptions of these functions are available in Wikipedia, Abrabowitz and Stegun (Ch. 9-11), and DLMF (Ch. 10).  This implementation is based on the rjbesl Fortran routine at Netlib.  From the Fortran code:   This program is based on a program written by David J. Sookne (2) that computes values of the Bessel functions J or I of real argument and integer order. Modifications include the restriction of the computation to the J Bessel function of non-negative real argument, the extension of the computation to arbitrary positive order, and the elimination of most underflow.  References:  "A Note on Backward Recurrence Algorithms," Olver, F. W. J., and Sookne, D. J., Math. Comp. 26, 1972, pp 941-947. "Bessel Functions of Real Argument and Integer Order," Sookne, D. J., NBS Jour. of Res. B. 77B, 1973, pp 125-132. 
org.apache.commons.math4.special.BesselJ.BesselJ	(	double	): Create a new BesselJ with the given order.
org.apache.commons.math4.special.BesselJ.BesselJResult: Encapsulates the results returned by rjBesl().  getVals() returns the computed function values. getnVals() is the number of values among those returned by getnVals() that can be considered accurate.  nVals < 0: An argument is out of range. For example, nb <= 0, alpha < 0 or > 1, or x is too large. In this case, b(0) is set to zero, the remainder of the b-vector is not calculated, and nVals is set to MIN(nb,0) - 1 so that nVals != nb. nb > nVals > 0: Not all requested function values could be calculated accurately. This usually occurs because nb is much larger than abs(x). In this case, b(n) is calculated to the desired accuracy for n < nVals, but precision is lost for nVals < n <= nb. If b(n) does not vanish for n > nVals (because it is too small to be represented), and b(n)/b(nVals) = \(10^{-k}\), then only the first NSIG-k significant figures of b(n) can be trusted.
org.apache.commons.math4.special.BesselJ.BesselJResult.BesselJResult	(	double[]	int	): Create a new BesselJResult with the given values and valid value count.
org.apache.commons.math4.special.BesselJ.BesselJResult.getVals	(	): 
org.apache.commons.math4.special.BesselJ.BesselJResult.getnVals	(	): 
org.apache.commons.math4.special.BesselJ.rjBesl	(	double	double	int	): Calculates Bessel functions \(J_{n+alpha}(x)\) for non-negative argument x, and non-negative order n + alpha.  Before using the output vector, the user should check that nVals = nb, i.e., all orders have been calculated to the desired accuracy. See BesselResult class javadoc for details on return values. 
org.apache.commons.math4.special.BesselJ.value	(	double	): Returns the value of the constructed Bessel function of the first kind, for the passed argument.
org.apache.commons.math4.special.BesselJ.value	(	double	double	): Returns the first Bessel function, \(J_{order}(x)\).
org.apache.commons.math4.stat.CertifiedDataTest: Certified data test cases.
org.apache.commons.math4.stat.CertifiedDataTest.loadStats	(	String	Object	): loads a DescriptiveStatistics off of a test file
org.apache.commons.math4.stat.CertifiedDataTest.testDescriptiveStatistics	(	): Test DescriptiveStatistics - implementations that store full array of values and execute multi-pass algorithms
org.apache.commons.math4.stat.CertifiedDataTest.testSummaryStatistics	(	): Test SummaryStatistics - implementations that do not store the data and use single pass algorithms to compute statistics
org.apache.commons.math4.stat.Frequency: Maintains a frequency distribution. The values are ordered using the default (natural order), unless a Comparator is supplied in the constructor.
org.apache.commons.math4.stat.Frequency.Frequency	(	): Default constructor.
org.apache.commons.math4.stat.Frequency.Frequency	(	Comparator	): Constructor allowing values Comparator to be specified.
org.apache.commons.math4.stat.Frequency.NaturalComparator: A Comparator that compares comparable objects using the natural order. Copied from Commons Collections ComparableComparator.
org.apache.commons.math4.stat.Frequency.NaturalComparator.compare	(	U	U	): Compare the two Comparable Comparable arguments. This method is equivalent to: ((Comparable Comparable)o1).compareTo(o2)
org.apache.commons.math4.stat.Frequency.addValue	(	T	): Adds 1 to the frequency count for v.
org.apache.commons.math4.stat.Frequency.clear	(	): Clears the frequency table 
org.apache.commons.math4.stat.Frequency.entrySetIterator	(	): Return an Iterator over the set of keys and values that have been added. Using the entry set to iterate is more efficient in the case where you need to access respective counts as well as values, since it doesn't require a "get" for every key...the value is provided in the Map.Entry.
org.apache.commons.math4.stat.Frequency.equals	(	Object	):  
org.apache.commons.math4.stat.Frequency.getCount	(	T	): Returns the number of values equal to v.
org.apache.commons.math4.stat.Frequency.getCumFreq	(	T	): Returns the cumulative frequency of values less than or equal to v.
org.apache.commons.math4.stat.Frequency.getCumPct	(	T	): Returns the cumulative percentage of values less than or equal to v (as a proportion between 0 and 1).  Returns Double.NaN if no values have been added. 
org.apache.commons.math4.stat.Frequency.getMode	(	): Returns the mode value(s) in comparator order.
org.apache.commons.math4.stat.Frequency.getPct	(	T	): Returns the percentage of values that are equal to v (as a proportion between 0 and 1).  Returns Double.NaN if no values have been added. 
org.apache.commons.math4.stat.Frequency.getSumFreq	(	): Returns the sum of all frequencies.
org.apache.commons.math4.stat.Frequency.getUniqueCount	(	): Returns the number of values in the frequency table.
org.apache.commons.math4.stat.Frequency.hashCode	(	):  
org.apache.commons.math4.stat.Frequency.incrementValue	(	T	long	): Increments the frequency count for v.
org.apache.commons.math4.stat.Frequency.merge	(	Collection	): Merge a Collection of Frequency objects into this instance. This Frequency's counts will be incremented (or set when not already set) by the counts represented by each of the others.
org.apache.commons.math4.stat.Frequency.merge	(	Frequency	): Merge another Frequency object's counts into this instance. This Frequency's counts will be incremented (or set when not already set) by the counts represented by other.
org.apache.commons.math4.stat.Frequency.toString	(	): Return a string representation of this frequency distribution.
org.apache.commons.math4.stat.Frequency.valuesIterator	(	): Returns an Iterator over the set of values that have been added.
org.apache.commons.math4.stat.FrequencyTest: Test cases for the Frequency class.
org.apache.commons.math4.stat.FrequencyTest.testAdd	(	): test adding incomparable values 
org.apache.commons.math4.stat.FrequencyTest.testCounts	(	): test freq counts 
org.apache.commons.math4.stat.FrequencyTest.testEmptyTable	(	): test empty table 
org.apache.commons.math4.stat.FrequencyTest.testPcts	(	): test pcts 
org.apache.commons.math4.stat.FrequencyTest.testToString	(	): Tests toString()
org.apache.commons.math4.stat.StatUtils: StatUtils provides static methods for computing statistics based on data stored in double[] arrays.
org.apache.commons.math4.stat.StatUtils.StatUtils	(	): Private Constructor
org.apache.commons.math4.stat.StatUtils.geometricMean	(	double[]	): Returns the geometric mean of the entries in the input array, or Double.NaN if the array is empty.  Throws IllegalArgumentException if the array is null.  See org.apache.commons.math4.stat.descriptive.moment.GeometricMean GeometricMean for details on the computing algorithm.
org.apache.commons.math4.stat.StatUtils.geometricMean	(	double[]	int	int	): Returns the geometric mean of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.  See org.apache.commons.math4.stat.descriptive.moment.GeometricMean GeometricMean for details on the computing algorithm.
org.apache.commons.math4.stat.StatUtils.getMode	(	double[]	int	int	): Private helper method. Assumes parameters have been validated.
org.apache.commons.math4.stat.StatUtils.max	(	double[]	): Returns the maximum of the entries in the input array, or Double.NaN if the array is empty.  Throws MathIllegalArgumentException if the array is null.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.POSITIVE_INFINITY, the result is Double.POSITIVE_INFINITY. 
org.apache.commons.math4.stat.StatUtils.max	(	double[]	int	int	): Returns the maximum of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.POSITIVE_INFINITY, the result is Double.POSITIVE_INFINITY. 
org.apache.commons.math4.stat.StatUtils.mean	(	double[]	): Returns the arithmetic mean of the entries in the input array, or Double.NaN if the array is empty.  Throws IllegalArgumentException if the array is null.  See org.apache.commons.math4.stat.descriptive.moment.Mean for details on the computing algorithm.
org.apache.commons.math4.stat.StatUtils.mean	(	double[]	int	int	): Returns the arithmetic mean of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.  See org.apache.commons.math4.stat.descriptive.moment.Mean Mean for details on the computing algorithm.
org.apache.commons.math4.stat.StatUtils.meanDifference	(	double[]	double[]	): Returns the mean of the (signed) differences between corresponding elements of the input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.
org.apache.commons.math4.stat.StatUtils.min	(	double[]	): Returns the minimum of the entries in the input array, or Double.NaN if the array is empty.  Throws MathIllegalArgumentException if the array is null.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.NEGATIVE_INFINITY, the result is Double.NEGATIVE_INFINITY. 
org.apache.commons.math4.stat.StatUtils.min	(	double[]	int	int	): Returns the minimum of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.NEGATIVE_INFINITY, the result is Double.NEGATIVE_INFINITY. 
org.apache.commons.math4.stat.StatUtils.mode	(	double[]	): Returns the sample mode(s).  The mode is the most frequently occurring value in the sample. If there is a unique value with maximum frequency, this value is returned as the only element of the output array. Otherwise, the returned array contains the maximum frequency elements in increasing order.  For example, if sample is {0, 12, 5, 6, 0, 13, 5, 17}, the returned array will have length two, with 0 in the first element and 5 in the second.  NaN values are ignored when computing the mode - i.e., NaNs will never appear in the output array. If the sample includes only NaNs or has length 0, an empty array is returned.
org.apache.commons.math4.stat.StatUtils.mode	(	double[]	int	int	): Returns the sample mode(s).  The mode is the most frequently occurring value in the sample. If there is a unique value with maximum frequency, this value is returned as the only element of the output array. Otherwise, the returned array contains the maximum frequency elements in increasing order.  For example, if sample is {0, 12, 5, 6, 0, 13, 5, 17}, the returned array will have length two, with 0 in the first element and 5 in the second.  NaN values are ignored when computing the mode - i.e., NaNs will never appear in the output array. If the sample includes only NaNs or has length 0, an empty array is returned.
org.apache.commons.math4.stat.StatUtils.normalize	(	double[]	): Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.
org.apache.commons.math4.stat.StatUtils.percentile	(	double[]	double	): Returns an estimate of the pth percentile of the values in the values array.  Returns Double.NaN if values has length 0 Returns (for any value of p) values[0] if values has length 1 Throws IllegalArgumentException if values is null or p is not a valid quantile value (p must be greater than 0 and less than or equal to 100)   See org.apache.commons.math4.stat.descriptive.rank.Percentile Percentile for a description of the percentile estimation algorithm used.
org.apache.commons.math4.stat.StatUtils.percentile	(	double[]	int	int	double	): Returns an estimate of the pth percentile of the values in the values array, starting with the element in (0-based) position begin in the array and including length values.  Returns Double.NaN if length = 0 Returns (for any value of p) values[begin] if length = 1  Throws MathIllegalArgumentException if values is null, begin or length is invalid, or p is not a valid quantile value (p must be greater than 0 and less than or equal to 100)   See org.apache.commons.math4.stat.descriptive.rank.Percentile Percentile for a description of the percentile estimation algorithm used.
org.apache.commons.math4.stat.StatUtils.populationVariance	(	double[]	): Returns the  population variance of the entries in the input array, or Double.NaN if the array is empty.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the formula and computing algorithm.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.populationVariance	(	double[]	double	): Returns the  population variance of the entries in the input array, using the precomputed mean value. Returns Double.NaN if the array is empty.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.populationVariance	(	double[]	double	int	int	): Returns the  population variance of the entries in the specified portion of the input array, using the precomputed mean value. Returns Double.NaN if the designated subarray is empty.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.
org.apache.commons.math4.stat.StatUtils.populationVariance	(	double[]	int	int	): Returns the  population variance of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.
org.apache.commons.math4.stat.StatUtils.product	(	double[]	): Returns the product of the entries in the input array, or Double.NaN if the array is empty.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.product	(	double[]	int	int	): Returns the product of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.sum	(	double[]	): Returns the sum of the values in the input array, or Double.NaN if the array is empty.  Throws IllegalArgumentException if the input array is null.
org.apache.commons.math4.stat.StatUtils.sum	(	double[]	int	int	): Returns the sum of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.sumDifference	(	double[]	double[]	): Returns the sum of the (signed) differences between corresponding elements of the input arrays -- i.e., sum(sample1[i] - sample2[i]).
org.apache.commons.math4.stat.StatUtils.sumLog	(	double[]	): Returns the sum of the natural logs of the entries in the input array, or Double.NaN if the array is empty.  Throws IllegalArgumentException if the array is null.  See org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.
org.apache.commons.math4.stat.StatUtils.sumLog	(	double[]	int	int	): Returns the sum of the natural logs of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.  See org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.
org.apache.commons.math4.stat.StatUtils.sumSq	(	double[]	): Returns the sum of the squares of the entries in the input array, or Double.NaN if the array is empty.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.sumSq	(	double[]	int	int	): Returns the sum of the squares of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.variance	(	double[]	): Returns the variance of the entries in the input array, or Double.NaN if the array is empty.  This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use populationVariance() for the non-bias-corrected population variance.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.variance	(	double[]	double	): Returns the variance of the entries in the input array, using the precomputed mean value. Returns Double.NaN if the array is empty.  This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use populationVariance() for the non-bias-corrected population variance.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.StatUtils.variance	(	double[]	double	int	int	): Returns the variance of the entries in the specified portion of the input array, using the precomputed mean value. Returns Double.NaN if the designated subarray is empty.  This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use populationVariance() for the non-bias-corrected population variance.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.
org.apache.commons.math4.stat.StatUtils.variance	(	double[]	int	int	): Returns the variance of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use populationVariance() for the non-bias-corrected population variance.  See org.apache.commons.math4.stat.descriptive.moment.Variance Variance for details on the computing algorithm.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.
org.apache.commons.math4.stat.StatUtils.varianceDifference	(	double[]	double[]	double	): Returns the variance of the (signed) differences between corresponding elements of the input arrays -- i.e., var(sample1[i] - sample2[i]).
org.apache.commons.math4.stat.StatUtilsTest: Test cases for the StatUtils class.
org.apache.commons.math4.stat.StatUtilsTest.testNormalize1	(	): Run the test with the values 50 and 100 and assume standardized values
org.apache.commons.math4.stat.StatUtilsTest.testNormalize2	(	): Run with 77 random values, assuming that the outcome has a mean of 0 and a standard deviation of 1 with a precision of 1E-10.
org.apache.commons.math4.stat.StatUtilsTest.testStats	(	): test stats 
org.apache.commons.math4.stat.correlation.Covariance: Computes covariances for pairs of arrays or columns of a matrix. The constructors that take RealMatrix or double[][] arguments generate covariance matrices. The columns of the input matrices are assumed to represent variable values. The constructor argument biasCorrected determines whether or not computed covariances are bias-corrected. Unbiased covariances are given by the formula cov(X, Y) = Σ[(xi - E(X))(yi - E(Y))] / (n - 1) where E(X) is the mean of X and E(Y) is the mean of the Y values. Non-bias-corrected estimates use n in place of n - 1
org.apache.commons.math4.stat.correlation.Covariance.Covariance	(	): Create a Covariance with no data
org.apache.commons.math4.stat.correlation.Covariance.Covariance	(	RealMatrix	): Create a covariance matrix from a matrix whose columns represent covariates. The matrix must have at least one column and two rows
org.apache.commons.math4.stat.correlation.Covariance.Covariance	(	RealMatrix	boolean	): Create a covariance matrix from a matrix whose columns represent covariates. The biasCorrected parameter determines whether or not covariance estimates are bias-corrected. The matrix must have at least one column and two rows
org.apache.commons.math4.stat.correlation.Covariance.Covariance	(	double[][]	): Create a Covariance matrix from a rectangular array whose columns represent covariates. The input array must be rectangular with at least one column and two rows
org.apache.commons.math4.stat.correlation.Covariance.Covariance	(	double[][]	boolean	): Create a Covariance matrix from a rectangular array whose columns represent covariates. The biasCorrected parameter determines whether or not covariance estimates are bias-corrected. The input array must be rectangular with at least one column and two rows.
org.apache.commons.math4.stat.correlation.Covariance.checkSufficientData	(	RealMatrix	): Throws MathIllegalArgumentException if the matrix does not have at least one column and two rows.
org.apache.commons.math4.stat.correlation.Covariance.computeCovarianceMatrix	(	RealMatrix	): Create a covariance matrix from a matrix whose columns represent covariates. Covariances are computed using the bias-corrected formula.
org.apache.commons.math4.stat.correlation.Covariance.computeCovarianceMatrix	(	RealMatrix	boolean	): Compute a covariance matrix from a matrix whose columns represent covariates.
org.apache.commons.math4.stat.correlation.Covariance.computeCovarianceMatrix	(	double[][]	): Create a covariance matrix from a rectangular array whose columns represent covariates. Covariances are computed using the bias-corrected formula.
org.apache.commons.math4.stat.correlation.Covariance.computeCovarianceMatrix	(	double[][]	boolean	): Compute a covariance matrix from a rectangular array whose columns represent covariates.
org.apache.commons.math4.stat.correlation.Covariance.covariance	(	double[]	double[]	): Computes the covariance between the two arrays, using the bias-corrected formula. Array lengths must match and the common length must be at least 2.
org.apache.commons.math4.stat.correlation.Covariance.covariance	(	double[]	double[]	boolean	): Computes the covariance between the two arrays. Array lengths must match and the common length must be at least 2.
org.apache.commons.math4.stat.correlation.Covariance.getCovarianceMatrix	(	): Returns the covariance matrix
org.apache.commons.math4.stat.correlation.Covariance.getN	(	): Returns the number of observations (length of covariate vectors)
org.apache.commons.math4.stat.correlation.CovarianceTest.testConsistency	(	): Verify that diagonal entries are consistent with Variance computation and matrix matches column-by-column covariances
org.apache.commons.math4.stat.correlation.CovarianceTest.testConstant	(	): Constant column
org.apache.commons.math4.stat.correlation.CovarianceTest.testInsufficientData	(	): Insufficient data
org.apache.commons.math4.stat.correlation.CovarianceTest.testLongly	(	): Test Longley dataset against R. Data Source: J. Longley (1967) "An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association, vol. 62. September, pp. 819-841. Data are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat
org.apache.commons.math4.stat.correlation.CovarianceTest.testOneColumn	(	): One column
org.apache.commons.math4.stat.correlation.CovarianceTest.testSwissFertility	(	): Test R Swiss fertility dataset against R. Data Source: R datasets package
org.apache.commons.math4.stat.correlation.KendallsCorrelation: Implementation of Kendall's Tau-b rank correlation.  A pair of observations (x1, y1) and (x2, y2) are considered concordant if x1 < x2 and y1 < y2 or x2 < x1 and y2 < y1. The pair is discordant if x1 < x2 and y2 < y1 or x2 < x1 and y1 < y2. If either x1 = x2 or y1 = y2, the pair is neither concordant nor discordant.  Kendall's Tau-b is defined as:  taub = (nc - nd) / sqrt((n0 - n1) * (n0 - n2))   where:  n0 = n * (n - 1) / 2 nc = Number of concordant pairs nd = Number of discordant pairs n1 = sum of ti * (ti - 1) / 2 for all i n2 = sum of uj * (uj - 1) / 2 for all j ti = Number of tied values in the ith group of ties in x uj = Number of tied values in the jth group of ties in y   This implementation uses the O(n log n) algorithm described in William R. Knight's 1966 paper "A Computer Method for Calculating Kendall's Tau with Ungrouped Data" in the Journal of the American Statistical Association.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.KendallsCorrelation	(	): Create a KendallsCorrelation instance without data.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.KendallsCorrelation	(	RealMatrix	): Create a KendallsCorrelation from a RealMatrix whose columns represent variables to be correlated.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.KendallsCorrelation	(	double[][]	): Create a KendallsCorrelation from a rectangular array whose columns represent values of variables to be correlated.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.computeCorrelationMatrix	(	RealMatrix	): Computes the Kendall's Tau rank correlation matrix for the columns of the input matrix.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.computeCorrelationMatrix	(	double[][]	): Computes the Kendall's Tau rank correlation matrix for the columns of the input rectangular array. The columns of the array represent values of variables to be correlated.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.correlation	(	double[]	double[]	): Computes the Kendall's Tau rank correlation coefficient between the two arrays.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.getCorrelationMatrix	(	): Returns the correlation matrix.
org.apache.commons.math4.stat.correlation.KendallsCorrelation.sum	(	long	): Returns the sum of the number from 1 .. n according to Gauss' summation formula: \[ \sum\limits_{k=1}^n k = \frac{n(n + 1)}{2} \]
org.apache.commons.math4.stat.correlation.KendallsCorrelationTest: Test cases for Kendall's Tau rank correlation.
org.apache.commons.math4.stat.correlation.KendallsCorrelationTest.testLongly	(	): Test Longley dataset against R.
org.apache.commons.math4.stat.correlation.KendallsCorrelationTest.testSwiss	(	): Test R swiss fertility dataset.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation: Computes Pearson's product-moment correlation coefficients for pairs of arrays or columns of a matrix. The constructors that take RealMatrix or double[][] arguments generate correlation matrices. The columns of the input matrices are assumed to represent variable values. Correlations are given by the formula cor(X, Y) = Σ[(xi - E(X))(yi - E(Y))] / [(n - 1)s(X)s(Y)] where E(X) is the mean of X, E(Y) is the mean of the Y values and s(X), s(Y) are standard deviations. To compute the correlation coefficient for a single pair of arrays, use PearsonsCorrelation() to construct an instance with no data and then correlation(). Correlation matrices can also be computed directly from an instance with no data using computeCorrelationMatrix(). In order to use getCorrelationMatrix(), getCorrelationPValues(), or getCorrelationStandardErrors(); however, one of the constructors supplying data or a covariance matrix must be used to create the instance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.PearsonsCorrelation	(	): Create a PearsonsCorrelation instance without data.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.PearsonsCorrelation	(	Covariance	): Create a PearsonsCorrelation from a Covariance. The correlation matrix is computed by scaling the Covariance's covariance matrix. The Covariance instance must have been created from a data matrix with columns representing variable values.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.PearsonsCorrelation	(	RealMatrix	): Create a PearsonsCorrelation from a RealMatrix whose columns represent variables to be correlated. Throws MathIllegalArgumentException if the matrix does not have at least two columns and two rows. Pairwise correlations are set to NaN if one of the correlates has zero variance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.PearsonsCorrelation	(	RealMatrix	int	): Create a PearsonsCorrelation from a covariance matrix. The correlation matrix is computed by scaling the covariance matrix.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.PearsonsCorrelation	(	double[][]	): Create a PearsonsCorrelation from a rectangular array whose columns represent values of variables to be correlated. Throws MathIllegalArgumentException if the input array does not have at least two columns and two rows. Pairwise correlations are set to NaN if one of the correlates has zero variance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.checkSufficientData	(	RealMatrix	): Throws MathIllegalArgumentException if the matrix does not have at least two columns and two rows.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.computeCorrelationMatrix	(	RealMatrix	): Computes the correlation matrix for the columns of the input matrix, using correlation(). Throws MathIllegalArgumentException if the matrix does not have at least two columns and two rows. Pairwise correlations are set to NaN if one of the correlates has zero variance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.computeCorrelationMatrix	(	double[][]	): Computes the correlation matrix for the columns of the input rectangular array. The columns of the array represent values of variables to be correlated. Throws MathIllegalArgumentException if the matrix does not have at least two columns and two rows or if the array is not rectangular. Pairwise correlations are set to NaN if one of the correlates has zero variance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.correlation	(	double[]	double[]	): Computes the Pearson's product-moment correlation coefficient between two arrays. Throws MathIllegalArgumentException if the arrays do not have the same length or their common length is less than 2. Returns NaN if either of the arrays has zero variance (i.e., if one of the arrays does not contain at least two distinct values).
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.covarianceToCorrelation	(	RealMatrix	): Derives a correlation matrix from a covariance matrix. Uses the formula  r(X,Y) = cov(X,Y)/s(X)s(Y) where r(·,·) is the correlation coefficient and s(·) means standard deviation.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.getCorrelationMatrix	(	): Returns the correlation matrix. This method will return null if the argumentless constructor was used to create this instance, even if computeCorrelationMatrix() has been called before it is activated.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.getCorrelationPValues	(	): Returns a matrix of p-values associated with the (two-sided) null hypothesis that the corresponding correlation coefficient is zero. getCorrelationPValues().getEntry(i,j) is the probability that a random variable distributed as tn-2 takes a value with absolute value greater than or equal to  |r|((n - 2) / (1 - r2))1/2 The values in the matrix are sometimes referred to as the significance of the corresponding correlation coefficients. To use this method, one of the constructors that supply an input matrix must have been used to create this instance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelation.getCorrelationStandardErrors	(	): Returns a matrix of standard errors associated with the estimates in the correlation matrix. getCorrelationStandardErrors().getEntry(i,j) is the standard error associated with getCorrelationMatrix.getEntry(i,j) The formula used to compute the standard error is  SEr = ((1 - r2) / (n - 2))1/2 where r is the estimated correlation coefficient and n is the number of observations in the source dataset. To use this method, one of the constructors that supply an input matrix must have been used to create this instance.
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testConstant	(	): Constant column
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testCovarianceConsistency	(	): Verify that creating correlation from covariance gives same results as direct computation from the original matrix
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testInsufficientData	(	): Insufficient data
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testLongly	(	): Test Longley dataset against R.
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testPValueNearZero	(	): Test p-value near 0. JIRA: MATH-371
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testStdErrorConsistency	(	): Verify that direct t-tests using standard error estimates are consistent with reported p-values
org.apache.commons.math4.stat.correlation.PearsonsCorrelationTest.testSwissFertility	(	): Test R Swiss fertility dataset against R.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation: Spearman's rank correlation. This implementation performs a rank transformation on the input data and then computes PearsonsCorrelation on the ranked data.  By default, ranks are computed using NaturalRanking with default strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged). The ranking algorithm can be set using a constructor argument.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.SpearmansCorrelation	(	): Create a SpearmansCorrelation without data.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.SpearmansCorrelation	(	RankingAlgorithm	): Create a SpearmansCorrelation with the given ranking algorithm.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.SpearmansCorrelation	(	RealMatrix	): Create a SpearmansCorrelation from the given data matrix.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.SpearmansCorrelation	(	RealMatrix	RankingAlgorithm	): Create a SpearmansCorrelation with the given input data matrix and ranking algorithm.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.computeCorrelationMatrix	(	RealMatrix	): Computes the Spearman's rank correlation matrix for the columns of the input matrix.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.computeCorrelationMatrix	(	double[][]	): Computes the Spearman's rank correlation matrix for the columns of the input rectangular array. The columns of the array represent values of variables to be correlated.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.correlation	(	double[]	double[]	): Computes the Spearman's rank correlation coefficient between the two arrays.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.getCorrelationMatrix	(	): Calculate the Spearman Rank Correlation Matrix.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.getRankCorrelation	(	): Returns a PearsonsCorrelation instance constructed from the ranked input data. That is, new SpearmansCorrelation(matrix).getRankCorrelation() is equivalent to new PearsonsCorrelation(rankTransform(matrix)) where rankTransform(matrix) is the result of applying the configured RankingAlgorithm to each of the columns of matrix. Returns null if this instance was created with no data.
org.apache.commons.math4.stat.correlation.SpearmansCorrelation.rankTransform	(	RealMatrix	): Applies rank transform to each of the columns of matrix using the current rankingAlgorithm.
org.apache.commons.math4.stat.correlation.SpearmansRankCorrelationTest: Test cases for Spearman's rank correlation
org.apache.commons.math4.stat.correlation.SpearmansRankCorrelationTest.testConstant	(	): Constant column
org.apache.commons.math4.stat.correlation.SpearmansRankCorrelationTest.testInsufficientData	(	): Insufficient data
org.apache.commons.math4.stat.correlation.SpearmansRankCorrelationTest.testLongly	(	): Test Longley dataset against R.
org.apache.commons.math4.stat.correlation.SpearmansRankCorrelationTest.testSwiss	(	): Test R swiss fertility dataset.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance: Bivariate Covariance implementation that does not require input data to be stored in memory. This class is based on a paper written by Philippe Pébay:  Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments, 2008, Technical Report SAND2008-6212, Sandia National Laboratories. It computes the covariance for a pair of variables. Use StorelessCovariance to estimate an entire covariance matrix. Note: This class is package private as it is only used internally in the StorelessCovariance class.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance.StorelessBivariateCovariance	(	): Create an empty StorelessBivariateCovariance instance with bias correction.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance.StorelessBivariateCovariance	(	boolean	): Create an empty StorelessBivariateCovariance instance.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance.append	(	StorelessBivariateCovariance	): Appends another bivariate covariance calculation to this. After this operation, statistics returned should be close to what would have been obtained by by performing all of the increment() operations in cov directly on this.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance.getN	(	): Returns the number of observations.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance.getResult	(	): Return the current covariance estimate.
org.apache.commons.math4.stat.correlation.StorelessBivariateCovariance.increment	(	double	double	): Update the covariance estimation with a pair of variables (x, y).
org.apache.commons.math4.stat.correlation.StorelessCovariance: Covariance implementation that does not require input data to be stored in memory. The size of the covariance matrix is specified in the constructor. Specific elements of the matrix are incrementally updated with calls to incrementRow() or increment Covariance(). This class is based on a paper written by Philippe Pébay:  Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments, 2008, Technical Report SAND2008-6212, Sandia National Laboratories. Note: the underlying covariance matrix is symmetric, thus only the upper triangular part of the matrix is stored and updated each increment.
org.apache.commons.math4.stat.correlation.StorelessCovariance.StorelessCovariance	(	int	): Create a bias corrected covariance matrix with a given dimension.
org.apache.commons.math4.stat.correlation.StorelessCovariance.StorelessCovariance	(	int	boolean	): Create a covariance matrix with a given number of rows and columns and the indicated bias correction.
org.apache.commons.math4.stat.correlation.StorelessCovariance.append	(	StorelessCovariance	): Appends sc to this, effectively aggregating the computations in sc with this. After invoking this method, covariances returned should be close to what would have been obtained by performing all of the increment() operations in sc directly on this.
org.apache.commons.math4.stat.correlation.StorelessCovariance.getCovariance	(	int	int	): Get the covariance for an individual element of the covariance matrix.
org.apache.commons.math4.stat.correlation.StorelessCovariance.getCovarianceMatrix	(	): Returns the covariance matrix
org.apache.commons.math4.stat.correlation.StorelessCovariance.getData	(	): Return the covariance matrix as two-dimensional array.
org.apache.commons.math4.stat.correlation.StorelessCovariance.getElement	(	int	int	): Gets the element at index (i, j) from the covariance matrix
org.apache.commons.math4.stat.correlation.StorelessCovariance.getN	(	): This Covariance method is not supported by a StorelessCovariance, since the number of bivariate observations does not have to be the same for different pairs of covariates - i.e., N as defined in getN() is undefined.
org.apache.commons.math4.stat.correlation.StorelessCovariance.increment	(	double[]	): Increment the covariance matrix with one row of data.
org.apache.commons.math4.stat.correlation.StorelessCovariance.indexOf	(	int	int	): Returns the index (i, j) translated into the one-dimensional array used to store the upper triangular part of the symmetric covariance matrix.
org.apache.commons.math4.stat.correlation.StorelessCovariance.initializeMatrix	(	boolean	): Initialize the internal two-dimensional array of StorelessBivariateCovariance instances.
org.apache.commons.math4.stat.correlation.StorelessCovariance.setElement	(	int	int	StorelessBivariateCovariance	): Sets the covariance element at index (i, j) in the covariance matrix
org.apache.commons.math4.stat.correlation.StorelessCovarianceTest.testEquivalence	(	): Test equality of covariance. chk: covariance of two samples separately and adds them together. cov: computes covariance of the combined sample showing both are equal.
org.apache.commons.math4.stat.correlation.StorelessCovarianceTest.testLonglyByRow	(	): Test Longley dataset against R. Data Source: J. Longley (1967) "An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association, vol. 62. September, pp. 819-841. Data are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat
org.apache.commons.math4.stat.correlation.StorelessCovarianceTest.testSwissFertilityByRow	(	): Test R Swiss fertility dataset against R. Data Source: R datasets package
org.apache.commons.math4.stat.correlation.StorelessCovarianceTest.testSymmetry	(	): Test symmetry of the covariance matrix
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic: Abstract base class for implementations of the StorelessUnivariateStatistic interface.  Provides default evaluate(double[],...) and incrementAll(double[]) implementations.  Note that these implementations are not synchronized.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.equals	(	Object	): Returns true iff object is the same type of StorelessUnivariateStatistic (the object's class equals this instance) returning the same values as this for getResult() and getN().
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.evaluate	(	double[]	): This default implementation creates a copy of this StorelessUnivariateStatistic instance, calls clear on it, then calls incrementAll with the specified portion of the input array, and then uses getResult to compute the return value.  Note that this implementation does not change the internal state of the statistic.  Implementations may override this method with a more efficient and possibly more accurate implementation that works directly with the input array.  If the array is null, a MathIllegalArgumentException is thrown.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.evaluate	(	double[]	int	int	): This default implementation creates a copy of this StorelessUnivariateStatistic instance, calls clear on it, then calls incrementAll with the specified portion of the input array, and then uses getResult to compute the return value.  Note that this implementation does not change the internal state of the statistic.  Implementations may override this method with a more efficient and possibly more accurate implementation that works directly with the input array.  If the array is null or the index parameters are not valid, an MathIllegalArgumentException is thrown.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.hashCode	(	): Returns hash code based on getResult() and getN().
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.incrementAll	(	double[]	): This default implementation just calls increment in a loop over the input array.  Throws IllegalArgumentException if the input values array is null.
org.apache.commons.math4.stat.descriptive.AbstractStorelessUnivariateStatistic.incrementAll	(	double[]	int	int	): This default implementation just calls increment in a loop over the specified portion of the input array.  Throws IllegalArgumentException if the input values array is null.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic: Abstract base class for implementations of the UnivariateStatistic interface.  Provides a default implementation of evaluate(double[]), delegating to evaluate(double[], int, int) in the natural way.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.evaluate	(	): Returns the result of evaluating the statistic over the stored data.  The stored array is the one which was set by previous calls to setData(). 
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.evaluate	(	double[]	): Returns the result of evaluating the statistic over the input array.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.evaluate	(	double[]	int	int	): Returns the result of evaluating the statistic over the specified entries in the input array.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.getData	(	): Get a copy of the stored data array.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.getDataRef	(	): Get a reference to the stored data array.
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.setData	(	double[]	): Set the data array.  The stored value is a copy of the parameter array, not the array itself. 
org.apache.commons.math4.stat.descriptive.AbstractUnivariateStatistic.setData	(	double[]	int	int	): Set the data array. The input array is copied, not referenced.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics:  An aggregator for SummaryStatistics from several data sets or data set partitions. In its simplest usage mode, the client creates an instance via the zero-argument constructor, then uses createContributingStatistics() to obtain a SummaryStatistics for each individual data set / partition. The per-set statistics objects are used as normal, and at any time the aggregate statistics for all the contributors can be obtained from this object.  Clients with specialized requirements can use alternative constructors to control the statistics implementations and initial values used by the contributing and the internal aggregate SummaryStatistics objects.  A static aggregate() method is also included that computes aggregate statistics directly from a Collection of SummaryStatistics instances.  When createContributingStatistics() is used to create SummaryStatistics instances to be aggregated concurrently, the created instances' addValue() methods must synchronize on the aggregating instance maintained by this class. In multithreaded environments, if the functionality provided by aggregate() is adequate, that method should be used to avoid unnecessary computation and synchronization delays.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregateSummaryStatistics	(	): Initializes a new AggregateSummaryStatistics with default statistics implementations.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregateSummaryStatistics	(	SummaryStatistics	): Initializes a new AggregateSummaryStatistics with the specified statistics object as a prototype for contributing statistics and for the internal aggregate statistics. This provides for customized statistics implementations to be used by contributing and aggregate statistics.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregateSummaryStatistics	(	SummaryStatistics	SummaryStatistics	): Initializes a new AggregateSummaryStatistics with the specified statistics object as a prototype for contributing statistics and for the internal aggregate statistics. This provides for different statistics implementations to be used by contributing and aggregate statistics and for an initial state to be supplied for the aggregate statistics.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregatingSummaryStatistics: A SummaryStatistics that also forwards all values added to it to a second SummaryStatistics for aggregation.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregatingSummaryStatistics.AggregatingSummaryStatistics	(	SummaryStatistics	): Initializes a new AggregatingSummaryStatistics with the specified aggregate statistics object
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregatingSummaryStatistics.addValue	(	double	): Add a value to the data. This version adds the provided value to the configured aggregate after adding it to these statistics.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregatingSummaryStatistics.equals	(	Object	): Returns true iff object is a SummaryStatistics instance and all statistics have the same values as this.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.AggregatingSummaryStatistics.hashCode	(	): Returns hash code based on values of statistics
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.aggregate	(	Collection	): Computes aggregate summary statistics. This method can be used to combine statistics computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned should contain the same values that would have been obtained by computing a single StatisticalSummary over the combined dataset.  Returns null if the collection is empty or null. 
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics	(	): Creates and returns a SummaryStatistics whose data will be aggregated with those of this AggregateSummaryStatistics.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getGeometricMean	(	): Returns the geometric mean of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getMax	(	): Returns the maximum of the available values. This version returns the maximum over all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getMean	(	): Returns the  arithmetic mean  of the available values. This version returns the mean of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getMin	(	): Returns the minimum of the available values. This version returns the minimum over all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getN	(	): Returns the number of available values. This version returns a count of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getSecondMoment	(	): Returns a statistic related to the Second Central Moment. Specifically, what is returned is the sum of squared deviations from the sample mean among the all of the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getStandardDeviation	(	): Returns the standard deviation of the available values.. This version returns the standard deviation of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getSum	(	): Returns the sum of the values that have been added to Univariate.. This version returns a sum of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getSumOfLogs	(	): Returns the sum of the logs of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getSummary	(	): Return a StatisticalSummaryValues instance reporting current aggregate statistics.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getSumsq	(	): Returns the sum of the squares of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatistics.getVariance	(	): Returns the variance of the available values.. This version returns the variance of all the aggregated data.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest: Test cases for AggregateSummaryStatistics
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.assertEquals	(	StatisticalSummary	StatisticalSummary	double	): Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up to delta, with NaNs, infinities returned in the same spots. For max, min, n, values have to agree exactly, delta is used only for sum, mean, variance, std dev.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.generatePartition	(	double[]	): Generates a partition of  into up to 5 sequentially selected subsamples with randomly selected partition points.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.generateSample	(	): Generates a random sample of double values. Sample size is random, between 10 and 100 and values are uniformly distributed over [-100, 100].
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.testAggregate	(	): Test aggregate function by randomly generating a dataset of 10-100 values from [-100, 100], dividing it into 2-5 partitions, computing stats for each partition and comparing the result of aggregate(...) applied to the collection of per-partition SummaryStatistics with a single SummaryStatistics computed over the full sample.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.testAggregateStatisticalSummary	(	): Similar to testAggregate() but operating on StatisticalSummary instead.
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.testAggregation	(	): Tests the standard aggregation behavior
org.apache.commons.math4.stat.descriptive.AggregateSummaryStatisticsTest.testAggregationConsistency	(	): Verify that aggregating over a partition gives the same results as direct computation. 1) Randomly generate a dataset of 10-100 values from [-100, 100] 2) Divide the dataset it into 2-5 partitions 3) Create an AggregateSummaryStatistic and ContributingStatistics for each partition 4) Compare results from the AggregateSummaryStatistic with values returned by a single SummaryStatistics instance that is provided the full dataset
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics: Maintains a dataset of values of a single variable and computes descriptive statistics based on stored data.  The getWindowSize() windowSize property sets a limit on the number of values that can be stored in the dataset. The default value, INFINITE_WINDOW, puts no limit on the size of the dataset. This value should be used with caution, as the backing store will grow without bound in this case. For very large datasets, SummaryStatistics, which does not store the dataset, should be used instead of this class. If windowSize is not INFINITE_WINDOW and more values are added than can be stored in the dataset, new values are added in a "rolling" manner, with new values replacing the "oldest" values in the dataset.  Note: this class is not threadsafe. Use SynchronizedDescriptiveStatistics if concurrent access from multiple threads is required.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.DescriptiveStatistics	(	): Construct a DescriptiveStatistics instance with an infinite window.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.DescriptiveStatistics	(	DescriptiveStatistics	): Copy constructor. Construct a new DescriptiveStatistics instance that is a copy of original.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.DescriptiveStatistics	(	double[]	): Construct a DescriptiveStatistics instance with an infinite window and the initial data values in double[] initialDoubleArray. If initialDoubleArray is null, then this constructor corresponds to DescriptiveStatistics()
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.DescriptiveStatistics	(	int	): Construct a DescriptiveStatistics instance with the specified window.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.addValue	(	double	): Adds the value to the dataset. If the dataset is at the maximum size (i.e., the number of stored elements equals the currently configured windowSize), the first (oldest) element in the dataset is discarded to make room for the new value.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.apply	(	UnivariateStatistic	): Apply the given statistic to the data associated with this set of statistics.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.clear	(	): Resets all statistics and storage
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.copy	(	): Returns a copy of this DescriptiveStatistics instance with the same internal state.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.copy	(	DescriptiveStatistics	DescriptiveStatistics	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getElement	(	int	): Returns the element at the specified index
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getGeometricMean	(	): Returns the  geometric mean  of the available values.  See GeometricMean for details on the computing algorithm.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getGeometricMeanImpl	(	): Returns the currently configured geometric mean implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getKurtosis	(	): Returns the Kurtosis of the available values. Kurtosis is a measure of the "peakedness" of a distribution.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getKurtosisImpl	(	): Returns the currently configured kurtosis implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getMax	(	): Returns the maximum of the available values
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getMaxImpl	(	): Returns the currently configured maximum implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getMean	(	): Returns the  arithmetic mean  of the available values
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getMeanImpl	(	): Returns the currently configured mean implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getMin	(	): Returns the minimum of the available values
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getMinImpl	(	): Returns the currently configured minimum implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getPercentile	(	double	): Returns an estimate for the pth percentile of the stored values.  The implementation provided here follows the first estimation procedure presented here.  Preconditions: 0 < p ≤ 100 (otherwise an MathIllegalArgumentException is thrown) at least one value must be stored (returns Double.NaN  otherwise) 
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getPercentileImpl	(	): Returns the currently configured percentile implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getPopulationVariance	(	): Returns the  population variance of the available values.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getQuadraticMean	(	): Returns the quadratic mean, a.k.a.  root-mean-square of the available values
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSkewness	(	): Returns the skewness of the available values. Skewness is a measure of the asymmetry of a given distribution.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSkewnessImpl	(	): Returns the currently configured skewness implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSortedValues	(	): Returns the current set of values in an array of double primitives, sorted in ascending order. The returned array is a fresh copy of the underlying data -- i.e., it is not a reference to the stored data.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getStandardDeviation	(	): Returns the standard deviation of the available values.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSum	(	): Returns the sum of the values that have been added to Univariate.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSumImpl	(	): Returns the currently configured sum implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSumsq	(	): Returns the sum of the squares of the available values.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getSumsqImpl	(	): Returns the currently configured sum of squares implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getValues	(	): Returns the current set of values in an array of double primitives. The order of addition is preserved. The returned array is a fresh copy of the underlying data -- i.e., it is not a reference to the stored data.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getVariance	(	): Returns the (sample) variance of the available values. This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use getPopulationVariance() for the non-bias-corrected population variance.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getVarianceImpl	(	): Returns the currently configured variance implementation.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.getWindowSize	(	): Returns the maximum number of values that can be stored in the dataset, or INFINITE_WINDOW (-1) if there is no limit.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.removeMostRecentValue	(	): Removes the most recent value from the dataset.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.replaceMostRecentValue	(	double	): Replaces the most recently stored value with the given value. There must be at least one element stored to call this method.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setGeometricMeanImpl	(	UnivariateStatistic	): Sets the implementation for the geometric mean.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setKurtosisImpl	(	UnivariateStatistic	): Sets the implementation for the kurtosis.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setMaxImpl	(	UnivariateStatistic	): Sets the implementation for the maximum.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setMeanImpl	(	UnivariateStatistic	): Sets the implementation for the mean.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setMinImpl	(	UnivariateStatistic	): Sets the implementation for the minimum.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setPercentileImpl	(	UnivariateStatistic	): Sets the implementation to be used by getPercentile(). The supplied UnivariateStatistic must provide a setQuantile(double) method; otherwise IllegalArgumentException is thrown.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setSkewnessImpl	(	UnivariateStatistic	): Sets the implementation for the skewness.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setSumImpl	(	UnivariateStatistic	): Sets the implementation for the sum.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setSumsqImpl	(	UnivariateStatistic	): Sets the implementation for the sum of squares.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setVarianceImpl	(	UnivariateStatistic	): Sets the implementation for the variance.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.setWindowSize	(	int	): WindowSize controls the number of values that contribute to the reported statistics. For example, if windowSize is set to 3 and the values {1,2,3,4,5} have been added  in that order then the available values are {3,4,5} and all reported statistics will be based on these values. If windowSize is decreased as a result of this call and there are more than the new value of elements in the current dataset, values from the front of the array are discarded to reduce the dataset to windowSize elements.
org.apache.commons.math4.stat.descriptive.DescriptiveStatistics.toString	(	): Generates a text report displaying univariate statistics from values that have been added. Each statistic is displayed on a separate line.
org.apache.commons.math4.stat.descriptive.DescriptiveStatisticsTest: Test cases for the DescriptiveStatistics class.
org.apache.commons.math4.stat.descriptive.DescriptiveStatisticsTest.badPercentile: "Bad" test percentile implementation - no setQuantile
org.apache.commons.math4.stat.descriptive.DescriptiveStatisticsTest.deepMean: A new way to compute the mean
org.apache.commons.math4.stat.descriptive.DescriptiveStatisticsTest.goodPercentile: Test percentile implementation - wraps a Percentile
org.apache.commons.math4.stat.descriptive.DescriptiveStatisticsTest.subPercentile: Test percentile subclass - another "new math" impl Always returns currently set quantile
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.ListUnivariateImpl	(	): No argument Constructor
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.ListUnivariateImpl	(	List	): Construct a ListUnivariate with a specific List.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.ListUnivariateImpl	(	List	NumberTransformer	): Construct a ListUnivariate with a specific List.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.addObject	(	Object	): Adds an object to this list.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.addValue	(	double	): Adds the value to the dataset. If the dataset is at the maximum size (i.e., the number of stored elements equals the currently configured windowSize), the first (oldest) element in the dataset is discarded to make room for the new value. 
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.apply	(	UnivariateStatistic	): Apply the given statistic to this univariate collection.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.clear	(	): Clears all statistics.  N.B.:  This method has the side effect of clearing the underlying list.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.getElement	(	int	): Returns the element at the specified index 
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.getN	(	): Returns the number of available values 
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.getTransformer	(	): Access the number transformer.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.getValues	(	): Returns the current set of values in an array of double primitives. The order of addition is preserved. The returned array is a fresh copy of the underlying data -- i.e., it is not a reference to the stored data. 
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.setTransformer	(	NumberTransformer	): Modify the number transformer.
org.apache.commons.math4.stat.descriptive.ListUnivariateImpl.setWindowSize	(	int	): WindowSize controls the number of values that contribute to the reported statistics. For example, if windowSize is set to 3 and the values {1,2,3,4,5} have been added  in that order then the available values are {3,4,5} and all reported statistics will be based on these values. If windowSize is decreased as a result of this call and there are more than the new value of elements in the current dataset, values from the front of the array are discarded to reduce the dataset to windowSize elements. 
org.apache.commons.math4.stat.descriptive.ListUnivariateImplTest: Test cases for the ListUnivariateImpl class.
org.apache.commons.math4.stat.descriptive.ListUnivariateImplTest.testSerialization	(	): test stats 
org.apache.commons.math4.stat.descriptive.ListUnivariateImplTest.testStats	(	): test stats 
org.apache.commons.math4.stat.descriptive.MixedListUnivariateImplTest: Test cases for the ListUnivariateImpl class.
org.apache.commons.math4.stat.descriptive.MixedListUnivariateImplTest.testStats	(	): test stats 
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics: Computes summary statistics for a stream of n-tuples added using the addValue() method. The data values are not stored in memory, so this class can be used to compute statistics for very large n-tuple streams. The StorelessUnivariateStatistic instances used to maintain summary state and compute statistics are configurable via setters. For example, the default implementation for the mean can be overridden by calling setMeanImpl(). Actual parameters to these methods must implement the StorelessUnivariateStatistic interface and configuration must be completed before addValue is called. No configuration is necessary to use the default, commons-math provided implementations. To compute statistics for a stream of n-tuples, construct a MultivariateStatistics instance with dimension n and then use addValue() to add n-tuples. The getXxx methods where Xxx is a statistic return an array of double values, where for i = 0,...,n-1 the ith array element is the value of the given statistic for data range consisting of the ith element of each of the input n-tuples. For example, if addValue is called with actual parameters {0, 1, 2}, then {3, 4, 5} and finally {6, 7, 8}, getSum will return a three-element array with values {0+3+6, 1+4+7, 2+5+8} Note: This class is not thread-safe. Use SynchronizedMultivariateSummaryStatistics if concurrent access from multiple threads is required.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.MultivariateSummaryStatistics	(	int	boolean	): Construct a MultivariateSummaryStatistics instance
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.addValue	(	double[]	): Add an n-tuple to the data
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.append	(	StringBuilder	double[]	String	String	String	): Append a text representation of an array to a buffer.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.checkDimension	(	int	): Throws DimensionMismatchException if dimension != k.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.checkEmpty	(	): Throws MathIllegalStateException if the statistic is not empty.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.clear	(	): Resets all statistics and storage
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.equals	(	Object	): Returns true iff object is a MultivariateSummaryStatistics instance and all statistics have the same values as this.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getCovariance	(	): Returns the covariance matrix of the values that have been added.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getDimension	(	): Returns the dimension of the data
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getGeoMeanImpl	(	): Returns the currently configured geometric mean implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getGeometricMean	(	): Returns an array whose ith entry is the geometric mean of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getMax	(	): Returns an array whose ith entry is the maximum of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getMaxImpl	(	): Returns the currently configured maximum implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getMean	(	): Returns an array whose ith entry is the mean of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getMeanImpl	(	): Returns the currently configured mean implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getMin	(	): Returns an array whose ith entry is the minimum of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getMinImpl	(	): Returns the currently configured minimum implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getResults	(	StorelessUnivariateStatistic[]	): Returns an array of the results of a statistic.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getStandardDeviation	(	): Returns an array whose ith entry is the standard deviation of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getSum	(	): Returns an array whose ith entry is the sum of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getSumImpl	(	): Returns the currently configured Sum implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getSumLog	(	): Returns an array whose ith entry is the sum of logs of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getSumLogImpl	(	): Returns the currently configured sum of logs implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getSumSq	(	): Returns an array whose ith entry is the sum of squares of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.getSumsqImpl	(	): Returns the currently configured sum of squares implementation
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.hashCode	(	): Returns hash code based on values of statistics
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setGeoMeanImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the geometric mean. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setImpl	(	StorelessUnivariateStatistic[]	StorelessUnivariateStatistic[]	): Sets statistics implementations.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setMaxImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the maximum. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setMeanImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the mean. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setMinImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the minimum. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setSumImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the Sum. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setSumLogImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the sum of logs. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.setSumsqImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the sum of squares. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics.toString	(	): Generates a text report displaying summary statistics from values that have been added.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatisticsTest: Test cases for the MultivariateSummaryStatistics class.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatisticsTest.sumMean: Bogus mean implementation to test setter injection. Returns the sum instead of the mean.
org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatisticsTest.testStats	(	): test stats 
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary: Reporting interface for basic multivariate statistics.
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getCovariance	(	): Returns the covariance of the available values.
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getDimension	(	): Returns the dimension of the data
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getGeometricMean	(	): Returns an array whose ith entry is the geometric mean of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getMax	(	): Returns an array whose ith entry is the maximum of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getMean	(	): Returns an array whose ith entry is the mean of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getMin	(	): Returns an array whose ith entry is the minimum of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getStandardDeviation	(	): Returns an array whose ith entry is the standard deviation of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getSum	(	): Returns an array whose ith entry is the sum of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getSumLog	(	): Returns an array whose ith entry is the sum of logs of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalMultivariateSummary.getSumSq	(	): Returns an array whose ith entry is the sum of squares of the ith entries of the arrays that correspond to each multivariate sample
org.apache.commons.math4.stat.descriptive.StatisticalSummary: Reporting interface for basic univariate statistics.
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getMax	(	): Returns the maximum of the available values
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getMean	(	): Returns the  arithmetic mean  of the available values
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getMin	(	): Returns the minimum of the available values
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getStandardDeviation	(	): Returns the standard deviation of the available values.
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getSum	(	): Returns the sum of the values that have been added to Univariate.
org.apache.commons.math4.stat.descriptive.StatisticalSummary.getVariance	(	): Returns the variance of the available values.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues: Value object representing the results of a univariate statistical summary.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.StatisticalSummaryValues	(	double	double	long	double	double	double	): Constructor
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.equals	(	Object	): Returns true iff object is a StatisticalSummaryValues instance and all statistics have the same values as this.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getMax	(	): Returns the maximum of the available values
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getMean	(	): Returns the  arithmetic mean  of the available values
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getMin	(	): Returns the minimum of the available values
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getStandardDeviation	(	): Returns the standard deviation of the available values.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getSum	(	): Returns the sum of the values that have been added to Univariate.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.getVariance	(	): Returns the variance of the available values.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.hashCode	(	): Returns hash code based on values of statistics
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValues.toString	(	): Generates a text report displaying values of statistics. Each statistic is displayed on a separate line.
org.apache.commons.math4.stat.descriptive.StatisticalSummaryValuesTest: Test cases for the StatisticalSummaryValues class.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic: Extends the definition of UnivariateStatistic with increment and incrementAll() methods for adding values and updating internal state.  This interface is designed to be used for calculating statistics that can be computed in one pass through the data without storing the full array of sample values.  Note: unless otherwise stated, the evaluate() and evaluate() methods do NOT alter the internal state of the respective statistic.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.incrementAll	(	double[]	): Updates the internal state of the statistic to reflect addition of all values in the values array. Does not clear the statistic first -- i.e., the values are added incrementally to the dataset.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatistic.incrementAll	(	double[]	int	int	): Updates the internal state of the statistic to reflect addition of the values in the designated portion of the values array. Does not clear the statistic first -- i.e., the values are added incrementally to the dataset.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest: Test cases for StorelessUnivariateStatistic classes.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest.testConsistency	(	): Make sure that evaluate(double[]) and inrementAll(double[]), getResult() give same results.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest.testCopyConsistency	(	): Verifies that copied statistics remain equal to originals when incremented the same way.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest.testEvaluateInternalState	(	): Make sure that evaluate(double[]) does not alter the internal state.
org.apache.commons.math4.stat.descriptive.StorelessUnivariateStatisticAbstractTest.testIncrementation	(	): Verifies that increment() and incrementAll work properly.
org.apache.commons.math4.stat.descriptive.SummaryStatistics:  Computes summary statistics for a stream of data values added using the addValue() method. The data values are not stored in memory, so this class can be used to compute statistics for very large data streams.   The StorelessUnivariateStatistic instances used to maintain summary state and compute statistics are configurable via setters. For example, the default implementation for the variance can be overridden by calling setVarianceImpl(). Actual parameters to these methods must implement the StorelessUnivariateStatistic interface and configuration must be completed before addValue is called. No configuration is necessary to use the default, commons-math provided implementations.   Note: This class is not thread-safe. Use SynchronizedSummaryStatistics if concurrent access from multiple threads is required. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.SummaryStatistics	(	): Construct a SummaryStatistics instance
org.apache.commons.math4.stat.descriptive.SummaryStatistics.SummaryStatistics	(	SummaryStatistics	): A copy constructor. Creates a deep-copy of the original.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.addValue	(	double	): Add a value to the data
org.apache.commons.math4.stat.descriptive.SummaryStatistics.checkEmpty	(	): Throws IllegalStateException if n > 0.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.clear	(	): Resets all statistics and storage
org.apache.commons.math4.stat.descriptive.SummaryStatistics.copy	(	): Returns a copy of this SummaryStatistics instance with the same internal state.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.copy	(	SummaryStatistics	SummaryStatistics	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.equals	(	Object	): Returns true iff object is a SummaryStatistics instance and all statistics have the same values as this.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getGeoMeanImpl	(	): Returns the currently configured geometric mean implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getGeometricMean	(	): Returns the geometric mean of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getMax	(	): Returns the maximum of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getMaxImpl	(	): Returns the currently configured maximum implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getMean	(	): Returns the mean of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getMeanImpl	(	): Returns the currently configured mean implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getMin	(	): Returns the minimum of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getMinImpl	(	): Returns the currently configured minimum implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getPopulationVariance	(	): Returns the  population variance of the values that have been added. Double.NaN is returned if no values have been added.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getQuadraticMean	(	): Returns the quadratic mean, a.k.a.  root-mean-square of the available values
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSecondMoment	(	): Returns a statistic related to the Second Central Moment. Specifically, what is returned is the sum of squared deviations from the sample mean among the values that have been added.  Returns Double.NaN if no data values have been added and returns 0 if there is just one value in the data set. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getStandardDeviation	(	): Returns the standard deviation of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSum	(	): Returns the sum of the values that have been added
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSumImpl	(	): Returns the currently configured Sum implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSumLogImpl	(	): Returns the currently configured sum of logs implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSumOfLogs	(	): Returns the sum of the logs of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSummary	(	): Return a StatisticalSummaryValues instance reporting current statistics.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSumsq	(	): Returns the sum of the squares of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getSumsqImpl	(	): Returns the currently configured sum of squares implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getVariance	(	): Returns the (sample) variance of the available values. This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use getPopulationVariance() for the non-bias-corrected population variance. Double.NaN is returned if no values have been added.
org.apache.commons.math4.stat.descriptive.SummaryStatistics.getVarianceImpl	(	): Returns the currently configured variance implementation
org.apache.commons.math4.stat.descriptive.SummaryStatistics.hashCode	(	): Returns hash code based on values of statistics
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setGeoMeanImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the geometric mean.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setMaxImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the maximum.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setMeanImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the mean.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setMinImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the minimum.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setSumImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the Sum.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setSumLogImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the sum of logs.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setSumsqImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the sum of squares.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.setVarianceImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the variance.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SummaryStatistics.toString	(	): Generates a text report displaying summary statistics from values that have been added.
org.apache.commons.math4.stat.descriptive.SummaryStatisticsTest: Test cases for the SummaryStatistics class.
org.apache.commons.math4.stat.descriptive.SummaryStatisticsTest.testOverrideVarianceWithMathClass	(	): JIRA: MATH-691
org.apache.commons.math4.stat.descriptive.SummaryStatisticsTest.testStats	(	): test stats 
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics: Implementation of org.apache.commons.math4.stat.descriptive.DescriptiveStatistics that is safe to use in a multithreaded environment. Multiple threads can safely operate on a single instance without causing runtime exceptions due to race conditions. In effect, this implementation makes modification and access methods atomic operations for a single instance. That is to say, as one thread is computing a statistic from the instance, no other thread can modify the instance nor compute another statistic.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.SynchronizedDescriptiveStatistics	(	): Construct an instance with infinite window
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.SynchronizedDescriptiveStatistics	(	SynchronizedDescriptiveStatistics	): A copy constructor. Creates a deep-copy of the original.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.SynchronizedDescriptiveStatistics	(	int	): Construct an instance with finite window
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.addValue	(	double	): Adds the value to the dataset. If the dataset is at the maximum size (i.e., the number of stored elements equals the currently configured windowSize), the first (oldest) element in the dataset is discarded to make room for the new value.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.apply	(	UnivariateStatistic	): Apply the given statistic to the data associated with this set of statistics.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.clear	(	): Resets all statistics and storage
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.copy	(	): Returns a copy of this SynchronizedDescriptiveStatistics instance with the same internal state.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.copy	(	SynchronizedDescriptiveStatistics	SynchronizedDescriptiveStatistics	): Copies source to dest. Neither source nor dest can be null. Acquires synchronization lock on source, then dest before copying.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.getElement	(	int	): Returns the element at the specified index
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.getQuadraticMean	(	): Returns the quadratic mean, a.k.a.  root-mean-square of the available values
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.getStandardDeviation	(	): Returns the standard deviation of the available values.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.getValues	(	): Returns the current set of values in an array of double primitives. The order of addition is preserved. The returned array is a fresh copy of the underlying data -- i.e., it is not a reference to the stored data.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.getWindowSize	(	): Returns the maximum number of values that can be stored in the dataset, or INFINITE_WINDOW (-1) if there is no limit.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.setWindowSize	(	int	): WindowSize controls the number of values that contribute to the reported statistics. For example, if windowSize is set to 3 and the values {1,2,3,4,5} have been added  in that order then the available values are {3,4,5} and all reported statistics will be based on these values. If windowSize is decreased as a result of this call and there are more than the new value of elements in the current dataset, values from the front of the array are discarded to reduce the dataset to windowSize elements.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatistics.toString	(	): Generates a text report displaying univariate statistics from values that have been added. Each statistic is displayed on a separate line.
org.apache.commons.math4.stat.descriptive.SynchronizedDescriptiveStatisticsTest: Test cases for the SynchronizedDescriptiveStatisticsTest class. 2007) $
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics: Implementation of org.apache.commons.math4.stat.descriptive.MultivariateSummaryStatistics that is safe to use in a multithreaded environment. Multiple threads can safely operate on a single instance without causing runtime exceptions due to race conditions. In effect, this implementation makes modification and access methods atomic operations for a single instance. That is to say, as one thread is computing a statistic from the instance, no other thread can modify the instance nor compute another statistic.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.SynchronizedMultivariateSummaryStatistics	(	int	boolean	): Construct a SynchronizedMultivariateSummaryStatistics instance
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.addValue	(	double[]	): Add an n-tuple to the data
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.clear	(	): Resets all statistics and storage
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.equals	(	Object	): Returns true iff object is a MultivariateSummaryStatistics instance and all statistics have the same values as this.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getCovariance	(	): Returns the covariance matrix of the values that have been added.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getDimension	(	): Returns the dimension of the data
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getGeoMeanImpl	(	): Returns the currently configured geometric mean implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getGeometricMean	(	): Returns an array whose ith entry is the geometric mean of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getMax	(	): Returns an array whose ith entry is the maximum of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getMaxImpl	(	): Returns the currently configured maximum implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getMean	(	): Returns an array whose ith entry is the mean of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getMeanImpl	(	): Returns the currently configured mean implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getMin	(	): Returns an array whose ith entry is the minimum of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getMinImpl	(	): Returns the currently configured minimum implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getStandardDeviation	(	): Returns an array whose ith entry is the standard deviation of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getSum	(	): Returns an array whose ith entry is the sum of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getSumImpl	(	): Returns the currently configured Sum implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getSumLog	(	): Returns an array whose ith entry is the sum of logs of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getSumLogImpl	(	): Returns the currently configured sum of logs implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getSumSq	(	): Returns an array whose ith entry is the sum of squares of the ith entries of the arrays that have been added using addValue()
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.getSumsqImpl	(	): Returns the currently configured sum of squares implementation
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.hashCode	(	): Returns hash code based on values of statistics
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setGeoMeanImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the geometric mean. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setMaxImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the maximum. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setMeanImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the mean. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setMinImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the minimum. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setSumImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the Sum. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setSumLogImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the sum of logs. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.setSumsqImpl	(	StorelessUnivariateStatistic[]	): Sets the implementation for the sum of squares. This method must be activated before any data has been added - i.e., before addValue() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatistics.toString	(	): Generates a text report displaying summary statistics from values that have been added.
org.apache.commons.math4.stat.descriptive.SynchronizedMultivariateSummaryStatisticsTest: Test cases for the SynchronizedMultivariateSummaryStatisticsTest class. 2007) $
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics: Implementation of org.apache.commons.math4.stat.descriptive.SummaryStatistics that is safe to use in a multithreaded environment. Multiple threads can safely operate on a single instance without causing runtime exceptions due to race conditions. In effect, this implementation makes modification and access methods atomic operations for a single instance. That is to say, as one thread is computing a statistic from the instance, no other thread can modify the instance nor compute another statistic.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.SynchronizedSummaryStatistics	(	): Construct a SynchronizedSummaryStatistics instance
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.SynchronizedSummaryStatistics	(	SynchronizedSummaryStatistics	): A copy constructor. Creates a deep-copy of the original.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.addValue	(	double	): Add a value to the data
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.clear	(	): Resets all statistics and storage
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.copy	(	): Returns a copy of this SynchronizedSummaryStatistics instance with the same internal state.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.copy	(	SynchronizedSummaryStatistics	SynchronizedSummaryStatistics	): Copies source to dest. Neither source nor dest can be null. Acquires synchronization lock on source, then dest before copying.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.equals	(	Object	): Returns true iff object is a SummaryStatistics instance and all statistics have the same values as this.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getGeoMeanImpl	(	): Returns the currently configured geometric mean implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getGeometricMean	(	): Returns the geometric mean of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getMax	(	): Returns the maximum of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getMaxImpl	(	): Returns the currently configured maximum implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getMean	(	): Returns the mean of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getMeanImpl	(	): Returns the currently configured mean implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getMin	(	): Returns the minimum of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getMinImpl	(	): Returns the currently configured minimum implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getN	(	): Returns the number of available values
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getPopulationVariance	(	): Returns the  population variance of the values that have been added. Double.NaN is returned if no values have been added.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getQuadraticMean	(	): Returns the quadratic mean, a.k.a.  root-mean-square of the available values
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getStandardDeviation	(	): Returns the standard deviation of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getSum	(	): Returns the sum of the values that have been added
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getSumImpl	(	): Returns the currently configured Sum implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getSumLogImpl	(	): Returns the currently configured sum of logs implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getSummary	(	): Return a StatisticalSummaryValues instance reporting current statistics.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getSumsq	(	): Returns the sum of the squares of the values that have been added.  Double.NaN is returned if no values have been added. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getSumsqImpl	(	): Returns the currently configured sum of squares implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getVariance	(	): Returns the (sample) variance of the available values. This method returns the bias-corrected sample variance (using n - 1 in the denominator). Use getPopulationVariance() for the non-bias-corrected population variance. Double.NaN is returned if no values have been added.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.getVarianceImpl	(	): Returns the currently configured variance implementation
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.hashCode	(	): Returns hash code based on values of statistics
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setGeoMeanImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the geometric mean.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setMaxImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the maximum.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setMeanImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the mean.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setMinImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the minimum.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setSumImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the Sum.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setSumLogImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the sum of logs.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setSumsqImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the sum of squares.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.setVarianceImpl	(	StorelessUnivariateStatistic	):  Sets the implementation for the variance.   This method cannot be activated after data has been added - i.e., after addValue() has been used to add data. If it is activated after data has been added, an IllegalStateException will be thrown. 
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatistics.toString	(	): Generates a text report displaying summary statistics from values that have been added.
org.apache.commons.math4.stat.descriptive.SynchronizedSummaryStatisticsTest: Test cases for the SynchronizedSummaryStatisticsTest class. 2007) $
org.apache.commons.math4.stat.descriptive.UnivariateStatistic: Base interface implemented by all statistics.
org.apache.commons.math4.stat.descriptive.UnivariateStatistic.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.UnivariateStatistic.evaluate	(	double[]	): Returns the result of evaluating the statistic over the input array.
org.apache.commons.math4.stat.descriptive.UnivariateStatistic.evaluate	(	double[]	int	int	): Returns the result of evaluating the statistic over the specified entries in the input array.
org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest.testWeightedConsistency	(	): Tests consistency of weighted statistic computation. For statistics that support weighted evaluation, this test case compares the result of direct computation on an array with repeated values with a weighted computation on the corresponding (shorter) array with each value appearing only once but with a weight value equal to its multiplicity in the repeating array.
org.apache.commons.math4.stat.descriptive.WeightedEvaluation: Weighted evaluation for statistics.
org.apache.commons.math4.stat.descriptive.WeightedEvaluation.evaluate	(	double[]	double[]	): Returns the result of evaluating the statistic over the input array, using the supplied weights.
org.apache.commons.math4.stat.descriptive.WeightedEvaluation.evaluate	(	double[]	double[]	int	int	): Returns the result of evaluating the statistic over the specified entries in the input array, using corresponding entries in the supplied weights array.
org.apache.commons.math4.stat.descriptive.moment.FirstMoment: Computes the first moment (arithmetic mean). Uses the definitional formula:  mean = sum(x_i) / n   where n is the number of observations.   To limit numeric errors, the value of the statistic is computed using the following recursive updating algorithm:   Initialize m =  the first value For each additional value, update using  m = m + (new value - m) / (number of observations)   Returns Double.NaN if the dataset is empty. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.FirstMoment	(	): Create a FirstMoment instance
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.FirstMoment	(	FirstMoment	): Copy constructor, creates a new FirstMoment identical to the original
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.copy	(	FirstMoment	FirstMoment	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.FirstMoment.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.moment.FirstMomentTest: Test cases for the FirstMoment class.
org.apache.commons.math4.stat.descriptive.moment.FirstMomentTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.FirstMomentTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.FirstMomentTest.testSpecialValues	(	): Added in an attempt to resolve MATH-1146 Commented out tests that won't pass with the current implementation.
org.apache.commons.math4.stat.descriptive.moment.FourthMoment: Computes a statistic related to the Fourth Central Moment. Specifically, what is computed is the sum of  (x_i - xbar) ^ 4,   where the x_i are the sample observations and xbar is the sample mean.   The following recursive updating formula is used:   Let   dev = (current obs - previous mean)   m2 = previous value of SecondMoment   m2 = previous value of ThirdMoment   n = number of observations (including current obs)   Then  new value = old value - 4 * (dev/n) * m3 + 6 * (dev/n)^2 * m2 +  [n^2 - 3 * (n-1)] * dev^4 * (n-1) / n^3   Returns Double.NaN if no data values have been added and returns 0 if there is just one value in the data set. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally. 
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.FourthMoment	(	): Create a FourthMoment instance
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.FourthMoment	(	FourthMoment	): Copy constructor, creates a new FourthMoment identical to the original.
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.copy	(	FourthMoment	FourthMoment	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.FourthMoment.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.moment.FourthMomentTest: Test cases for the FourthMoment class.
org.apache.commons.math4.stat.descriptive.moment.FourthMomentTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.FourthMomentTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.GeometricMean: Returns the  geometric mean  of the available values.  Uses a SumOfLogs instance to compute sum of logs and returns  exp( 1/n (sum of logs) ). Therefore,   If any of values are < 0, the result is NaN. If all values are non-negative and less than Double.POSITIVE_INFINITY, but at least one value is 0, the result is 0. If both Double.POSITIVE_INFINITY and Double.NEGATIVE_INFINITY are among the values, the result is NaN.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.GeometricMean	(	): Create a GeometricMean instance.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.GeometricMean	(	GeometricMean	): Copy constructor, creates a new GeometricMean identical to the original.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.GeometricMean	(	SumOfLogs	): Create a GeometricMean instance using the given SumOfLogs instance
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.checkEmpty	(	): Throws MathIllegalStateException if n > 0.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.copy	(	GeometricMean	GeometricMean	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.evaluate	(	double[]	int	int	): Returns the geometric mean of the entries in the specified portion of the input array.  See GeometricMean for details on the computing algorithm.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.getSumLogImpl	(	): Returns the currently configured sum of logs implementation.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.moment.GeometricMean.setSumLogImpl	(	StorelessUnivariateStatistic	): Sets the implementation for the sum of logs. This method must be activated before any data has been added - i.e., before increment() has been used to add data; otherwise an IllegalStateException will be thrown.
org.apache.commons.math4.stat.descriptive.moment.GeometricMeanTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.moment.GeometricMeanTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.GeometricMeanTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.Kurtosis: Computes the Kurtosis of the available values.  We use the following (unbiased) formula to define kurtosis:  kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)]  where n is the number of values, mean is the Mean and std is the StandardDeviation  Note that this statistic is undefined for n < 4. Double.Nan is returned when there is not sufficient data to compute the statistic. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.Kurtosis	(	): Construct a Kurtosis.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.Kurtosis	(	FourthMoment	): Construct a Kurtosis from an external moment.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.Kurtosis	(	Kurtosis	): Copy constructor, creates a new Kurtosis identical to the original.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.copy	(	Kurtosis	Kurtosis	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.evaluate	(	double[]	int	int	): Returns the kurtosis of the entries in the specified portion of the input array.  See Kurtosis for details on the computing algorithm.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.Kurtosis.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value. Note that when Kurtosis() is used to create a Variance, this method does nothing. In that case, the FourthMoment should be incremented directly.
org.apache.commons.math4.stat.descriptive.moment.KurtosisTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.moment.KurtosisTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.KurtosisTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.KurtosisTest.testNaN	(	): Make sure Double.NaN is returned iff n < 4
org.apache.commons.math4.stat.descriptive.moment.Mean: Computes the arithmetic mean of a set of values. Uses the definitional formula:  mean = sum(x_i) / n  where n is the number of observations.  When increment() is used to add data incrementally from a stream of (unstored) values, the value of the statistic that getResult() returns is computed using the following recursive updating algorithm:   Initialize m =  the first value For each additional value, update using  m = m + (new value - m) / (number of observations)   If evaluate() is used to compute the mean of an array of stored values, a two-pass, corrected algorithm is used, starting with the definitional formula computed using the array of stored values and then correcting this by adding the mean deviation of the data values from the arithmetic mean. See, e.g. "Comparison of Several Algorithms for Computing Sample Means and Variances," Robert F. Ling, Journal of the American Statistical Association, Vol. 69, No. 348 (Dec., 1974), pp. 859-866.   Returns Double.NaN if the dataset is empty. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.Mean.Mean	(	): Constructs a Mean. 
org.apache.commons.math4.stat.descriptive.moment.Mean.Mean	(	FirstMoment	): Constructs a Mean with an External Moment.
org.apache.commons.math4.stat.descriptive.moment.Mean.Mean	(	Mean	): Copy constructor, creates a new Mean identical to the original.
org.apache.commons.math4.stat.descriptive.moment.Mean.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.Mean.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.Mean.copy	(	Mean	Mean	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.Mean.evaluate	(	double[]	double[]	): Returns the weighted arithmetic mean of the entries in the input array.  Throws MathIllegalArgumentException if either array is null.  See Mean for details on the computing algorithm. The two-pass algorithm described above is used here, with weights applied in computing both the original estimate and the correction factor.  Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values 
org.apache.commons.math4.stat.descriptive.moment.Mean.evaluate	(	double[]	double[]	int	int	): Returns the weighted arithmetic mean of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if either array is null.  See Mean for details on the computing algorithm. The two-pass algorithm described above is used here, with weights applied in computing both the original estimate and the correction factor.  Throws IllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array 
org.apache.commons.math4.stat.descriptive.moment.Mean.evaluate	(	double[]	int	int	): Returns the arithmetic mean of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws IllegalArgumentException if the array is null.  See Mean for details on the computing algorithm.
org.apache.commons.math4.stat.descriptive.moment.Mean.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.Mean.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.Mean.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value. Note that when Mean() is used to create a Mean, this method does nothing. In that case, the FirstMoment should be incremented directly.
org.apache.commons.math4.stat.descriptive.moment.MeanTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.moment.MeanTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.MeanTest.expectedWeightedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.MeanTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.SecondMoment: Computes a statistic related to the Second Central Moment. Specifically, what is computed is the sum of squared deviations from the sample mean.  The following recursive updating formula is used:  Let   dev = (current obs - previous mean)   n = number of observations (including current obs)   Then  new value = old value + dev^2 * (n -1) / n.  Returns Double.NaN if no data values have been added and returns 0 if there is just one value in the data set. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.SecondMoment	(	): Create a SecondMoment instance.
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.SecondMoment	(	SecondMoment	): Copy constructor, creates a new SecondMoment identical to the original.
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.copy	(	SecondMoment	SecondMoment	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.SecondMoment.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.moment.SecondMomentTest: Test cases for the SecondMoment class.
org.apache.commons.math4.stat.descriptive.moment.SecondMomentTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.SecondMomentTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.SemiVariance: Computes the semivariance of a set of values with respect to a given cutoff value. We define the downside semivariance of a set of values x against the cutoff value cutoff to be  Σ (x[i] - target)2 / df  where the sum is taken over all i such that x[i] < cutoff and df is the length of x (non-bias-corrected) or one less than this number (bias corrected). The upside semivariance is defined similarly, with the sum taken over values of x that exceed the cutoff value. The cutoff value defaults to the mean, bias correction defaults to true and the "variance direction" (upside or downside) defaults to downside. The variance direction and bias correction may be set using property setters or their values can provided as parameters to evaluate(). If the input array is null, evaluate methods throw IllegalArgumentException. If the array has length 1, 0 is returned, regardless of the value of the cutoff. Note that this class is not intended to be threadsafe. If multiple threads access an instance of this class concurrently, and one or more of these threads invoke property setters, external synchronization must be provided to ensure correct results.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.SemiVariance	(	): Constructs a SemiVariance with default (true) biasCorrected property and default (Downside) varianceDirection property.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.SemiVariance	(	Direction	): Constructs a SemiVariance with the specified Direction property and default (true) biasCorrected property
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.SemiVariance	(	SemiVariance	): Copy constructor, creates a new SemiVariance identical to the original.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.SemiVariance	(	boolean	): Constructs a SemiVariance with the specified biasCorrected property and default (Downside) varianceDirection property.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.SemiVariance	(	boolean	Direction	): Constructs a SemiVariance with the specified isBiasCorrected property and the specified Direction property.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.copy	(	SemiVariance	SemiVariance	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.evaluate	(	double[]	Direction	): This method calculates SemiVariance for the entire array against the mean, using the current value of the biasCorrection instance property.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.evaluate	(	double[]	double	): Returns the SemiVariance of the designated values against the cutoff, using instance properties variancDirection and biasCorrection. Returns NaN if the array is empty and throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.evaluate	(	double[]	double	Direction	): Returns the SemiVariance of the designated values against the cutoff in the given direction, using the current value of the biasCorrection instance property. Returns NaN if the array is empty and throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.evaluate	(	double[]	double	Direction	boolean	int	int	): Returns the SemiVariance of the designated values against the cutoff in the given direction with the provided bias correction. Returns NaN if the array is empty and throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.evaluate	(	double[]	int	int	): Returns the SemiVariance of the designated values against the mean, using instance properties varianceDirection and biasCorrection. Returns NaN if the array is empty and throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.getVarianceDirection	(	): Returns the varianceDirection property.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.isBiasCorrected	(	): Returns true iff biasCorrected property is set to true.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.setBiasCorrected	(	boolean	): Sets the biasCorrected property.
org.apache.commons.math4.stat.descriptive.moment.SemiVariance.setVarianceDirection	(	Direction	): Sets the variance direction
org.apache.commons.math4.stat.descriptive.moment.SemiVarianceTest.testVarianceDecompMeanCutoff	(	): Check that the lower + upper semivariance against the mean sum to the variance.
org.apache.commons.math4.stat.descriptive.moment.SemiVarianceTest.testVarianceDecompNonMeanCutoff	(	): Check that upper and lower semivariances against a cutoff sum to the sum of squared deviations of the full set of values against the cutoff divided by df = length - 1 (assuming bias-corrected).
org.apache.commons.math4.stat.descriptive.moment.Skewness: Computes the skewness of the available values.  We use the following (unbiased) formula to define skewness:  skewness = [n / (n -1) (n - 2)] sum[(x_i - mean)^3] / std^3   where n is the number of values, mean is the Mean and std is the StandardDeviation   Note that this statistic is undefined for n < 3. Double.Nan is returned when there is not sufficient data to compute the statistic. Double.NaN may also be returned if the input includes NaN and / or infinite values.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally. 
org.apache.commons.math4.stat.descriptive.moment.Skewness.Skewness	(	): Constructs a Skewness.
org.apache.commons.math4.stat.descriptive.moment.Skewness.Skewness	(	Skewness	): Copy constructor, creates a new Skewness identical to the original.
org.apache.commons.math4.stat.descriptive.moment.Skewness.Skewness	(	ThirdMoment	): Constructs a Skewness with an external moment.
org.apache.commons.math4.stat.descriptive.moment.Skewness.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.Skewness.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.Skewness.copy	(	Skewness	Skewness	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.Skewness.evaluate	(	double[]	int	int	): Returns the Skewness of the entries in the specified portion of the input array.  See Skewness for the definition used in the computation.  Throws IllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.Skewness.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.Skewness.getResult	(	): Returns the value of the statistic based on the values that have been added.  See Skewness for the definition used in the computation.
org.apache.commons.math4.stat.descriptive.moment.Skewness.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value. Note that when Skewness() is used to create a Skewness, this method does nothing. In that case, the ThirdMoment should be incremented directly.
org.apache.commons.math4.stat.descriptive.moment.SkewnessTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.moment.SkewnessTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.SkewnessTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.SkewnessTest.testNaN	(	): Make sure Double.NaN is returned iff n < 3
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation: Computes the sample standard deviation. The standard deviation is the positive square root of the variance. This implementation wraps a Variance instance. The isBiasCorrected property of the wrapped Variance instance is exposed, so that this class can be used to compute both the "sample standard deviation" (the square root of the bias-corrected "sample variance") or the "population standard deviation" (the square root of the non-bias-corrected "population variance"). See Variance for more information.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.StandardDeviation	(	): Constructs a StandardDeviation. Sets the underlying Variance instance's isBiasCorrected property to true.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.StandardDeviation	(	SecondMoment	): Constructs a StandardDeviation from an external second moment.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.StandardDeviation	(	StandardDeviation	): Copy constructor, creates a new StandardDeviation identical to the original.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.StandardDeviation	(	boolean	): Constructs a StandardDeviation with the specified value for the isBiasCorrected property. If this property is set to true, the Variance used in computing results will use the bias-corrected, or "sample" formula. See Variance for details.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.StandardDeviation	(	boolean	SecondMoment	): Constructs a StandardDeviation with the specified value for the isBiasCorrected property and the supplied external moment. If isBiasCorrected is set to true, the Variance used in computing results will use the bias-corrected, or "sample" formula. See Variance for details.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.copy	(	StandardDeviation	StandardDeviation	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.evaluate	(	double[]	): Returns the Standard Deviation of the entries in the input array, or Double.NaN if the array is empty.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.evaluate	(	double[]	double	): Returns the Standard Deviation of the entries in the input array, using the precomputed mean value. Returns Double.NaN if the designated subarray is empty.  Returns 0 for a single-value (i.e. length = 1) sample.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Throws MathIllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.evaluate	(	double[]	double	int	int	): Returns the Standard Deviation of the entries in the specified portion of the input array, using the precomputed mean value. Returns Double.NaN if the designated subarray is empty.  Returns 0 for a single-value (i.e. length = 1) sample.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Throws IllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.evaluate	(	double[]	int	int	): Returns the Standard Deviation of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Returns 0 for a single-value (i.e. length = 1) sample.   Throws MathIllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.isBiasCorrected	(	): 
org.apache.commons.math4.stat.descriptive.moment.StandardDeviation.setBiasCorrected	(	boolean	): 
org.apache.commons.math4.stat.descriptive.moment.StandardDeviationTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.moment.StandardDeviationTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.StandardDeviationTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.StandardDeviationTest.populationStandardDeviation	(	double[]	): Definitional formula for population standard deviation
org.apache.commons.math4.stat.descriptive.moment.StandardDeviationTest.testNaN	(	): Make sure Double.NaN is returned iff n = 0
org.apache.commons.math4.stat.descriptive.moment.StandardDeviationTest.testPopulation	(	): Test population version of variance
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment: Computes a statistic related to the Third Central Moment. Specifically, what is computed is the sum of cubed deviations from the sample mean.  The following recursive updating formula is used:  Let   dev = (current obs - previous mean)   m2 = previous value of SecondMoment   n = number of observations (including current obs)   Then  new value = old value - 3 * (dev/n) * m2 + (n-1) * (n -2) * (dev^3/n^2)  Returns Double.NaN if no data values have been added and returns 0 if there is just one value in the data set. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.ThirdMoment	(	): Create a FourthMoment instance.
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.ThirdMoment	(	ThirdMoment	): Copy constructor, creates a new ThirdMoment identical to the original.
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.copy	(	ThirdMoment	ThirdMoment	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.ThirdMoment.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.moment.ThirdMomentTest: Test cases for the ThirdMoment class.
org.apache.commons.math4.stat.descriptive.moment.ThirdMomentTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.ThirdMomentTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.Variance: Computes the variance of the available values. By default, the unbiased "sample variance" definitional formula is used:  variance = sum((x_i - mean)^2) / (n - 1)   where mean is the Mean and n is the number of sample observations.  The definitional formula does not have good numerical properties, so this implementation does not compute the statistic using the definitional formula.   The getResult method computes the variance using updating formulas based on West's algorithm, as described in  Chan, T. F. and J. G. Lewis 1979, Communications of the ACM, vol. 22 no. 9, pp. 526-531.  The evaluate methods leverage the fact that they have the full array of values in memory to execute a two-pass algorithm. Specifically, these methods use the "corrected two-pass algorithm" from Chan, Golub, Levesque, Algorithms for Computing the Sample Variance, American Statistician, vol. 37, no. 3 (1983) pp. 242-247. Note that adding values using increment or incrementAll and then executing getResult will sometimes give a different, less accurate, result than executing evaluate with the full array of values. The former approach should only be used when the full array of values is not available.  The "population variance" ( sum((x_i - mean)^2) / n ) can also be computed using this statistic. The isBiasCorrected property determines whether the "population" or "sample" value is returned by the evaluate and getResult methods. To compute population variances, set this property to false.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.moment.Variance.Variance	(	): Constructs a Variance with default (true) isBiasCorrected property.
org.apache.commons.math4.stat.descriptive.moment.Variance.Variance	(	SecondMoment	): Constructs a Variance based on an external second moment.  When this constructor is used, the statistic may only be incremented via the moment, i.e., increment() does nothing; whereas m2.increment(value) increments both m2 and the Variance instance constructed from it.
org.apache.commons.math4.stat.descriptive.moment.Variance.Variance	(	Variance	): Copy constructor, creates a new Variance identical to the original.
org.apache.commons.math4.stat.descriptive.moment.Variance.Variance	(	boolean	): Constructs a Variance with the specified isBiasCorrected property.
org.apache.commons.math4.stat.descriptive.moment.Variance.Variance	(	boolean	SecondMoment	): Constructs a Variance with the specified isBiasCorrected property and the supplied external second moment.
org.apache.commons.math4.stat.descriptive.moment.Variance.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.Variance.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.moment.Variance.copy	(	Variance	Variance	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	): Returns the variance of the entries in the input array, or Double.NaN if the array is empty.  See Variance for details on the computing algorithm.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	double	): Returns the variance of the entries in the input array, using the precomputed mean value. Returns Double.NaN if the array is empty.  See Variance for details on the computing algorithm.  If isBiasCorrected is true the formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. If the mean is a known population parameter, or if the "population" version of the variance is desired, set isBiasCorrected to false before invoking this method.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	double	int	int	): Returns the variance of the entries in the specified portion of the input array, using the precomputed mean value. Returns Double.NaN if the designated subarray is empty.  See Variance for details on the computing algorithm.  The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if the array is null.  Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	double[]	):  Returns the weighted variance of the entries in the the input array.  Uses the formula  Σ(weights[i]*(values[i] - weightedMean)2)/(Σ(weights[i]) - 1)  where weightedMean is the weighted mean  This formula will not return the same result as the unweighted variance when all weights are equal, unless all weights are equal to 1. The formula assumes that weights are to be treated as "expansion values," as will be the case if for example the weights represent frequency counts. To normalize weights so that the denominator in the variance computation equals the length of the input vector minus one, use  evaluate(values, MathArrays.normalizeArray(weights, values.length));    Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values   Does not change the internal state of the statistic.  Throws MathIllegalArgumentException if either array is null.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	double[]	double	): Returns the weighted variance of the values in the input array, using the precomputed weighted mean value.  Uses the formula  Σ(weights[i]*(values[i] - mean)2)/(Σ(weights[i]) - 1)   The formula used assumes that the supplied mean value is the weighted arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  This formula will not return the same result as the unweighted variance when all weights are equal, unless all weights are equal to 1. The formula assumes that weights are to be treated as "expansion values," as will be the case if for example the weights represent frequency counts. To normalize weights so that the denominator in the variance computation equals the length of the input vector minus one, use  evaluate(values, MathArrays.normalizeArray(weights, values.length), mean);    Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values   Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	double[]	double	int	int	): Returns the weighted variance of the entries in the specified portion of the input array, using the precomputed weighted mean value. Returns Double.NaN if the designated subarray is empty.  Uses the formula  Σ(weights[i]*(values[i] - mean)2)/(Σ(weights[i]) - 1)   The formula used assumes that the supplied mean value is the weighted arithmetic mean of the sample data, not a known population parameter. This method is supplied only to save computation when the mean has already been computed.  This formula will not return the same result as the unweighted variance when all weights are equal, unless all weights are equal to 1. The formula assumes that weights are to be treated as "expansion values," as will be the case if for example the weights represent frequency counts. To normalize weights so that the denominator in the variance computation equals the length of the input vector minus one, use  evaluate(values, MathArrays.normalizeArray(weights, values.length), mean);    Returns 0 for a single-value (i.e. length = 1) sample.  Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array   Does not change the internal state of the statistic.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	double[]	int	int	): Returns the weighted variance of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Uses the formula  Σ(weights[i]*(values[i] - weightedMean)2)/(Σ(weights[i]) - 1)  where weightedMean is the weighted mean  This formula will not return the same result as the unweighted variance when all weights are equal, unless all weights are equal to 1. The formula assumes that weights are to be treated as "expansion values," as will be the case if for example the weights represent frequency counts. To normalize weights so that the denominator in the variance computation equals the length of the input vector minus one, use  evaluate(values, MathArrays.normalizeArray(weights, values.length));    Returns 0 for a single-value (i.e. length = 1) sample.  Throws IllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array   Does not change the internal state of the statistic.  Throws MathIllegalArgumentException if either array is null.
org.apache.commons.math4.stat.descriptive.moment.Variance.evaluate	(	double[]	int	int	): Returns the variance of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty. Note that Double.NaN may also be returned if the input includes NaN and / or infinite values.  See Variance for details on the computing algorithm.  Returns 0 for a single-value (i.e. length = 1) sample.  Does not change the internal state of the statistic.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.moment.Variance.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.moment.Variance.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.moment.Variance.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value. If all values are available, it is more accurate to use evaluate() rather than adding values one at a time using this method and then executing getResult, since evaluate leverages the fact that is has the full list of values together to execute a two-pass algorithm. See Variance. Note also that when Variance() is used to create a Variance, this method does nothing. In that case, the SecondMoment should be incremented directly.
org.apache.commons.math4.stat.descriptive.moment.Variance.isBiasCorrected	(	): 
org.apache.commons.math4.stat.descriptive.moment.Variance.setBiasCorrected	(	boolean	): 
org.apache.commons.math4.stat.descriptive.moment.VarianceTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.moment.VarianceTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.VarianceTest.expectedWeightedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.moment.VarianceTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.moment.VarianceTest.populationVariance	(	double[]	): Definitional formula for population variance
org.apache.commons.math4.stat.descriptive.moment.VarianceTest.testNaN	(	): Make sure Double.NaN is returned iff n = 0
org.apache.commons.math4.stat.descriptive.moment.VarianceTest.testPopulation	(	): Test population version of variance
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance: Returns the covariance matrix of the available vectors.
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.VectorialCovariance	(	int	boolean	): Constructs a VectorialCovariance.
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.equals	(	Object	):  
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.getN	(	): Get the number of vectors in the sample.
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.getResult	(	): Get the covariance matrix.
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.hashCode	(	):  
org.apache.commons.math4.stat.descriptive.moment.VectorialCovariance.increment	(	double[]	): Add a new vector to the sample.
org.apache.commons.math4.stat.descriptive.moment.VectorialMean: Returns the arithmetic mean of the available vectors.
org.apache.commons.math4.stat.descriptive.moment.VectorialMean.VectorialMean	(	int	): Constructs a VectorialMean.
org.apache.commons.math4.stat.descriptive.moment.VectorialMean.equals	(	Object	):  
org.apache.commons.math4.stat.descriptive.moment.VectorialMean.getN	(	): Get the number of vectors in the sample.
org.apache.commons.math4.stat.descriptive.moment.VectorialMean.getResult	(	): Get the mean vector.
org.apache.commons.math4.stat.descriptive.moment.VectorialMean.hashCode	(	):  
org.apache.commons.math4.stat.descriptive.moment.VectorialMean.increment	(	double[]	): Add a new vector to the sample.
org.apache.commons.math4.stat.descriptive.rank.Max: Returns the maximum of the available values.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.POSITIVE_INFINITY, the result is Double.POSITIVE_INFINITY.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.rank.Max.Max	(	): Create a Max instance.
org.apache.commons.math4.stat.descriptive.rank.Max.Max	(	Max	): Copy constructor, creates a new Max identical to the original.
org.apache.commons.math4.stat.descriptive.rank.Max.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.rank.Max.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.rank.Max.copy	(	Max	Max	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.rank.Max.evaluate	(	double[]	int	int	): Returns the maximum of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.POSITIVE_INFINITY, the result is Double.POSITIVE_INFINITY. 
org.apache.commons.math4.stat.descriptive.rank.Max.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.rank.Max.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.rank.Max.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.rank.MaxTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.rank.MaxTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.rank.MaxTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.rank.Median: Returns the median of the available values. This is the same as the 50th percentile. See Percentile for a description of the algorithm used.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.rank.Median.Median	(	): Default constructor.
org.apache.commons.math4.stat.descriptive.rank.Median.Median	(	EstimationType	NaNStrategy	KthSelector	): Constructs a Median with the specific EstimationType, NaNStrategy and PivotingStrategy.
org.apache.commons.math4.stat.descriptive.rank.Median.Median	(	Median	): Copy constructor, creates a new Median identical to the original
org.apache.commons.math4.stat.descriptive.rank.Median.withEstimationType	(	EstimationType	): Build a new instance similar to the current one except for the EstimationType estimation type.  This method is intended to be used as part of a fluent-type builder pattern. Building finely tune instances should be done as follows:   Percentile customized = new Percentile(quantile). withEstimationType(estimationType). withNaNStrategy(nanStrategy). withKthSelector(kthSelector);   If any of the withXxx method is omitted, the default value for the corresponding customization parameter will be used.  
org.apache.commons.math4.stat.descriptive.rank.Median.withKthSelector	(	KthSelector	): Build a new instance similar to the current one except for the KthSelector kthSelector instance specifically set.  This method is intended to be used as part of a fluent-type builder pattern. Building finely tune instances should be done as follows:   Percentile customized = new Percentile(quantile). withEstimationType(estimationType). withNaNStrategy(nanStrategy). withKthSelector(newKthSelector);   If any of the withXxx method is omitted, the default value for the corresponding customization parameter will be used.  
org.apache.commons.math4.stat.descriptive.rank.Median.withNaNStrategy	(	NaNStrategy	): Build a new instance similar to the current one except for the NaNStrategy NaN handling strategy.  This method is intended to be used as part of a fluent-type builder pattern. Building finely tune instances should be done as follows:   Percentile customized = new Percentile(quantile). withEstimationType(estimationType). withNaNStrategy(nanStrategy). withKthSelector(kthSelector);   If any of the withXxx method is omitted, the default value for the corresponding customization parameter will be used.  
org.apache.commons.math4.stat.descriptive.rank.MedianTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.rank.MedianTest.expectedValue	(	): 
org.apache.commons.math4.stat.descriptive.rank.MedianTest.getUnivariateStatistic	(	): 
org.apache.commons.math4.stat.descriptive.rank.MedianTest.testAssertMappedValues	(	double[]	Object[][]	Double	): Simple test assertion utility method
org.apache.commons.math4.stat.descriptive.rank.Min: Returns the minimum of the available values.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.NEGATIVE_INFINITY, the result is Double.NEGATIVE_INFINITY.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.rank.Min.Min	(	): Create a Min instance.
org.apache.commons.math4.stat.descriptive.rank.Min.Min	(	Min	): Copy constructor, creates a new Min identical to the original.
org.apache.commons.math4.stat.descriptive.rank.Min.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.rank.Min.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.rank.Min.copy	(	Min	Min	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.rank.Min.evaluate	(	double[]	int	int	): Returns the minimum of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null or the array index parameters are not valid.  The result is NaN iff all values are NaN (i.e. NaN values have no impact on the value of the statistic). If any of the values equals Double.NEGATIVE_INFINITY, the result is Double.NEGATIVE_INFINITY. 
org.apache.commons.math4.stat.descriptive.rank.Min.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.rank.Min.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.rank.Min.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.rank.MinTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.rank.MinTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.rank.MinTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile: A StorelessUnivariateStatistic estimating percentiles using the P2 Algorithm as explained by Raj Jain and Imrich Chlamtac in P2 Algorithm for Dynamic Calculation of Quantiles and Histogram Without Storing Observations.  Note: This implementation is not synchronized and produces an approximate result. For small samples, where data can be stored and processed in memory, Percentile should be used.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.FixedCapacityList: A simple fixed capacity list that has an upper bound to growth. Once its capacity is reached, add is a no-op, returning false.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.FixedCapacityList.FixedCapacityList	(	int	): This constructor constructs the list with given capacity and as well as stores the capacity
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.FixedCapacityList.add	(	E	):  In addition it checks if the size() returns a size that is within capacity and if true it adds; otherwise the list contents are unchanged and false is returned.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.FixedCapacityList.addAll	(	Collection	):  In addition it checks if the sum of Collection size and this instance's size() returns a value that is within capacity and if true it adds the collection; otherwise the list contents are unchanged and false is returned.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker: The class modeling the attributes of the marker of the P-square algorithm
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.Marker	(	): Default constructor
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.Marker	(	double	double	double	double	): Constructor of the marker with parameters
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.clone	(	): Clone this instance.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.difference	(	): Difference between desired and actual position
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.equals	(	Object	): This equals method checks for marker attributes and as well checks if navigation pointers (next and previous) are the same between this and passed in object
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.estimate	(	): Estimate the quantile for the current marker.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.hashCode	(	):  
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.incrementPosition	(	int	): Increment Position by d.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.index	(	int	): Sets the index of the marker.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.isEstimateBad	(	double[]	double	): Check if parabolic/nonlinear estimate is bad by checking if the ordinate found is beyond the y[0] and y[2].
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.next	(	Marker	): Sets the next marker.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.previous	(	Marker	): Sets the previous marker.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.readObject	(	ObjectInputStream	): Read Object to deserialize.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.toString	(	): 
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Marker.updateDesiredPosition	(	): Update desired Position with increment.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers: Markers is an encapsulation of the five markers/buckets as indicated in the original works.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.Markers	(	List	double	): Constructor
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.Markers	(	Marker[]	): Constructor
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.adjustHeightsOfMarkers	(	): Adjust marker heights by setting quantile estimates to middle markers.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.clone	(	): .Clone Markers
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.createMarkerArray	(	List	double	): Creates a marker array using initial five elements and a quantile
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.equals	(	Object	): .This equals method basically checks for marker array to be deep equals.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.estimate	(	int	): An Estimate of the percentile value of a given Marker
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.findCellAndUpdateMinMax	(	double	): Finds the cell where the input observation / value fits.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.getPercentileValue	(	): Returns the percentile computed thus far.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.hashCode	(	): 
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.height	(	int	): Return marker height given index
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.incrementPositions	(	int	int	int	): Increment positions by d. Refer to algorithm paper for the definition of d.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.processDataPoint	(	double	): Process a data point
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.readObject	(	ObjectInputStream	): Sets previous and next markers after default read is done.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.toString	(	): Returns string representation of the Marker array.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.Markers.updateDesiredPositions	(	): Desired positions incremented by bucket width. The bucket width is basically the desired increments.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers: An interface that encapsulates abstractions of the P-square algorithm markers as is explained in the original works. This interface is exposed with protected access to help in testability.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers.clone	(	): A clone function to clone the current instance. It's created as an interface method as well for convenience though Cloneable is just a marker interface.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers.estimate	(	int	): An Estimate of the percentile value of a given Marker
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers.getPercentileValue	(	): Returns Percentile value computed thus far.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers.height	(	int	): Returns the marker height (or percentile) of a given marker index.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquareMarkers.processDataPoint	(	double	): Process a data point by moving the marker heights based on estimator.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquarePercentile	(	): Default constructor that assumes a DEFAULT_QUANTILE_DESIRED default quantile needed.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.PSquarePercentile	(	double	): Constructs a PSquarePercentile with the specific percentile value.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.clear	(	): Clears the internal state of the Statistic. This basically clears all the markers, the initialFive list and sets countOfObservations to 0.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.equals	(	Object	): Returns true iff o is a PSquarePercentile returning the same values as this for getResult() and getN() and also having equal markers
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.hashCode	(	): Returns hash code based on getResult() and getN().
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.The internal state updated due to the new value in this context is basically of the marker positions and computation of the approximate quantile.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.maximum	(	): 
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.minimum	(	): 
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.newMarkers	(	List	double	): A creation method to build Markers
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.quantile	(	): Returns the quantile estimated by this statistic in the range [0.0-1.0]
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentile.toString	(	): Returns a string containing the last observation, the current estimate of the quantile and all markers.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentileTest: Test cases for the PSquarePercentile class which naturally extends StorelessUnivariateStatisticAbstractTest.
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentileTest.testCopyConsistencyWithInitialFirstFewElements	(	): Verifies that copied statistics remain equal to originals when incremented the same way by way of copying original after just a few elements are incremented
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentileTest.testCopyConsistencyWithInitialMostElements	(	): Verifies that copied statistics remain equal to originals when incremented the same way by making the copy after a majority of elements are incremented
org.apache.commons.math4.stat.descriptive.rank.PSquarePercentileTest.testDistribution	(	): Test Various Dist
org.apache.commons.math4.stat.descriptive.rank.Percentile: Provides percentile computation.  There are several commonly used methods for estimating percentiles (a.k.a. quantiles) based on sample data. For large samples, the different methods agree closely, but when sample sizes are small, different methods will give significantly different results. The algorithm implemented here works as follows:  Let n be the length of the (sorted) array and 0 < p <= 100 be the desired percentile. If  n = 1  return the unique array element (regardless of the value of p); otherwise  Compute the estimated percentile position  pos = p * (n + 1) / 100 and the difference, d between pos and floor(pos) (i.e. the fractional part of pos).  If pos < 1 return the smallest element in the array.  Else if pos >= n return the largest element in the array.  Else let lower be the element in position floor(pos) in the array and let upper be the next element in the array. Return lower + d * (upper - lower)    To compute percentiles, the data must be at least partially ordered. Input arrays are copied and recursively partitioned using an ordering definition. The ordering used by Arrays.sort(double[]) is the one determined by compareTo(). This ordering makes Double.NaN larger than any other value (including Double.POSITIVE_INFINITY). Therefore, for example, the median (50th percentile) of {0, 1, 2, 3, 4, Double.NaN} evaluates to 2.5.  Since percentile estimation usually involves interpolation between array elements, arrays containing NaN or infinite values will often result in NaN or infinite values returned.  Further, to include different estimation types such as R1, R2 as mentioned in Quantile page(wikipedia), a type specific NaN handling strategy is used to closely match with the typically observed results from popular tools like R(R1-R9), Excel(R7).  Since 2.2, Percentile uses only selection instead of complete sorting and caches selection algorithm state between calls to the various evaluate methods. This greatly improves efficiency, both for a single percentile and multiple percentile computations. To maximize performance when multiple percentiles are computed based on the same data, users should set the data array once using either one of the evaluate() or setData() methods and thereafter evaluate() with just the percentile provided.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.rank.Percentile.Percentile	(	): Constructs a Percentile with the following defaults.  default quantile: 50.0, can be reset with setQuantile() default estimation type: LEGACY, can be reset with withEstimationType() default NaN strategy: REMOVED, can be reset with withNaNStrategy() a KthSelector that makes use of MedianOf3PivotingStrategy, can be reset with withKthSelector() 
org.apache.commons.math4.stat.descriptive.rank.Percentile.Percentile	(	Percentile	): Copy constructor, creates a new Percentile identical to the original
org.apache.commons.math4.stat.descriptive.rank.Percentile.Percentile	(	double	): Constructs a Percentile with the specific quantile value and the following  default method type: LEGACY default NaN strategy: REMOVED a Kth Selector : KthSelector 
org.apache.commons.math4.stat.descriptive.rank.Percentile.Percentile	(	double	EstimationType	NaNStrategy	KthSelector	): Constructs a Percentile with the specific quantile value, EstimationType, NaNStrategy and KthSelector.
org.apache.commons.math4.stat.descriptive.rank.Percentile.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.rank.Percentile.copyOf	(	double[]	int	int	): Make a copy of the array for the slice defined by array part from [begin, begin+length)
org.apache.commons.math4.stat.descriptive.rank.Percentile.evaluate	(	double	): Returns the result of evaluating the statistic over the stored data.  The stored array is the one which was set by previous calls to setData() 
org.apache.commons.math4.stat.descriptive.rank.Percentile.evaluate	(	double[]	double	): Returns an estimate of the pth percentile of the values in the values array.  Calls to this method do not modify the internal quantile state of this statistic.  Returns Double.NaN if values has length 0 Returns (for any value of p) values[0] if values has length 1 Throws MathIllegalArgumentException if values is null or p is not a valid quantile value (p must be greater than 0 and less than or equal to 100)    See Percentile for a description of the percentile estimation algorithm used.
org.apache.commons.math4.stat.descriptive.rank.Percentile.evaluate	(	double[]	int	int	): Returns an estimate of the quantileth percentile of the designated values in the values array. The quantile estimated is determined by the quantile property.  Returns Double.NaN if length = 0 Returns (for any value of quantile) values[begin] if length = 1  Throws MathIllegalArgumentException if values is null, or start or length is invalid   See Percentile for a description of the percentile estimation algorithm used.
org.apache.commons.math4.stat.descriptive.rank.Percentile.evaluate	(	double[]	int	int	double	): Returns an estimate of the pth percentile of the values in the values array, starting with the element in (0-based) position begin in the array and including length values.  Calls to this method do not modify the internal quantile state of this statistic.  Returns Double.NaN if length = 0 Returns (for any value of p) values[begin] if length = 1  Throws MathIllegalArgumentException if values is null , begin or length is invalid, or p is not a valid quantile value (p must be greater than 0 and less than or equal to 100)   See Percentile for a description of the percentile estimation algorithm used.
org.apache.commons.math4.stat.descriptive.rank.Percentile.getEstimationType	(	): Get the estimation EstimationType type used for computation.
org.apache.commons.math4.stat.descriptive.rank.Percentile.getKthSelector	(	): Get the KthSelector kthSelector used for computation.
org.apache.commons.math4.stat.descriptive.rank.Percentile.getNaNStrategy	(	): Get the NaNStrategy NaN Handling strategy used for computation.
org.apache.commons.math4.stat.descriptive.rank.Percentile.getPivotingStrategy	(	): Get the PivotingStrategyInterface used in KthSelector for computation.
org.apache.commons.math4.stat.descriptive.rank.Percentile.getPivots	(	double[]	): Get pivots which is either cached or a newly created one
org.apache.commons.math4.stat.descriptive.rank.Percentile.getQuantile	(	): Returns the value of the quantile field (determines what percentile is computed when evaluate() is called with no quantile argument).
org.apache.commons.math4.stat.descriptive.rank.Percentile.getWorkArray	(	double[]	int	int	): Get the work array to operate. Makes use of prior storedData if it exists or else do a check on NaNs and copy a subset of the array defined by begin and length parameters. The set nanStrategy will be used to either retain/remove/replace any NaNs present before returning the resultant array.
org.apache.commons.math4.stat.descriptive.rank.Percentile.removeAndSlice	(	double[]	int	int	double	): Remove the occurrence of a given value in a copied slice of array defined by the array part from [begin, begin+length).
org.apache.commons.math4.stat.descriptive.rank.Percentile.replaceAndSlice	(	double[]	int	int	double	double	): Replace every occurrence of a given value with a replacement value in a copied slice of array defined by array part from [begin, begin+length).
org.apache.commons.math4.stat.descriptive.rank.Percentile.setData	(	double[]	): Set the data array.  The stored value is a copy of the parameter array, not the array itself.  
org.apache.commons.math4.stat.descriptive.rank.Percentile.setData	(	double[]	int	int	): Set the data array. The input array is copied, not referenced. 
org.apache.commons.math4.stat.descriptive.rank.Percentile.setQuantile	(	double	): Sets the value of the quantile field (determines what percentile is computed when evaluate() is called with no quantile argument).
org.apache.commons.math4.stat.descriptive.rank.Percentile.withEstimationType	(	EstimationType	): Build a new instance similar to the current one except for the EstimationType estimation type.  This method is intended to be used as part of a fluent-type builder pattern. Building finely tune instances should be done as follows:   Percentile customized = new Percentile(quantile). withEstimationType(estimationType). withNaNStrategy(nanStrategy). withKthSelector(kthSelector);   If any of the withXxx method is omitted, the default value for the corresponding customization parameter will be used. 
org.apache.commons.math4.stat.descriptive.rank.Percentile.withKthSelector	(	KthSelector	): Build a new instance similar to the current one except for the KthSelector kthSelector instance specifically set.  This method is intended to be used as part of a fluent-type builder pattern. Building finely tune instances should be done as follows:   Percentile customized = new Percentile(quantile). withEstimationType(estimationType). withNaNStrategy(nanStrategy). withKthSelector(newKthSelector);   If any of the withXxx method is omitted, the default value for the corresponding customization parameter will be used. 
org.apache.commons.math4.stat.descriptive.rank.Percentile.withNaNStrategy	(	NaNStrategy	): Build a new instance similar to the current one except for the NaNStrategy NaN handling strategy.  This method is intended to be used as part of a fluent-type builder pattern. Building finely tune instances should be done as follows:   Percentile customized = new Percentile(quantile). withEstimationType(estimationType). withNaNStrategy(nanStrategy). withKthSelector(kthSelector);   If any of the withXxx method is omitted, the default value for the corresponding customization parameter will be used. 
org.apache.commons.math4.stat.descriptive.rank.PercentileTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.rank.PercentileTest.before	(	): Before method to ensure defaults retained
org.apache.commons.math4.stat.descriptive.rank.PercentileTest.expectedValue	(	): 
org.apache.commons.math4.stat.descriptive.rank.PercentileTest.getUnivariateStatistic	(	): 
org.apache.commons.math4.stat.descriptive.rank.PercentileTest.testAllTechniquesHighPercentile	(	): While testHighPercentile() checks only for the existing implementation; this method verifies for all the types including Percentile.Type.CM Percentile.Type.
org.apache.commons.math4.stat.descriptive.rank.PercentileTest.testAssertMappedValues	(	double[]	Object[][]	Double	Double	): Simple test assertion utility method assuming NaNStrategy default nan handling strategy specific to each EstimationType type
org.apache.commons.math4.stat.descriptive.rank.PercentileTest.testAssertMappedValues	(	double[]	Object[][]	Double	Double	NaNStrategy	): Simple test assertion utility method
org.apache.commons.math4.stat.descriptive.summary.Product: Returns the product of the available values.  If there are no values in the dataset, then 1 is returned. If any of the values are NaN, then NaN is returned.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.summary.Product.Product	(	): Create a Product instance.
org.apache.commons.math4.stat.descriptive.summary.Product.Product	(	Product	): Copy constructor, creates a new Product identical to the original.
org.apache.commons.math4.stat.descriptive.summary.Product.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.summary.Product.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.summary.Product.copy	(	Product	Product	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.summary.Product.evaluate	(	double[]	double[]	): Returns the weighted product of the entries in the input array. Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values  Uses the formula,  weighted product = ∏values[i]weights[i]  that is, the weights are applied as exponents when computing the weighted product.
org.apache.commons.math4.stat.descriptive.summary.Product.evaluate	(	double[]	double[]	int	int	): Returns the weighted product of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty. Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array  Uses the formula,  weighted product = ∏values[i]weights[i]  that is, the weights are applied as exponents when computing the weighted product.
org.apache.commons.math4.stat.descriptive.summary.Product.evaluate	(	double[]	int	int	): Returns the product of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.summary.Product.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.summary.Product.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.summary.Product.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.summary.ProductTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.summary.ProductTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.summary.ProductTest.expectedWeightedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.summary.ProductTest.getTolerance	(	): 
org.apache.commons.math4.stat.descriptive.summary.ProductTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.summary.Sum: Returns the sum of the available values.  If there are no values in the dataset, then 0 is returned. If any of the values are NaN, then NaN is returned.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.summary.Sum.Sum	(	): Create a Sum instance.
org.apache.commons.math4.stat.descriptive.summary.Sum.Sum	(	Sum	): Copy constructor, creates a new Sum identical to the original.
org.apache.commons.math4.stat.descriptive.summary.Sum.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.summary.Sum.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.summary.Sum.copy	(	Sum	Sum	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.summary.Sum.evaluate	(	double[]	double[]	): The weighted sum of the entries in the the input array.  Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values   Uses the formula,  weighted sum = Σ(values[i] * weights[i]) 
org.apache.commons.math4.stat.descriptive.summary.Sum.evaluate	(	double[]	double[]	int	int	): The weighted sum of the entries in the specified portion of the input array, or 0 if the designated subarray is empty.  Throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array   Uses the formula,  weighted sum = Σ(values[i] * weights[i]) 
org.apache.commons.math4.stat.descriptive.summary.Sum.evaluate	(	double[]	int	int	): The sum of the entries in the specified portion of the input array, or 0 if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.summary.Sum.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.summary.Sum.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.summary.Sum.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.summary.SumLogTest: Test cases for the UnivariateStatistic class.
org.apache.commons.math4.stat.descriptive.summary.SumLogTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.summary.SumLogTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs: Returns the sum of the natural logs for this collection of values.  Uses log() to compute the logs. Therefore,  If any of values are < 0, the result is NaN. If all values are non-negative and less than Double.POSITIVE_INFINITY, but at least one value is 0, the result is Double.NEGATIVE_INFINITY. If both Double.POSITIVE_INFINITY and Double.NEGATIVE_INFINITY are among the values, the result is NaN.   Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.SumOfLogs	(	): Create a SumOfLogs instance.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.SumOfLogs	(	SumOfLogs	): Copy constructor, creates a new SumOfLogs identical to the original.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.copy	(	SumOfLogs	SumOfLogs	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.evaluate	(	double[]	int	int	): Returns the sum of the natural logs of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null.  See SumOfLogs.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.summary.SumOfLogs.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares: Returns the sum of the squares of the available values.  If there are no values in the dataset, then 0 is returned. If any of the values are NaN, then NaN is returned.  Note that this implementation is not synchronized. If multiple threads access an instance of this class concurrently, and at least one of the threads invokes the increment() or clear() method, it must be synchronized externally.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.SumOfSquares	(	): Create a SumOfSquares instance.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.SumOfSquares	(	SumOfSquares	): Copy constructor, creates a new SumOfSquares identical to the original.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.clear	(	): Clears the internal state of the Statistic
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.copy	(	): Returns a copy of the statistic with the same internal state.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.copy	(	SumOfSquares	SumOfSquares	): Copies source to dest. Neither source nor dest can be null.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.evaluate	(	double[]	int	int	): Returns the sum of the squares of the entries in the specified portion of the input array, or Double.NaN if the designated subarray is empty.  Throws MathIllegalArgumentException if the array is null.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.getN	(	): Returns the number of values that have been added.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.getResult	(	): Returns the current value of the Statistic.
org.apache.commons.math4.stat.descriptive.summary.SumOfSquares.increment	(	double	): Updates the internal state of the statistic to reflect the addition of the new value.
org.apache.commons.math4.stat.descriptive.summary.SumSqTest: Test cases for the SumOfSquares class.
org.apache.commons.math4.stat.descriptive.summary.SumSqTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.summary.SumSqTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.descriptive.summary.SumTest: Test cases for the Sum class.
org.apache.commons.math4.stat.descriptive.summary.SumTest.expectedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.summary.SumTest.expectedWeightedValue	(	): Expected value for the testArray defined in UnivariateStatisticAbstractTest 
org.apache.commons.math4.stat.descriptive.summary.SumTest.getUnivariateStatistic	(	): Return a new instance of the statistic 
org.apache.commons.math4.stat.inference.BinomialTest: Implements binomial test statistics.  Exact test for the statistical significance of deviations from a theoretically expected distribution of observations into two categories.
org.apache.commons.math4.stat.inference.BinomialTest.binomialTest	(	int	int	double	AlternativeHypothesis	): Returns the observed significance level, or p-value, associated with a  Binomial test.  The number returned is the smallest significance level at which one can reject the null hypothesis. The form of the hypothesis depends on alternativeHypothesis.  The p-Value represents the likelihood of getting a result at least as extreme as the sample, given the provided probability of success on a single trial. For single-sided tests, this value can be directly derived from the Binomial distribution. For the two-sided test, the implementation works as follows: we start by looking at the most extreme cases (0 success and n success where n is the number of trials from the sample) and determine their likelihood. The lower value is added to the p-Value (if both values are equal, both are added). Then we continue with the next extreme value, until we added the value for the actual observed sample.  Preconditions:  Number of trials must be ≥ 0. Number of successes must be ≥ 0. Number of successes must be ≤ number of trials. Probability must be ≥ 0 and ≤ 1. 
org.apache.commons.math4.stat.inference.BinomialTest.binomialTest	(	int	int	double	AlternativeHypothesis	double	): Returns whether the null hypothesis can be rejected with the given confidence level.  Preconditions:  Number of trials must be ≥ 0. Number of successes must be ≥ 0. Number of successes must be ≤ number of trials. Probability must be ≥ 0 and ≤ 1. 
org.apache.commons.math4.stat.inference.BinomialTestTest: Test cases for the BinomialTest class.
org.apache.commons.math4.stat.inference.ChiSquareTest: Implements Chi-Square test statistics. This implementation handles both known and unknown distributions. Two samples tests can be used when the distribution is unknown a priori but provided by one sample, or when the hypothesis under test is that the two samples come from the same underlying distribution.
org.apache.commons.math4.stat.inference.ChiSquareTest.ChiSquareTest	(	): Construct a ChiSquareTest
org.apache.commons.math4.stat.inference.ChiSquareTest.checkArray	(	long[][]	): Checks to make sure that the input long[][] array is rectangular, has at least 2 rows and 2 columns, and has all non-negative entries.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquare	(	double[]	long[]	): Computes the  Chi-Square statistic comparing observed and expected frequency counts.  This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that the observed counts follow the expected distribution.  Preconditions:  Expected counts must all be positive.  Observed counts must all be ≥ 0.  The observed and expected arrays must have the same length and their common length must be at least 2.  If any of the preconditions are not met, an IllegalArgumentException is thrown. Note: This implementation rescales the expected array if necessary to ensure that the sum of the expected and observed counts are equal.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquare	(	long[][]	): Computes the Chi-Square statistic associated with a  chi-square test of independence based on the input counts array, viewed as a two-way table.  The rows of the 2-way table are count[0], ... , count[count.length - 1]   Preconditions:  All counts must be ≥ 0.  The count array must be rectangular (i.e. all count[i] subarrays must have the same length).  The 2-way table represented by counts must have at least 2 columns and at least 2 rows.   If any of the preconditions are not met, an IllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareDataSetsComparison	(	long[]	long[]	): Computes a  Chi-Square two sample test statistic comparing bin frequency counts in observed1 and observed2. The sums of frequency counts in the two samples are not required to be the same. The formula used to compute the test statistic is  ∑[(K * observed1[i] - observed2[i]/K)2 / (observed1[i] + observed2[i])]  where K = √[∑(observed2 / ∑(observed1)] This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that both observed counts follow the same distribution.  Preconditions:  Observed counts must be non-negative.  Observed counts for a specific bin must not both be zero.  Observed counts for a specific sample must not all be 0.  The arrays observed1 and observed2 must have the same length and their common length must be at least 2.  If any of the preconditions are not met, an IllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareTest	(	double[]	long[]	): Returns the observed significance level, or  p-value, associated with a  Chi-square goodness of fit test comparing the observed frequency counts to those in the expected array.  The number returned is the smallest significance level at which one can reject the null hypothesis that the observed counts conform to the frequency distribution described by the expected counts.  Preconditions:  Expected counts must all be positive.  Observed counts must all be ≥ 0.  The observed and expected arrays must have the same length and their common length must be at least 2.  If any of the preconditions are not met, an IllegalArgumentException is thrown. Note: This implementation rescales the expected array if necessary to ensure that the sum of the expected and observed counts are equal.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareTest	(	double[]	long[]	double	): Performs a  Chi-square goodness of fit test evaluating the null hypothesis that the observed counts conform to the frequency distribution described by the expected counts, with significance level alpha. Returns true iff the null hypothesis can be rejected with 100 * (1 - alpha) percent confidence.  Example: To test the hypothesis that observed follows expected at the 99% level, use  chiSquareTest(expected, observed, 0.01)   Preconditions:  Expected counts must all be positive.  Observed counts must all be ≥ 0.  The observed and expected arrays must have the same length and their common length must be at least 2.   0 < alpha < 0.5   If any of the preconditions are not met, an IllegalArgumentException is thrown. Note: This implementation rescales the expected array if necessary to ensure that the sum of the expected and observed counts are equal.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareTest	(	long[][]	): Returns the observed significance level, or  p-value, associated with a  chi-square test of independence based on the input counts array, viewed as a two-way table.  The rows of the 2-way table are count[0], ... , count[count.length - 1]   Preconditions:  All counts must be ≥ 0.  The count array must be rectangular (i.e. all count[i] subarrays must have the same length).  The 2-way table represented by counts must have at least 2 columns and at least 2 rows.   If any of the preconditions are not met, an IllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareTest	(	long[][]	double	): Performs a  chi-square test of independence evaluating the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, with significance level alpha. Returns true iff the null hypothesis can be rejected with 100 * (1 - alpha) percent confidence.  The rows of the 2-way table are count[0], ... , count[count.length - 1]   Example: To test the null hypothesis that the counts in count[0], ... , count[count.length - 1]  all correspond to the same underlying probability distribution at the 99% level, use chiSquareTest(counts, 0.01)  Preconditions:  All counts must be ≥ 0.  The count array must be rectangular (i.e. all count[i] subarrays must have the same length). The 2-way table represented by counts must have at least 2 columns and at least 2 rows.  If any of the preconditions are not met, an IllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareTestDataSetsComparison	(	long[]	long[]	): Returns the observed significance level, or  p-value, associated with a Chi-Square two sample test comparing bin frequency counts in observed1 and observed2.  The number returned is the smallest significance level at which one can reject the null hypothesis that the observed counts conform to the same distribution.  See chiSquareDataSetsComparison() for details on the formula used to compute the test statistic. The degrees of of freedom used to perform the test is one less than the common length of the input observed count arrays.  Preconditions:  Observed counts must be non-negative.  Observed counts for a specific bin must not both be zero.  Observed counts for a specific sample must not all be 0.  The arrays observed1 and observed2 must have the same length and their common length must be at least 2.  If any of the preconditions are not met, an IllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.ChiSquareTest.chiSquareTestDataSetsComparison	(	long[]	long[]	double	): Performs a Chi-Square two sample test comparing two binned data sets. The test evaluates the null hypothesis that the two lists of observed counts conform to the same frequency distribution, with significance level alpha. Returns true iff the null hypothesis can be rejected with 100 * (1 - alpha) percent confidence.  See chiSquareDataSetsComparison() for details on the formula used to compute the Chisquare statistic used in the test. The degrees of of freedom used to perform the test is one less than the common length of the input observed count arrays.  Preconditions:  Observed counts must be non-negative.  Observed counts for a specific bin must not both be zero.  Observed counts for a specific sample must not all be 0.  The arrays observed1 and observed2 must have the same length and their common length must be at least 2.    0 < alpha < 0.5   If any of the preconditions are not met, an IllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.ChiSquareTestTest: Test cases for the ChiSquareTestImpl class.
org.apache.commons.math4.stat.inference.ChiSquareTestTest.testChiSquareDataSetsComparisonEqualCounts	(	): Target values verified using DATAPLOT version 2006.3 
org.apache.commons.math4.stat.inference.ChiSquareTestTest.testChiSquareDataSetsComparisonUnEqualCounts	(	): Target values verified using DATAPLOT version 2006.3 
org.apache.commons.math4.stat.inference.ChiSquareTestTest.testChiSquareZeroCount	(	): Contingency table containing zeros - PR # 32531 
org.apache.commons.math4.stat.inference.GTest: Implements G Test statistics. This is known in statistical genetics as the McDonald-Kreitman test. The implementation handles both known and unknown distributions. Two samples tests can be used when the distribution is unknown a priori but provided by one sample, or when the hypothesis under test is that the two samples come from the same underlying distribution.
org.apache.commons.math4.stat.inference.GTest.entropy	(	long[]	): Calculates the  Shannon entropy for a vector. The values of k are taken to be incidence counts of the values of a random variable. What is returned is  ∑pilog(pi where pi = k[i] / (sum of elements in k)
org.apache.commons.math4.stat.inference.GTest.entropy	(	long[][]	): Calculates the Shannon entropy for 2 Dimensional Matrix. The value returned is the entropy of the vector formed by concatenating the rows (or columns) of k to form a vector. See entropy().
org.apache.commons.math4.stat.inference.GTest.g	(	double[]	long[]	): Computes the G statistic for Goodness of Fit comparing observed and expected frequency counts. This statistic can be used to perform a G test (Log-Likelihood Ratio Test) evaluating the null hypothesis that the observed counts follow the expected distribution. Preconditions:  Expected counts must all be positive.  Observed counts must all be ≥ 0.  The observed and expected arrays must have the same length and their common length must be at least 2.  If any of the preconditions are not met, a MathIllegalArgumentException is thrown. Note:This implementation rescales the expected array if necessary to ensure that the sum of the expected and observed counts are equal.
org.apache.commons.math4.stat.inference.GTest.gDataSetsComparison	(	long[]	long[]	): Computes a G (Log-Likelihood Ratio) two sample test statistic for independence comparing frequency counts in observed1 and observed2. The sums of frequency counts in the two samples are not required to be the same. The formula used to compute the test statistic is  2 * totalSum * [H(rowSums) + H(colSums) - H(k)]  where H is the  Shannon Entropy of the random variable formed by viewing the elements of the argument array as incidence counts;  k is a matrix with rows [observed1, observed2];  rowSums, colSums are the row/col sums of k;  and totalSum is the overall sum of all entries in k. This statistic can be used to perform a G test evaluating the null hypothesis that both observed counts are independent   Preconditions:  Observed counts must be non-negative.  Observed counts for a specific bin must not both be zero.  Observed counts for a specific sample must not all be 0.  The arrays observed1 and observed2 must have the same length and their common length must be at least 2.  If any of the preconditions are not met, a MathIllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.GTest.gTest	(	double[]	long[]	): Returns the observed significance level, or  p-value, associated with a G-Test for goodness of fit comparing the observed frequency counts to those in the expected array. The number returned is the smallest significance level at which one can reject the null hypothesis that the observed counts conform to the frequency distribution described by the expected counts. The probability returned is the tail probability beyond g() g(expected, observed) in the ChiSquare distribution with degrees of freedom one less than the common length of expected and observed.  Preconditions:  Expected counts must all be positive.  Observed counts must all be ≥ 0.  The observed and expected arrays must have the same length and their common length must be at least 2.  If any of the preconditions are not met, a MathIllegalArgumentException is thrown. Note:This implementation rescales the expected array if necessary to ensure that the sum of the expected and observed counts are equal.
org.apache.commons.math4.stat.inference.GTest.gTest	(	double[]	long[]	double	): Performs a G-Test (Log-Likelihood Ratio Test) for goodness of fit evaluating the null hypothesis that the observed counts conform to the frequency distribution described by the expected counts, with significance level alpha. Returns true iff the null hypothesis can be rejected with 100 * (1 - alpha) percent confidence. Example: To test the hypothesis that observed follows expected at the 99% level, use  gTest(expected, observed, 0.01) Returns true iff gTest() gTestGoodnessOfFitPValue(expected, observed) < alpha Preconditions:  Expected counts must all be positive.  Observed counts must all be ≥ 0.  The observed and expected arrays must have the same length and their common length must be at least 2.  0 < alpha < 0.5  If any of the preconditions are not met, a MathIllegalArgumentException is thrown. Note:This implementation rescales the expected array if necessary to ensure that the sum of the expected and observed counts are equal.
org.apache.commons.math4.stat.inference.GTest.gTestDataSetsComparison	(	long[]	long[]	): Returns the observed significance level, or  p-value, associated with a G-Value (Log-Likelihood Ratio) for two sample test comparing bin frequency counts in observed1 and observed2. The number returned is the smallest significance level at which one can reject the null hypothesis that the observed counts conform to the same distribution.  See gTest() for details on how the p-value is computed. The degrees of of freedom used to perform the test is one less than the common length of the input observed count arrays. Preconditions:  Observed counts must be non-negative.  Observed counts for a specific bin must not both be zero.  Observed counts for a specific sample must not all be 0.  The arrays observed1 and observed2 must have the same length and their common length must be at least 2.    If any of the preconditions are not met, a MathIllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.GTest.gTestDataSetsComparison	(	long[]	long[]	double	): Performs a G-Test (Log-Likelihood Ratio Test) comparing two binned data sets. The test evaluates the null hypothesis that the two lists of observed counts conform to the same frequency distribution, with significance level alpha. Returns true iff the null hypothesis can be rejected with 100 * (1 - alpha) percent confidence.  See gDataSetsComparison() for details on the formula used to compute the G (LLR) statistic used in the test and gTest() for information on how the observed significance level is computed. The degrees of of freedom used to perform the test is one less than the common length of the input observed count arrays.  Preconditions:  Observed counts must be non-negative.  Observed counts for a specific bin must not both be zero.  Observed counts for a specific sample must not all be 0.  The arrays observed1 and observed2 must have the same length and their common length must be at least 2.  0 < alpha < 0.5  If any of the preconditions are not met, a MathIllegalArgumentException is thrown.
org.apache.commons.math4.stat.inference.GTest.gTestIntrinsic	(	double[]	long[]	): Returns the intrinsic (Hardy-Weinberg proportions) p-Value, as described in p64-69 of McDonald, J.H. 2009. Handbook of Biological Statistics (2nd ed.). Sparky House Publishing, Baltimore, Maryland.  The probability returned is the tail probability beyond g() g(expected, observed) in the ChiSquare distribution with degrees of freedom two less than the common length of expected and observed.
org.apache.commons.math4.stat.inference.GTest.rootLogLikelihoodRatio	(	long	long	long	long	): Calculates the root log-likelihood ratio for 2 state Datasets. See gDataSetsComparison(). Given two events A and B, let k11 be the number of times both events occur, k12 the incidence of B without A, k21 the count of A without B, and k22 the number of times neither A nor B occurs. What is returned by this method is  (sgn) sqrt(gValueDataSetsComparison({k11, k12}, {k21, k22}) where sgn is -1 if k11 / (k11 + k12) < k21 / (k21 + k22)); 1 otherwise. Signed root LLR has two advantages over the basic LLR: a) it is positive where k11 is bigger than expected, negative where it is lower b) if there is no difference it is asymptotically normally distributed. This allows one to talk about "number of standard deviations" which is a more common frame of reference than the chi^2 distribution.
org.apache.commons.math4.stat.inference.GTestTest: Test cases for the GTest class. Data for the tests are from p64-69 in: McDonald, J.H. 2009. Handbook of Biological Statistics (2nd ed.). Sparky House Publishing, Baltimore, Maryland.
org.apache.commons.math4.stat.inference.InferenceTestUtils: A collection of static methods to create inference test instances or to perform inference tests.
org.apache.commons.math4.stat.inference.InferenceTestUtils.InferenceTestUtils	(	): Prevent instantiation.
org.apache.commons.math4.stat.inference.InferenceTestUtils.approximateP	(	double	int	int	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquare	(	double[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquare	(	long[][]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareDataSetsComparison	(	long[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareTest	(	double[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareTest	(	double[]	long[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareTest	(	long[][]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareTest	(	long[][]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareTestDataSetsComparison	(	long[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.chiSquareTestDataSetsComparison	(	long[]	long[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.exactP	(	double	int	int	boolean	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.g	(	double[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.gDataSetsComparison	(	long[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.gTest	(	double[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.gTest	(	double[]	long[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.gTestDataSetsComparison	(	long[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.gTestDataSetsComparison	(	long[]	long[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.gTestIntrinsic	(	double[]	long[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.homoscedasticT	(	StatisticalSummary	StatisticalSummary	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.homoscedasticT	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.homoscedasticTTest	(	StatisticalSummary	StatisticalSummary	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.homoscedasticTTest	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.homoscedasticTTest	(	double[]	double[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovStatistic	(	RealDistribution	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovStatistic	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovTest	(	RealDistribution	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovTest	(	RealDistribution	double[]	boolean	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovTest	(	RealDistribution	double[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovTest	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.kolmogorovSmirnovTest	(	double[]	double[]	boolean	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.monteCarloP	(	double	int	int	boolean	int	UniformRandomProvider	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.oneWayAnovaFValue	(	Collection	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.oneWayAnovaPValue	(	Collection	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.oneWayAnovaTest	(	Collection	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.pairedT	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.pairedTTest	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.pairedTTest	(	double[]	double[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.rootLogLikelihoodRatio	(	long	long	long	long	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.t	(	StatisticalSummary	StatisticalSummary	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.t	(	double	StatisticalSummary	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.t	(	double	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.t	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	StatisticalSummary	StatisticalSummary	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	StatisticalSummary	StatisticalSummary	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	double	StatisticalSummary	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	double	StatisticalSummary	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	double	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	double	double[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	double[]	double[]	): 
org.apache.commons.math4.stat.inference.InferenceTestUtils.tTest	(	double[]	double[]	double	): 
org.apache.commons.math4.stat.inference.InferenceTestUtilsTest: Test cases for the TestUtils class.
org.apache.commons.math4.stat.inference.InferenceTestUtilsTest.testChiSquareZeroCount	(	): Contingency table containing zeros - PR # 32531 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest: Implementation of the  Kolmogorov-Smirnov (K-S) test for equality of continuous distributions.  The K-S test uses a statistic based on the maximum deviation of the empirical distribution of sample data points from the distribution expected under the null hypothesis. For one-sample tests evaluating the null hypothesis that a set of sample data points follow a given distribution, the test statistic is \(D_n=\sup_x |F_n(x)-F(x)|\), where \(F\) is the expected distribution and \(F_n\) is the empirical distribution of the \(n\) sample data points. The distribution of \(D_n\) is estimated using a method based on [1] with certain quick decisions for extreme values given in [2].   Two-sample tests are also supported, evaluating the null hypothesis that the two samples x and y come from the same underlying distribution. In this case, the test statistic is \(D_{n,m}=\sup_t | F_n(t)-F_m(t)|\) where \(n\) is the length of x, \(m\) is the length of y, \(F_n\) is the empirical distribution that puts mass \(1/n\) at each of the values in x and \(F_m\) is the empirical distribution of the y values. The default 2-sample test method, kolmogorovSmirnovTest() works as follows:  When the product of the sample sizes is less than 10000, the method presented in [4] is used to compute the exact p-value for the 2-sample test. When the product of the sample sizes is larger, the asymptotic distribution of \(D_{n,m}\) is used. See approximateP() for details on the approximation.  For small samples (former case), if the data contains ties, random jitter is added to the sample data to break ties before applying the algorithm above. Alternatively, the bootstrap() method, modeled after ks.boot in the R Matching package [3], can be used if ties are known to be present in the data.   In the two-sample case, \(D_{n,m}\) has a discrete distribution. This makes the p-value associated with the null hypothesis \(H_0 : D_{n,m} \ge d \) differ from \(H_0 : D_{n,m} \ge d \) by the mass of the observed value \(d\). To distinguish these, the two-sample tests use a boolean strict parameter. This parameter is ignored for large samples.   The methods used by the 2-sample default implementation are also exposed directly:  exactP() computes exact 2-sample p-values approximateP() uses the asymptotic distribution The boolean arguments in the first two methods allow the probability used to estimate the p-value to be expressed using strict or non-strict inequality. See kolmogorovSmirnovTest().   References:  [1]  Evaluating Kolmogorov's Distribution by George Marsaglia, Wai Wan Tsang, and Jingbo Wang [2]  Computing the Two-Sided Kolmogorov-Smirnov Distribution by Richard Simard and Pierre L'Ecuyer [3] Jasjeet S. Sekhon. 2011.  Multivariate and Propensity Score Matching Software with Automated Balance Optimization: The Matching package for R Journal of Statistical Software, 42(7): 1-52. [4] Wilcox, Rand. 2012. Introduction to Robust Estimation and Hypothesis Testing, Chapter 5, 3rd Ed. Academic Press.   Note that [1] contains an error in computing h, refer to MATH-437 for details.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.approximateP	(	double	int	int	): Uses the Kolmogorov-Smirnov distribution to approximate \(P(D_{n,m} > d)\) where \(D_{n,m}\) is the 2-sample Kolmogorov-Smirnov statistic. See kolmogorovSmirnovStatistic() for the definition of \(D_{n,m}\).  Specifically, what is returned is \(1 - k(d \sqrt{mn / (m + n)})\) where \(k(t) = 1 + 2 \sum_{i=1}^\infty (-1)^i e^{-2 i^2 t^2}\). See ksSum() for details on how convergence of the sum is determined. 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.bootstrap	(	double[]	double[]	int	boolean	UniformRandomProvider	): Estimates the p-value of a two-sample Kolmogorov-Smirnov test evaluating the null hypothesis that x and y are samples drawn from the same probability distribution. This method estimates the p-value by repeatedly sampling sets of size x.length and y.length from the empirical distribution of the combined sample. When strict is true, this is equivalent to the algorithm implemented in the R function ks.boot, described in  Jasjeet S. Sekhon. 2011. 'Multivariate and Propensity Score Matching Software with Automated Balance Optimization: The Matching package for R.' Journal of Statistical Software, 42(7): 1-52. 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.c	(	int	int	int	int	long	boolean	): The function C(i, j) defined in [4] (class javadoc), formula (5.5). defined to return 1 if |i/n - j/m| <= c; 0 otherwise. Here c is scaled up and recoded as a long to avoid rounding errors in comparison tests, so what is actually tested is |im - jn| <= cmn.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.calculateIntegralD	(	double	int	int	boolean	): Given a d-statistic in the range [0, 1] and the two sample sizes n and m, an integral d-statistic in the range [0, n*m] is calculated, that can be used for comparison with other integral d-statistics. Depending whether strict is true or not, the returned value divided by (n*m) is greater than (resp greater than or equal to) the given d value (allowing some tolerance).
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.cdf	(	double	int	): Calculates \(P(D_n < d)\) using the method described in [1] with quick decisions for extreme values given in [2] (see above). The result is not exact as with cdfExact() because calculations are based on double rather than org.apache.commons.math4.fraction.BigFraction.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.cdf	(	double	int	boolean	): Calculates P(D_n < d) using method described in [1] with quick decisions for extreme values given in [2] (see above).
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.cdfExact	(	double	int	): Calculates P(D_n < d). The result is exact in the sense that BigFraction/BigReal is used everywhere at the expense of very slow execution time. Almost never choose this in real applications unless you are very sure; this is almost solely for verification purposes. Normally, you would choose cdf(). See the class javadoc for definitions and algorithm description.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.checkArray	(	double[]	): Verifies that array has length at least 2.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.createExactH	(	double	int	): Creates H of size m x m as described in [1] (see above).
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.createRoundedH	(	double	int	): Creates H of size m x m as described in [1] (see above) using double-precision.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.exactK	(	double	int	): Calculates the exact value of P(D_n < d) using the method described in [1] (reference in class javadoc above) and org.apache.commons.math4.fraction.BigFraction (see above).
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.exactP	(	double	int	int	boolean	): Computes \(P(D_{n,m} > d)\) if strict is true; otherwise \(P(D_{n,m} \ge d)\), where \(D_{n,m}\) is the 2-sample Kolmogorov-Smirnov statistic. See kolmogorovSmirnovStatistic() for the definition of \(D_{n,m}\).  The returned probability is exact, implemented by unwinding the recursive function definitions presented in [4] (class javadoc). 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.fillBooleanArrayRandomlyWithFixedNumberTrueValues	(	boolean[]	int	UniformRandomProvider	): Fills a boolean array randomly with a fixed number of true values. The method uses a simplified version of the Fisher-Yates shuffle algorithm. By processing first the true values followed by the remaining false values less random numbers need to be generated. The method is optimized for the case that the number of true values is larger than or equal to the number of false values.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.fixTies	(	double[]	double[]	): If there are no ties in the combined dataset formed from x and y, this method is a no-op. If there are ties, a uniform random deviate in is added to each value in x and y, and this method overwrites the data in x and y with the jittered values.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.hasTies	(	double[]	double[]	): Returns true iff there are ties in the combined sample formed from x and y.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.integralKolmogorovSmirnovStatistic	(	double[]	double[]	): Computes the two-sample Kolmogorov-Smirnov test statistic, \(D_{n,m}=\sup_x |F_n(x)-F_m(x)|\) where \(n\) is the length of x, \(m\) is the length of y, \(F_n\) is the empirical distribution that puts mass \(1/n\) at each of the values in x and \(F_m\) is the empirical distribution of the y values. Finally \(n m D_{n,m}\) is returned as long value.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.integralMonteCarloP	(	long	int	int	int	UniformRandomProvider	): Uses Monte Carlo simulation to approximate \(P(D_{n,m} >= d / (n * m))\) where \(D_{n,m}\) is the 2-sample Kolmogorov-Smirnov statistic.  Here d is the D-statistic represented as long value. The real D-statistic is obtained by dividing d by n * m. See also monteCarloP().
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.jitter	(	double[]	UniformRandomProvider	int	): Adds random jitter to data using deviates sampled from dist.  Note that jitter is applied in-place - i.e., the array values are overwritten with the result of applying jitter.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovStatistic	(	RealDistribution	double[]	): Computes the one-sample Kolmogorov-Smirnov test statistic, \(D_n=\sup_x |F_n(x)-F(x)|\) where \(F\) is the distribution (cdf) function associated with distribution, \(n\) is the length of data and \(F_n\) is the empirical distribution that puts mass \(1/n\) at each of the values in data.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovStatistic	(	double[]	double[]	): Computes the two-sample Kolmogorov-Smirnov test statistic, \(D_{n,m}=\sup_x |F_n(x)-F_m(x)|\) where \(n\) is the length of x, \(m\) is the length of y, \(F_n\) is the empirical distribution that puts mass \(1/n\) at each of the values in x and \(F_m\) is the empirical distribution of the y values.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovTest	(	RealDistribution	double[]	): Computes the p-value, or observed significance level, of a one-sample  Kolmogorov-Smirnov test evaluating the null hypothesis that data conforms to distribution.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovTest	(	RealDistribution	double[]	boolean	): Computes the p-value, or observed significance level, of a one-sample  Kolmogorov-Smirnov test evaluating the null hypothesis that data conforms to distribution. If exact is true, the distribution used to compute the p-value is computed using extended precision. See cdfExact().
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovTest	(	RealDistribution	double[]	double	): Performs a  Kolmogorov-Smirnov test evaluating the null hypothesis that data conforms to distribution.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovTest	(	double[]	double[]	): Computes the p-value, or observed significance level, of a two-sample  Kolmogorov-Smirnov test evaluating the null hypothesis that x and y are samples drawn from the same probability distribution. Assumes the strict form of the inequality used to compute the p-value. See kolmogorovSmirnovTest().
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.kolmogorovSmirnovTest	(	double[]	double[]	boolean	): Computes the p-value, or observed significance level, of a two-sample  Kolmogorov-Smirnov test evaluating the null hypothesis that x and y are samples drawn from the same probability distribution. Specifically, what is returned is an estimate of the probability that the kolmogorovSmirnovStatistic() associated with a randomly selected partition of the combined sample into subsamples of sizes x.length and y.length will strictly exceed (if strict is true) or be at least as large as (if strict is false) as kolmogorovSmirnovStatistic(x, y).
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.ksSum	(	double	double	int	): Computes \( 1 + 2 \sum_{i=1}^\infty (-1)^i e^{-2 i^2 t^2} \) stopping when successive partial sums are within tolerance of one another, or when maxIterations partial sums have been computed. If the sum does not converge before maxIterations iterations a TooManyIterationsException is thrown.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.monteCarloP	(	double	int	int	boolean	int	UniformRandomProvider	): Uses Monte Carlo simulation to approximate \(P(D_{n,m} > d)\) where \(D_{n,m}\) is the 2-sample Kolmogorov-Smirnov statistic. See kolmogorovSmirnovStatistic() for the definition of \(D_{n,m}\).  The simulation generates iterations random partitions of m + n into an n set and an m set, computing \(D_{n,m}\) for each partition and returning the proportion of values that are greater than d, or greater than or equal to d if strict is false. 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.n	(	int	int	int	int	long	boolean	): The function N(i, j) defined in [4] (class javadoc). Returns the number of paths over the lattice {(i,j) : 0 <= i <= n, 0 <= j <= m} from (0,0) to (i,j) satisfying C(h,k, m, n, c) = 1 for each (h,k) on the path. The return value is integral, but subject to overflow, so it is maintained and returned as a double.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.pelzGood	(	double	int	): Computes the Pelz-Good approximation for \(P(D_n < d)\) as described in [2] in the class javadoc.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTest.roundedK	(	double	int	): Calculates P(D_n < d) using method described in [1] and doubles (see above).
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest: Test cases for KolmogorovSmirnovTest.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.checkApproximateTable	(	int	int	double	double	double	): Verifies that approximateP(criticalValue, n, m) is within epsilon of alpha.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.checkExactTable	(	int	int	double	double	): Verifies the inequality exactP(criticalValue, n, m, true) < alpha < exactP(criticalValue, n, m, false). Note that the validity of this check depends on the fact that alpha lies strictly between two attained values of the distribution and that criticalValue is one of the attained values. The critical value table (reference below) uses attained values. This test therefore also verifies that criticalValue is attained.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.checkFixTies	(	double[]	double[]	): Checks that fixTies eliminates ties in the data but does not otherwise perturb the ordering.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.fixTies	(	double[]	double[]	): Reflection hack to expose private fixTies method for testing.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.hasTies	(	double[]	double[]	): Reflection hack to expose private hasTies method.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testBootstrapLargeSamples	(	): Reference data is R 3.2.0, ks.boot implemented in Matching (Version 4.8-3.4, Build Date: 2013/10/28)
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testBootstrapRounding	(	): Test an example where D-values are close (subject to rounding). Reference data is R 3.2.0, ks.boot implemented in Matching (Version 4.8-3.4, Build Date: 2013/10/28)
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testBootstrapSmallSamplesWithTies	(	): Test an example with ties in the data. Reference data is R 3.2.0, ks.boot implemented in Matching (Version 4.8-3.4, Build Date: 2013/10/28)
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testDRounding	(	): JIRA: MATH-1245 Verify that D-values are not viewed as distinct when they are mathematically equal when computing p-statistics for small sample tests. Reference values are from R 3.2.0.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testDRoundingMonteCarlo	(	): JIRA: MATH-1245 Verify that D-values are not viewed as distinct when they are mathematically equal when computing p-statistics for small sample tests. Reference values are from R 3.2.0.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testFixTiesConsistency	(	): Verify that fixTies is deterministic, i.e, x = x', y = y' => fixTies(x,y) = fixTies(x', y')
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testOneSampleGaussianGaussian	(	): Unit normal distribution, unit normal data 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testOneSampleGaussianGaussianSmallSample	(	): Unit normal distribution, unit normal data, small dataset 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testOneSampleGaussianUniform	(	): Unit normal distribution, uniform data 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testOneSampleUniformGaussian	(	): Uniform distribution, unit normal dataset 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testOneSampleUniformUniform	(	): Uniform distribution, uniform data 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testOneSampleUniformUniformSmallSample	(	): Uniform distribution, uniform data, small dataset 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleApproximateP	(	): Verifies large sample approximate p values against R 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleExactP	(	): Checks exact p-value computations using critical values from Table 9 in V.K Rohatgi, An Introduction to Probability and Mathematical Statistics, Wiley, 1976, ISBN 0-471-73135-8.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleMonteCarlo	(	): Verifies that Monte Carlo simulation gives results close to exact p values.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleMonteCarloPerformance	(	): Performance test for monteCarlo method. Disabled by default.
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleProductSizeOverflow	(	): MATH-1181 Verify that large sample method is selected for sample product > Integer.MAX_VALUE (integer overflow in sample product)
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleSmallSampleExact	(	): Small samples - exact p-value, checked against R 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleSmallSampleExact2	(	): Small samples - exact p-value, checked against R 
org.apache.commons.math4.stat.inference.KolmogorovSmirnovTestTest.testTwoSampleSmallSampleExact3	(	): Small samples - exact p-value, checked against R 
org.apache.commons.math4.stat.inference.MannWhitneyUTest: An implementation of the Mann-Whitney U test (also called Wilcoxon rank-sum test).
org.apache.commons.math4.stat.inference.MannWhitneyUTest.MannWhitneyUTest	(	): Create a test instance using where NaN's are left in place and ties get the average of applicable ranks. Use this unless you are very sure of what you are doing.
org.apache.commons.math4.stat.inference.MannWhitneyUTest.MannWhitneyUTest	(	NaNStrategy	TiesStrategy	): Create a test instance using the given strategies for NaN's and ties. Only use this if you are sure of what you are doing.
org.apache.commons.math4.stat.inference.MannWhitneyUTest.calculateAsymptoticPValue	(	double	int	int	): 
org.apache.commons.math4.stat.inference.MannWhitneyUTest.concatenateSamples	(	double[]	double[]	): Concatenate the samples into one array.
org.apache.commons.math4.stat.inference.MannWhitneyUTest.ensureDataConformance	(	double[]	double[]	): Ensures that the provided arrays fulfills the assumptions.
org.apache.commons.math4.stat.inference.MannWhitneyUTest.mannWhitneyU	(	double[]	double[]	): Computes the  Mann-Whitney U statistic comparing mean for two independent samples possibly of different length.  This statistic can be used to perform a Mann-Whitney U test evaluating the null hypothesis that the two independent samples has equal mean.   Let Xi denote the i'th individual of the first sample and Yj the j'th individual in the second sample. Note that the samples would often have different length.   Preconditions:  All observations in the two samples are independent. The observations are at least ordinal (continuous are also ordinal). 
org.apache.commons.math4.stat.inference.MannWhitneyUTest.mannWhitneyUTest	(	double[]	double[]	): Returns the asymptotic observed significance level, or  p-value, associated with a  Mann-Whitney U statistic comparing mean for two independent samples.  Let Xi denote the i'th individual of the first sample and Yj the j'th individual in the second sample. Note that the samples would often have different length.   Preconditions:  All observations in the two samples are independent. The observations are at least ordinal (continuous are also ordinal).  Ties give rise to biased variance at the moment. See e.g. http://mlsc.lboro.ac.uk/resources/statistics/Mannwhitney.pdf.
org.apache.commons.math4.stat.inference.MannWhitneyUTestTest: Test cases for the MannWhitneyUTestImpl class.
org.apache.commons.math4.stat.inference.OneWayAnova: Implements one-way ANOVA (analysis of variance) statistics.  Tests for differences between two or more categories of univariate data (for example, the body mass index of accountants, lawyers, doctors and computer programmers). When two categories are given, this is equivalent to the org.apache.commons.math4.stat.inference.TTest.  Uses the org.apache.commons.math4.distribution.FDistribution commons-math F Distribution implementation to estimate exact p-values. This implementation is based on a description at http://faculty.vassar.edu/lowry/ch13pt1.html  Abbreviations: bg = between groups, wg = within groups, ss = sum squared deviations 
org.apache.commons.math4.stat.inference.OneWayAnova.AnovaStats: Convenience class to pass dfbg,dfwg,F values around within OneWayAnova. No get/set methods provided.
org.apache.commons.math4.stat.inference.OneWayAnova.AnovaStats.AnovaStats	(	int	int	double	): Constructor
org.apache.commons.math4.stat.inference.OneWayAnova.OneWayAnova	(	): Default constructor.
org.apache.commons.math4.stat.inference.OneWayAnova.anovaFValue	(	Collection	): Computes the ANOVA F-value for a collection of double[] arrays. Preconditions:  The categoryData Collection must contain double[] arrays.  There must be at least two double[] arrays in the categoryData collection and each of these arrays must contain at least two values. This implementation computes the F statistic using the definitional formula F = msbg/mswg where msbg = between group mean square mswg = within group mean square are as defined  here
org.apache.commons.math4.stat.inference.OneWayAnova.anovaPValue	(	Collection	): Computes the ANOVA P-value for a collection of double[] arrays. Preconditions:  The categoryData Collection must contain double[] arrays.  There must be at least two double[] arrays in the categoryData collection and each of these arrays must contain at least two values. This implementation uses the org.apache.commons.math4.distribution.FDistribution commons-math F Distribution implementation to estimate the exact p-value, using the formula p = 1 - cumulativeProbability(F) where F is the F value and cumulativeProbability is the commons-math implementation of the F distribution.
org.apache.commons.math4.stat.inference.OneWayAnova.anovaPValue	(	Collection	boolean	): Computes the ANOVA P-value for a collection of SummaryStatistics. Preconditions:  The categoryData Collection must contain SummaryStatistics.  There must be at least two SummaryStatistics in the categoryData collection and each of these statistics must contain at least two values. This implementation uses the org.apache.commons.math4.distribution.FDistribution commons-math F Distribution implementation to estimate the exact p-value, using the formula p = 1 - cumulativeProbability(F) where F is the F value and cumulativeProbability is the commons-math implementation of the F distribution.
org.apache.commons.math4.stat.inference.OneWayAnova.anovaStats	(	Collection	): This method calls the method that actually does the calculations (except P-value).
org.apache.commons.math4.stat.inference.OneWayAnova.anovaStats	(	Collection	boolean	): This method actually does the calculations (except P-value).
org.apache.commons.math4.stat.inference.OneWayAnova.anovaTest	(	Collection	double	): Performs an ANOVA test, evaluating the null hypothesis that there is no difference among the means of the data categories. Preconditions:  The categoryData Collection must contain double[] arrays.  There must be at least two double[] arrays in the categoryData collection and each of these arrays must contain at least two values. alpha must be strictly greater than 0 and less than or equal to 0.5.  This implementation uses the org.apache.commons.math4.distribution.FDistribution commons-math F Distribution implementation to estimate the exact p-value, using the formula p = 1 - cumulativeProbability(F) where F is the F value and cumulativeProbability is the commons-math implementation of the F distribution. True is returned iff the estimated p-value is less than alpha.
org.apache.commons.math4.stat.inference.OneWayAnovaTest: Test cases for the OneWayAnovaImpl class.
org.apache.commons.math4.stat.inference.TTest: An implementation for Student's t-tests.  Tests can be: One-sample or two-sample One-sided or two-sided Paired or unpaired (for two-sample tests) Homoscedastic (equal variance assumption) or heteroscedastic (for two sample tests) Fixed significance level (boolean-valued) or returning p-values.   Test statistics are available for all tests. Methods including "Test" in in their names perform tests, all other methods return t-statistics. Among the "Test" methods, double-valued methods return p-values; boolean-valued methods perform fixed significance level tests. Significance levels are always specified as numbers between 0 and 0.5 (e.g. tests at the 95% level use alpha=0.05).  Input to tests can be either double[] arrays or StatisticalSummary instances. Uses commons-math org.apache.commons.math4.distribution.TDistribution implementation to estimate exact p-values.
org.apache.commons.math4.stat.inference.TTest.checkSampleData	(	StatisticalSummary	): Check sample data.
org.apache.commons.math4.stat.inference.TTest.checkSampleData	(	double[]	): Check sample data.
org.apache.commons.math4.stat.inference.TTest.checkSignificanceLevel	(	double	): Check significance level.
org.apache.commons.math4.stat.inference.TTest.df	(	double	double	double	double	): Computes approximate degrees of freedom for 2-sample t-test.
org.apache.commons.math4.stat.inference.TTest.homoscedasticT	(	StatisticalSummary	StatisticalSummary	): Computes a 2-sample t statistic, comparing the means of the datasets described by two StatisticalSummary instances, under the assumption of equal subpopulation variances. To compute a t-statistic without the equal variances assumption, use t().  This statistic can be used to perform a (homoscedastic) two-sample t-test to compare sample means.  The t-statistic returned is     t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))  where n1 is the size of first sample;  n2 is the size of second sample;  m1 is the mean of first sample;  m2 is the mean of second sample and var is the pooled variance estimate:  var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))  with var1 the variance of the first sample and var2 the variance of the second sample.  Preconditions:  The datasets described by the two Univariates must each contain at least 2 observations. 
org.apache.commons.math4.stat.inference.TTest.homoscedasticT	(	double	double	double	double	double	double	): Computes t test statistic for 2-sample t-test under the hypothesis of equal subpopulation variances.
org.apache.commons.math4.stat.inference.TTest.homoscedasticT	(	double[]	double[]	): Computes a 2-sample t statistic, under the hypothesis of equal subpopulation variances. To compute a t-statistic without the equal variances hypothesis, use t().  This statistic can be used to perform a (homoscedastic) two-sample t-test to compare sample means.  The t-statistic is     t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))  where n1 is the size of first sample;  n2 is the size of second sample;  m1 is the mean of first sample;  m2 is the mean of second sample and var is the pooled variance estimate:  var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))  with var1 the variance of the first sample and var2 the variance of the second sample.  Preconditions:  The observed array lengths must both be at least 2. 
org.apache.commons.math4.stat.inference.TTest.homoscedasticTTest	(	StatisticalSummary	StatisticalSummary	): Returns the observed significance level, or p-value, associated with a two-sample, two-tailed t-test comparing the means of the datasets described by two StatisticalSummary instances, under the hypothesis of equal subpopulation variances. To perform a test without the equal variances assumption, use tTest().  The number returned is the smallest significance level at which one can reject the null hypothesis that the two means are equal in favor of the two-sided alternative that they are different. For a one-sided test, divide the returned value by 2.  See homoscedasticT() for the formula used to compute the t-statistic. The sum of the sample sizes minus 2 is used as the degrees of freedom.  Usage Note: The validity of the p-value depends on the assumptions of the parametric t-test procedure, as discussed here  Preconditions:  The datasets described by the two Univariates must each contain at least 2 observations. 
org.apache.commons.math4.stat.inference.TTest.homoscedasticTTest	(	double	double	double	double	double	double	): Computes p-value for 2-sided, 2-sample t-test, under the assumption of equal subpopulation variances.  The sum of the sample sizes minus 2 is used as degrees of freedom.
org.apache.commons.math4.stat.inference.TTest.homoscedasticTTest	(	double[]	double[]	): Returns the observed significance level, or p-value, associated with a two-sample, two-tailed t-test comparing the means of the input arrays, under the assumption that the two samples are drawn from subpopulations with equal variances. To perform the test without the equal variances assumption, use tTest().  The number returned is the smallest significance level at which one can reject the null hypothesis that the two means are equal in favor of the two-sided alternative that they are different. For a one-sided test, divide the returned value by 2.  A pooled variance estimate is used to compute the t-statistic. See homoscedasticT(). The sum of the sample sizes minus 2 is used as the degrees of freedom.  Usage Note: The validity of the p-value depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The observed array lengths must both be at least 2. 
org.apache.commons.math4.stat.inference.TTest.homoscedasticTTest	(	double[]	double[]	double	): Performs a  two-sided t-test evaluating the null hypothesis that sample1 and sample2 are drawn from populations with the same mean, with significance level alpha, assuming that the subpopulation variances are equal. Use tTest() to perform the test without the assumption of equal variances.  Returns true iff the null hypothesis that the means are equal can be rejected with confidence 1 - alpha. To perform a 1-sided test, use alpha * 2. To perform the test without the assumption of equal subpopulation variances, use tTest().  A pooled variance estimate is used to compute the t-statistic. See t() for the formula. The sum of the sample sizes minus 2 is used as the degrees of freedom.  Examples: To test the (2-sided) hypothesis mean 1 = mean 2  at the 95% level, use tTest(sample1, sample2, 0.05).   To test the (one-sided) hypothesis  mean 1 < mean 2,  at the 99% level, first verify that the measured mean of sample 1 is less than the mean of sample 2 and then use tTest(sample1, sample2, 0.02)    Usage Note: The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The observed array lengths must both be at least 2.    0 < alpha < 0.5  
org.apache.commons.math4.stat.inference.TTest.pairedT	(	double[]	double[]	): Computes a paired, 2-sample t-statistic based on the data in the input arrays. The t-statistic returned is equivalent to what would be returned by computing the one-sample t-statistic t(), with mu = 0 and the sample array consisting of the (signed) differences between corresponding entries in sample1 and sample2.  Preconditions:  The input arrays must have the same length and their common length must be at least 2. 
org.apache.commons.math4.stat.inference.TTest.pairedTTest	(	double[]	double[]	): Returns the observed significance level, or  p-value, associated with a paired, two-sample, two-tailed t-test based on the data in the input arrays.  The number returned is the smallest significance level at which one can reject the null hypothesis that the mean of the paired differences is 0 in favor of the two-sided alternative that the mean paired difference is not equal to 0. For a one-sided test, divide the returned value by 2.  This test is equivalent to a one-sample t-test computed using tTest() with mu = 0 and the sample array consisting of the signed differences between corresponding elements of sample1 and sample2.  Usage Note: The validity of the p-value depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The input array lengths must be the same and their common length must be at least 2. 
org.apache.commons.math4.stat.inference.TTest.pairedTTest	(	double[]	double[]	double	): Performs a paired t-test evaluating the null hypothesis that the mean of the paired differences between sample1 and sample2 is 0 in favor of the two-sided alternative that the mean paired difference is not equal to 0, with significance level alpha.  Returns true iff the null hypothesis can be rejected with confidence 1 - alpha. To perform a 1-sided test, use alpha * 2  Usage Note: The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The input array lengths must be the same and their common length must be at least 2.    0 < alpha < 0.5  
org.apache.commons.math4.stat.inference.TTest.t	(	StatisticalSummary	StatisticalSummary	): Computes a 2-sample t statistic, comparing the means of the datasets described by two StatisticalSummary instances, without the assumption of equal subpopulation variances. Use homoscedasticT() to compute a t-statistic under the equal variances assumption.  This statistic can be used to perform a two-sample t-test to compare sample means.  The returned t-statistic is      t = (m1 - m2) / sqrt(var1/n1 + var2/n2)  where n1 is the size of the first sample;  n2 is the size of the second sample;  m1 is the mean of the first sample;  m2 is the mean of the second sample  var1 is the variance of the first sample;  var2 is the variance of the second sample  Preconditions:  The datasets described by the two Univariates must each contain at least 2 observations. 
org.apache.commons.math4.stat.inference.TTest.t	(	double	StatisticalSummary	): Computes a  t statistic  to use in comparing the mean of the dataset described by sampleStats to mu.  This statistic can be used to perform a one sample t-test for the mean.  Preconditions:  observed.getN() ≥ 2. 
org.apache.commons.math4.stat.inference.TTest.t	(	double	double	double	double	): Computes t test statistic for 1-sample t-test.
org.apache.commons.math4.stat.inference.TTest.t	(	double	double	double	double	double	double	): Computes t test statistic for 2-sample t-test.  Does not assume that subpopulation variances are equal.
org.apache.commons.math4.stat.inference.TTest.t	(	double	double[]	): Computes a  t statistic  given observed values and a comparison constant.  This statistic can be used to perform a one sample t-test for the mean.  Preconditions:  The observed array length must be at least 2. 
org.apache.commons.math4.stat.inference.TTest.t	(	double[]	double[]	): Computes a 2-sample t statistic, without the hypothesis of equal subpopulation variances. To compute a t-statistic assuming equal variances, use homoscedasticT().  This statistic can be used to perform a two-sample t-test to compare sample means.  The t-statistic is      t = (m1 - m2) / sqrt(var1/n1 + var2/n2)  where n1 is the size of the first sample  n2 is the size of the second sample;  m1 is the mean of the first sample;  m2 is the mean of the second sample;  var1 is the variance of the first sample;  var2 is the variance of the second sample;  Preconditions:  The observed array lengths must both be at least 2. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	StatisticalSummary	StatisticalSummary	): Returns the observed significance level, or p-value, associated with a two-sample, two-tailed t-test comparing the means of the datasets described by two StatisticalSummary instances.  The number returned is the smallest significance level at which one can reject the null hypothesis that the two means are equal in favor of the two-sided alternative that they are different. For a one-sided test, divide the returned value by 2.  The test does not assume that the underlying population variances are equal and it uses approximated degrees of freedom computed from the sample data to compute the p-value. To perform the test assuming equal variances, use homoscedasticTTest().  Usage Note: The validity of the p-value depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The datasets described by the two Univariates must each contain at least 2 observations. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	StatisticalSummary	StatisticalSummary	double	): Performs a  two-sided t-test evaluating the null hypothesis that sampleStats1 and sampleStats2 describe datasets drawn from populations with the same mean, with significance level alpha. This test does not assume that the subpopulation variances are equal. To perform the test under the equal variances assumption, use homoscedasticTTest().  Returns true iff the null hypothesis that the means are equal can be rejected with confidence 1 - alpha. To perform a 1-sided test, use alpha * 2  See t() for the formula used to compute the t-statistic. Degrees of freedom are approximated using the  Welch-Satterthwaite approximation.  Examples: To test the (2-sided) hypothesis mean 1 = mean 2  at the 95%, use tTest(sampleStats1, sampleStats2, 0.05)   To test the (one-sided) hypothesis  mean 1 < mean 2  at the 99% level, first verify that the measured mean of sample 1 is less than the mean of sample 2 and then use tTest(sampleStats1, sampleStats2, 0.02)    Usage Note: The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The datasets described by the two Univariates must each contain at least 2 observations.    0 < alpha < 0.5  
org.apache.commons.math4.stat.inference.TTest.tTest	(	double	StatisticalSummary	): Returns the observed significance level, or p-value, associated with a one-sample, two-tailed t-test comparing the mean of the dataset described by sampleStats with the constant mu.  The number returned is the smallest significance level at which one can reject the null hypothesis that the mean equals mu in favor of the two-sided alternative that the mean is different from mu. For a one-sided test, divide the returned value by 2.  Usage Note: The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The sample must contain at least 2 observations. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	double	StatisticalSummary	double	): Performs a  two-sided t-test evaluating the null hypothesis that the mean of the population from which the dataset described by stats is drawn equals mu.  Returns true iff the null hypothesis can be rejected with confidence 1 - alpha. To perform a 1-sided test, use alpha * 2.  Examples: To test the (2-sided) hypothesis sample mean = mu  at the 95% level, use tTest(mu, sampleStats, 0.05)   To test the (one-sided) hypothesis  sample mean < mu  at the 99% level, first verify that the measured sample mean is less than mu and then use tTest(mu, sampleStats, 0.02)    Usage Note: The validity of the test depends on the assumptions of the one-sample parametric t-test procedure, as discussed here  Preconditions:  The sample must include at least 2 observations. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	double	double	double	double	): Computes p-value for 2-sided, 1-sample t-test.
org.apache.commons.math4.stat.inference.TTest.tTest	(	double	double	double	double	double	double	): Computes p-value for 2-sided, 2-sample t-test.  Does not assume subpopulation variances are equal. Degrees of freedom are estimated from the data.
org.apache.commons.math4.stat.inference.TTest.tTest	(	double	double[]	): Returns the observed significance level, or p-value, associated with a one-sample, two-tailed t-test comparing the mean of the input array with the constant mu.  The number returned is the smallest significance level at which one can reject the null hypothesis that the mean equals mu in favor of the two-sided alternative that the mean is different from mu. For a one-sided test, divide the returned value by 2.  Usage Note: The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed here  Preconditions:  The observed array length must be at least 2. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	double	double[]	double	): Performs a  two-sided t-test evaluating the null hypothesis that the mean of the population from which sample is drawn equals mu.  Returns true iff the null hypothesis can be rejected with confidence 1 - alpha. To perform a 1-sided test, use alpha * 2  Examples: To test the (2-sided) hypothesis sample mean = mu  at the 95% level, use tTest(mu, sample, 0.05)   To test the (one-sided) hypothesis  sample mean < mu  at the 99% level, first verify that the measured sample mean is less than mu and then use tTest(mu, sample, 0.02)    Usage Note: The validity of the test depends on the assumptions of the one-sample parametric t-test procedure, as discussed here  Preconditions:  The observed array length must be at least 2. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	double[]	double[]	): Returns the observed significance level, or p-value, associated with a two-sample, two-tailed t-test comparing the means of the input arrays.  The number returned is the smallest significance level at which one can reject the null hypothesis that the two means are equal in favor of the two-sided alternative that they are different. For a one-sided test, divide the returned value by 2.  The test does not assume that the underlying popuation variances are equal and it uses approximated degrees of freedom computed from the sample data to compute the p-value. The t-statistic used is as defined in t() and the Welch-Satterthwaite approximation to the degrees of freedom is used, as described  here. To perform the test under the assumption of equal subpopulation variances, use homoscedasticTTest().  Usage Note: The validity of the p-value depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The observed array lengths must both be at least 2. 
org.apache.commons.math4.stat.inference.TTest.tTest	(	double[]	double[]	double	): Performs a  two-sided t-test evaluating the null hypothesis that sample1 and sample2 are drawn from populations with the same mean, with significance level alpha. This test does not assume that the subpopulation variances are equal. To perform the test assuming equal variances, use homoscedasticTTest().  Returns true iff the null hypothesis that the means are equal can be rejected with confidence 1 - alpha. To perform a 1-sided test, use alpha * 2  See t() for the formula used to compute the t-statistic. Degrees of freedom are approximated using the  Welch-Satterthwaite approximation.  Examples: To test the (2-sided) hypothesis mean 1 = mean 2  at the 95% level, use tTest(sample1, sample2, 0.05).   To test the (one-sided) hypothesis  mean 1 < mean 2 , at the 99% level, first verify that the measured mean of sample 1 is less than the mean of sample 2 and then use tTest(sample1, sample2, 0.02)    Usage Note: The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  here  Preconditions:  The observed array lengths must both be at least 2.    0 < alpha < 0.5  
org.apache.commons.math4.stat.inference.TTestTest: Test cases for the TTestImpl class.
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest: An implementation of the Wilcoxon signed-rank test.
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.WilcoxonSignedRankTest	(	): Create a test instance where NaN's are left in place and ties get the average of applicable ranks. Use this unless you are very sure of what you are doing.
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.WilcoxonSignedRankTest	(	NaNStrategy	TiesStrategy	): Create a test instance using the given strategies for NaN's and ties. Only use this if you are sure of what you are doing.
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.calculateAbsoluteDifferences	(	double[]	): Calculates |z[i]| for all i
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.calculateAsymptoticPValue	(	double	int	): 
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.calculateDifferences	(	double[]	double[]	): Calculates y[i] - x[i] for all i
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.calculateExactPValue	(	double	int	): Algorithm inspired by http://www.fon.hum.uva.nl/Service/Statistics/Signed_Rank_Algorihms.html#C by Rob van Son, Institute of Phonetic Sciences & IFOTT, University of Amsterdam
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.ensureDataConformance	(	double[]	double[]	): Ensures that the provided arrays fulfills the assumptions.
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.wilcoxonSignedRank	(	double[]	double[]	): Computes the  Wilcoxon signed ranked statistic comparing mean for two related samples or repeated measurements on a single sample.  This statistic can be used to perform a Wilcoxon signed ranked test evaluating the null hypothesis that the two related samples or repeated measurements on a single sample has equal mean.   Let Xi denote the i'th individual of the first sample and Yi the related i'th individual in the second sample. Let Zi = Yi - Xi.   Preconditions:  The differences Zi must be independent. Each Zi comes from a continuous population (they must be identical) and is symmetric about a common median. The values that Xi and Yi represent are ordered, so the comparisons greater than, less than, and equal to are meaningful. 
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTest.wilcoxonSignedRankTest	(	double[]	double[]	boolean	): Returns the observed significance level, or  p-value, associated with a  Wilcoxon signed ranked statistic comparing mean for two related samples or repeated measurements on a single sample.  Let Xi denote the i'th individual of the first sample and Yi the related i'th individual in the second sample. Let Zi = Yi - Xi.   Preconditions:  The differences Zi must be independent. Each Zi comes from a continuous population (they must be identical) and is symmetric about a common median. The values that Xi and Yi represent are ordered, so the comparisons greater than, less than, and equal to are meaningful. 
org.apache.commons.math4.stat.inference.WilcoxonSignedRankTestTest: Test cases for the WilcoxonSignedRangTest class.
org.apache.commons.math4.stat.interval.AgrestiCoullInterval: Implements the Agresti-Coull method for creating a binomial proportion confidence interval.
org.apache.commons.math4.stat.interval.AgrestiCoullInterval.createInterval	(	int	int	double	): Create a confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.  Preconditions:  numberOfTrials must be positive numberOfSuccesses may not exceed numberOfTrials confidenceLevel must be strictly between 0 and 1 (exclusive)  
org.apache.commons.math4.stat.interval.AgrestiCoullIntervalTest: Test cases for the AgrestiCoullInterval class.
org.apache.commons.math4.stat.interval.BinomialConfidenceInterval: Interface to generate confidence intervals for a binomial proportion.
org.apache.commons.math4.stat.interval.BinomialConfidenceInterval.createInterval	(	int	int	double	): Create a confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.  Preconditions:  numberOfTrials must be positive numberOfSuccesses may not exceed numberOfTrials confidenceLevel must be strictly between 0 and 1 (exclusive) 
org.apache.commons.math4.stat.interval.BinomialConfidenceIntervalAbstractTest: Test cases for the BinomialConfidenceInterval implementations.
org.apache.commons.math4.stat.interval.BinomialConfidenceIntervalAbstractTest.createStandardTestInterval	(	): Returns the confidence interval for the given statistic with the following values:  trials: 500 successes: 50 confidenceLevel: 0.9 
org.apache.commons.math4.stat.interval.ClopperPearsonInterval: Implements the Clopper-Pearson method for creating a binomial proportion confidence interval.
org.apache.commons.math4.stat.interval.ClopperPearsonInterval.createInterval	(	int	int	double	): Create a confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.  Preconditions:  numberOfTrials must be positive numberOfSuccesses may not exceed numberOfTrials confidenceLevel must be strictly between 0 and 1 (exclusive)  
org.apache.commons.math4.stat.interval.ClopperPearsonIntervalTest: Test cases for the ClopperPearsonInterval class.
org.apache.commons.math4.stat.interval.ConfidenceInterval: Represents an interval estimate of a population parameter.
org.apache.commons.math4.stat.interval.ConfidenceInterval.ConfidenceInterval	(	double	double	double	): Create a confidence interval with the given bounds and confidence level.  Preconditions:  lower must be strictly less than upper confidenceLevel must be strictly between 0 and 1 (exclusive) 
org.apache.commons.math4.stat.interval.ConfidenceInterval.checkParameters	(	double	double	double	): Verifies that (lower, upper) is a valid non-empty interval and confidence is strictly between 0 and 1.
org.apache.commons.math4.stat.interval.ConfidenceInterval.getConfidenceLevel	(	): 
org.apache.commons.math4.stat.interval.ConfidenceInterval.getLowerBound	(	): 
org.apache.commons.math4.stat.interval.ConfidenceInterval.getUpperBound	(	): 
org.apache.commons.math4.stat.interval.ConfidenceInterval.toString	(	): 
org.apache.commons.math4.stat.interval.IntervalUtils: Factory methods to generate confidence intervals for a binomial proportion. The supported methods are:  Agresti-Coull interval Clopper-Pearson method (exact method) Normal approximation (based on central limit theorem) Wilson score interval 
org.apache.commons.math4.stat.interval.IntervalUtils.IntervalUtils	(	): Prevent instantiation.
org.apache.commons.math4.stat.interval.IntervalUtils.checkParameters	(	int	int	double	): Verifies that parameters satisfy preconditions.
org.apache.commons.math4.stat.interval.IntervalUtils.getAgrestiCoullInterval	(	int	int	double	): Create an Agresti-Coull binomial confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.
org.apache.commons.math4.stat.interval.IntervalUtils.getClopperPearsonInterval	(	int	int	double	): Create a Clopper-Pearson binomial confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.  Preconditions:  numberOfTrials must be positive numberOfSuccesses may not exceed numberOfTrials confidenceLevel must be strictly between 0 and 1 (exclusive) 
org.apache.commons.math4.stat.interval.IntervalUtils.getNormalApproximationInterval	(	int	int	double	): Create a binomial confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level using the Normal approximation to the binomial distribution.
org.apache.commons.math4.stat.interval.IntervalUtils.getWilsonScoreInterval	(	int	int	double	): Create a Wilson score binomial confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.
org.apache.commons.math4.stat.interval.IntervalUtilsTest: Test cases for the IntervalUtils class.
org.apache.commons.math4.stat.interval.NormalApproximationInterval: Implements the normal approximation method for creating a binomial proportion confidence interval.
org.apache.commons.math4.stat.interval.NormalApproximationInterval.createInterval	(	int	int	double	): Create a confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.  Preconditions:  numberOfTrials must be positive numberOfSuccesses may not exceed numberOfTrials confidenceLevel must be strictly between 0 and 1 (exclusive)  
org.apache.commons.math4.stat.interval.NormalApproximationIntervalTest: Test cases for the NormalApproximationInterval class.
org.apache.commons.math4.stat.interval.WilsonScoreInterval: Implements the  Wilson score method for creating a binomial proportion confidence interval.
org.apache.commons.math4.stat.interval.WilsonScoreInterval.createInterval	(	int	int	double	): Create a confidence interval for the true probability of success of an unknown binomial distribution with the given observed number of trials, successes and confidence level.  Preconditions:  numberOfTrials must be positive numberOfSuccesses may not exceed numberOfTrials confidenceLevel must be strictly between 0 and 1 (exclusive)  
org.apache.commons.math4.stat.interval.WilsonScoreIntervalTest: Test cases for the WilsonScoreInterval class.
org.apache.commons.math4.stat.ranking.NaturalRanking: Ranking based on the natural ordering on doubles. NaNs are treated according to the configured NaNStrategy and ties are handled using the selected TiesStrategy. Configuration settings are supplied in optional constructor arguments. Defaults are FAILED and AVERAGE, respectively. When using RANDOM, a UniformRandomProvider random generator may be supplied as a constructor argument. Examples:   Input data: (20, 17, 30, 42.3, 17, 50, Double.NaN, Double.NEGATIVE_INFINITY, 17)  NaNStrategyTiesStrategy rank(data)  default (NaNs maximal) default (ties averaged) (5, 3, 6, 7, 3, 8, 9, 1, 3)  default (NaNs maximal) MINIMUM (5, 2, 6, 7, 2, 8, 9, 1, 2)  MINIMAL default (ties averaged) (6, 4, 7, 8, 4, 9, 1.5, 1.5, 4)  REMOVED SEQUENTIAL (5, 2, 6, 7, 3, 8, 1, 4)  MINIMAL MAXIMUM (6, 5, 7, 8, 5, 9, 2, 2, 5)
org.apache.commons.math4.stat.ranking.NaturalRanking.IntDoublePair: Represents the position of a double value in an ordering. Comparable interface is implemented so Arrays.sort can be used to sort an array of IntDoublePairs by value. Note that the implicitly defined natural ordering is NOT consistent with equals.
org.apache.commons.math4.stat.ranking.NaturalRanking.IntDoublePair.IntDoublePair	(	double	int	): Construct an IntDoublePair with the given value and position.
org.apache.commons.math4.stat.ranking.NaturalRanking.IntDoublePair.compareTo	(	IntDoublePair	): Compare this IntDoublePair to another pair. Only the values are compared.
org.apache.commons.math4.stat.ranking.NaturalRanking.IntDoublePair.getPosition	(	): Returns the original position of the pair.
org.apache.commons.math4.stat.ranking.NaturalRanking.IntDoublePair.getValue	(	): Returns the value of the pair.
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	): Create a NaturalRanking with default strategies for handling ties and NaNs.
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	NaNStrategy	): Create a NaturalRanking with the given NaNStrategy.
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	NaNStrategy	TiesStrategy	): Create a NaturalRanking with the given NaNStrategy and TiesStrategy.
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	NaNStrategy	TiesStrategy	UniformRandomProvider	): 
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	NaNStrategy	UniformRandomProvider	): Create a NaturalRanking with the given NaNStrategy, TiesStrategy.RANDOM and the given source of random data.
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	TiesStrategy	): Create a NaturalRanking with the given TiesStrategy.
org.apache.commons.math4.stat.ranking.NaturalRanking.NaturalRanking	(	UniformRandomProvider	): Create a NaturalRanking with TiesStrategy.RANDOM and the given random generator as the source of random data.
org.apache.commons.math4.stat.ranking.NaturalRanking.containsNaNs	(	IntDoublePair[]	): Checks for presence of NaNs in ranks.
org.apache.commons.math4.stat.ranking.NaturalRanking.fill	(	double[]	List	double	): Setsdata[i] = value for each i in tiesTrace.
org.apache.commons.math4.stat.ranking.NaturalRanking.getNanPositions	(	IntDoublePair[]	): Returns a list of indexes where ranks is NaN.
org.apache.commons.math4.stat.ranking.NaturalRanking.getNanStrategy	(	): Return the NaNStrategy
org.apache.commons.math4.stat.ranking.NaturalRanking.getTiesStrategy	(	): Return the TiesStrategy
org.apache.commons.math4.stat.ranking.NaturalRanking.rank	(	double[]	): Rank data using the natural ordering on Doubles, with NaN values handled according to nanStrategy and ties resolved using tiesStrategy.
org.apache.commons.math4.stat.ranking.NaturalRanking.recodeNaNs	(	IntDoublePair[]	double	): Recodes NaN values to the given value.
org.apache.commons.math4.stat.ranking.NaturalRanking.removeNaNs	(	IntDoublePair[]	): Returns an array that is a copy of the input array with IntDoublePairs having NaN values removed.
org.apache.commons.math4.stat.ranking.NaturalRanking.resolveTie	(	double[]	List	): Resolve a sequence of ties, using the configured TiesStrategy. The input ranks array is expected to take the same value for all indices in tiesTrace. The common value is recoded according to the tiesStrategy. For example, if ranks = <5,8,2,6,2,7,1,2>, tiesTrace = <2,4,7> and tiesStrategy is MINIMUM, ranks will be unchanged. The same array and trace with tiesStrategy AVERAGE will come out <5,8,3,6,3,7,1,3>.
org.apache.commons.math4.stat.ranking.NaturalRanking.restoreNaNs	(	double[]	List	): Set ranks[i] = Double.NaN for each i in nanPositions.
org.apache.commons.math4.stat.ranking.NaturalRankingTest: Test cases for NaturalRanking class
org.apache.commons.math4.stat.ranking.RankingAlgorithm: Interface representing a rank transformation.
org.apache.commons.math4.stat.ranking.RankingAlgorithm.rank	(	double[]	): Performs a rank transformation on the input data, returning an array of ranks. Ranks should be 1-based - that is, the smallest value returned in an array of ranks should be greater than or equal to one, rather than 0. Ranks should in general take integer values, though implementations may return averages or other floating point values to resolve ties in the input data.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression: Abstract base class for implementations of MultipleLinearRegression.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.calculateBeta	(	): Calculates the beta of multiple linear regression in matrix notation.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.calculateBetaVariance	(	): Calculates the beta variance of multiple linear regression in matrix notation.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.calculateErrorVariance	(	): Calculates the variance of the error term. Uses the formula  var(u) = u · u / (n - k)  where n and k are the row and column dimensions of the design matrix X.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.calculateResiduals	(	): Calculates the residuals of multiple linear regression in matrix notation.  u = y - X * b 
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.calculateYVariance	(	): Calculates the variance of the y values.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateErrorVariance	(	): Estimates the variance of the error.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateRegressandVariance	(	): Returns the variance of the regressand, ie Var(y).
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateRegressionParameters	(	): Estimates the regression parameters b.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateRegressionParametersStandardErrors	(	): Returns the standard errors of the regression parameters.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateRegressionParametersVariance	(	): Estimates the variance of the regression parameters, ie Var(b).
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateRegressionStandardError	(	): Estimates the standard error of the regression.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.estimateResiduals	(	): Estimates the residuals, ie u = y - X*b.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.getX	(	): 
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.getY	(	): 
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.isNoIntercept	(	): 
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.newSampleData	(	double[]	int	int	): Loads model x and y sample data from a flat input array, overriding any previous sample.  Assumes that rows are concatenated with y values first in each row. For example, an input data array containing the sequence of values (1, 2, 3, 4, 5, 6, 7, 8, 9) with nobs = 3 and nvars = 2 creates a regression dataset with two independent variables, as below:  y x[0] x[1] -------------- 1 2 3 4 5 6 7 8 9  Note that there is no need to add an initial unitary column (column of 1's) when specifying a model including an intercept term. If isNoIntercept() is true, the X matrix will be created without an initial column of "1"s; otherwise this column will be added.  Throws IllegalArgumentException if any of the following preconditions fail: data cannot be null data.length = nobs * (nvars + 1) nobs > nvars
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.newXSampleData	(	double[][]	): Loads new x sample data, overriding any previous data.  The input x array should have one row for each sample observation, with columns corresponding to independent variables. For example, if   x = new double[][] {{1, 2}, {3, 4}, {5, 6}}  then setXSampleData(x)  results in a model with two independent variables and 3 observations:  x[0] x[1] ---------- 1 2 3 4 5 6  Note that there is no need to add an initial unitary column (column of 1's) when specifying a model including an intercept term. 
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.newYSampleData	(	double[]	): Loads new y sample data, overriding any previous data.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.setNoIntercept	(	boolean	): 
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.validateCovarianceData	(	double[][]	double[][]	): Validates that the x data and covariance matrix have the same number of rows and that the covariance matrix is square.
org.apache.commons.math4.stat.regression.AbstractMultipleLinearRegression.validateSampleData	(	double[][]	double[]	): Validates sample data. Checks that Neither x nor y is null or empty; The length (i.e. number of rows) of x equals the length of y x has at least one more row than it has columns (i.e. there is sufficient data to estimate regression coefficients for each of the columns in x plus an intercept. 
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression: The GLS implementation of multiple linear regression. GLS assumes a general covariance matrix Omega of the error  u ~ N(0, Omega)  Estimated by GLS,  b=(X' Omega^-1 X)^-1X'Omega^-1 y  whose variance is  Var(b)=(X' Omega^-1 X)^-1 
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression.calculateBeta	(	): Calculates beta by GLS.  b=(X' Omega^-1 X)^-1X'Omega^-1 y 
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression.calculateBetaVariance	(	): Calculates the variance on the beta.  Var(b)=(X' Omega^-1 X)^-1 
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression.calculateErrorVariance	(	): Calculates the estimated variance of the error term using the formula  Var(u) = Tr(u' Omega^-1 u)/(n-k)  where n and k are the row and column dimensions of the design matrix X.
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression.getOmegaInverse	(	): Get the inverse of the covariance. The inverse of the covariance matrix is lazily evaluated and cached.
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression.newCovarianceData	(	double[][]	): Add the covariance data.
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegression.newSampleData	(	double[]	double[][]	double[][]	): Replace sample data, overriding any previous sample.
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegressionTest.testGLSEfficiency	(	): Generate an error covariance matrix and sample data representing models with this error structure. Then verify that GLS estimated coefficients, on average, perform better than OLS.
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegressionTest.testGLSOLSConsistency	(	): Verifies that GLS with identity covariance matrix gives the same results as OLS.
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegressionTest.testNewSample2	(	): Verifies that setting X, Y and covariance separately has the same effect as newSample(X,Y,cov).
org.apache.commons.math4.stat.regression.GLSMultipleLinearRegressionTest.testYVariance	(	): test calculateYVariance
org.apache.commons.math4.stat.regression.MillerUpdatingRegression: This class is a concrete implementation of the UpdatingMultipleLinearRegression interface. The algorithm is described in:  Algorithm AS 274: Least Squares Routines to Supplement Those of Gentleman Author(s): Alan J. Miller Source: Journal of the Royal Statistical Society. Series C (Applied Statistics), Vol. 41, No. 2 (1992), pp. 458-478 Published by: Blackwell Publishing for the Royal Statistical Society Stable URL: http://www.jstor.org/stable/2347583  This method for multiple regression forms the solution to the OLS problem by updating the QR decomposition as described by Gentleman.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.MillerUpdatingRegression	(	): Set the default constructor to private access to prevent inadvertent instantiation
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.MillerUpdatingRegression	(	int	boolean	): Primary constructor for the MillerUpdatingRegression.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.MillerUpdatingRegression	(	int	boolean	double	): This is the augmented constructor for the MillerUpdatingRegression class.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.addObservation	(	double[]	double	): Adds an observation to the regression model.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.addObservations	(	double[][]	double[]	): Adds multiple observations to the model.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.clear	(	): As the name suggests, clear wipes the internals and reorders everything in the canonical order.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.cov	(	int	): Calculates the cov matrix assuming only the first nreq variables are included in the calculation. The returned array contains a symmetric matrix stored in lower triangular form. The matrix will have ( nreq + 1 ) * nreq / 2 elements. For illustration  cov = { cov_00, cov_10, cov_11, cov_20, cov_21, cov22, ... } 
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.getDiagonalOfHatMatrix	(	double[]	): Gets the diagonal of the Hat matrix also known as the leverage matrix.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.getN	(	): Gets the number of observations added to the regression model.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.getOrderOfRegressors	(	): Gets the order of the regressors, useful if some type of reordering has been called. Calling regress with int[]{} args will trigger a reordering.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.getPartialCorrelations	(	int	): In the original algorithm only the partial correlations of the regressors is returned to the user. In this implementation, we have  corr = { corrxx - lower triangular corrxy - bottom row of the matrix } Replaces subroutines PCORR and COR of: ALGORITHM AS274 APPL. STATIST. (1992) VOL.41, NO. 2  Calculate partial correlations after the variables in rows 1, 2, ..., IN have been forced into the regression. If IN = 1, and the first row of R represents a constant in the model, then the usual simple correlations are returned. If IN = 0, the value returned in array CORMAT for the correlation of variables Xi & Xj is:  sum ( Xi.Xj ) / Sqrt ( sum (Xi^2) . sum (Xj^2) ) On return, array CORMAT contains the upper triangle of the matrix of partial correlations stored by rows, excluding the 1's on the diagonal. e.g. if IN = 2, the consecutive elements returned are: (3,4) (3,5) ... (3,ncol), (4,5) (4,6) ... (4,ncol), etc. Array YCORR stores the partial correlations with the Y-variable starting with YCORR(IN+1) = partial correlation with the variable in position (IN+1). 
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.hasIntercept	(	): A getter method which determines whether a constant is included.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.include	(	double[]	double	double	): The include method is where the QR decomposition occurs. This statement forms all intermediate data which will be used for all derivative measures. According to the miller paper, note that in the original implementation the x vector is overwritten. In this implementation, the include method is passed a copy of the original data vector so that there is no contamination of the data. Additionally, this method differs slightly from Gentleman's method, in that the assumption is of dense design matrices, there is some advantage in using the original gentleman algorithm on sparse matrices.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.inverse	(	double[]	int	): This internal method calculates the inverse of the upper-triangular portion of the R matrix.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.regcf	(	int	): The regcf method conducts the linear regression and extracts the parameter vector. Notice that the algorithm can do subset regression with no alteration.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.regress	(	): Conducts a regression on the data in the model, using all regressors.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.regress	(	int	): Conducts a regression on the data in the model, using a subset of regressors.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.regress	(	int[]	): Conducts a regression on the data in the model, using regressors in array Calling this method will change the internal order of the regressors and care is required in interpreting the hatmatrix.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.reorderRegressors	(	int[]	int	): ALGORITHM AS274 APPL. STATIST. (1992) VOL.41, NO. 2  Re-order the variables in an orthogonal reduction produced by AS75.1 so that the N variables in LIST start at position POS1, though will not necessarily be in the same order as in LIST. Any variables in VORDER before position POS1 are not moved. Auxiliary routine called: VMOVE.  This internal method reorders the regressors.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.singcheck	(	): The method which checks for singularities and then eliminates the offending columns.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.smartAdd	(	double	double	): Adds to number a and b such that the contamination due to numerical smallness of one addend does not corrupt the sum.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.ss	(	): Calculates the sum of squared errors for the full regression and all subsets in the following manner:  rss[] ={ ResidualSumOfSquares_allNvars, ResidualSumOfSquares_FirstNvars-1, ResidualSumOfSquares_FirstNvars-2, ..., ResidualSumOfSquares_FirstVariable} 
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.tolset	(	): This sets up tolerances for singularity testing.
org.apache.commons.math4.stat.regression.MillerUpdatingRegression.vmove	(	int	int	): ALGORITHM AS274 APPL. STATIST. (1992) VOL.41, NO. 2. Move variable from position FROM to position TO in an orthogonal reduction produced by AS75.1.
org.apache.commons.math4.stat.regression.MillerUpdatingRegressionTest: MillerUpdatingRegression tests.
org.apache.commons.math4.stat.regression.MillerUpdatingRegressionTest.testAddObsGetNClear	(	): Test of getN method, of class MillerUpdatingRegression.
org.apache.commons.math4.stat.regression.MillerUpdatingRegressionTest.testHasIntercept	(	): Test of hasIntercept method, of class MillerUpdatingRegression.
org.apache.commons.math4.stat.regression.MillerUpdatingRegressionTest.testLongly	(	): Test Longley dataset against certified values provided by NIST. Data Source: J. Longley (1967) "An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association, vol. 62. September, pp. 819-841. Certified values (and data) are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat
org.apache.commons.math4.stat.regression.ModelSpecificationException: Exception thrown when a regression model is not correctly specified.
org.apache.commons.math4.stat.regression.ModelSpecificationException.ModelSpecificationException	(	Localizable	Object	): 
org.apache.commons.math4.stat.regression.MultipleLinearRegression: The multiple linear regression can be represented in matrix-notation.  y=X*b+u  where y is an n-vector regressand, X is a [n,k] matrix whose k columns are called regressors, b is k-vector of regression parameters and u is an n-vector of error terms or residuals. The notation is quite standard in literature, cf eg Davidson and MacKinnon, Econometrics Theory and Methods, 2004.
org.apache.commons.math4.stat.regression.MultipleLinearRegression.estimateRegressandVariance	(	): Returns the variance of the regressand, ie Var(y).
org.apache.commons.math4.stat.regression.MultipleLinearRegression.estimateRegressionParameters	(	): Estimates the regression parameters b.
org.apache.commons.math4.stat.regression.MultipleLinearRegression.estimateRegressionParametersStandardErrors	(	): Returns the standard errors of the regression parameters.
org.apache.commons.math4.stat.regression.MultipleLinearRegression.estimateRegressionParametersVariance	(	): Estimates the variance of the regression parameters, ie Var(b).
org.apache.commons.math4.stat.regression.MultipleLinearRegression.estimateResiduals	(	): Estimates the residuals, ie u = y - X*b.
org.apache.commons.math4.stat.regression.MultipleLinearRegressionAbstractTest.testNewSample	(	): Verifies that newSampleData methods consistently insert unitary columns in design matrix. Confirms the fix for MATH-411.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression: Implements ordinary least squares (OLS) to estimate the parameters of a multiple linear regression model. The regression coefficients, b, satisfy the normal equations:  XT X b = XT y  To solve the normal equations, this implementation uses QR decomposition of the X matrix. (See QRDecomposition for details on the decomposition algorithm.) The X matrix, also known as the design matrix, has rows corresponding to sample observations and columns corresponding to independent variables. When the model is estimated using an intercept term (i.e. when isNoIntercept() is false as it is by default), the X matrix includes an initial column identically equal to 1. We solve the normal equations as follows:  XTX b = XT y (QR)T (QR) b = (QR)Ty RT (QTQ) R b = RT QT y RT R b = RT QT y (RT)-1 RT R b = (RT)-1 RT QT y R b = QT y  Given Q and R, the last equation is solved by back-substitution.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.OLSMultipleLinearRegression	(	): Create an empty OLSMultipleLinearRegression instance.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.OLSMultipleLinearRegression	(	double	): Create an empty OLSMultipleLinearRegression instance, using the given singularity threshold for the QR decomposition.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateAdjustedRSquared	(	): Returns the adjusted R-squared statistic, defined by the formula  R2adj = 1 - [SSR (n - 1)] / [SSTO (n - p)]  where SSR is the calculateResidualSumOfSquares() sum of squared residuals, SSTO is the calculateTotalSumOfSquares() total sum of squares, n is the number of observations and p is the number of parameters estimated (including the intercept). If the regression is estimated without an intercept term, what is returned is   1 - (1 - calculateRSquared()) * (n / (n - p))   If there is no variance in y, i.e., SSTO = 0, NaN is returned.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateBeta	(	): Calculates the regression coefficients using OLS. Data for the model must have been successfully loaded using one of the newSampleData methods before invoking this method; otherwise a NullPointerException will be thrown.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateBetaVariance	(	): Calculates the variance-covariance matrix of the regression parameters.  Var(b) = (XTX)-1  Uses QR decomposition to reduce (XTX)-1 to (RTR)-1, with only the top p rows of R included, where p = the length of the beta vector. Data for the model must have been successfully loaded using one of the newSampleData methods before invoking this method; otherwise a NullPointerException will be thrown.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateHat	(	): Compute the "hat" matrix.  The hat matrix is defined in terms of the design matrix X by X(XTX)-1XT  The implementation here uses the QR decomposition to compute the hat matrix as Q IpQT where Ip is the p-dimensional identity matrix augmented by 0's. This computational formula is from "The Hat Matrix in Regression and ANOVA", David C. Hoaglin and Roy E. Welsch, The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.  Data for the model must have been successfully loaded using one of the newSampleData methods before invoking this method; otherwise a NullPointerException will be thrown.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateRSquared	(	): Returns the R-Squared statistic, defined by the formula  R2 = 1 - SSR / SSTO  where SSR is the calculateResidualSumOfSquares() sum of squared residuals and SSTO is the calculateTotalSumOfSquares() total sum of squares If there is no variance in y, i.e., SSTO = 0, NaN is returned.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateResidualSumOfSquares	(	): Returns the sum of squared residuals.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.calculateTotalSumOfSquares	(	): Returns the sum of squared deviations of Y from its mean. If the model has no intercept term, 0 is used for the mean of Y - i.e., what is returned is the sum of the squared Y values. The value returned by this method is the SSTO value used in the calculateRSquared() R-squared computation.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.newSampleData	(	double[]	double[][]	): Loads model x and y sample data, overriding any previous sample. Computes and caches QR decomposition of the X matrix.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.newSampleData	(	double[]	int	int	): Loads model x and y sample data from a flat input array, overriding any previous sample.  Assumes that rows are concatenated with y values first in each row. For example, an input data array containing the sequence of values (1, 2, 3, 4, 5, 6, 7, 8, 9) with nobs = 3 and nvars = 2 creates a regression dataset with two independent variables, as below:  y x[0] x[1] -------------- 1 2 3 4 5 6 7 8 9  Note that there is no need to add an initial unitary column (column of 1's) when specifying a model including an intercept term. If isNoIntercept() is true, the X matrix will be created without an initial column of "1"s; otherwise this column will be added.  Throws IllegalArgumentException if any of the following preconditions fail: data cannot be null data.length = nobs * (nvars + 1) nobs > nvars This implementation computes and caches the QR decomposition of the X matrix.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegression.newXSampleData	(	double[][]	): Loads new x sample data, overriding any previous data.  The input x array should have one row for each sample observation, with columns corresponding to independent variables. For example, if   x = new double[][] {{1, 2}, {3, 4}, {5, 6}}  then setXSampleData(x)  results in a model with two independent variables and 3 observations:  x[0] x[1] ---------- 1 2 3 4 5 6  Note that there is no need to add an initial unitary column (column of 1's) when specifying a model including an intercept term.  This implementation computes and caches the QR decomposition of the X matrix once it is successfully loaded.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.checkVarianceConsistency	(	OLSMultipleLinearRegression	): Verifies that calculateYVariance and calculateResidualVariance return consistent values with direct variance computation from Y, residuals, respectively.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.testHat	(	): Test hat matrix computation
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.testLongly	(	): Test Longley dataset against certified values provided by NIST. Data Source: J. Longley (1967) "An Appraisal of Least Squares Programs for the Electronic Computer from the Point of View of the User" Journal of the American Statistical Association, vol. 62. September, pp. 819-841. Certified values (and data) are from NIST: http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.testNewSample2	(	): Verifies that setting X and Y separately has the same effect as newSample(X,Y).
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.testSingularCalculateBeta	(	): Anything requiring beta calculation should advertise SME.
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.testSwissFertility	(	): Test R Swiss fertility dataset against R. Data Source: R datasets package
org.apache.commons.math4.stat.regression.OLSMultipleLinearRegressionTest.testYVariance	(	): test calculateYVariance
org.apache.commons.math4.stat.regression.RegressionResults: Results of a Multiple Linear Regression model fit.
org.apache.commons.math4.stat.regression.RegressionResults.RegressionResults	(	): Set the default constructor to private access to prevent inadvertent instantiation
org.apache.commons.math4.stat.regression.RegressionResults.RegressionResults	(	double[]	double[][]	boolean	long	int	double	double	double	boolean	boolean	): Constructor for Regression Results.
org.apache.commons.math4.stat.regression.RegressionResults.getAdjustedRSquared	(	): Returns the adjusted R-squared statistic, defined by the formula  R2adj = 1 - [SSR (n - 1)] / [SSTO (n - p)]  where SSR is the sum of squared residuals}, SSTO is the total sum of squares}, n is the number of observations and p is the number of parameters estimated (including the intercept). If the regression is estimated without an intercept term, what is returned is   1 - (1 - getRSquared() ) * (n / (n - p))  
org.apache.commons.math4.stat.regression.RegressionResults.getCovarianceOfParameters	(	int	int	): Returns the covariance between regression parameters i and j. If there are problems with an ill conditioned design matrix then the covariance which involves redundant columns will be assigned Double.NaN. 
org.apache.commons.math4.stat.regression.RegressionResults.getErrorSumSquares	(	): Returns the  sum of squared errors (SSE) associated with the regression model. The return value is constrained to be non-negative - i.e., if due to rounding errors the computational formula returns a negative result, 0 is returned. Preconditions:  numberOfParameters data pairs must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.RegressionResults.getMeanSquareError	(	): Returns the sum of squared errors divided by the degrees of freedom, usually abbreviated MSE. If there are fewer than numberOfParameters + 1 data pairs in the model, or if there is no variation in x, this returns Double.NaN.
org.apache.commons.math4.stat.regression.RegressionResults.getN	(	): Returns the number of observations added to the regression model.
org.apache.commons.math4.stat.regression.RegressionResults.getNumberOfParameters	(	): Returns the number of parameters estimated in the model. This is the maximum number of regressors, some techniques may drop redundant parameters
org.apache.commons.math4.stat.regression.RegressionResults.getParameterEstimate	(	int	): Returns the parameter estimate for the regressor at the given index. A redundant regressor will have its redundancy flag set, as well as a parameters estimated equal to Double.NaN
org.apache.commons.math4.stat.regression.RegressionResults.getParameterEstimates	(	): Returns a copy of the regression parameters estimates. The parameter estimates are returned in the natural order of the data. A redundant regressor will have its redundancy flag set, as will a parameter estimate equal to Double.NaN.
org.apache.commons.math4.stat.regression.RegressionResults.getRSquared	(	): Returns the  coefficient of multiple determination, usually denoted r-square. Preconditions:  At least numberOfParameters observations (with at least numberOfParameters different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.RegressionResults.getRegressionSumSquares	(	): Returns the sum of squared deviations of the predicted y values about their mean (which equals the mean of y). This is usually abbreviated SSR or SSM. It is defined as SSM here Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double.NaN is returned. 
org.apache.commons.math4.stat.regression.RegressionResults.getStdErrorOfEstimate	(	int	): Returns the standard error of the parameter estimate at index, usually denoted s(bindex).
org.apache.commons.math4.stat.regression.RegressionResults.getStdErrorOfEstimates	(	): Returns the standard error of the parameter estimates, usually denoted s(bi). If there are problems with an ill conditioned design matrix then the regressor which is redundant will be assigned Double.NaN. 
org.apache.commons.math4.stat.regression.RegressionResults.getTotalSumSquares	(	): Returns the sum of squared deviations of the y values about their mean. This is defined as SSTO here. If n < 2, this returns Double.NaN.
org.apache.commons.math4.stat.regression.RegressionResults.getVcvElement	(	int	int	): Gets the i-jth element of the variance-covariance matrix.
org.apache.commons.math4.stat.regression.RegressionResults.hasIntercept	(	): Returns true if the regression model has been computed including an intercept. In this case, the coefficient of the intercept is the first element of the getParameterEstimates() parameter estimates.
org.apache.commons.math4.stat.regression.SimpleRegression: Estimates an ordinary least squares regression model with one independent variable.   y = intercept + slope * x   Standard errors for intercept and slope are available as well as ANOVA, r-square and Pearson's r statistics.  Observations (x,y pairs) can be added to the model one at a time or they can be provided in a 2-dimensional array. The observations are not stored in memory, so there is no limit to the number of observations that can be added to the model.  Usage Notes:   When there are fewer than two observations in the model, or when there is no variation in the x values (i.e. all x values are the same) all statistics return NaN. At least two observations with different x coordinates are required to estimate a bivariate regression model.   Getters for the statistics always compute values based on the current set of observations -- i.e., you can get statistics, then add more data and get updated statistics without using a new instance. There is no "compute" method that updates all statistics. Each of the getters performs the necessary computations to return the requested statistic.   The intercept term may be suppressed by passing false to the SimpleRegression() constructor. When the hasIntercept property is false, the model is estimated without a constant term and getIntercept() returns 0. 
org.apache.commons.math4.stat.regression.SimpleRegression.SimpleRegression	(	): Create an empty SimpleRegression instance
org.apache.commons.math4.stat.regression.SimpleRegression.SimpleRegression	(	boolean	): Create a SimpleRegression instance, specifying whether or not to estimate an intercept. Use false to estimate a model with no intercept. When the hasIntercept property is false, the model is estimated without a constant term and getIntercept() returns 0.
org.apache.commons.math4.stat.regression.SimpleRegression.addData	(	double	double	): Adds the observation (x,y) to the regression data set.  Uses updating formulas for means and sums of squares defined in "Algorithms for Computing the Sample Variance: Analysis and Recommendations", Chan, T.F., Golub, G.H., and LeVeque, R.J. 1983, American Statistician, vol. 37, pp. 242-247, referenced in Weisberg, S. "Applied Linear Regression". 2nd Ed. 1985.
org.apache.commons.math4.stat.regression.SimpleRegression.addData	(	double[][]	): Adds the observations represented by the elements in data.  (data[0][0],data[0][1]) will be the first observation, then (data[1][0],data[1][1]), etc.  This method does not replace data that has already been added. The observations represented by data are added to the existing dataset.  To replace all data, use clear() before adding the new data.
org.apache.commons.math4.stat.regression.SimpleRegression.addObservation	(	double[]	double	): Adds one observation to the regression model.
org.apache.commons.math4.stat.regression.SimpleRegression.addObservations	(	double[][]	double[]	): Adds a series of observations to the regression model. The lengths of x and y must be the same and x must be rectangular.
org.apache.commons.math4.stat.regression.SimpleRegression.append	(	SimpleRegression	): Appends data from another regression calculation to this one. The mean update formulae are based on a paper written by Philippe Pébay:  Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments, 2008, Technical Report SAND2008-6212, Sandia National Laboratories.
org.apache.commons.math4.stat.regression.SimpleRegression.clear	(	): Clears all data from the model.
org.apache.commons.math4.stat.regression.SimpleRegression.getIntercept	(	): Returns the intercept of the estimated regression line, if hasIntercept() is true; otherwise 0.  The least squares estimate of the intercept is computed using the normal equations. The intercept is sometimes denoted b0.  Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.getIntercept	(	double	): Returns the intercept of the estimated regression line, given the slope.  Will return NaN if slope is NaN.
org.apache.commons.math4.stat.regression.SimpleRegression.getInterceptStdErr	(	): Returns the  standard error of the intercept estimate, usually denoted s(b0).  If there are fewer that three observations in the model, or if there is no variation in x, this returns Double.NaN. Additionally, a Double.NaN is returned when the intercept is constrained to be zero
org.apache.commons.math4.stat.regression.SimpleRegression.getMeanSquareError	(	): Returns the sum of squared errors divided by the degrees of freedom, usually abbreviated MSE.  If there are fewer than three data pairs in the model, or if there is no variation in x, this returns Double.NaN.
org.apache.commons.math4.stat.regression.SimpleRegression.getN	(	): Returns the number of observations that have been added to the model.
org.apache.commons.math4.stat.regression.SimpleRegression.getR	(	): Returns  Pearson's product moment correlation coefficient, usually denoted r.  Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.getRSquare	(	): Returns the  coefficient of determination, usually denoted r-square.  Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.getRegressionSumSquares	(	): Returns the sum of squared deviations of the predicted y values about their mean (which equals the mean of y).  This is usually abbreviated SSR or SSM. It is defined as SSM here  Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double.NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.getRegressionSumSquares	(	double	): Computes SSR from b1.
org.apache.commons.math4.stat.regression.SimpleRegression.getSignificance	(	): Returns the significance level of the slope (equiv) correlation.  Specifically, the returned value is the smallest alpha such that the slope confidence interval with significance level equal to alpha does not include 0. On regression output, this is often denoted Prob(|t| > 0)  Usage Note: The validity of this statistic depends on the assumption that the observations included in the model are drawn from a  Bivariate Normal Distribution.  If there are fewer that three observations in the model, or if there is no variation in x, this returns Double.NaN.
org.apache.commons.math4.stat.regression.SimpleRegression.getSlope	(	): Returns the slope of the estimated regression line.  The least squares estimate of the slope is computed using the normal equations. The slope is sometimes denoted b1.  Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double.NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.getSlopeConfidenceInterval	(	): Returns the half-width of a 95% confidence interval for the slope estimate.  The 95% confidence interval is  (getSlope() - getSlopeConfidenceInterval(), getSlope() + getSlopeConfidenceInterval())  If there are fewer that three observations in the model, or if there is no variation in x, this returns Double.NaN.  Usage Note: The validity of this statistic depends on the assumption that the observations included in the model are drawn from a  Bivariate Normal Distribution.
org.apache.commons.math4.stat.regression.SimpleRegression.getSlopeConfidenceInterval	(	double	): Returns the half-width of a (100-100*alpha)% confidence interval for the slope estimate.  The (100-100*alpha)% confidence interval is   (getSlope() - getSlopeConfidenceInterval(), getSlope() + getSlopeConfidenceInterval())  To request, for example, a 99% confidence interval, use alpha = .01  Usage Note: The validity of this statistic depends on the assumption that the observations included in the model are drawn from a  Bivariate Normal Distribution.   Preconditions: If there are fewer that three observations in the model, or if there is no variation in x, this returns Double.NaN.  (0 < alpha < 1); otherwise an OutOfRangeException is thrown. 
org.apache.commons.math4.stat.regression.SimpleRegression.getSlopeStdErr	(	): Returns the standard error of the slope estimate, usually denoted s(b1).  If there are fewer that three data pairs in the model, or if there is no variation in x, this returns Double.NaN. 
org.apache.commons.math4.stat.regression.SimpleRegression.getSumOfCrossProducts	(	): Returns the sum of crossproducts, xi*yi.
org.apache.commons.math4.stat.regression.SimpleRegression.getSumSquaredErrors	(	): Returns the  sum of squared errors (SSE) associated with the regression model.  The sum is computed using the computational formula  SSE = SYY - (SXY * SXY / SXX)  where SYY is the sum of the squared deviations of the y values about their mean, SXX is similarly defined and SXY is the sum of the products of x and y mean deviations.  The sums are accumulated using the updating algorithm referenced in addData.  The return value is constrained to be non-negative - i.e., if due to rounding errors the computational formula returns a negative result, 0 is returned.  Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.getTotalSumSquares	(	): Returns the sum of squared deviations of the y values about their mean.  This is defined as SSTO here.  If n < 2, this returns Double.NaN.
org.apache.commons.math4.stat.regression.SimpleRegression.getXSumSquares	(	): Returns the sum of squared deviations of the x values about their mean. If n < 2, this returns Double.NaN.
org.apache.commons.math4.stat.regression.SimpleRegression.hasIntercept	(	): Returns true if the model includes an intercept term.
org.apache.commons.math4.stat.regression.SimpleRegression.predict	(	double	): Returns the "predicted" y value associated with the supplied x value, based on the data that has been added to the model when this method is activated.   predict(x) = intercept + slope * x   Preconditions:  At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, Double,NaN is returned. 
org.apache.commons.math4.stat.regression.SimpleRegression.regress	(	): Performs a regression on data present in buffers and outputs a RegressionResults object. If there are fewer than 3 observations in the model and hasIntercept is true a NoDataException is thrown. If there is no intercept term, the model must contain at least 2 observations.
org.apache.commons.math4.stat.regression.SimpleRegression.regress	(	int[]	): Performs a regression on data present in buffers including only regressors indexed in variablesToInclude and outputs a RegressionResults object
org.apache.commons.math4.stat.regression.SimpleRegression.removeData	(	double	double	): Removes the observation (x,y) from the regression data set.  Mirrors the addData method. This method permits the use of SimpleRegression instances in streaming mode where the regression is applied to a sliding "window" of observations, however the caller is responsible for maintaining the set of observations in the window. The method has no effect if there are no points of data (i.e. n=0)
org.apache.commons.math4.stat.regression.SimpleRegression.removeData	(	double[][]	): Removes observations represented by the elements in data.  If the array is larger than the current n, only the first n elements are processed. This method permits the use of SimpleRegression instances in streaming mode where the regression is applied to a sliding "window" of observations, however the caller is responsible for maintaining the set of observations in the window.  To remove all data, use clear().
org.apache.commons.math4.stat.regression.SimpleRegressionTest: Test cases for the TestStatistic class.
org.apache.commons.math4.stat.regression.SimpleRegressionTest.check	(	boolean	): Checks that adding data to a single model gives the same result as adding "parts" of the dataset to smaller models and using append to aggregate the smaller models.
org.apache.commons.math4.stat.regression.SimpleRegressionTest.equals	(	SimpleRegression	SimpleRegression	double	): Returns true iff the statistics reported by model1 are all within tol of those reported by model2.
org.apache.commons.math4.stat.regression.SimpleRegressionTest.testAppend	(	): Test that the SimpleRegression objects generated from combining two SimpleRegression objects created from subsets of data are identical to SimpleRegression objects created from the combined data.
org.apache.commons.math4.stat.regression.SimpleRegressionTest.testRegressExceptions	(	): Verify that regress generates exceptions as advertised for bad model specifications.
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression: An interface for regression models allowing for dynamic updating of the data. That is, the entire data set need not be loaded into memory. As observations become available, they can be added to the regression model and an updated estimate regression statistics can be calculated.
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.addObservation	(	double[]	double	): Adds one observation to the regression model.
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.addObservations	(	double[][]	double[]	): Adds a series of observations to the regression model. The lengths of x and y must be the same and x must be rectangular.
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.clear	(	): Clears internal buffers and resets the regression model. This means all data and derived values are initialized
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.getN	(	): Returns the number of observations added to the regression model.
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.hasIntercept	(	): Returns true if a constant has been included false otherwise.
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.regress	(	): Performs a regression on data present in buffers and outputs a RegressionResults object
org.apache.commons.math4.stat.regression.UpdatingMultipleLinearRegression.regress	(	int[]	): Performs a regression on data present in buffers including only regressors indexed in variablesToInclude and outputs a RegressionResults object
org.apache.commons.math4.transform.FastCosineTransformer: Implements the Fast Cosine Transform for transformation of one-dimensional real data sets. For reference, see James S. Walker, Fast Fourier Transforms, chapter 3 (ISBN 0849371635).  There are several variants of the discrete cosine transform. The present implementation corresponds to DCT-I, with various normalization conventions, which are specified by the parameter DctNormalization.  DCT-I is equivalent to DFT of an even extension of the data series. More precisely, if x0, …, xN-1 is the data set to be cosine transformed, the extended data set x0#, …, x2N-3# is defined as follows  xk# = xk if 0 ≤ k < N, xk# = x2N-2-k if N ≤ k < 2N - 2.   Then, the standard DCT-I y0, …, yN-1 of the real data set x0, …, xN-1 is equal to half of the N first elements of the DFT of the extended data set x0#, …, x2N-3#  yn = (1 / 2) ∑k=02N-3 xk# exp[-2πi nk / (2N - 2)]     k = 0, …, N-1.  The present implementation of the discrete cosine transform as a fast cosine transform requires the length of the data set to be a power of two plus one (N = 2n + 1). Besides, it implicitly assumes that the sampled function is even.
org.apache.commons.math4.transform.FastCosineTransformer.FastCosineTransformer	(	DctNormalization	): Creates a new instance of this class, with various normalization conventions.
org.apache.commons.math4.transform.FastCosineTransformer.fct	(	double[]	): Perform the FCT algorithm (including inverse).
org.apache.commons.math4.transform.FastCosineTransformer.transform	(	UnivariateFunction	double	double	int	TransformType	): Returns the (forward, inverse) transform of the specified real function, sampled on the specified interval.
org.apache.commons.math4.transform.FastCosineTransformer.transform	(	double[]	TransformType	): Returns the (forward, inverse) transform of the specified real data set.
org.apache.commons.math4.transform.FastCosineTransformerTest: Test case for fast cosine transformer.  FCT algorithm is exact, the small tolerance number is used only to account for round-off errors.
org.apache.commons.math4.transform.FastCosineTransformerTest.data	(	): Returns an array containing true, false in order to check both standard and orthogonal DCTs.
org.apache.commons.math4.transform.FastCosineTransformerTest.testAdHocData	(	): Test of transformer for the ad hoc data. 
org.apache.commons.math4.transform.FastCosineTransformerTest.testParameters	(	): Test of parameters for the transformer. 
org.apache.commons.math4.transform.FastCosineTransformerTest.testSinFunction	(	): Test of transformer for the sine function. 
org.apache.commons.math4.transform.FastFourierTransformer: Implements the Fast Fourier Transform for transformation of one-dimensional real or complex data sets. For reference, see Applied Numerical Linear Algebra, ISBN 0898713897, chapter 6.  There are several variants of the discrete Fourier transform, with various normalization conventions, which are specified by the parameter DftNormalization.  The current implementation of the discrete Fourier transform as a fast Fourier transform requires the length of the data set to be a power of 2. This greatly simplifies and speeds up the code. Users can pad the data with zeros to meet this requirement. There are other flavors of FFT, for reference, see S. Winograd, On computing the discrete Fourier transform, Mathematics of Computation, 32 (1978), 175 - 199.
org.apache.commons.math4.transform.FastFourierTransformer.FastFourierTransformer	(	DftNormalization	): Creates a new instance of this class, with various normalization conventions.
org.apache.commons.math4.transform.FastFourierTransformer.bitReversalShuffle2	(	double[]	double[]	): Performs identical index bit reversal shuffles on two arrays of identical size. Each element in the array is swapped with another element based on the bit-reversal of the index. For example, in an array with length 16, item at binary index 0011 (decimal 3) would be swapped with the item at binary index 1100 (decimal 12).
org.apache.commons.math4.transform.FastFourierTransformer.normalizeTransformedData	(	double[][]	DftNormalization	TransformType	): Applies the proper normalization to the specified transformed data.
org.apache.commons.math4.transform.FastFourierTransformer.transform	(	Complex[]	TransformType	): Returns the (forward, inverse) transform of the specified complex data set.
org.apache.commons.math4.transform.FastFourierTransformer.transform	(	UnivariateFunction	double	double	int	TransformType	): Returns the (forward, inverse) transform of the specified real function, sampled on the specified interval.
org.apache.commons.math4.transform.FastFourierTransformer.transform	(	double[]	TransformType	): Returns the (forward, inverse) transform of the specified real data set.
org.apache.commons.math4.transform.FastFourierTransformer.transformInPlace	(	double[][]	DftNormalization	TransformType	): Computes the standard transform of the specified complex data. The computation is done in place. The input data is laid out as follows  dataRI[0][i] is the real part of the i-th data point, dataRI[1][i] is the imaginary part of the i-th data point. 
org.apache.commons.math4.transform.FastFourierTransformerTest: Test case for fast Fourier transformer.  FFT algorithm is exact, the small tolerance number is used only to account for round-off errors.
org.apache.commons.math4.transform.FastFourierTransformerTest.dft	(	Complex[]	int	): Naive implementation of DFT, for reference. 
org.apache.commons.math4.transform.FastFourierTransformerTest.testAdHocData	(	): Test of transformer for the ad hoc data taken from Mathematica.
org.apache.commons.math4.transform.FastFourierTransformerTest.testSinFunction	(	): Test of transformer for the sine function.
org.apache.commons.math4.transform.FastHadamardTransformer: Implements the Fast Hadamard Transform (FHT). Transformation of an input vector x to the output vector y.  In addition to transformation of real vectors, the Hadamard transform can transform integer vectors into integer vectors. However, this integer transform cannot be inverted directly. Due to a scaling factor it may lead to rational results. As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational vector (1/2, -1/2, 0, 0).
org.apache.commons.math4.transform.FastHadamardTransformer.fht	(	double[]	): The FHT (Fast Hadamard Transformation) which uses only subtraction and addition. Requires N * log2(N) = n * 2^n additions. Short Table of manual calculation for N=8  x is the input vector to be transformed, y is the output vector (Fast Hadamard transform of x), a and b are helper rows.     x a b y   x0 a0 = x0 + x1 b0 = a0 + a1 y0 = b0+ b1   x1 a1 = x2 + x3 b0 = a2 + a3 y0 = b2 + b3   x2 a2 = x4 + x5 b0 = a4 + a5 y0 = b4 + b5   x3 a3 = x6 + x7 b0 = a6 + a7 y0 = b6 + b7   x4 a0 = x0 - x1 b0 = a0 - a1 y0 = b0 - b1   x5 a1 = x2 - x3 b0 = a2 - a3 y0 = b2 - b3   x6 a2 = x4 - x5 b0 = a4 - a5 y0 = b4 - b5   x7 a3 = x6 - x7 b0 = a6 - a7 y0 = b6 - b7    How it works  Construct a matrix with N rows and n + 1 columns, hadm[n+1][N]. (If I use [x][y] it always means [row-offset][column-offset] of a Matrix with n rows and m columns. Its entries go from M[0][0] to M[n][N]) Place the input vector x[N] in the first column of the matrix hadm. The entries of the submatrix D_top are calculated as follows  D_top goes from entry [0][1] to [N / 2 - 1][n + 1], the columns of D_top are the pairwise mutually exclusive sums of the previous column.   The entries of the submatrix D_bottom are calculated as follows  D_bottom goes from entry [N / 2][1] to [N][n + 1], the columns of D_bottom are the pairwise differences of the previous column.   The consputation of D_top and D_bottom are best understood with the above example (for N = 8). The output vector y is now in the last column of hadm. Algorithm from chipcenter.  Visually    0123 … n + 1   0 x0  ↑ ← Dtop → ↓   1x1 2x2 …… N / 2 - 1xN/2-1  N / 2 xN/2  ↑ ← Dbottom → ↓   N / 2 + 1xN/2+1 N / 2 + 2xN/2+2 …… NxN  
org.apache.commons.math4.transform.FastHadamardTransformer.fht	(	int[]	): Returns the forward transform of the specified integer data set. The FHT (Fast Hadamard Transform) uses only subtraction and addition.
org.apache.commons.math4.transform.FastHadamardTransformer.transform	(	UnivariateFunction	double	double	int	TransformType	): Returns the (forward, inverse) transform of the specified real function, sampled on the specified interval.
org.apache.commons.math4.transform.FastHadamardTransformer.transform	(	double[]	TransformType	): Returns the (forward, inverse) transform of the specified real data set.
org.apache.commons.math4.transform.FastHadamardTransformer.transform	(	int[]	): Returns the forward transform of the specified integer data set.The integer transform cannot be inverted directly, due to a scaling factor which may lead to double results.
org.apache.commons.math4.transform.FastHadamardTransformerTest: JUnit Test for HadamardTransformerTest
org.apache.commons.math4.transform.FastHadamardTransformerTest.test3Points	(	): Test of transformer for wrong number of points
org.apache.commons.math4.transform.FastHadamardTransformerTest.test4Points	(	): Test of transformer for the a 4-points FHT (means n=4)
org.apache.commons.math4.transform.FastHadamardTransformerTest.test8Points	(	): Test of transformer for the a 8-point FHT (means n=8)
org.apache.commons.math4.transform.FastHadamardTransformerTest.testNoIntInverse	(	): Test the inverse transform of an integer vector is not always an integer vector
org.apache.commons.math4.transform.FastSineTransformer: Implements the Fast Sine Transform for transformation of one-dimensional real data sets. For reference, see James S. Walker, Fast Fourier Transforms, chapter 3 (ISBN 0849371635).  There are several variants of the discrete sine transform. The present implementation corresponds to DST-I, with various normalization conventions, which are specified by the parameter DstNormalization. It should be noted that regardless to the convention, the first element of the dataset to be transformed must be zero.  DST-I is equivalent to DFT of an odd extension of the data series. More precisely, if x0, …, xN-1 is the data set to be sine transformed, the extended data set x0#, …, x2N-1# is defined as follows  x0# = x0 = 0, xk# = xk if 1 ≤ k < N, xN# = 0, xk# = -x2N-k if N + 1 ≤ k < 2N.   Then, the standard DST-I y0, …, yN-1 of the real data set x0, …, xN-1 is equal to half of i (the pure imaginary number) times the N first elements of the DFT of the extended data set x0#, …, x2N-1#  yn = (i / 2) ∑k=02N-1 xk# exp[-2πi nk / (2N)]     k = 0, …, N-1.  The present implementation of the discrete sine transform as a fast sine transform requires the length of the data to be a power of two. Besides, it implicitly assumes that the sampled function is odd. In particular, the first element of the data set must be 0, which is enforced in transform(), after sampling.
org.apache.commons.math4.transform.FastSineTransformer.FastSineTransformer	(	DstNormalization	): Creates a new instance of this class, with various normalization conventions.
org.apache.commons.math4.transform.FastSineTransformer.fst	(	double[]	): Perform the FST algorithm (including inverse). The first element of the data set is required to be 0.
org.apache.commons.math4.transform.FastSineTransformer.transform	(	UnivariateFunction	double	double	int	TransformType	): Returns the (forward, inverse) transform of the specified real function, sampled on the specified interval. This implementation enforces f(x) = 0.0 at x = 0.0.
org.apache.commons.math4.transform.FastSineTransformer.transform	(	double[]	TransformType	): Returns the (forward, inverse) transform of the specified real data set. The first element of the specified data set is required to be 0.
org.apache.commons.math4.transform.FastSineTransformerTest: Test case for fast sine transformer.  FST algorithm is exact, the small tolerance number is used only to account for round-off errors.
org.apache.commons.math4.transform.FastSineTransformerTest.createRealData	(	int	): Returns a random array of doubles. Random generator always uses the same seed. Overriding the default implementation allows to ensure that the first element of the data set is zero.
org.apache.commons.math4.transform.FastSineTransformerTest.data	(	): Returns an array containing true, false in order to check both standard and orthogonal DSTs.
org.apache.commons.math4.transform.FastSineTransformerTest.testAdHocData	(	): Test of transformer for the ad hoc data.
org.apache.commons.math4.transform.FastSineTransformerTest.testParameters	(	): Test of parameters for the transformer.
org.apache.commons.math4.transform.FastSineTransformerTest.testSinFunction	(	): Test of transformer for the sine function.
org.apache.commons.math4.transform.RealTransformer: Interface for one-dimensional data sets transformations producing real results.  Such transforms include FastSineTransformer sine transform, FastCosineTransformer cosine transform or FastHadamardTransformer Hadamard transform. FastFourierTransformer Fourier transform is of a different kind and does not implement this interface since it produces org.apache.commons.math4.complex.Complex results instead of real ones.
org.apache.commons.math4.transform.RealTransformer.transform	(	UnivariateFunction	double	double	int	TransformType	): Returns the (forward, inverse) transform of the specified real function, sampled on the specified interval.
org.apache.commons.math4.transform.RealTransformer.transform	(	double[]	TransformType	): Returns the (forward, inverse) transform of the specified real data set.
org.apache.commons.math4.transform.RealTransformerAbstractTest: Abstract test for classes implementing the RealTransformer interface. This abstract test handles the automatic generation of random data of various sizes. For each generated data array, actual values (returned by the transformer to be tested) are compared to expected values, returned by the transform() (to be implemented by the user: a naive method may be used). Methods are also provided to test that invalid parameters throw the expected exceptions.
org.apache.commons.math4.transform.RealTransformerAbstractTest.createRealData	(	int	): Returns a random array of doubles. Random generator always uses the same seed.
org.apache.commons.math4.transform.RealTransformerAbstractTest.createRealTransformer	(	): Returns a new instance of the RealTransformer to be tested.
org.apache.commons.math4.transform.RealTransformerAbstractTest.getInvalidDataSize	(	int	): Returns an invalid data size. Transforms with this data size should trigger a MathIllegalArgumentException.
org.apache.commons.math4.transform.RealTransformerAbstractTest.getNumberOfInvalidDataSizes	(	): Returns the total number of invalid data sizes to be tested. If data array of any size can be handled by the RealTransformer to be tested, this method should return 0.
org.apache.commons.math4.transform.RealTransformerAbstractTest.getNumberOfValidDataSizes	(	): Returns the total number of valid data sizes to be tested.
org.apache.commons.math4.transform.RealTransformerAbstractTest.getRelativeTolerance	(	int	): Returns the expected relative accuracy for data arrays of size getValidDataSize(i).
org.apache.commons.math4.transform.RealTransformerAbstractTest.getValidDataSize	(	int	): Returns a valid data size. This method allows for data arrays of various sizes to be automatically tested (by allowing multiple values of the specified index).
org.apache.commons.math4.transform.RealTransformerAbstractTest.getValidFunction	(	): Returns a function for the accuracy check of transform(). This function should be valid. In other words, none of the above methods should throw an exception when passed this function.
org.apache.commons.math4.transform.RealTransformerAbstractTest.getValidLowerBound	(	): Returns a sampling lower bound for the accuracy check of transform(). This lower bound should be valid. In other words, none of the above methods should throw an exception when passed this bound.
org.apache.commons.math4.transform.RealTransformerAbstractTest.getValidUpperBound	(	): Returns a sampling upper bound for the accuracy check of transform(). This upper bound should be valid. In other words, none of the above methods should throw an exception when passed this bound.
org.apache.commons.math4.transform.RealTransformerAbstractTest.testTransformFunction	(	): Accuracy check of transform(). For each valid data size returned by getValidDataSize() getValidDataSize(i), the UnivariateFunction returned by getValidFunction() is sampled. The actual transform is computed and compared to the expected transform, return by transform(). Actual and expected values should be equal to within the relative error returned by getRelativeTolerance() getRelativeTolerance(i).
org.apache.commons.math4.transform.RealTransformerAbstractTest.testTransformFunctionInvalidBounds	(	): transform() should throw a NumberIsTooLargeException if sampling bounds are not correctly ordered.
org.apache.commons.math4.transform.RealTransformerAbstractTest.testTransformFunctionInvalidDataSize	(	): transform() should throw a MathIllegalArgumentException if number of samples is invalid.
org.apache.commons.math4.transform.RealTransformerAbstractTest.testTransformFunctionNotStrictlyPositiveNumberOfSamples	(	): transform() should throw a NotStrictlyPositiveException if number of samples is not strictly positive.
org.apache.commons.math4.transform.RealTransformerAbstractTest.testTransformReal	(	): Accuracy check of transform(). For each valid data size returned by getValidDataSize() getValidDataSize(i), a random data array is generated with createRealData() createRealData(i). The actual transform is computed and compared to the expected transform, return by transform(). Actual and expected values should be equal to within the relative error returned by getRelativeTolerance() getRelativeTolerance(i).
org.apache.commons.math4.transform.RealTransformerAbstractTest.testTransformRealInvalidDataSize	(	): transform() should throw a MathIllegalArgumentException if data size is invalid.
org.apache.commons.math4.transform.RealTransformerAbstractTest.transform	(	double[]	TransformType	): Returns the expected transform of the specified real data array.
org.apache.commons.math4.transform.TransformUtils: Useful functions for the implementation of various transforms.
org.apache.commons.math4.transform.TransformUtils.TransformUtils	(	): Private constructor. 
org.apache.commons.math4.transform.TransformUtils.createComplexArray	(	double[][]	): Builds a new array of Complex from the specified two dimensional array of real and imaginary parts. In the returned array dataC, the data is laid out as follows  dataC[i].getReal() = dataRI[0][i], dataC[i].getImaginary() = dataRI[1][i]. 
org.apache.commons.math4.transform.TransformUtils.createRealImaginaryArray	(	Complex[]	): Builds a new two dimensional array of double filled with the real and imaginary parts of the specified Complex numbers. In the returned array dataRI, the data is laid out as follows  dataRI[0][i] = dataC[i].getReal(), dataRI[1][i] = dataC[i].getImaginary(). 
org.apache.commons.math4.transform.TransformUtils.exactLog2	(	int	): Returns the base-2 logarithm of the specified int. Throws an exception if n is not a power of two.
org.apache.commons.math4.transform.TransformUtils.scaleArray	(	Complex[]	double	): Multiply every component in the given complex array by the given real number. The change is made in place.
org.apache.commons.math4.transform.TransformUtils.scaleArray	(	double[]	double	): Multiply every component in the given real array by the given real number. The change is made in place.
org.apache.commons.math4.userguide.ClusterAlgorithmComparison: Plots clustering results for various algorithms and datasets. Based on scikit learn.
org.apache.commons.math4.userguide.ExampleUtils.ExampleFrame.getMainPanel	(	): Returns the main panel which should be printed by the screenshot action.  By default, it returns the content pane of this frame, but can be overriden in case the frame has a global scroll pane which would cut off any offscreen content. 
org.apache.commons.math4.userguide.FastMathTestPerformance: Performance benchmark for FastMath.
org.apache.commons.math4.userguide.IntegerDistributionComparison: Displays pdf/cdf for integer distributions.
org.apache.commons.math4.userguide.LowDiscrepancyGeneratorComparison: Plots 2D samples drawn from various pseudo / quasi-random generators.
org.apache.commons.math4.userguide.RealDistributionComparison: Displays pdf/cdf for real distributions.
org.apache.commons.math4.userguide.clustering.ImageClusteringExample: This example shows how clustering can be applied to images.
org.apache.commons.math4.userguide.filter.ConstantVoltageExample.VoltMeter.getVoltage	(	): Returns the real voltage without any measurement noise.
org.apache.commons.math4.userguide.filter.ConstantVoltageExample.constantVoltageTest	(	Chart	Chart	): constant voltage test 
org.apache.commons.math4.userguide.genetics.HelloWorldExample.StringChromosome: String Chromosome represented by a list of characters.
org.apache.commons.math4.userguide.genetics.ImageEvolutionExample: This example shows a more advanced use of a genetic algorithm: approximate a raster image with ~100 semi-transparent polygons of length 6.  The fitness function is quite simple yet expensive to compute: - draw the polygons of a chromosome to an image - compare each pixel with the corresponding reference image  To improve the speed of the calculation, we calculate the fitness not on the original image size, but rather on a scaled down version, which is sufficient to demonstrate the power of such a genetic algorithm.  TODO: - improve user interface - make algorithm parameters configurable - add a gallery of results after x iterations / minutes (either automatic or based on button click) - allow loading / selection of other images - add logging in the user interface, e.g. number of generations, time spent, ...
org.apache.commons.math4.userguide.genetics.Polygon: Represents a fixed size polgon with its fill color.
org.apache.commons.math4.userguide.genetics.Polygon.draw	(	Graphics2D	int	int	): Draw the Polygon to the buffer of the given size.
org.apache.commons.math4.userguide.genetics.Polygon.mutate	(	float	float	): Return a new Polygon, mutated with the given rate and amount.  Each component of the Polygon may be mutated according to the specified mutation rate. In case a component is going to be mutated, its value will be randomly modified in the uniform range of [-mutationAmount, +mutationAmount].
org.apache.commons.math4.userguide.genetics.Polygon.randomPolygon	(	int	): Creates a new random Polygon of the given length.
org.apache.commons.math4.userguide.genetics.PolygonChromosome: A simple chromosome representing a list of polygons.
org.apache.commons.math4.userguide.genetics.PolygonChromosome.fitness	(	): Calculate the fitness function for this chromosome.  For this purpose, we first draw the polygons on the test buffer, and then compare the resulting image pixel by pixel with the reference image.
org.apache.commons.math4.userguide.genetics.PolygonChromosome.getPolygonRepresentation	(	): Return the internal representation, which is needed for our custom mutation policy.
org.apache.commons.math4.userguide.geometry.GeometryExample: Simple example illustrating some parts of the geometry package. TODO: - select tolerance level - allow editing of the point set
org.apache.commons.math4.userguide.rng.RandomNumberGeneratorBenchmark: Benchmark of the RNGs.
org.apache.commons.math4.userguide.rng.RandomNumberGeneratorBenchmark.benchmark	(	List	): Test all generators. The reference is JDK's "Random".
org.apache.commons.math4.userguide.rng.RandomNumberGeneratorBenchmark.main	(	String[]	): Program's entry point.
org.apache.commons.math4.userguide.rng.RandomNumberGeneratorBenchmark.printEnv	(	): Print environment.
org.apache.commons.math4.userguide.sofm.ChineseRings: Class that creates two intertwined rings. Each ring is composed of a cloud of points.
org.apache.commons.math4.userguide.sofm.ChineseRings.ChineseRings	(	Cartesian3D	double	double	double	double	int	int	): 
org.apache.commons.math4.userguide.sofm.ChineseRings.getPoints	(	): Gets all the points.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier: SOFM for categorizing points that belong to each of two intertwined rings. The output currently consists in 3 text files:  "before.chinese.U.seq.dat": U-matrix of the SOFM before training "after.chinese.U.seq.dat": U-matrix of the SOFM after training "after.chinese.hit.seq.dat": Hit histogram after training 
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.ChineseRingsClassifier	(	ChineseRings	int	int	): 
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.computeHitHistogram	(	): Computes the hit histogram.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.computeQuantizationError	(	): Computes the quantization error.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.computeTopographicError	(	): Computes the topographic error.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.computeU	(	): Computes the U-matrix.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.createIterable	(	): Creates an iterable that will present the points coordinates.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.createParallelTasks	(	int	long	): Creates training tasks.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.createRandomIterator	(	long	): Creates an iterator that will present a series of points coordinates in a random order.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.createSequentialTask	(	long	): Creates a training task.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.makeInitializers	(	): Creates the features' initializers. They are sampled from a uniform distribution around the barycentre of the rings.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.printHit	(	String	ChineseRingsClassifier	): Prints the hit histogram of the map to the given filename.
org.apache.commons.math4.userguide.sofm.ChineseRingsClassifier.printU	(	String	ChineseRingsClassifier	): Prints the U-matrix of the map to the given filename.
org.apache.commons.math4.util.BigReal: Arbitrary precision decimal number.  This class is a simple wrapper around the standard BigDecimal in order to implement the FieldElement interface. 
org.apache.commons.math4.util.BigReal.BigReal	(	BigDecimal	): Build an instance from a BigDecimal.
org.apache.commons.math4.util.BigReal.BigReal	(	BigInteger	): Build an instance from a BigInteger.
org.apache.commons.math4.util.BigReal.BigReal	(	BigInteger	MathContext	): Build an instance from a BigInteger.
org.apache.commons.math4.util.BigReal.BigReal	(	BigInteger	int	): Build an instance from an unscaled BigInteger.
org.apache.commons.math4.util.BigReal.BigReal	(	BigInteger	int	MathContext	): Build an instance from an unscaled BigInteger.
org.apache.commons.math4.util.BigReal.BigReal	(	String	): Build an instance from a String representation.
org.apache.commons.math4.util.BigReal.BigReal	(	String	MathContext	): Build an instance from a String representation.
org.apache.commons.math4.util.BigReal.BigReal	(	char[]	): Build an instance from a characters representation.
org.apache.commons.math4.util.BigReal.BigReal	(	char[]	MathContext	): Build an instance from a characters representation.
org.apache.commons.math4.util.BigReal.BigReal	(	char[]	int	int	): Build an instance from a characters representation.
org.apache.commons.math4.util.BigReal.BigReal	(	char[]	int	int	MathContext	): Build an instance from a characters representation.
org.apache.commons.math4.util.BigReal.BigReal	(	double	): Build an instance from a double.
org.apache.commons.math4.util.BigReal.BigReal	(	double	MathContext	): Build an instance from a double.
org.apache.commons.math4.util.BigReal.BigReal	(	int	): Build an instance from an int.
org.apache.commons.math4.util.BigReal.BigReal	(	int	MathContext	): Build an instance from an int.
org.apache.commons.math4.util.BigReal.BigReal	(	long	): Build an instance from a long.
org.apache.commons.math4.util.BigReal.BigReal	(	long	MathContext	): Build an instance from a long.
org.apache.commons.math4.util.BigReal.add	(	BigReal	):  
org.apache.commons.math4.util.BigReal.bigDecimalValue	(	): Get the BigDecimal value corresponding to the instance.
org.apache.commons.math4.util.BigReal.compareTo	(	BigReal	):  
org.apache.commons.math4.util.BigReal.divide	(	BigReal	): 
org.apache.commons.math4.util.BigReal.doubleValue	(	): Get the double value corresponding to the instance.
org.apache.commons.math4.util.BigReal.equals	(	Object	):  
org.apache.commons.math4.util.BigReal.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.util.BigReal.getRoundingMode	(	): Gets the rounding mode for division operations The default is RoundingMode.HALF_UP
org.apache.commons.math4.util.BigReal.getScale	(	): Sets the scale for division operations. The default is 64
org.apache.commons.math4.util.BigReal.hashCode	(	):  
org.apache.commons.math4.util.BigReal.multiply	(	BigReal	):  
org.apache.commons.math4.util.BigReal.multiply	(	int	): Compute n × this. Multiplication by an integer number is defined as the following sum  n × this = ∑i=1n this.  
org.apache.commons.math4.util.BigReal.negate	(	): Returns the additive inverse of this element. 
org.apache.commons.math4.util.BigReal.reciprocal	(	): Returns the multiplicative inverse of this element.
org.apache.commons.math4.util.BigReal.setRoundingMode	(	RoundingMode	): Sets the rounding mode for decimal divisions.
org.apache.commons.math4.util.BigReal.setScale	(	int	): Sets the scale for division operations.
org.apache.commons.math4.util.BigReal.subtract	(	BigReal	):  
org.apache.commons.math4.util.BigRealField: Representation of real numbers with arbitrary precision field.  This class is a singleton. 
org.apache.commons.math4.util.BigRealField.BigRealField	(	): Private constructor for the singleton.
org.apache.commons.math4.util.BigRealField.LazyHolder: Holder for the instance. We use here the Initialization On Demand Holder Idiom.
org.apache.commons.math4.util.BigRealField.getInstance	(	): Get the unique instance.
org.apache.commons.math4.util.BigRealField.getOne	(	): Get the multiplicative identity of the field.  The multiplicative identity is the element e1 of the field such that for all elements a of the field, the equalities a × e1 = e1 × a = a hold.  
org.apache.commons.math4.util.BigRealField.getRuntimeClass	(	): Returns the runtime class of the FieldElement. 
org.apache.commons.math4.util.BigRealField.getZero	(	): Get the additive identity of the field.  The additive identity is the element e0 of the field such that for all elements a of the field, the equalities a + e0 = e0 + a = a hold.  
org.apache.commons.math4.util.BigRealField.readResolve	(	): Handle deserialization of the singleton.
org.apache.commons.math4.util.CentralPivotingStrategy: A mid point strategy based on the average of begin and end indices.
org.apache.commons.math4.util.CentralPivotingStrategy.pivotIndex	(	double[]	int	int	): Find pivot index of the array so that partition and Kth element selection can be made This in particular picks a average of begin and end indices
org.apache.commons.math4.util.CombinatoricsUtils: Combinatorial utilities.
org.apache.commons.math4.util.CombinatoricsUtils.CombinatoricsUtils	(	): Private constructor (class contains only static methods). 
org.apache.commons.math4.util.CombinatoricsUtils.stirlingS2	(	int	int	): Returns the  Stirling number of the second kind, "S(n,k)", the number of ways of partitioning an n-element set into k non-empty subsets.  The preconditions are 0 <= k <= n (otherwise NotPositiveException is thrown) 
org.apache.commons.math4.util.CombinatoricsUtilsTest: Test cases for the CombinatoricsUtils class.
org.apache.commons.math4.util.CompositeFormat: Base class for formatters of composite objects (complex numbers, vectors ...).
org.apache.commons.math4.util.CompositeFormat.CompositeFormat	(	): Class contains only static methods.
org.apache.commons.math4.util.CompositeFormat.formatDouble	(	double	NumberFormat	StringBuffer	FieldPosition	): Formats a double value to produce a string. In general, the value is formatted using the formatting rules of format. There are three exceptions to this:  NaN is formatted as '(NaN)' Positive infinity is formatted as '(Infinity)' Negative infinity is formatted as '(-Infinity)' 
org.apache.commons.math4.util.CompositeFormat.getDefaultNumberFormat	(	): Create a default number format. The default number format is based on getInstance() with the only customizing that the maximum number of fraction digits is set to 10.
org.apache.commons.math4.util.CompositeFormat.getDefaultNumberFormat	(	Locale	): Create a default number format. The default number format is based on getInstance() with the only customizing that the maximum number of fraction digits is set to 10.
org.apache.commons.math4.util.CompositeFormat.parseAndIgnoreWhitespace	(	String	ParsePosition	): Parses source until a non-whitespace character is found.
org.apache.commons.math4.util.CompositeFormat.parseFixedstring	(	String	String	ParsePosition	): Parse source for an expected fixed string.
org.apache.commons.math4.util.CompositeFormat.parseNextCharacter	(	String	ParsePosition	): Parses source until a non-whitespace character is found.
org.apache.commons.math4.util.CompositeFormat.parseNumber	(	String	NumberFormat	ParsePosition	): Parses source for a number. This method can parse normal, numeric values as well as special values. These special values include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.
org.apache.commons.math4.util.CompositeFormat.parseNumber	(	String	double	ParsePosition	): Parses source for special double values. These values include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.
org.apache.commons.math4.util.Decimal64: This class wraps a double value in an object. It is similar to the standard class Double, while also implementing the RealFieldElement interface.
org.apache.commons.math4.util.Decimal64.Decimal64	(	double	): Creates a new instance of this class.
org.apache.commons.math4.util.Decimal64.abs	(	): absolute value.
org.apache.commons.math4.util.Decimal64.acos	(	): Arc cosine operation.
org.apache.commons.math4.util.Decimal64.acosh	(	): Inverse hyperbolic cosine operation.
org.apache.commons.math4.util.Decimal64.add	(	Decimal64	):  The current implementation strictly enforces this.add(a).equals(new Decimal64(this.doubleValue() + a.doubleValue())).
org.apache.commons.math4.util.Decimal64.add	(	double	): '+' operator.
org.apache.commons.math4.util.Decimal64.asin	(	): Arc sine operation.
org.apache.commons.math4.util.Decimal64.asinh	(	): Inverse hyperbolic sine operation.
org.apache.commons.math4.util.Decimal64.atan	(	): Arc tangent operation.
org.apache.commons.math4.util.Decimal64.atan2	(	Decimal64	): 
org.apache.commons.math4.util.Decimal64.atanh	(	): Inverse hyperbolic tangent operation.
org.apache.commons.math4.util.Decimal64.byteValue	(	):  The current implementation performs casting to a byte.
org.apache.commons.math4.util.Decimal64.cbrt	(	): Cubic root.
org.apache.commons.math4.util.Decimal64.ceil	(	): Get the smallest whole number larger than instance.
org.apache.commons.math4.util.Decimal64.compareTo	(	Decimal64	):  The current implementation returns the same value as  new Double(this.doubleValue()).compareTo(new Double(o.doubleValue())) 
org.apache.commons.math4.util.Decimal64.copySign	(	Decimal64	): 
org.apache.commons.math4.util.Decimal64.copySign	(	double	): Returns the instance with the sign of the argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.util.Decimal64.cos	(	): Cosine operation.
org.apache.commons.math4.util.Decimal64.cosh	(	): Hyperbolic cosine operation.
org.apache.commons.math4.util.Decimal64.divide	(	Decimal64	):  The current implementation strictly enforces this.divide(a).equals(new Decimal64(this.doubleValue() / a.doubleValue())).
org.apache.commons.math4.util.Decimal64.divide	(	double	): '÷' operator.
org.apache.commons.math4.util.Decimal64.doubleValue	(	):  
org.apache.commons.math4.util.Decimal64.equals	(	Object	):  
org.apache.commons.math4.util.Decimal64.exp	(	): Exponential.
org.apache.commons.math4.util.Decimal64.expm1	(	): Exponential minus 1.
org.apache.commons.math4.util.Decimal64.floatValue	(	):  The current implementation performs casting to a float.
org.apache.commons.math4.util.Decimal64.floor	(	): Get the largest whole number smaller than instance.
org.apache.commons.math4.util.Decimal64.getField	(	): Get the Field to which the instance belongs. 
org.apache.commons.math4.util.Decimal64.getReal	(	): Get the real value of the number.
org.apache.commons.math4.util.Decimal64.hashCode	(	):  The current implementation returns the same value as new Double(this.doubleValue()).hashCode()
org.apache.commons.math4.util.Decimal64.hypot	(	Decimal64	): 
org.apache.commons.math4.util.Decimal64.intValue	(	):  The current implementation performs casting to a int.
org.apache.commons.math4.util.Decimal64.isInfinite	(	): Returns true if this double precision number is infinite (POSITIVE_INFINITY or NEGATIVE_INFINITY).
org.apache.commons.math4.util.Decimal64.isNaN	(	): Returns true if this double precision number is Not-a-Number (NaN), false otherwise.
org.apache.commons.math4.util.Decimal64.linearCombination	(	Decimal64	Decimal64	Decimal64	Decimal64	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	Decimal64	Decimal64	Decimal64	Decimal64	Decimal64	Decimal64	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	Decimal64	Decimal64	Decimal64	Decimal64	Decimal64	Decimal64	Decimal64	Decimal64	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	Decimal64[]	Decimal64[]	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	double	Decimal64	double	Decimal64	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	double	Decimal64	double	Decimal64	double	Decimal64	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	double	Decimal64	double	Decimal64	double	Decimal64	double	Decimal64	): 
org.apache.commons.math4.util.Decimal64.linearCombination	(	double[]	Decimal64[]	): 
org.apache.commons.math4.util.Decimal64.log	(	): Natural logarithm.
org.apache.commons.math4.util.Decimal64.log10	(	): Base 10 logarithm.
org.apache.commons.math4.util.Decimal64.log1p	(	): Shifted natural logarithm.
org.apache.commons.math4.util.Decimal64.longValue	(	):  The current implementation performs casting to a long.
org.apache.commons.math4.util.Decimal64.multiply	(	Decimal64	):  The current implementation strictly enforces this.multiply(a).equals(new Decimal64(this.doubleValue() * a.doubleValue())).
org.apache.commons.math4.util.Decimal64.multiply	(	double	): '×' operator.
org.apache.commons.math4.util.Decimal64.multiply	(	int	): Compute n × this. Multiplication by an integer number is defined as the following sum  n × this = ∑i=1n this.  The current implementation strictly enforces this.multiply(n).equals(new Decimal64(n * this.doubleValue())).
org.apache.commons.math4.util.Decimal64.negate	(	): Returns the additive inverse of this element. The current implementation strictly enforces this.negate().equals(new Decimal64(-this.doubleValue())).
org.apache.commons.math4.util.Decimal64.pow	(	Decimal64	): 
org.apache.commons.math4.util.Decimal64.pow	(	double	): Power operation.
org.apache.commons.math4.util.Decimal64.pow	(	int	): Integer power operation.
org.apache.commons.math4.util.Decimal64.reciprocal	(	): Returns the multiplicative inverse of this element.  The current implementation strictly enforces this.reciprocal().equals(new Decimal64(1.0 / this.doubleValue())).
org.apache.commons.math4.util.Decimal64.remainder	(	Decimal64	): 
org.apache.commons.math4.util.Decimal64.remainder	(	double	): IEEE remainder operator.
org.apache.commons.math4.util.Decimal64.rint	(	): Get the whole number that is the nearest to the instance, or the even one if x is exactly half way between two integers.
org.apache.commons.math4.util.Decimal64.rootN	(	int	): Nth root.
org.apache.commons.math4.util.Decimal64.round	(	): Get the closest long to instance value.
org.apache.commons.math4.util.Decimal64.scalb	(	int	): Multiply the instance by a power of 2.
org.apache.commons.math4.util.Decimal64.shortValue	(	):  The current implementation performs casting to a short.
org.apache.commons.math4.util.Decimal64.signum	(	): Compute the signum of the instance. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
org.apache.commons.math4.util.Decimal64.sin	(	): Sine operation.
org.apache.commons.math4.util.Decimal64.sinh	(	): Hyperbolic sine operation.
org.apache.commons.math4.util.Decimal64.sqrt	(	): Square root.
org.apache.commons.math4.util.Decimal64.subtract	(	Decimal64	):  The current implementation strictly enforces this.subtract(a).equals(new Decimal64(this.doubleValue() - a.doubleValue())).
org.apache.commons.math4.util.Decimal64.subtract	(	double	): '-' operator.
org.apache.commons.math4.util.Decimal64.tan	(	): Tangent operation.
org.apache.commons.math4.util.Decimal64.tanh	(	): Hyperbolic tangent operation.
org.apache.commons.math4.util.Decimal64.toString	(	):  The returned String is equal to Double.toString(this.doubleValue())
org.apache.commons.math4.util.Decimal64Field: The field of double precision floating-point numbers.
org.apache.commons.math4.util.Decimal64Field.Decimal64Field	(	): Default constructor. 
org.apache.commons.math4.util.Decimal64Field.getInstance	(	): Returns the unique instance of this class.
org.apache.commons.math4.util.Decimal64Field.getOne	(	): Get the multiplicative identity of the field.  The multiplicative identity is the element e1 of the field such that for all elements a of the field, the equalities a × e1 = e1 × a = a hold.  
org.apache.commons.math4.util.Decimal64Field.getRuntimeClass	(	): Returns the runtime class of the FieldElement. 
org.apache.commons.math4.util.Decimal64Field.getZero	(	): Get the additive identity of the field.  The additive identity is the element e0 of the field such that for all elements a of the field, the equalities a + e0 = e0 + a = a hold.  
org.apache.commons.math4.util.DefaultTransformer: A Default NumberTransformer for java.lang.Numbers and Numeric Strings. This provides some simple conversion capabilities to turn any java.lang.Number into a primitive double or to turn a String representation of a Number into a double.
org.apache.commons.math4.util.DefaultTransformer.equals	(	Object	):  
org.apache.commons.math4.util.DefaultTransformer.hashCode	(	):  
org.apache.commons.math4.util.DefaultTransformer.transform	(	Object	): Implementing this interface provides a facility to transform from Object to Double.
org.apache.commons.math4.util.DefaultTransformerTest.testTransformBigDecimal	(	): 
org.apache.commons.math4.util.DefaultTransformerTest.testTransformDouble	(	): 
org.apache.commons.math4.util.DefaultTransformerTest.testTransformInteger	(	): 
org.apache.commons.math4.util.DefaultTransformerTest.testTransformNull	(	): 
org.apache.commons.math4.util.DefaultTransformerTest.testTransformObject	(	): 
org.apache.commons.math4.util.DefaultTransformerTest.testTransformString	(	): 
org.apache.commons.math4.util.DoubleArray: Provides a standard interface for double arrays. Allows different array implementations to support various storage mechanisms such as automatic expansion, contraction, and array "rolling".
org.apache.commons.math4.util.DoubleArray.addElement	(	double	): Adds an element to the end of this expandable array
org.apache.commons.math4.util.DoubleArray.addElementRolling	(	double	):  Adds an element to the end of the array and removes the first element in the array. Returns the discarded first element. The effect is similar to a push operation in a FIFO queue.   Example: If the array contains the elements 1, 2, 3, 4 (in that order) and addElementRolling(5) is invoked, the result is an array containing the entries 2, 3, 4, 5 and the value returned is 1. 
org.apache.commons.math4.util.DoubleArray.addElements	(	double[]	): Adds elements to the end of this expandable array
org.apache.commons.math4.util.DoubleArray.clear	(	): Clear the double array
org.apache.commons.math4.util.DoubleArray.getElement	(	int	): Returns the element at the specified index. Note that if an out of bounds index is supplied a ArrayIndexOutOfBoundsException will be thrown.
org.apache.commons.math4.util.DoubleArray.getElements	(	): Returns a double[] array containing the elements of this DoubleArray. If the underlying implementation is array-based, this method should always return a copy, rather than a reference to the underlying array so that changes made to the returned array have no effect on the DoubleArray.
org.apache.commons.math4.util.DoubleArray.getNumElements	(	): Returns the number of elements currently in the array. Please note that this may be different from the length of the internal storage array.
org.apache.commons.math4.util.DoubleArray.setElement	(	int	double	): Sets the element at the specified index. If the specified index is greater than getNumElements() - 1, the numElements property is increased to index +1 and additional storage is allocated (if necessary) for the new element and all (uninitialized) elements between the new element and the previous end of the array).
org.apache.commons.math4.util.DoubleArrayAbstractTest: This class contains test cases for the ExpandableDoubleArray.
org.apache.commons.math4.util.FastMath: Faster, more accurate, portable alternative to Math and StrictMath for large scale computation.  FastMath is a drop-in replacement for both Math and StrictMath. This means that for any method in Math (say Math.sin(x) or Math.cbrt(y)), user can directly change the class and use the methods as is (using FastMath.sin(x) or FastMath.cbrt(y) in the previous example).   FastMath speed is achieved by relying heavily on optimizing compilers to native code present in many JVMs today and use of large tables. The larger tables are lazily initialized on first use, so that the setup time does not penalize methods that don't need them.   Note that FastMath is extensively used inside Apache Commons Math, so by calling some algorithms, the overhead when the the tables need to be initialized will occur regardless of the end-user calling FastMath methods directly or not. Performance figures for a specific JVM and hardware can be evaluated by running the FastMathTestPerformance tests in the test directory of the source distribution.   FastMath accuracy should be mostly independent of the JVM as it relies only on IEEE-754 basic operations and on embedded tables. Almost all operations are accurate to about 0.5 ulp throughout the domain range. This statement, of course is only a rough global observed behavior, it is not a guarantee for every double numbers input (see William Kahan's Table Maker's Dilemma).   FastMath additionally implements the following methods not found in Math/StrictMath:  asinh() acosh() atanh()  The following methods are found in Math/StrictMath since 1.6 only, they are provided by FastMath even in 1.5 Java virtual machines  copySign() getExponent() nextAfter() nextUp() scalb() copySign() getExponent() nextAfter() nextUp() scalb() 
org.apache.commons.math4.util.FastMath.CodyWaite: Enclose the Cody/Waite reduction (used in "sin", "cos" and "tan"). 
org.apache.commons.math4.util.FastMath.CodyWaite.CodyWaite	(	double	): 
org.apache.commons.math4.util.FastMath.CodyWaite.getK	(	): 
org.apache.commons.math4.util.FastMath.CodyWaite.getRemA	(	): 
org.apache.commons.math4.util.FastMath.CodyWaite.getRemB	(	): 
org.apache.commons.math4.util.FastMath.ExpFracTable: Enclose large data table in nested static class so it's only loaded on first access. 
org.apache.commons.math4.util.FastMath.ExpIntTable: Enclose large data table in nested static class so it's only loaded on first access. 
org.apache.commons.math4.util.FastMath.FastMath	(	): Private Constructor
org.apache.commons.math4.util.FastMath.IEEEremainder	(	double	double	): Computes the remainder as prescribed by the IEEE 754 standard. The remainder value is mathematically equal to x - y*n where n is the mathematical integer closest to the exact mathematical value of the quotient x/y. If two mathematical integers are equally close to x/y then n is the integer that is even.  If either operand is NaN, the result is NaN. If the result is not NaN, the sign of the result equals the sign of the dividend. If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN. If the dividend is finite and the divisor is an infinity, the result equals the dividend. If the dividend is a zero and the divisor is finite, the result equals the dividend. 
org.apache.commons.math4.util.FastMath.Split: Class operator on double numbers split into one 26 bits number and one 27 bits number. 
org.apache.commons.math4.util.FastMath.Split.Split	(	double	): Simple constructor.
org.apache.commons.math4.util.FastMath.Split.Split	(	double	double	): Simple constructor.
org.apache.commons.math4.util.FastMath.Split.Split	(	double	double	double	): Simple constructor.
org.apache.commons.math4.util.FastMath.Split.multiply	(	Split	): Multiply the instance by another one.
org.apache.commons.math4.util.FastMath.Split.pow	(	long	): Computes this^e.
org.apache.commons.math4.util.FastMath.Split.reciprocal	(	): Compute the reciprocal of the instance.
org.apache.commons.math4.util.FastMath.abs	(	double	): Absolute value.
org.apache.commons.math4.util.FastMath.abs	(	float	): Absolute value.
org.apache.commons.math4.util.FastMath.abs	(	int	): Absolute value.
org.apache.commons.math4.util.FastMath.abs	(	long	): Absolute value.
org.apache.commons.math4.util.FastMath.acos	(	double	): Compute the arc cosine of a number.
org.apache.commons.math4.util.FastMath.acosh	(	double	): Compute the inverse hyperbolic cosine of a number.
org.apache.commons.math4.util.FastMath.addExact	(	int	int	): Add two numbers, detecting overflows.
org.apache.commons.math4.util.FastMath.addExact	(	long	long	): Add two numbers, detecting overflows.
org.apache.commons.math4.util.FastMath.asin	(	double	): Compute the arc sine of a number.
org.apache.commons.math4.util.FastMath.asinh	(	double	): Compute the inverse hyperbolic sine of a number.
org.apache.commons.math4.util.FastMath.atan	(	double	): Arctangent function
org.apache.commons.math4.util.FastMath.atan	(	double	double	boolean	): Internal helper function to compute arctangent.
org.apache.commons.math4.util.FastMath.atan2	(	double	double	): Two arguments arctangent function
org.apache.commons.math4.util.FastMath.atanh	(	double	): Compute the inverse hyperbolic tangent of a number.
org.apache.commons.math4.util.FastMath.cbrt	(	double	): Compute the cubic root of a number.
org.apache.commons.math4.util.FastMath.ceil	(	double	): Get the smallest whole number larger than x.
org.apache.commons.math4.util.FastMath.copySign	(	double	double	): Returns the first argument with the sign of the second argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.util.FastMath.copySign	(	float	float	): Returns the first argument with the sign of the second argument. A NaN sign argument is treated as positive.
org.apache.commons.math4.util.FastMath.cos	(	double	): Cosine function.
org.apache.commons.math4.util.FastMath.cosQ	(	double	double	): Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ. This is more accurate as the input approaches PI/2.
org.apache.commons.math4.util.FastMath.cosh	(	double	): Compute the hyperbolic cosine of a number.
org.apache.commons.math4.util.FastMath.decrementExact	(	int	): Decrement a number, detecting overflows.
org.apache.commons.math4.util.FastMath.decrementExact	(	long	): Decrement a number, detecting overflows.
org.apache.commons.math4.util.FastMath.doubleHighPart	(	double	): Get the high order bits from the mantissa. Equivalent to adding and subtracting HEX_40000 but also works for very large numbers
org.apache.commons.math4.util.FastMath.exp	(	double	): Exponential function. Computes exp(x), function result is nearly rounded. It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 ULP error. Method: Lookup intVal = exp(int(x)) Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) = intVal * fracVal * (1 + z) Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.
org.apache.commons.math4.util.FastMath.exp	(	double	double	double[]	): Internal helper method for exponential function.
org.apache.commons.math4.util.FastMath.expm1	(	double	): Compute exp(x) - 1
org.apache.commons.math4.util.FastMath.expm1	(	double	double	): Internal helper method for expm1
org.apache.commons.math4.util.FastMath.floor	(	double	): Get the largest whole number smaller than x.
org.apache.commons.math4.util.FastMath.floorDiv	(	int	int	): Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.  This methods returns the same value as integer division when a and b are same signs, but returns a different value when they are opposite (i.e. q is negative). 
org.apache.commons.math4.util.FastMath.floorDiv	(	long	long	): Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.  This methods returns the same value as integer division when a and b are same signs, but returns a different value when they are opposite (i.e. q is negative). 
org.apache.commons.math4.util.FastMath.floorMod	(	int	int	): Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.  This methods returns the same value as integer modulo when a and b are same signs, but returns a different value when they are opposite (i.e. q is negative). 
org.apache.commons.math4.util.FastMath.floorMod	(	long	long	): Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.  This methods returns the same value as integer modulo when a and b are same signs, but returns a different value when they are opposite (i.e. q is negative). 
org.apache.commons.math4.util.FastMath.getExponent	(	double	): Return the exponent of a double number, removing the bias.  For double numbers of the form 2x, the unbiased exponent is exactly x. 
org.apache.commons.math4.util.FastMath.getExponent	(	float	): Return the exponent of a float number, removing the bias.  For float numbers of the form 2x, the unbiased exponent is exactly x. 
org.apache.commons.math4.util.FastMath.hypot	(	double	double	): Returns the hypotenuse of a triangle with sides x and y - sqrt(x2 +y2) avoiding intermediate overflow or underflow.   If either argument is infinite, then the result is positive infinity.  else, if either argument is NaN then the result is NaN. 
org.apache.commons.math4.util.FastMath.incrementExact	(	int	): Increment a number, detecting overflows.
org.apache.commons.math4.util.FastMath.incrementExact	(	long	): Increment a number, detecting overflows.
org.apache.commons.math4.util.FastMath.lnMant: Enclose large data table in nested static class so it's only loaded on first access. 
org.apache.commons.math4.util.FastMath.log	(	double	): Natural logarithm.
org.apache.commons.math4.util.FastMath.log	(	double	double	): Computes the  logarithm in a given base. Returns NaN if either argument is negative. If base is 0 and x is positive, 0 is returned. If base is positive and x is 0, Double.NEGATIVE_INFINITY is returned. If both arguments are 0, the result is NaN.
org.apache.commons.math4.util.FastMath.log	(	double	double[]	): Internal helper method for natural logarithm function.
org.apache.commons.math4.util.FastMath.log10	(	double	): Compute the base 10 logarithm.
org.apache.commons.math4.util.FastMath.log1p	(	double	): Computes log(1 + x).
org.apache.commons.math4.util.FastMath.main	(	String[]	): Print out contents of arrays, and check the length. used to generate the preset arrays originally.
org.apache.commons.math4.util.FastMath.max	(	double	double	): Compute the maximum of two values
org.apache.commons.math4.util.FastMath.max	(	float	float	): Compute the maximum of two values
org.apache.commons.math4.util.FastMath.max	(	int	int	): Compute the maximum of two values
org.apache.commons.math4.util.FastMath.max	(	long	long	): Compute the maximum of two values
org.apache.commons.math4.util.FastMath.min	(	double	double	): Compute the minimum of two values
org.apache.commons.math4.util.FastMath.min	(	float	float	): Compute the minimum of two values
org.apache.commons.math4.util.FastMath.min	(	int	int	): Compute the minimum of two values
org.apache.commons.math4.util.FastMath.min	(	long	long	): Compute the minimum of two values
org.apache.commons.math4.util.FastMath.multiplyExact	(	int	int	): Multiply two numbers, detecting overflows.
org.apache.commons.math4.util.FastMath.multiplyExact	(	long	long	): Multiply two numbers, detecting overflows.
org.apache.commons.math4.util.FastMath.nextAfter	(	double	double	): Get the next machine representable number after a number, moving in the direction of another number.  The ordering is as follows (increasing):  -INFINITY -MAX_VALUE -MIN_VALUE -0.0 +0.0 +MIN_VALUE +MAX_VALUE +INFINITY    If arguments compare equal, then the second argument is returned.  If direction is greater than d, the smallest machine representable number strictly greater than d is returned; if less, then the largest representable number strictly less than d is returned.  If d is infinite and direction does not bring it back to finite numbers, it is returned unchanged.
org.apache.commons.math4.util.FastMath.nextAfter	(	float	double	): Get the next machine representable number after a number, moving in the direction of another number.  The ordering is as follows (increasing):  -INFINITY -MAX_VALUE -MIN_VALUE -0.0 +0.0 +MIN_VALUE +MAX_VALUE +INFINITY    If arguments compare equal, then the second argument is returned.  If direction is greater than f, the smallest machine representable number strictly greater than f is returned; if less, then the largest representable number strictly less than f is returned.  If f is infinite and direction does not bring it back to finite numbers, it is returned unchanged.
org.apache.commons.math4.util.FastMath.nextDown	(	double	): Compute next number towards negative infinity.
org.apache.commons.math4.util.FastMath.nextDown	(	float	): Compute next number towards negative infinity.
org.apache.commons.math4.util.FastMath.nextUp	(	double	): Compute next number towards positive infinity.
org.apache.commons.math4.util.FastMath.nextUp	(	float	): Compute next number towards positive infinity.
org.apache.commons.math4.util.FastMath.polyCosine	(	double	): Computes cos(x) - 1, where |x| < 1/16. Use a Remez polynomial approximation.
org.apache.commons.math4.util.FastMath.polySine	(	double	): Computes sin(x) - x, where |x| < 1/16. Use a Remez polynomial approximation.
org.apache.commons.math4.util.FastMath.pow	(	double	double	): Power function. Compute x^y.
org.apache.commons.math4.util.FastMath.pow	(	double	int	): Raise a double to an int power.
org.apache.commons.math4.util.FastMath.pow	(	double	long	): Raise a double to a long power.
org.apache.commons.math4.util.FastMath.random	(	): Returns a pseudo-random number between 0.0 and 1.0. Note: this implementation currently delegates to random
org.apache.commons.math4.util.FastMath.reducePayneHanek	(	double	double	): Reduce the input argument using the Payne and Hanek method. This is good for all inputs 0.0 < x < inf Output is remainder after dividing by PI/2 The result array should contain 3 numbers. result[0] is the integer portion, so mod 4 this gives the quadrant. result[1] is the upper bits of the remainder result[2] is the lower bits of the remainder
org.apache.commons.math4.util.FastMath.rint	(	double	): Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
org.apache.commons.math4.util.FastMath.round	(	double	): Get the closest long to x.
org.apache.commons.math4.util.FastMath.round	(	float	): Get the closest int to x.
org.apache.commons.math4.util.FastMath.scalb	(	double	int	): Multiply a double number by a power of 2.
org.apache.commons.math4.util.FastMath.scalb	(	float	int	): Multiply a float number by a power of 2.
org.apache.commons.math4.util.FastMath.signum	(	double	): Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
org.apache.commons.math4.util.FastMath.signum	(	float	): Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
org.apache.commons.math4.util.FastMath.sin	(	double	): Sine function.
org.apache.commons.math4.util.FastMath.sinQ	(	double	double	): Compute sine over the first quadrant (0 < x < pi/2). Use combination of table lookup and rational polynomial expansion.
org.apache.commons.math4.util.FastMath.sinh	(	double	): Compute the hyperbolic sine of a number.
org.apache.commons.math4.util.FastMath.sqrt	(	double	): Compute the square root of a number. Note: this implementation currently delegates to sqrt
org.apache.commons.math4.util.FastMath.subtractExact	(	int	int	): Subtract two numbers, detecting overflows.
org.apache.commons.math4.util.FastMath.subtractExact	(	long	long	): Subtract two numbers, detecting overflows.
org.apache.commons.math4.util.FastMath.tan	(	double	): Tangent function.
org.apache.commons.math4.util.FastMath.tanQ	(	double	double	boolean	): Compute tangent (or cotangent) over the first quadrant. 0 < x < pi/2 Use combination of table lookup and rational polynomial expansion.
org.apache.commons.math4.util.FastMath.tanh	(	double	): Compute the hyperbolic tangent of a number.
org.apache.commons.math4.util.FastMath.toDegrees	(	double	): Convert radians to degrees, with error of less than 0.5 ULP
org.apache.commons.math4.util.FastMath.toIntExact	(	long	): Convert a long to integer, detecting overflows
org.apache.commons.math4.util.FastMath.toRadians	(	double	): Convert degrees to radians, with error of less than 0.5 ULP
org.apache.commons.math4.util.FastMath.ulp	(	double	): Compute least significant bit (Unit in Last Position) for a number.
org.apache.commons.math4.util.FastMath.ulp	(	float	): Compute least significant bit (Unit in Last Position) for a number.
org.apache.commons.math4.util.FastMathCalc: Class used to compute the classical functions tables.
org.apache.commons.math4.util.FastMathCalc.FastMathCalc	(	): Private Constructor.
org.apache.commons.math4.util.FastMathCalc.buildSinCosTables	(	double[]	double[]	double[]	double[]	int	double[]	double[]	): Build the sine and cosine tables.
org.apache.commons.math4.util.FastMathCalc.checkLen	(	int	int	): Check two lengths are equal.
org.apache.commons.math4.util.FastMathCalc.expint	(	int	double	): Compute exp(p) for a integer p in extended precision.
org.apache.commons.math4.util.FastMathCalc.format	(	double	): Format a double.
org.apache.commons.math4.util.FastMathCalc.printarray	(	PrintStream	String	int	double[]	): Print an array.
org.apache.commons.math4.util.FastMathCalc.printarray	(	PrintStream	String	int	double[][]	): Print an array.
org.apache.commons.math4.util.FastMathCalc.quadMult	(	double	double	double	): Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.
org.apache.commons.math4.util.FastMathCalc.resplit	(	double	): Recompute a split.
org.apache.commons.math4.util.FastMathCalc.slowCos	(	double	double	): For x between 0 and pi/4 compute cosine using Talor series cos(x) = 1 - x^2/2! + x^4/4! ...
org.apache.commons.math4.util.FastMathCalc.slowLog	(	double	): xi in the range of [1, 2]. 3 5 7 x+1 / x x x \ ln ----- = 2 * | x + ---- + ---- + ---- + ... | 1-x \ 3 5 7 / So, compute a Remez approximation of the following function ln ((sqrt(x)+1)/(1-sqrt(x))) / x This will be an even function with only positive coefficents. x is in the range [0 - 1/3]. Transform xi for input to the above function by setting x = (xi-1)/(xi+1). Input to the polynomial is x^2, then the result is multiplied by x.
org.apache.commons.math4.util.FastMathCalc.slowSin	(	double	double	): For x between 0 and pi/4 compute sine using Taylor expansion: sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...
org.apache.commons.math4.util.FastMathCalc.slowexp	(	double	double	): For x between 0 and 1, returns exp(x), uses extended precision
org.apache.commons.math4.util.FastMathCalc.split	(	double	double	): Compute split[0], split[1] such that their sum is equal to d, and split[0] has its 30 least significant bits as zero.
org.apache.commons.math4.util.FastMathCalc.splitAdd	(	double	double	double	): Add two numbers in split form.
org.apache.commons.math4.util.FastMathCalc.splitMult	(	double	double	double	): Multiply two numbers in split form.
org.apache.commons.math4.util.FastMathCalc.splitReciprocal	(	double	double	): Compute the reciprocal of in. Use the following algorithm. in = c + d. want to find x + y such that x+y = 1/(c+d) and x is much larger than y and x has several zero bits on the right. Set b = 1/(2^22), a = 1 - b. Thus (a+b) = 1. Use following identity to compute (a+b)/(c+d) (a+b)/(c+d) = a/c + (bc - ad) / (c^2 + cd) set x = a/c and y = (bc - ad) / (c^2 + cd) This will be close to the right answer, but there will be some rounding in the calculation of X. So by carefully computing 1 - (c+d)(x+y) we can compute an error and add that back in. This is done carefully so that terms of similar size are subtracted first.
org.apache.commons.math4.util.FastMathLiteralArrays: Utility class for loading tabulated data used by FastMath.
org.apache.commons.math4.util.FastMathLiteralArrays.FastMathLiteralArrays	(	): Class contains only static methods.
org.apache.commons.math4.util.FastMathLiteralArrays.loadExpFracA	(	): Load "EXP_FRAC_A".
org.apache.commons.math4.util.FastMathLiteralArrays.loadExpFracB	(	): Load "EXP_FRAC_B".
org.apache.commons.math4.util.FastMathLiteralArrays.loadExpIntA	(	): Load "EXP_INT_A".
org.apache.commons.math4.util.FastMathLiteralArrays.loadExpIntB	(	): Load "EXP_INT_B".
org.apache.commons.math4.util.FastMathLiteralArrays.loadLnMant	(	): Load "LN_MANT".
org.apache.commons.math4.util.FastMathStrictComparisonTest: Test to compare FastMath results against StrictMath results for boundary values.  Running all tests independently:  mvn test -Dtest=FastMathStrictComparisonTest or just run tests against a single method (e.g. scalb): mvn test -Dtest=FastMathStrictComparisonTest -DargLine="-DtestMethod=scalb"
org.apache.commons.math4.util.FastMathTest.testAcosSpecialCases	(	): Added tests for a 100% coverage of acos().
org.apache.commons.math4.util.FastMathTest.testAsinSpecialCases	(	): Added tests for a 100% coverage of asin().
org.apache.commons.math4.util.FastMathTest.testRoundDown	(	): http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6430675
org.apache.commons.math4.util.Incrementor: Utility that increments a counter until a maximum is reached, at which point, the instance will by default throw a MaxCountExceededException. However, the user is able to override this behaviour by defining a custom MaxCountExceededCallback callback, in order to e.g. select which exception must be thrown.
org.apache.commons.math4.util.Incrementor.Incrementor	(	): Default constructor. For the new instance to be useful, the maximal count must be set by calling setMaximalCount().
org.apache.commons.math4.util.Incrementor.Incrementor	(	int	): Defines a maximal count.
org.apache.commons.math4.util.Incrementor.Incrementor	(	int	MaxCountExceededCallback	): Defines a maximal count and a callback method to be triggered at counter exhaustion.
org.apache.commons.math4.util.Incrementor.MaxCountExceededCallback: Defines a method to be called at counter exhaustion. The trigger() method should usually throw an exception.
org.apache.commons.math4.util.Incrementor.MaxCountExceededCallback.trigger	(	int	): Function called when the maximal count has been reached.
org.apache.commons.math4.util.Incrementor.canIncrement	(	): Checks whether a single increment is allowed.
org.apache.commons.math4.util.Incrementor.getCount	(	): Gets the current count.
org.apache.commons.math4.util.Incrementor.getMaximalCount	(	): Gets the upper limit of the counter.
org.apache.commons.math4.util.Incrementor.incrementCount	(	): Adds one to the current iteration count. At counter exhaustion, this method will call the trigger() method of the callback object passed to the Incrementor() constructor. If not explictly set, a default callback is used that will throw a MaxCountExceededException.
org.apache.commons.math4.util.Incrementor.incrementCount	(	int	): Performs multiple increments. See the other incrementCount() method).
org.apache.commons.math4.util.Incrementor.resetCount	(	): Resets the counter to 0.
org.apache.commons.math4.util.Incrementor.setMaximalCount	(	int	): Sets the upper limit for the counter. This does not automatically reset the current count to zero (see resetCount()).
org.apache.commons.math4.util.IncrementorTest: Test for Incrementor.
org.apache.commons.math4.util.IntegerSequence: Provides a sequence of integers.
org.apache.commons.math4.util.IntegerSequence.Incrementor: Utility that increments a counter until a maximum is reached, at which point, the instance will by default throw a MaxCountExceededException. However, the user is able to override this behaviour by defining a custom MaxCountExceededCallback callback, in order to e.g. select which exception must be thrown.
org.apache.commons.math4.util.IntegerSequence.Incrementor.Incrementor	(	int	int	int	MaxCountExceededCallback	): Creates an incrementor. The counter will be exhausted either when max is reached or when nTimes increments have been performed.
org.apache.commons.math4.util.IntegerSequence.Incrementor.MaxCountExceededCallback: Defines a method to be called at counter exhaustion. The trigger() method should usually throw an exception.
org.apache.commons.math4.util.IntegerSequence.Incrementor.MaxCountExceededCallback.trigger	(	int	): Function called when the maximal count has been reached.
org.apache.commons.math4.util.IntegerSequence.Incrementor.canIncrement	(	): Checks whether incrementing the counter nTimes is allowed.
org.apache.commons.math4.util.IntegerSequence.Incrementor.canIncrement	(	int	): Checks whether incrementing the counter several times is allowed.
org.apache.commons.math4.util.IntegerSequence.Incrementor.create	(	): Factory method that creates a default instance. The initial and maximal values are set to 0. For the new instance to be useful, the maximal count must be set by calling withMaximalCount().
org.apache.commons.math4.util.IntegerSequence.Incrementor.getCount	(	): Gets the current count.
org.apache.commons.math4.util.IntegerSequence.Incrementor.getMaximalCount	(	): Gets the upper limit of the counter.
org.apache.commons.math4.util.IntegerSequence.Incrementor.hasNext	(	):  
org.apache.commons.math4.util.IntegerSequence.Incrementor.increment	(	): Adds the increment value to the current iteration count. At counter exhaustion, this method will call the trigger() method of the callback object passed to the withCallback() method. If not explictly set, a default callback is used that will throw a MaxCountExceededException.
org.apache.commons.math4.util.IntegerSequence.Incrementor.increment	(	int	): Performs multiple increments.
org.apache.commons.math4.util.IntegerSequence.Incrementor.next	(	):  
org.apache.commons.math4.util.IntegerSequence.Incrementor.remove	(	): Not applicable.
org.apache.commons.math4.util.IntegerSequence.Incrementor.withCallback	(	MaxCountExceededCallback	): Creates a new instance with a given callback. The counter is reset to the initial value.
org.apache.commons.math4.util.IntegerSequence.Incrementor.withIncrement	(	int	): Creates a new instance with a given increment. The counter is reset to the initial value.
org.apache.commons.math4.util.IntegerSequence.Incrementor.withMaximalCount	(	int	): Creates a new instance with a given maximal count. The counter is reset to the initial value.
org.apache.commons.math4.util.IntegerSequence.Incrementor.withStart	(	int	): Creates a new instance with a given initial value. The counter is reset to the initial value.
org.apache.commons.math4.util.IntegerSequence.IntegerSequence	(	): Utility class contains only static methods.
org.apache.commons.math4.util.IntegerSequence.Range: Generates a sequence of integers.
org.apache.commons.math4.util.IntegerSequence.Range.Range	(	int	int	int	): Creates a sequence ai, i < 0 < n where ai = start + i * step and n is such that an <= max and an+1 > max.
org.apache.commons.math4.util.IntegerSequence.Range.iterator	(	):  
org.apache.commons.math4.util.IntegerSequence.Range.size	(	): Gets the number of elements contained in the range.
org.apache.commons.math4.util.IntegerSequence.range	(	int	int	): Creates a sequence [start .. end]. It calls range() range(start, end, 1).
org.apache.commons.math4.util.IntegerSequence.range	(	int	int	int	): Creates a sequence ai, i < 0 < n where ai = start + i * step and n is such that an <= max and an+1 > max.
org.apache.commons.math4.util.IntegerSequenceTest: Tests for IntegerSequence and Incrementor.
org.apache.commons.math4.util.IterationEvent: The root class from which all events occurring while running an IterationManager should be derived.
org.apache.commons.math4.util.IterationEvent.IterationEvent	(	Object	int	): Creates a new instance of this class.
org.apache.commons.math4.util.IterationEvent.getIterations	(	): Returns the number of iterations performed at the time this event is created.
org.apache.commons.math4.util.IterationListener: The listener interface for receiving events occurring in an iterative algorithm.
org.apache.commons.math4.util.IterationListener.initializationPerformed	(	IterationEvent	): Invoked after completion of the initial phase of the iterative algorithm (prior to the main iteration loop).
org.apache.commons.math4.util.IterationListener.iterationPerformed	(	IterationEvent	): Invoked each time an iteration is completed (in the main iteration loop).
org.apache.commons.math4.util.IterationListener.iterationStarted	(	IterationEvent	): Invoked each time a new iteration is completed (in the main iteration loop).
org.apache.commons.math4.util.IterationListener.terminationPerformed	(	IterationEvent	): Invoked after completion of the operations which occur after breaking out of the main iteration loop.
org.apache.commons.math4.util.IterationManager: This abstract class provides a general framework for managing iterative algorithms. The maximum number of iterations can be set, and methods are provided to monitor the current iteration count. A lightweight event framework is also provided.
org.apache.commons.math4.util.IterationManager.IterationManager	(	int	): Creates a new instance of this class.
org.apache.commons.math4.util.IterationManager.IterationManager	(	int	Incrementor.MaxCountExceededCallback	): Creates a new instance of this class.
org.apache.commons.math4.util.IterationManager.addIterationListener	(	IterationListener	): Attaches a listener to this manager.
org.apache.commons.math4.util.IterationManager.fireInitializationEvent	(	IterationEvent	): Informs all registered listeners that the initial phase (prior to the main iteration loop) has been completed.
org.apache.commons.math4.util.IterationManager.fireIterationPerformedEvent	(	IterationEvent	): Informs all registered listeners that a new iteration (in the main iteration loop) has been performed.
org.apache.commons.math4.util.IterationManager.fireIterationStartedEvent	(	IterationEvent	): Informs all registered listeners that a new iteration (in the main iteration loop) has been started.
org.apache.commons.math4.util.IterationManager.fireTerminationEvent	(	IterationEvent	): Informs all registered listeners that the final phase (post-iterations) has been completed.
org.apache.commons.math4.util.IterationManager.getIterations	(	): Returns the number of iterations of this solver, 0 if no iterations has been performed yet.
org.apache.commons.math4.util.IterationManager.getMaxIterations	(	): Returns the maximum number of iterations.
org.apache.commons.math4.util.IterationManager.incrementIterationCount	(	): Increments the iteration count by one, and throws an exception if the maximum number of iterations is reached. This method should be called at the beginning of a new iteration.
org.apache.commons.math4.util.IterationManager.removeIterationListener	(	IterationListener	): Removes the specified iteration listener from the list of listeners currently attached to this object. Attempting to remove a listener which was not previously registered does not cause any error.
org.apache.commons.math4.util.IterationManager.resetIterationCount	(	): Sets the iteration count to 0. This method must be called during the initial phase.
org.apache.commons.math4.util.KthSelector: A Simple Kth selector implementation to pick up the Kth ordered element from a work array containing the input numbers.
org.apache.commons.math4.util.KthSelector.KthSelector	(	): Constructor with default MedianOf3PivotingStrategy median of 3 pivoting strategy
org.apache.commons.math4.util.KthSelector.KthSelector	(	PivotingStrategyInterface	): Constructor with specified pivoting strategy
org.apache.commons.math4.util.KthSelector.getPivotingStrategy	(	): Get the pivotin strategy.
org.apache.commons.math4.util.KthSelector.partition	(	double[]	int	int	int	): Partition an array slice around a pivot.Partitioning exchanges array elements such that all elements smaller than pivot are before it and all elements larger than pivot are after it.
org.apache.commons.math4.util.KthSelector.select	(	double[]	int[]	int	): Select Kth value in the array.
org.apache.commons.math4.util.MathArrays: Arrays utilities.
org.apache.commons.math4.util.MathArrays.Function: Real-valued function that operate on an array or a part of it.
org.apache.commons.math4.util.MathArrays.Function.evaluate	(	double[]	): Operates on an entire array.
org.apache.commons.math4.util.MathArrays.Function.evaluate	(	double[]	int	int	): 
org.apache.commons.math4.util.MathArrays.MathArrays	(	): Private constructor.
org.apache.commons.math4.util.MathArrays.PairDoubleInteger: Helper data structure holding a (double, integer) pair.
org.apache.commons.math4.util.MathArrays.PairDoubleInteger.PairDoubleInteger	(	double	int	): 
org.apache.commons.math4.util.MathArrays.PairDoubleInteger.getKey	(	): 
org.apache.commons.math4.util.MathArrays.PairDoubleInteger.getValue	(	): 
org.apache.commons.math4.util.MathArrays.buildArray	(	Field	int	): Build an array of elements.  Arrays are filled with field.getZero()
org.apache.commons.math4.util.MathArrays.buildArray	(	Field	int	int	): Build a double dimension array of elements.  Arrays are filled with field.getZero()
org.apache.commons.math4.util.MathArrays.checkEqualLength	(	double[]	double[]	): Check that both arrays have the same length.
org.apache.commons.math4.util.MathArrays.checkEqualLength	(	double[]	double[]	boolean	): Check that both arrays have the same length.
org.apache.commons.math4.util.MathArrays.checkEqualLength	(	int[]	int[]	): Check that both arrays have the same length.
org.apache.commons.math4.util.MathArrays.checkEqualLength	(	int[]	int[]	boolean	): Check that both arrays have the same length.
org.apache.commons.math4.util.MathArrays.checkNonNegative	(	long[]	): Check that all entries of the input array are >= 0.
org.apache.commons.math4.util.MathArrays.checkNonNegative	(	long[][]	): Check all entries of the input array are >= 0.
org.apache.commons.math4.util.MathArrays.checkNotNaN	(	double[]	): Check that no entry of the input array is NaN.
org.apache.commons.math4.util.MathArrays.checkOrder	(	double[]	): Check that the given array is sorted in strictly increasing order.
org.apache.commons.math4.util.MathArrays.checkOrder	(	double[]	OrderDirection	boolean	): Check that the given array is sorted.
org.apache.commons.math4.util.MathArrays.checkOrder	(	double[]	OrderDirection	boolean	boolean	): Check that the given array is sorted.
org.apache.commons.math4.util.MathArrays.checkPositive	(	double[]	): Check that all entries of the input array are strictly positive.
org.apache.commons.math4.util.MathArrays.checkRectangular	(	long[][]	): Throws DimensionMismatchException if the input array is not rectangular.
org.apache.commons.math4.util.MathArrays.concatenate	(	double[]	): Concatenates a sequence of arrays. The return array consists of the entries of the input arrays concatenated in the order they appear in the argument list. Null arrays cause NullPointerExceptions; zero length arrays are allowed (contributing nothing to the output array).
org.apache.commons.math4.util.MathArrays.convolve	(	double[]	double[]	): Calculates the  convolution between two sequences.  The solution is obtained via straightforward computation of the convolution sum (and not via FFT). Whenever the computation needs an element that would be located at an index outside the input arrays, the value is assumed to be zero.
org.apache.commons.math4.util.MathArrays.copyOf	(	double[]	): Creates a copy of the source array.
org.apache.commons.math4.util.MathArrays.copyOf	(	double[]	int	): Creates a copy of the source array.
org.apache.commons.math4.util.MathArrays.copyOf	(	int[]	): Creates a copy of the source array.
org.apache.commons.math4.util.MathArrays.copyOf	(	int[]	int	): Creates a copy of the source array.
org.apache.commons.math4.util.MathArrays.copyOfRange	(	double[]	int	int	): Creates a copy of the source array.
org.apache.commons.math4.util.MathArrays.distance	(	double[]	double[]	): Calculates the L2 (Euclidean) distance between two points.
org.apache.commons.math4.util.MathArrays.distance	(	int[]	int[]	): Calculates the L2 (Euclidean) distance between two points.
org.apache.commons.math4.util.MathArrays.distance1	(	double[]	double[]	): Calculates the L1 (sum of abs) distance between two points.
org.apache.commons.math4.util.MathArrays.distance1	(	int[]	int[]	): Calculates the L1 (sum of abs) distance between two points.
org.apache.commons.math4.util.MathArrays.distanceInf	(	double[]	double[]	): Calculates the L∞ (max of abs) distance between two points.
org.apache.commons.math4.util.MathArrays.distanceInf	(	int[]	int[]	): Calculates the L∞ (max of abs) distance between two points.
org.apache.commons.math4.util.MathArrays.ebeAdd	(	double[]	double[]	): Creates an array whose contents will be the element-by-element addition of the arguments.
org.apache.commons.math4.util.MathArrays.ebeDivide	(	double[]	double[]	): Creates an array whose contents will be the element-by-element division of the first argument by the second.
org.apache.commons.math4.util.MathArrays.ebeMultiply	(	double[]	double[]	): Creates an array whose contents will be the element-by-element multiplication of the arguments.
org.apache.commons.math4.util.MathArrays.ebeSubtract	(	double[]	double[]	): Creates an array whose contents will be the element-by-element subtraction of the second argument from the first.
org.apache.commons.math4.util.MathArrays.equals	(	double[]	double[]	): Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by equals().
org.apache.commons.math4.util.MathArrays.equals	(	float[]	float[]	): Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by equals().
org.apache.commons.math4.util.MathArrays.equalsIncludingNaN	(	double[]	double[]	): Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by equalsIncludingNaN() this method.
org.apache.commons.math4.util.MathArrays.equalsIncludingNaN	(	float[]	float[]	): Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by equalsIncludingNaN() this method.
org.apache.commons.math4.util.MathArrays.isMonotonic	(	T[]	OrderDirection	boolean	): Check that an array is monotonically increasing or decreasing.
org.apache.commons.math4.util.MathArrays.isMonotonic	(	double[]	OrderDirection	boolean	): Check that an array is monotonically increasing or decreasing.
org.apache.commons.math4.util.MathArrays.natural	(	int	): Returns an array representing the natural number n.
org.apache.commons.math4.util.MathArrays.normalizeArray	(	double[]	double	): Normalizes an array to make it sum to a specified value. Returns the result of the transformation  x |-> x * normalizedSum / sum  applied to each non-NaN element x of the input array, where sum is the sum of the non-NaN entries in the input array.  Throws IllegalArgumentException if normalizedSum is infinite or NaN and ArithmeticException if the input array contains any infinite elements or sums to 0.  Ignores (i.e., copies unchanged to the output array) NaNs in the input array.
org.apache.commons.math4.util.MathArrays.scale	(	double	double[]	): Create a copy of an array scaled by a value.
org.apache.commons.math4.util.MathArrays.scaleInPlace	(	double	double[]	): Multiply each element of an array by a value. The array is modified in place (no copy is created).
org.apache.commons.math4.util.MathArrays.sequence	(	int	int	int	): Returns an array of size integers starting at start, skipping stride numbers.
org.apache.commons.math4.util.MathArrays.sortInPlace	(	double[]	OrderDirection	double[]	): Sort an array in place and perform the same reordering of entries on other arrays. This method works the same as the other sortInPlace() method, but allows the order of the sort to be provided in the dir parameter.
org.apache.commons.math4.util.MathArrays.sortInPlace	(	double[]	double[]	): Sort an array in ascending order in place and perform the same reordering of entries on other arrays. For example, if x = [3, 1, 2], y = [1, 2, 3] and z = [0, 5, 7], then sortInPlace(x, y, z) will update x to [1, 2, 3], y to [2, 3, 1] and z to [5, 7, 0].
org.apache.commons.math4.util.MathArrays.unique	(	double[]	): Returns an array consisting of the unique values in data. The return array is sorted in descending order. Empty arrays are allowed, but null arrays result in NullPointerException. Infinities are allowed. NaN values are allowed with maximum sort order - i.e., if there are NaN values in data, Double.NaN will be the first element of the output array, even if the array also contains Double.POSITIVE_INFINITY.
org.apache.commons.math4.util.MathArrays.verifyValues	(	double[]	double[]	int	int	): This method is used to verify that the begin and length parameters designate a subarray of positive length and the weights are all non-negative, non-NaN, finite, and not all zero.  returns true iff the parameters designate a subarray of positive length and the weights array contains legitimate values. throws IllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array  returns false if the array is non-null, but length is 0. 
org.apache.commons.math4.util.MathArrays.verifyValues	(	double[]	double[]	int	int	boolean	): This method is used to verify that the begin and length parameters designate a subarray of positive length and the weights are all non-negative, non-NaN, finite, and not all zero.  returns true iff the parameters designate a subarray of non-negative length and the weights array contains legitimate values. throws MathIllegalArgumentException if any of the following are true: the values array is null the weights array is null the weights array does not have the same length as the values array the weights array contains one or more infinite values the weights array contains one or more NaN values the weights array contains negative values the start and length arguments do not determine a valid array  returns false if the array is non-null, but length is 0 unless allowEmpty is true. 
org.apache.commons.math4.util.MathArrays.verifyValues	(	double[]	int	int	): This method is used to verify that the input parameters designate a subarray of positive length.  returns true iff the parameters designate a subarray of positive length throws MathIllegalArgumentException if the array is null or or the indices are invalid returns false if the array is non-null, but length is 0. 
org.apache.commons.math4.util.MathArrays.verifyValues	(	double[]	int	int	boolean	): This method is used to verify that the input parameters designate a subarray of positive length.  returns true iff the parameters designate a subarray of non-negative length throws IllegalArgumentException if the array is null or or the indices are invalid returns false if the array is non-null, but length is 0 unless allowEmpty is true 
org.apache.commons.math4.util.MathArraysTest: Test cases for the MathArrays class.
org.apache.commons.math4.util.MathUtils: Miscellaneous utility functions.
org.apache.commons.math4.util.MathUtils.MathUtils	(	): Class contains only static methods.
org.apache.commons.math4.util.MathUtils.checkFinite	(	double	): Check that the argument is a real number.
org.apache.commons.math4.util.MathUtils.checkFinite	(	double[]	): Check that all the elements are real numbers.
org.apache.commons.math4.util.MathUtils.checkNotNull	(	Object	): Checks that an object is not null.
org.apache.commons.math4.util.MathUtils.checkNotNull	(	Object	Localizable	Object	): Checks that an object is not null.
org.apache.commons.math4.util.MathUtils.copySign	(	byte	byte	): Returns the first argument with the sign of the second argument.
org.apache.commons.math4.util.MathUtils.copySign	(	int	int	): Returns the first argument with the sign of the second argument.
org.apache.commons.math4.util.MathUtils.copySign	(	long	long	): Returns the first argument with the sign of the second argument.
org.apache.commons.math4.util.MathUtils.copySign	(	short	short	): Returns the first argument with the sign of the second argument.
org.apache.commons.math4.util.MathUtils.equals	(	double	double	): Returns true if the values are equal according to semantics of equals().
org.apache.commons.math4.util.MathUtils.hash	(	double	): Returns an integer hash code representing the given double value.
org.apache.commons.math4.util.MathUtils.hash	(	double[]	): Returns an integer hash code representing the given double array.
org.apache.commons.math4.util.MathUtils.max	(	T	T	): Find the maximum of two field elements.
org.apache.commons.math4.util.MathUtils.min	(	T	T	): Find the minimum of two field elements.
org.apache.commons.math4.util.MathUtils.reduce	(	double	double	double	): Reduce |a - offset| to the primary interval [0, |period|). Specifically, the value returned is  a - |period| * floor((a - offset) / |period|) - offset. If any of the parameters are NaN or infinite, the result is NaN.
org.apache.commons.math4.util.MathUtilsTest: Test cases for the MathUtils class.
org.apache.commons.math4.util.MathUtilsTest.testPermutedArrayHash	(	): Make sure that permuted arrays do not hash to the same value.
org.apache.commons.math4.util.MedianOf3PivotingStrategy: Classic median of 3 strategy given begin and end indices.
org.apache.commons.math4.util.MedianOf3PivotingStrategy.pivotIndex	(	double[]	int	int	): Find pivot index of the array so that partition and Kth element selection can be made This in specific makes use of median of 3 pivoting.
org.apache.commons.math4.util.MultidimensionalCounter: Converter between unidimensional storage structure and multidimensional conceptual structure. This utility will convert from indices in a multidimensional structure to the corresponding index in a one-dimensional array. For example, assuming that the ranges (in 3 dimensions) of indices are 2, 4 and 3, the following correspondences, between 3-tuples indices and unidimensional indices, will hold:  (0, 0, 0) corresponds to 0 (0, 0, 1) corresponds to 1 (0, 0, 2) corresponds to 2 (0, 1, 0) corresponds to 3 ... (1, 0, 0) corresponds to 12 ... (1, 3, 2) corresponds to 23 
org.apache.commons.math4.util.MultidimensionalCounter.Iterator: Perform iteration over the multidimensional counter.
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.Iterator	(	): Create an iterator
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.getCount	(	): Get the current unidimensional counter slot.
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.getCount	(	int	): Get the current count in the selected dimension.
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.getCounts	(	): Get the current multidimensional counter slots.
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.hasNext	(	): 
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.next	(	): 
org.apache.commons.math4.util.MultidimensionalCounter.Iterator.remove	(	): 
org.apache.commons.math4.util.MultidimensionalCounter.MultidimensionalCounter	(	int	): Create a counter.
org.apache.commons.math4.util.MultidimensionalCounter.getCount	(	int	): Convert to unidimensional counter.
org.apache.commons.math4.util.MultidimensionalCounter.getCounts	(	int	): Convert to multidimensional counter.
org.apache.commons.math4.util.MultidimensionalCounter.getDimension	(	): Get the number of dimensions of the multidimensional counter.
org.apache.commons.math4.util.MultidimensionalCounter.getSize	(	): Get the total number of elements.
org.apache.commons.math4.util.MultidimensionalCounter.getSizes	(	): Get the number of multidimensional counter slots in each dimension.
org.apache.commons.math4.util.MultidimensionalCounter.iterator	(	): Create an iterator over this counter.
org.apache.commons.math4.util.MultidimensionalCounter.toString	(	): 
org.apache.commons.math4.util.MultidimensionalCounterTest: Test cases for the MultidimensionalCounter class.
org.apache.commons.math4.util.NumberTransformer: Subclasses implementing this interface can transform Objects to doubles. No longer extends Serializable since 2.0
org.apache.commons.math4.util.NumberTransformer.transform	(	Object	): Implementing this interface provides a facility to transform from Object to Double.
org.apache.commons.math4.util.OpenIntToDoubleHashMap: Open addressed map from int to double. This class provides a dedicated map from integers to doubles with a much smaller memory overhead than standard java.util.Map. This class is not synchronized. The specialized iterators returned by iterator() are fail-fast: they throw a ConcurrentModificationException when they detect the map has been modified during iteration.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.Iterator: Iterator class for the map. 
org.apache.commons.math4.util.OpenIntToDoubleHashMap.Iterator.Iterator	(	): Simple constructor.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.Iterator.advance	(	): Advance iterator one step further.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.Iterator.hasNext	(	): Check if there is a next element in the map.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.Iterator.key	(	): Get the key of current entry.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.Iterator.value	(	): Get the value of current entry.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap	(	): Build an empty map with default size and using NaN for missing entries.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap	(	OpenIntToDoubleHashMap	): Copy constructor.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap	(	double	): Build an empty map with default size
org.apache.commons.math4.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap	(	int	): Build an empty map with specified size and using NaN for missing entries.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap	(	int	double	): Build an empty map with specified size.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.changeIndexSign	(	int	): Change the index sign
org.apache.commons.math4.util.OpenIntToDoubleHashMap.computeCapacity	(	int	): Compute the capacity needed for a given size.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.containsKey	(	int	): Check if a value is associated with a key.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.containsKey	(	int	int	): Check if the tables contain an element associated with specified key at specified index.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.doRemove	(	int	): Remove an element at specified index.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.findInsertionIndex	(	int	): Find the index at which a key should be inserted
org.apache.commons.math4.util.OpenIntToDoubleHashMap.findInsertionIndex	(	int[]	byte[]	int	int	): Find the index at which a key should be inserted
org.apache.commons.math4.util.OpenIntToDoubleHashMap.get	(	int	): Get the stored value associated with the given key
org.apache.commons.math4.util.OpenIntToDoubleHashMap.growTable	(	): Grow the tables.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.hashOf	(	int	): Compute the hash value of a key
org.apache.commons.math4.util.OpenIntToDoubleHashMap.iterator	(	): Get an iterator over map elements. The specialized iterators returned are fail-fast: they throw a ConcurrentModificationException when they detect the map has been modified during iteration.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.nextPowerOfTwo	(	int	): Find the smallest power of two greater than the input value
org.apache.commons.math4.util.OpenIntToDoubleHashMap.perturb	(	int	): Perturb the hash for starting probing.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.probe	(	int	int	): Compute next probe for collision resolution
org.apache.commons.math4.util.OpenIntToDoubleHashMap.put	(	int	double	): Put a value associated with a key in the map.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.readObject	(	ObjectInputStream	): Read a serialized object.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.remove	(	int	): Remove the value associated with a key.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.shouldGrowTable	(	): Check if tables should grow due to increased size.
org.apache.commons.math4.util.OpenIntToDoubleHashMap.size	(	): Get the number of elements stored in the map.
org.apache.commons.math4.util.OpenIntToDoubleHashMapTest: Test cases for the OpenIntToDoubleHashMap.
org.apache.commons.math4.util.OpenIntToDoubleHashMapTest.generateAbsent	(	): Returns a map with at least 100 elements where each element is absent from javaMap.
org.apache.commons.math4.util.OpenIntToDoubleHashMapTest.testPutKeysWithCollision2	(	): Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly different manner.
org.apache.commons.math4.util.OpenIntToDoubleHashMapTest.testPutKeysWithCollisions	(	): Regression test for a bug in findInsertionIndex where the hashing in the second probing loop was inconsistent with the first causing duplicate keys after the right sequence of puts and removes.
org.apache.commons.math4.util.OpenIntToFieldHashMap: Open addressed map from int to FieldElement. This class provides a dedicated map from integers to FieldElements with a much smaller memory overhead than standard java.util.Map. This class is not synchronized. The specialized iterators returned by iterator() are fail-fast: they throw a ConcurrentModificationException when they detect the map has been modified during iteration.
org.apache.commons.math4.util.OpenIntToFieldHashMap.Iterator: Iterator class for the map. 
org.apache.commons.math4.util.OpenIntToFieldHashMap.Iterator.Iterator	(	): Simple constructor.
org.apache.commons.math4.util.OpenIntToFieldHashMap.Iterator.advance	(	): Advance iterator one step further.
org.apache.commons.math4.util.OpenIntToFieldHashMap.Iterator.hasNext	(	): Check if there is a next element in the map.
org.apache.commons.math4.util.OpenIntToFieldHashMap.Iterator.key	(	): Get the key of current entry.
org.apache.commons.math4.util.OpenIntToFieldHashMap.Iterator.value	(	): Get the value of current entry.
org.apache.commons.math4.util.OpenIntToFieldHashMap.OpenIntToFieldHashMap	(	Field	): Build an empty map with default size and using zero for missing entries.
org.apache.commons.math4.util.OpenIntToFieldHashMap.OpenIntToFieldHashMap	(	Field	T	): Build an empty map with default size
org.apache.commons.math4.util.OpenIntToFieldHashMap.OpenIntToFieldHashMap	(	Field	int	): Build an empty map with specified size and using zero for missing entries.
org.apache.commons.math4.util.OpenIntToFieldHashMap.OpenIntToFieldHashMap	(	Field	int	T	): Build an empty map with specified size.
org.apache.commons.math4.util.OpenIntToFieldHashMap.OpenIntToFieldHashMap	(	OpenIntToFieldHashMap	): Copy constructor.
org.apache.commons.math4.util.OpenIntToFieldHashMap.buildArray	(	int	): Build an array of elements.
org.apache.commons.math4.util.OpenIntToFieldHashMap.changeIndexSign	(	int	): Change the index sign
org.apache.commons.math4.util.OpenIntToFieldHashMap.computeCapacity	(	int	): Compute the capacity needed for a given size.
org.apache.commons.math4.util.OpenIntToFieldHashMap.containsKey	(	int	): Check if a value is associated with a key.
org.apache.commons.math4.util.OpenIntToFieldHashMap.containsKey	(	int	int	): Check if the tables contain an element associated with specified key at specified index.
org.apache.commons.math4.util.OpenIntToFieldHashMap.doRemove	(	int	): Remove an element at specified index.
org.apache.commons.math4.util.OpenIntToFieldHashMap.findInsertionIndex	(	int	): Find the index at which a key should be inserted
org.apache.commons.math4.util.OpenIntToFieldHashMap.findInsertionIndex	(	int[]	byte[]	int	int	): Find the index at which a key should be inserted
org.apache.commons.math4.util.OpenIntToFieldHashMap.get	(	int	): Get the stored value associated with the given key
org.apache.commons.math4.util.OpenIntToFieldHashMap.growTable	(	): Grow the tables.
org.apache.commons.math4.util.OpenIntToFieldHashMap.hashOf	(	int	): Compute the hash value of a key
org.apache.commons.math4.util.OpenIntToFieldHashMap.iterator	(	): Get an iterator over map elements. The specialized iterators returned are fail-fast: they throw a ConcurrentModificationException when they detect the map has been modified during iteration.
org.apache.commons.math4.util.OpenIntToFieldHashMap.nextPowerOfTwo	(	int	): Find the smallest power of two greater than the input value
org.apache.commons.math4.util.OpenIntToFieldHashMap.perturb	(	int	): Perturb the hash for starting probing.
org.apache.commons.math4.util.OpenIntToFieldHashMap.probe	(	int	int	): Compute next probe for collision resolution
org.apache.commons.math4.util.OpenIntToFieldHashMap.put	(	int	T	): Put a value associated with a key in the map.
org.apache.commons.math4.util.OpenIntToFieldHashMap.readObject	(	ObjectInputStream	): Read a serialized object.
org.apache.commons.math4.util.OpenIntToFieldHashMap.remove	(	int	): Remove the value associated with a key.
org.apache.commons.math4.util.OpenIntToFieldHashMap.shouldGrowTable	(	): Check if tables should grow due to increased size.
org.apache.commons.math4.util.OpenIntToFieldHashMap.size	(	): Get the number of elements stored in the map.
org.apache.commons.math4.util.OpenIntToFieldTest.generateAbsent	(	): Returns a map with at least 100 elements where each element is absent from javaMap.
org.apache.commons.math4.util.OpenIntToFieldTest.testPutKeysWithCollision2	(	): Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly different manner.
org.apache.commons.math4.util.OpenIntToFieldTest.testPutKeysWithCollisions	(	): Regression test for a bug in findInsertionIndex where the hashing in the second probing loop was inconsistent with the first causing duplicate keys after the right sequence of puts and removes.
org.apache.commons.math4.util.Pair: Generic pair.  Although the instances of this class are immutable, it is impossible to ensure that the references passed to the constructor will not be modified by the caller.
org.apache.commons.math4.util.Pair.Pair	(	K	V	): Create an entry representing a mapping from the specified key to the specified value.
org.apache.commons.math4.util.Pair.Pair	(	Pair	): Create an entry representing the same mapping as the specified entry.
org.apache.commons.math4.util.Pair.create	(	K	V	): Convenience factory method that calls the Pair() constructor.
org.apache.commons.math4.util.Pair.equals	(	Object	): Compare the specified object with this entry for equality.
org.apache.commons.math4.util.Pair.getFirst	(	): Get the first element of the pair.
org.apache.commons.math4.util.Pair.getKey	(	): Get the key.
org.apache.commons.math4.util.Pair.getSecond	(	): Get the second element of the pair.
org.apache.commons.math4.util.Pair.getValue	(	): Get the value.
org.apache.commons.math4.util.Pair.hashCode	(	): Compute a hash code.
org.apache.commons.math4.util.Pair.toString	(	):  
org.apache.commons.math4.util.PairTest: Test for Pair.
org.apache.commons.math4.util.PairTest.MyInteger: A mutable integer.
org.apache.commons.math4.util.PivotingStrategyInterface: A strategy to pick a pivoting index of an array for doing partitioning.
org.apache.commons.math4.util.PivotingStrategyInterface.pivotIndex	(	double[]	int	int	): Find pivot index of the array so that partition and Kth element selection can be made
org.apache.commons.math4.util.RandomPivotingStrategy: A strategy of selecting random index between begin and end indices.
org.apache.commons.math4.util.RandomPivotingStrategy.RandomPivotingStrategy	(	RandomSource	long	): Simple constructor.
org.apache.commons.math4.util.RandomPivotingStrategy.pivotIndex	(	double[]	int	int	): Find pivot index of the array so that partition and Kth element selection can be made A uniform random pivot selection between begin and end indices.
org.apache.commons.math4.util.RandomPivotingStrategy.readObject	(	ObjectInputStream	): 
org.apache.commons.math4.util.RandomPivotingStrategy.writeObject	(	ObjectOutputStream	): 
org.apache.commons.math4.util.ResizableDoubleArray: A variable length DoubleArray implementation that automatically handles expanding and contracting its internal storage array as elements are added and removed.  The internal storage array starts with capacity determined by the initialCapacity property, which can be set by the constructor. The default initial capacity is 16. Adding elements using addElement() appends elements to the end of the array. When there are no open entries at the end of the internal storage array, the array is expanded. The size of the expanded array depends on the expansionMode and expansionFactor properties. The expansionMode determines whether the size of the array is multiplied by the expansionFactor (MULTIPLICATIVE) or if the expansion is additive (ADDITIVE -- expansionFactor storage locations added). The default expansionMode is MULTIPLICATIVE and the default expansionFactor is 2.  The addElementRolling() method adds a new element to the end of the internal storage array and adjusts the "usable window" of the internal array forward by one position (effectively making what was the second element the first, and so on). Repeated activations of this method (or activation of discardFrontElements()) will effectively orphan the storage locations at the beginning of the internal storage array. To reclaim this storage, each time one of these methods is activated, the size of the internal storage array is compared to the number of addressable elements (the numElements property) and if the difference is too large, the internal array is contracted to size numElements + 1. The determination of when the internal storage array is "too large" depends on the expansionMode and contractionFactor properties. If the expansionMode is MULTIPLICATIVE, contraction is triggered when the ratio between storage array length and numElements exceeds contractionFactor. If the expansionMode is ADDITIVE, the number of excess storage locations is compared to contractionFactor.  To avoid cycles of expansions and contractions, the expansionFactor must not exceed the contractionFactor. Constructors and mutators for both of these properties enforce this requirement, throwing a MathIllegalArgumentException if it is violated.  Note: this class is NOT thread-safe.
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	): Creates an instance with default properties.  initialCapacity = 16 expansionMode = MULTIPLICATIVE expansionFactor = 2.0 contractionCriterion = 2.5 
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	ResizableDoubleArray	): Copy constructor.  Creates a new ResizableDoubleArray that is a deep, fresh copy of the original. Original may not be null; otherwise a NullArgumentException is thrown.
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	double[]	): Creates an instance from an existing double[] with the initial capacity and numElements corresponding to the size of the supplied double[] array.  If the supplied array is null, a new empty array with the default initial capacity will be created. The input array is copied, not referenced. Other properties take default values:  expansionMode = MULTIPLICATIVE expansionFactor = 2.0 contractionCriterion = 2.5 
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	int	): Creates an instance with the specified initial capacity.  Other properties take default values:  expansionMode = MULTIPLICATIVE expansionFactor = 2.0 contractionCriterion = 2.5 
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	int	double	): Creates an instance with the specified initial capacity and expansion factor.  The remaining properties take default values:  expansionMode = MULTIPLICATIVE contractionCriterion = 0.5 + expansionFactor   Throws MathIllegalArgumentException if the following conditions are not met:  initialCapacity > 0 expansionFactor > 1 
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	int	double	double	): Creates an instance with the specified initial capacity, expansion factor, and contraction criteria.  The expansion mode will default to MULTIPLICATIVE.  Throws MathIllegalArgumentException if the following conditions are not met:  initialCapacity > 0 expansionFactor > 1 contractionCriterion >= expansionFactor 
org.apache.commons.math4.util.ResizableDoubleArray.ResizableDoubleArray	(	int	double	double	ExpansionMode	double	): Creates an instance with the specified properties.  Throws MathIllegalArgumentException if the following conditions are not met:  initialCapacity > 0 expansionFactor > 1 contractionCriterion >= expansionFactor 
org.apache.commons.math4.util.ResizableDoubleArray.addElement	(	double	): Adds an element to the end of this expandable array.
org.apache.commons.math4.util.ResizableDoubleArray.addElementRolling	(	double	): Adds an element to the end of the array and removes the first element in the array. Returns the discarded first element.  The effect is similar to a push operation in a FIFO queue.  Example: If the array contains the elements 1, 2, 3, 4 (in that order) and addElementRolling(5) is invoked, the result is an array containing the entries 2, 3, 4, 5 and the value returned is 1.
org.apache.commons.math4.util.ResizableDoubleArray.addElements	(	double[]	): Adds several element to the end of this expandable array.
org.apache.commons.math4.util.ResizableDoubleArray.checkContractExpand	(	double	double	): Checks the expansion factor and the contraction criterion and raises an exception if the contraction criterion is smaller than the expansion criterion.
org.apache.commons.math4.util.ResizableDoubleArray.clear	(	): Clear the array contents, resetting the number of elements to zero.
org.apache.commons.math4.util.ResizableDoubleArray.compute	(	MathArrays.Function	): Performs an operation on the addressable elements of the array.
org.apache.commons.math4.util.ResizableDoubleArray.contract	(	): Contracts the storage array to the (size of the element set) + 1 - to avoid a zero length array. This function also resets the startIndex to zero.
org.apache.commons.math4.util.ResizableDoubleArray.copy	(	): Returns a copy of the ResizableDoubleArray. Does not contract before the copy, so the returned object is an exact copy of this.
org.apache.commons.math4.util.ResizableDoubleArray.discardExtremeElements	(	int	boolean	): Discards the i first or last elements of the array, depending on the value of front.  For example, if the array contains the elements 1,2,3,4, invoking discardExtremeElements(2,false) will cause the last two elements to be discarded, leaving 1,2 in the array. For example, if the array contains the elements 1,2,3,4, invoking discardExtremeElements(2,true) will cause the first two elements to be discarded, leaving 3,4 in the array.
org.apache.commons.math4.util.ResizableDoubleArray.discardFrontElements	(	int	): Discards the i initial elements of the array.  For example, if the array contains the elements 1,2,3,4, invoking discardFrontElements(2) will cause the first two elements to be discarded, leaving 3,4 in the array.
org.apache.commons.math4.util.ResizableDoubleArray.discardMostRecentElements	(	int	): Discards the i last elements of the array.  For example, if the array contains the elements 1,2,3,4, invoking discardMostRecentElements(2) will cause the last two elements to be discarded, leaving 1,2 in the array.
org.apache.commons.math4.util.ResizableDoubleArray.equals	(	Object	): Returns true iff object is a ResizableDoubleArray with the same properties as this and an identical internal storage array.
org.apache.commons.math4.util.ResizableDoubleArray.expand	(	): Expands the internal storage array using the expansion factor.  If expansionMode is set to MULTIPLICATIVE, the new array size will be internalArray.length * expansionFactor. If expansionMode is set to ADDITIVE, the length after expansion will be internalArray.length + expansionFactor.
org.apache.commons.math4.util.ResizableDoubleArray.expandTo	(	int	): Expands the internal storage array to the specified size.
org.apache.commons.math4.util.ResizableDoubleArray.getArrayRef	(	): Provides direct access to the internal storage array. Please note that this method returns a reference to this object's storage array, not a copy.  To correctly address elements of the array, the "start index" is required (available via the getStartIndex() method.  This method should only be used to avoid copying the internal array. The returned value must be used for reading only; other uses could lead to this object becoming inconsistent.  The getElements method has no such limitation since it returns a copy of this array's addressable elements.
org.apache.commons.math4.util.ResizableDoubleArray.getCapacity	(	): Gets the currently allocated size of the internal data structure used for storing elements. This is not to be confused with getNumElements() the number of elements actually stored.
org.apache.commons.math4.util.ResizableDoubleArray.getContractionCriterion	(	): The contraction criterion defines when the internal array will contract to store only the number of elements in the element array.  If the expansionMode is MULTIPLICATIVE, contraction is triggered when the ratio between storage array length and numElements exceeds contractionFactor. If the expansionMode is ADDITIVE, the number of excess storage locations is compared to contractionFactor.
org.apache.commons.math4.util.ResizableDoubleArray.getElement	(	int	): Returns the element at the specified index.
org.apache.commons.math4.util.ResizableDoubleArray.getElements	(	): Returns a double array containing the elements of this ResizableArray.  This method returns a copy, not a reference to the underlying array, so that changes made to the returned array have no effect on this ResizableArray.
org.apache.commons.math4.util.ResizableDoubleArray.getExpansionFactor	(	): The expansion factor controls the size of a new array when an array needs to be expanded.  The expansionMode determines whether the size of the array is multiplied by the expansionFactor (MULTIPLICATIVE) or if the expansion is additive (ADDITIVE -- expansionFactor storage locations added). The default expansionMode is MULTIPLICATIVE and the default expansionFactor is 2.0.
org.apache.commons.math4.util.ResizableDoubleArray.getExpansionMode	(	): The expansion mode determines whether the internal storage array grows additively or multiplicatively when it is expanded.
org.apache.commons.math4.util.ResizableDoubleArray.getNumElements	(	): Returns the number of elements currently in the array. Please note that this is different from the length of the internal storage array.
org.apache.commons.math4.util.ResizableDoubleArray.getStartIndex	(	): Returns the "start index" of the internal array. This index is the position of the first addressable element in the internal storage array.  The addressable elements in the array are at indices contained in the interval [getStartIndex(), getStartIndex() + getNumElements() - 1].
org.apache.commons.math4.util.ResizableDoubleArray.hashCode	(	): Returns a hash code consistent with equals.
org.apache.commons.math4.util.ResizableDoubleArray.setElement	(	int	double	): Sets the element at the specified index.  If the specified index is greater than getNumElements() - 1, the numElements property is increased to index +1 and additional storage is allocated (if necessary) for the new element and all (uninitialized) elements between the new element and the previous end of the array).
org.apache.commons.math4.util.ResizableDoubleArray.setNumElements	(	int	): This function allows you to control the number of elements contained in this array, and can be used to "throw out" the last n values in an array. This function will also expand the internal array as needed.
org.apache.commons.math4.util.ResizableDoubleArray.shouldContract	(	): Returns true if the internal storage array has too many unused storage positions.
org.apache.commons.math4.util.ResizableDoubleArray.substituteMostRecentElement	(	double	): Substitutes value for the most recently added value.  Returns the value that has been replaced. If the array is empty (i.e. if numElements is zero), an MathIllegalStateException is thrown.
org.apache.commons.math4.util.ResizableDoubleArrayTest: This class contains test cases for the ResizableDoubleArray.
org.apache.commons.math4.util.TestBean.getX	(	): 
org.apache.commons.math4.util.TestBean.getY	(	): 
org.apache.commons.math4.util.TestBean.getZ	(	): 
org.apache.commons.math4.util.TestBean.setX	(	Double	): 
org.apache.commons.math4.util.TestBean.setY	(	String	): 
org.apache.commons.math4.util.TestBean.setZ	(	Double	): 
org.apache.commons.math4.util.TransformerMap: This TansformerMap automates the transformation of mixed object types. It provides a means to set NumberTransformers that will be selected based on the Class of the object handed to the Maps double transform(Object o) method.
org.apache.commons.math4.util.TransformerMap.TransformerMap	(	): Build a map containing only the default transformer.
org.apache.commons.math4.util.TransformerMap.classes	(	): Returns the Set of Classes used as keys in the map.
org.apache.commons.math4.util.TransformerMap.clear	(	): Clears all the Class to Transformer mappings.
org.apache.commons.math4.util.TransformerMap.containsClass	(	Class	): Tests if a Class is present in the TransformerMap.
org.apache.commons.math4.util.TransformerMap.containsTransformer	(	NumberTransformer	): Tests if a NumberTransformer is present in the TransformerMap.
org.apache.commons.math4.util.TransformerMap.equals	(	Object	):  
org.apache.commons.math4.util.TransformerMap.getTransformer	(	Class	): Returns the Transformer that is mapped to a class if mapping is not present, this returns null.
org.apache.commons.math4.util.TransformerMap.hashCode	(	):  
org.apache.commons.math4.util.TransformerMap.putTransformer	(	Class	NumberTransformer	): Sets a Class to Transformer Mapping in the Map. If the Class is already present, this overwrites that mapping.
org.apache.commons.math4.util.TransformerMap.removeTransformer	(	Class	): Removes a Class to Transformer Mapping in the Map.
org.apache.commons.math4.util.TransformerMap.transform	(	Object	): Attempts to transform the Object against the map of NumberTransformers. Otherwise it returns Double.NaN.
org.apache.commons.math4.util.TransformerMap.transformers	(	): Returns the Set of NumberTransformers used as values in the map.
org.apache.commons.math4.util.TransformerMapTest.testClasses	(	): 
org.apache.commons.math4.util.TransformerMapTest.testClear	(	): 
org.apache.commons.math4.util.TransformerMapTest.testContainsClass	(	): 
org.apache.commons.math4.util.TransformerMapTest.testContainsTransformer	(	): 
org.apache.commons.math4.util.TransformerMapTest.testPutTransformer	(	): 
org.apache.commons.math4.util.TransformerMapTest.testRemoveTransformer	(	): 
org.apache.commons.math4.util.TransformerMapTest.testTransformers	(	): 
