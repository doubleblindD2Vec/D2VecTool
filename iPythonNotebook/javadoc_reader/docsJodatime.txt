org.joda.example.time.AgeCalculator: AgeCalculator is a small Swing application that computes age from a specific birthdate and time zone. Age is broken down into multiple fields, which can be independently disabled.
org.joda.example.time.DateTimeBrowser: DateTimeBrowser is a Java Swing application which reads a file containing strings and displays DateTime values in a JTable. The input strings must be suitable for instantiation of DateTime objects. The file is read, and an attempt is made to instantiate a DateTimeObject from the input string on each file line. Comments (beginning with '#') and blank lines may appear in the file. Error messages may result from invalid input. Values calculated from any resulting DateTime objects are placed in a JTable and displayed in a JFrame.
org.joda.example.time.DateTimeBrowser.main	(	String[]	): This is the main swing application method. It sets up and displays the initial GUI, and controls execution thereafter. Everything else in this class is 'private', please read the code.
org.joda.example.time.DateTimePerformance: DateTimePerformance provides various comparisons between the Java supplied Date classes and the Joda ones.
org.joda.example.time.DateTimePerformance.DateTimePerformance	(	): Constructor
org.joda.example.time.DateTimePerformance.end	(	int	): End the stopwatch and print the result.
org.joda.example.time.DateTimePerformance.main	(	String[]	): Constructor
org.joda.example.time.DateTimePerformance.start	(	String	String	): Start the stopwatch.
org.joda.example.time.Examples: Example code demonstrating how to use Joda-Time.
org.joda.example.time.TimeZoneTable: Prints out all available time zones to standard out in an HTML table.
org.joda.time.Chronology: Chronology provides access to the individual date time fields for a chronological calendar system.  Various chronologies are supported by subclasses including ISO and GregorianJulian. To construct a Chronology you should use the factory methods on the chronology subclass in the chrono package.  For example, to obtain the current time in the coptic calendar system:  DateTime dt = new DateTime(CopticChronology.getInstance());   The provided chronology implementations are:  ISO - The de facto world calendar system, based on the ISO-8601 standard GJ - Historically accurate calendar with Julian followed by Gregorian Gregorian - The Gregorian calendar system used for all time (proleptic) Julian - The Julian calendar system used for all time (proleptic) Buddhist - The Buddhist calendar system which is an offset in years from GJ Coptic - The Coptic calendar system which defines 30 day months Ethiopic - The Ethiopic calendar system which defines 30 day months Islamic - The Islamic, or Hijri, lunar calendar system  Hopefully future releases will contain more chronologies.  This class defines a number of fields with names from the ISO8601 standard. It does not 'strongly' define these fields however, thus implementations are free to interpret the field names as they wish. For example, a week could be defined as 10 days and a month as 40 days in a special WeirdChronology implementation. Clearly the GJ and ISO implementations provided use the field names as you would expect.
org.joda.time.Chronology.add	(	ReadablePeriod	long	int	): Adds the period to the instant, specifying the number of times to add.
org.joda.time.Chronology.add	(	long	long	int	): Adds the duration to the instant, specifying the number of times to add.
org.joda.time.Chronology.centuries	(	): Get the centuries duration field for this chronology.
org.joda.time.Chronology.centuryOfEra	(	): Get the century of era field for this chronology.
org.joda.time.Chronology.clockhourOfDay	(	): Get the hour of day (offset to 1-24) field for this chronology.
org.joda.time.Chronology.clockhourOfHalfday	(	): Get the hour of am/pm (offset to 1-12) field for this chronology.
org.joda.time.Chronology.dayOfMonth	(	): Get the day of month field for this chronology.
org.joda.time.Chronology.dayOfWeek	(	): Get the day of week field for this chronology. DayOfWeek values are defined in DateTimeConstants. They use the ISO definitions, where 1 is Monday and 7 is Sunday.
org.joda.time.Chronology.dayOfYear	(	): Get the day of year field for this chronology.
org.joda.time.Chronology.days	(	): Get the days duration field for this chronology.
org.joda.time.Chronology.era	(	): Get the era field for this chronology.
org.joda.time.Chronology.eras	(	): Get the eras duration field for this chronology.
org.joda.time.Chronology.get	(	ReadablePartial	long	): Gets the values of a partial from an instant.
org.joda.time.Chronology.get	(	ReadablePeriod	long	): Gets the values of a period from an interval.
org.joda.time.Chronology.get	(	ReadablePeriod	long	long	): Gets the values of a period from an interval.
org.joda.time.Chronology.getDateTimeMillis	(	int	int	int	int	): Returns a datetime millisecond instant, formed from the given year, month, day, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.  The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.Chronology.getDateTimeMillis	(	int	int	int	int	int	int	int	): Returns a datetime millisecond instant, formed from the given year, month, day, hour, minute, second, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.  The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.Chronology.getDateTimeMillis	(	long	int	int	int	int	): Returns a datetime millisecond instant, from from the given instant, hour, minute, second, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.  The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.Chronology.getZone	(	): Returns the DateTimeZone that this Chronology operates in, or null if unspecified.
org.joda.time.Chronology.halfdayOfDay	(	): Get the AM(0) PM(1) field for this chronology.
org.joda.time.Chronology.halfdays	(	): Get the halfdays duration field for this chronology.
org.joda.time.Chronology.hourOfDay	(	): Get the hour of day (0-23) field for this chronology.
org.joda.time.Chronology.hourOfHalfday	(	): Get the hour of am/pm (0-11) field for this chronology.
org.joda.time.Chronology.hours	(	): Get the hours duration field for this chronology.
org.joda.time.Chronology.millis	(	): Get the millis duration field for this chronology.
org.joda.time.Chronology.millisOfDay	(	): Get the millis of day field for this chronology.
org.joda.time.Chronology.millisOfSecond	(	): Get the millis of second field for this chronology.
org.joda.time.Chronology.minuteOfDay	(	): Get the minute of day field for this chronology.
org.joda.time.Chronology.minuteOfHour	(	): Get the minute of hour field for this chronology.
org.joda.time.Chronology.minutes	(	): Get the minutes duration field for this chronology.
org.joda.time.Chronology.monthOfYear	(	): Get the month of year field for this chronology.
org.joda.time.Chronology.months	(	): Get the months duration field for this chronology.
org.joda.time.Chronology.secondOfDay	(	): Get the second of day field for this chronology.
org.joda.time.Chronology.secondOfMinute	(	): Get the second of minute field for this chronology.
org.joda.time.Chronology.seconds	(	): Get the seconds duration field for this chronology.
org.joda.time.Chronology.set	(	ReadablePartial	long	): Sets the partial into the instant.
org.joda.time.Chronology.toString	(	): Gets a debugging toString.
org.joda.time.Chronology.validate	(	ReadablePartial	int[]	): Validates whether the values are valid for the fields of a partial instant.
org.joda.time.Chronology.weekOfWeekyear	(	): Get the week of a week based year field for this chronology.
org.joda.time.Chronology.weeks	(	): Get the weeks duration field for this chronology.
org.joda.time.Chronology.weekyear	(	): Get the year of a week based year field for this chronology.
org.joda.time.Chronology.weekyearOfCentury	(	): Get the year of a week based year in a century field for this chronology.
org.joda.time.Chronology.weekyears	(	): Get the weekyears duration field for this chronology.
org.joda.time.Chronology.withUTC	(	): Returns an instance of this Chronology that operates in the UTC time zone. Chronologies that do not operate in a time zone or are already UTC must return themselves.
org.joda.time.Chronology.withZone	(	DateTimeZone	): Returns an instance of this Chronology that operates in any time zone.
org.joda.time.Chronology.year	(	): Get the year field for this chronology.
org.joda.time.Chronology.yearOfCentury	(	): Get the year of century field for this chronology.
org.joda.time.Chronology.yearOfEra	(	): Get the year of era field for this chronology.
org.joda.time.Chronology.years	(	): Get the years duration field for this chronology.
org.joda.time.ClassLoadTest: This class displays what the ClassLoader is up to. Run using JVM -verbose:class.
org.joda.time.DateMidnight: DateMidnight defines a date where the time component is fixed at midnight. The class uses a time zone, thus midnight is local unless a UTC time zone is used.  It is important to emphasise that this class represents the time of midnight on any given day. Note that midnight is defined as 00:00, which is at the very start of a day.  This class does not represent a day, but the millisecond instant at midnight. If you need a class that represents the whole day, then an Interval or a LocalDate may be more suitable.  This class uses a Chronology internally. The Chronology determines how the millisecond instant value is converted into the date time fields. The default Chronology is ISOChronology which is the agreed international standard and compatible with the modern Gregorian calendar. Each individual field can be queried in two ways:  getDayOfMonth() dayOfMonth().get()  The second technique also provides access to other useful methods on the field:  numeric value text value short text value maximum/minimum values add/subtract set rounding   DateMidnight is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.DateMidnight.DateMidnight	(	): Constructs an instance set to the current system millisecond time using ISOChronology in the default time zone. The constructed object will have a local time of midnight.
org.joda.time.DateMidnight.DateMidnight	(	Chronology	): Constructs an instance set to the current system millisecond time using the specified chronology. The constructed object will have a local time of midnight.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateMidnight.DateMidnight	(	DateTimeZone	): Constructs an instance set to the current system millisecond time using ISOChronology in the specified time zone. The constructed object will have a local time of midnight.  If the specified time zone is null, the default zone is used.
org.joda.time.DateMidnight.DateMidnight	(	Object	): Constructs an instance from an Object that represents a datetime. The constructed object will have a local time of midnight.  If the object implies a chronology (such as GregorianCalendar does), then that chronology will be used. Otherwise, ISO default is used. Thus if a GregorianCalendar is passed in, the chronology used will be GJ, but if a Date is passed in the chronology will be ISO.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateTimeParser().
org.joda.time.DateMidnight.DateMidnight	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology. The constructed object will have a local time of midnight.  If the chronology is null, ISO in the default time zone is used. Any chronology implied by the object (such as GregorianCalendar does) is ignored.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateTimeParser().
org.joda.time.DateMidnight.DateMidnight	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified. The constructed object will have a local time of midnight.  If the object implies a chronology (such as GregorianCalendar does), then that chronology will be used, but with the time zone adjusted. Otherwise, ISO is used in the specified time zone. If the specified time zone is null, the default zone is used. Thus if a GregorianCalendar is passed in, the chronology used will be GJ, but if a Date is passed in the chronology will be ISO.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateTimeParser().
org.joda.time.DateMidnight.DateMidnight	(	int	int	int	): Constructs an instance from datetime field values using ISOChronology in the default time zone. The constructed object will have a local time of midnight.
org.joda.time.DateMidnight.DateMidnight	(	int	int	int	Chronology	): Constructs an instance from datetime field values using the specified chronology. The constructed object will have a local time of midnight.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateMidnight.DateMidnight	(	int	int	int	DateTimeZone	): Constructs an instance from datetime field values using ISOChronology in the specified time zone. The constructed object will have a local time of midnight.  If the specified time zone is null, the default zone is used.
org.joda.time.DateMidnight.DateMidnight	(	long	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the default time zone. The constructed object will have a local time of midnight.
org.joda.time.DateMidnight.DateMidnight	(	long	Chronology	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using the specified chronology. The constructed object will have a local time of midnight.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateMidnight.DateMidnight	(	long	DateTimeZone	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the specified time zone. The constructed object will have a local time of midnight.  If the specified time zone is null, the default zone is used.
org.joda.time.DateMidnight.Property: DateMidnight.Property binds a DateMidnight to a DateTimeField allowing powerful datetime functionality to be easily accessed.  The simplest use of this class is as an alternative get method, here used to get the year '1972' (as an int) and the month 'December' (as a String).  DateMidnight dt = new DateMidnight(1972, 12, 3); int year = dt.year().get(); String monthStr = dt.monthOfYear().getAsText();   Methods are also provided that allow date modification. These return new instances of DateMidnight - they do not modify the original. The example below yields two independent immutable date objects 20 years apart.  DateMidnight dt = new DateMidnight(1972, 12, 3); DateMidnight dt20 = dt.year().addToCopy(20);  Serious modification of dates (ie. more than just changing one or two fields) should use the org.joda.time.MutableDateTime MutableDateTime class.  DateMidnight.Property itself is thread-safe and immutable.
org.joda.time.DateMidnight.Property.Property	(	DateMidnight	DateTimeField	): Constructor.
org.joda.time.DateMidnight.Property.addToCopy	(	int	): Adds to this field in a copy of this DateMidnight.  The DateMidnight attached to this property is unchanged by this call. This operation is faster than converting a DateMidnight to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateMidnight.Property.addToCopy	(	long	): Adds to this field in a copy of this DateMidnight.  The DateMidnight attached to this property is unchanged by this call. This operation is faster than converting a DateMidnight to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateMidnight.Property.addWrapFieldToCopy	(	int	): Adds to this field, possibly wrapped, in a copy of this DateMidnight. A wrapped operation only changes this field. Thus 31st January addWrapField one day goes to the 1st January.  The DateMidnight attached to this property is unchanged by this call. This operation is faster than converting a DateMidnight to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateMidnight.Property.getChronology	(	): Gets the chronology of the datetime that this property is linked to.
org.joda.time.DateMidnight.Property.getDateMidnight	(	): Gets the datetime being used.
org.joda.time.DateMidnight.Property.getField	(	): Gets the field being used.
org.joda.time.DateMidnight.Property.getMillis	(	): Gets the milliseconds of the datetime that this property is linked to.
org.joda.time.DateMidnight.Property.readObject	(	ObjectInputStream	): Reads the property from a safe serialization format.
org.joda.time.DateMidnight.Property.roundCeilingCopy	(	): Rounds to the highest whole unit of this field on a copy of this DateMidnight.
org.joda.time.DateMidnight.Property.roundFloorCopy	(	): Rounds to the lowest whole unit of this field on a copy of this DateMidnight.
org.joda.time.DateMidnight.Property.roundHalfCeilingCopy	(	): Rounds to the nearest whole unit of this field on a copy of this DateMidnight, favoring the ceiling if halfway.
org.joda.time.DateMidnight.Property.roundHalfEvenCopy	(	): Rounds to the nearest whole unit of this field on a copy of this DateMidnight. If halfway, the ceiling is favored over the floor only if it makes this field's value even.
org.joda.time.DateMidnight.Property.roundHalfFloorCopy	(	): Rounds to the nearest whole unit of this field on a copy of this DateMidnight, favoring the floor if halfway.
org.joda.time.DateMidnight.Property.setCopy	(	String	): Sets this field in a copy of the DateMidnight to a parsed text value.  The DateMidnight attached to this property is unchanged by this call. This operation is faster than converting a DateMidnight to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateMidnight.Property.setCopy	(	String	Locale	): Sets this field in a copy of the DateMidnight to a parsed text value.  The DateMidnight attached to this property is unchanged by this call. This operation is faster than converting a DateMidnight to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateMidnight.Property.setCopy	(	int	): Sets this field in a copy of the DateMidnight.  The DateMidnight attached to this property is unchanged by this call. This operation is faster than converting a DateMidnight to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateMidnight.Property.withMaximumValue	(	): Returns a new DateMidnight with this field set to the maximum value for this field.  This operation is useful for obtaining a DateTime on the last day of the month, as month lengths vary.  DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();   The DateMidnight attached to this property is unchanged by this call.
org.joda.time.DateMidnight.Property.withMinimumValue	(	): Returns a new DateMidnight with this field set to the minimum value for this field.  The DateMidnight attached to this property is unchanged by this call.
org.joda.time.DateMidnight.Property.writeObject	(	ObjectOutputStream	): Writes the property in a safe serialization format.
org.joda.time.DateMidnight.centuryOfEra	(	): Get the century of era property which provides access to advanced functionality.
org.joda.time.DateMidnight.checkInstant	(	long	Chronology	): Rounds the specified instant to midnight.
org.joda.time.DateMidnight.dayOfMonth	(	): Get the day of month property which provides access to advanced functionality.
org.joda.time.DateMidnight.dayOfWeek	(	): Get the day of week property which provides access to advanced functionality.
org.joda.time.DateMidnight.dayOfYear	(	): Get the day of year property which provides access to advanced functionality.
org.joda.time.DateMidnight.era	(	): Get the era property which provides access to advanced functionality.
org.joda.time.DateMidnight.minus	(	ReadableDuration	): Returns a copy of this date with the specified duration taken away.  If the amount is zero or null, then this is returned.
org.joda.time.DateMidnight.minus	(	ReadablePeriod	): Returns a copy of this date with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusYears().
org.joda.time.DateMidnight.minus	(	long	): Returns a copy of this date with the specified duration taken away.  If the amount is zero or null, then this is returned.
org.joda.time.DateMidnight.minusDays	(	int	): Returns a copy of this date minus the specified number of days.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight subtracted = dt.minusDays(6); DateMidnight subtracted = dt.minus(Period.days(6)); DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6); 
org.joda.time.DateMidnight.minusMonths	(	int	): Returns a copy of this date minus the specified number of months.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight subtracted = dt.minusMonths(6); DateMidnight subtracted = dt.minus(Period.months(6)); DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6); 
org.joda.time.DateMidnight.minusWeeks	(	int	): Returns a copy of this date minus the specified number of weeks.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight subtracted = dt.minusWeeks(6); DateMidnight subtracted = dt.minus(Period.weeks(6)); DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6); 
org.joda.time.DateMidnight.minusYears	(	int	): Returns a copy of this date minus the specified number of years.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateTime subtracted = dt.minusYears(6); DateTime subtracted = dt.minus(Period.years(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6); 
org.joda.time.DateMidnight.monthOfYear	(	): Get the month of year property which provides access to advanced functionality.
org.joda.time.DateMidnight.now	(	): Obtains a DateMidnight set to the current system millisecond time using ISOChronology in the default time zone. The constructed object will have a local time of midnight.
org.joda.time.DateMidnight.now	(	Chronology	): Obtains a DateMidnight set to the current system millisecond time using the specified chronology. The constructed object will have a local time of midnight.
org.joda.time.DateMidnight.now	(	DateTimeZone	): Obtains a DateMidnight set to the current system millisecond time using ISOChronology in the specified time zone. The constructed object will have a local time of midnight.
org.joda.time.DateMidnight.parse	(	String	): Parses a DateMidnight from the specified string.  This uses dateTimeParser().
org.joda.time.DateMidnight.parse	(	String	DateTimeFormatter	): Parses a DateMidnight from the specified string using a formatter.
org.joda.time.DateMidnight.plus	(	ReadableDuration	): Returns a copy of this date with the specified duration added.  If the amount is zero or null, then this is returned.
org.joda.time.DateMidnight.plus	(	ReadablePeriod	): Returns a copy of this date with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusYears().
org.joda.time.DateMidnight.plus	(	long	): Returns a copy of this date with the specified duration added.  If the amount is zero, then this is returned.
org.joda.time.DateMidnight.plusDays	(	int	): Returns a copy of this date plus the specified number of days.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight added = dt.plusDays(6); DateMidnight added = dt.plus(Period.days(6)); DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6); 
org.joda.time.DateMidnight.plusMonths	(	int	): Returns a copy of this date plus the specified number of months.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight added = dt.plusMonths(6); DateMidnight added = dt.plus(Period.months(6)); DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6); 
org.joda.time.DateMidnight.plusWeeks	(	int	): Returns a copy of this date plus the specified number of weeks.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight added = dt.plusWeeks(6); DateMidnight added = dt.plus(Period.weeks(6)); DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6); 
org.joda.time.DateMidnight.plusYears	(	int	): Returns a copy of this date plus the specified number of years.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  DateMidnight added = dt.plusYears(6); DateMidnight added = dt.plus(Period.years(6)); DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6); 
org.joda.time.DateMidnight.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.DateMidnight.toInterval	(	): Converts this object to an Interval encompassing the whole of this day.  The interval starts at midnight 00:00 and ends at 00:00 the following day, (which is not included in the interval, as intervals are half-open).
org.joda.time.DateMidnight.toLocalDate	(	): Converts this object to a LocalDate with the same date and chronology.
org.joda.time.DateMidnight.toYearMonthDay	(	): Converts this object to a YearMonthDay using the same date and chronology.
org.joda.time.DateMidnight.weekOfWeekyear	(	): Get the week of a week based year property which provides access to advanced functionality.
org.joda.time.DateMidnight.weekyear	(	): Get the year of a week based year property which provides access to advanced functionality.
org.joda.time.DateMidnight.withCenturyOfEra	(	int	): Returns a copy of this date with the century of era field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
org.joda.time.DateMidnight.withChronology	(	Chronology	): Returns a copy of this date with a different chronology, potentially changing the day in unexpected ways.  This method creates a new DateMidnight using the midnight millisecond value and the new chronology. If the same or similar chronology is specified, but with a different time zone, the day may change. This occurs because the new DateMidnight rounds down the millisecond value to get to midnight, and the time zone change may result in a rounding down to a different day.  For example, changing time zone from London (+00:00) to Paris (+01:00) will retain the same day, but changing from Paris to London will change the day. (When its midnight in London its the same day in Paris, but when its midnight in Paris its still the previous day in London)  To avoid these unusual effects, use withZoneRetainFields() to change time zones.
org.joda.time.DateMidnight.withDayOfMonth	(	int	): Returns a copy of this date with the day of month field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of month changed.
org.joda.time.DateMidnight.withDayOfWeek	(	int	): Returns a copy of this date with the day of week field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of week changed.
org.joda.time.DateMidnight.withDayOfYear	(	int	): Returns a copy of this date with the day of year field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of year changed.
org.joda.time.DateMidnight.withDurationAdded	(	ReadableDuration	int	): Returns a copy of this date with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.DateMidnight.withDurationAdded	(	long	int	): Returns a copy of this date with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.DateMidnight.withEra	(	int	): Returns a copy of this date with the era field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of era changed.
org.joda.time.DateMidnight.withField	(	DateTimeFieldType	int	): Returns a copy of this date with the specified field set to a new value.  For example, if the field type is dayOfMonth then the day of month field would be changed in the returned instance. If the field type is null, then this is returned.  These three lines are equivalent:  DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6); DateTime updated = dt.dayOfMonth().setCopy(6); DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6); 
org.joda.time.DateMidnight.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this date with the value of the specified field increased.  If the addition is zero or the field is null, then this is returned.  These three lines are equivalent:  DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6); DateMidnight added = dt.plusYears(6); DateMidnight added = dt.year().addToCopy(6); 
org.joda.time.DateMidnight.withFields	(	ReadablePartial	): Returns a copy of this date with the partial set of fields replacing those from this instance.  For example, if the partial is a LocalDate then the date fields would be changed in the returned instance. If the partial is null, then this is returned.
org.joda.time.DateMidnight.withMillis	(	long	): Returns a copy of this date with a different millisecond instant. The returned object will have a local time of midnight.  Only the millis will change, the chronology and time zone are kept. The returned object will be either be a new instance or this.
org.joda.time.DateMidnight.withMonthOfYear	(	int	): Returns a copy of this date with the month of year field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.DateMidnight.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this date with the specified period added.  If the addition is zero, then this is returned.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusYears().
org.joda.time.DateMidnight.withWeekOfWeekyear	(	int	): Returns a copy of this date with the week of weekyear field updated.  This field is associated with the "weekyear" via withWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of week of weekyear changed.
org.joda.time.DateMidnight.withWeekyear	(	int	): Returns a copy of this date with the weekyear field updated.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of weekyear changed.
org.joda.time.DateMidnight.withYear	(	int	): Returns a copy of this date with the year field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year changed.
org.joda.time.DateMidnight.withYearOfCentury	(	int	): Returns a copy of this date with the year of century field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of century changed.
org.joda.time.DateMidnight.withYearOfEra	(	int	): Returns a copy of this date with the year of era field updated.  DateMidnight is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of era changed.
org.joda.time.DateMidnight.withZoneRetainFields	(	DateTimeZone	): Returns a copy of this date with a different time zone, preserving the day The returned object will have a local time of midnight in the new zone on the same day as the original instant.
org.joda.time.DateMidnight.year	(	): Get the year property which provides access to advanced functionality.
org.joda.time.DateMidnight.yearOfCentury	(	): Get the year of century property which provides access to advanced functionality.
org.joda.time.DateMidnight.yearOfEra	(	): Get the year of era property which provides access to advanced functionality.
org.joda.time.DateTime: DateTime is the standard implementation of an unmodifiable datetime class.  DateTime is the most widely used implementation of ReadableInstant. As with all instants, it represents an exact point on the time-line, but limited to the precision of milliseconds. A DateTime calculates its fields with respect to a DateTimeZone time zone.  Internally, the class holds two pieces of data. Firstly, it holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z. Secondly, it holds a Chronology which determines how the millisecond instant value is converted into the date time fields. The default Chronology is ISOChronology which is the agreed international standard and compatible with the modern Gregorian calendar.  Each individual field can be queried in two ways:  getHourOfDay() hourOfDay().get()  The second technique also provides access to other useful methods on the field:  numeric value text value short text value maximum/minimum values add/subtract set rounding   DateTime is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.DateTime.DateTime	(	): Constructs an instance set to the current system millisecond time using ISOChronology in the default time zone.
org.joda.time.DateTime.DateTime	(	Chronology	): Constructs an instance set to the current system millisecond time using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateTime.DateTime	(	DateTimeZone	): Constructs an instance set to the current system millisecond time using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.DateTime.DateTime	(	Object	): Constructs an instance from an Object that represents a datetime.  If the object implies a chronology (such as GregorianCalendar does), then that chronology will be used. Otherwise, ISO default is used. Thus if a GregorianCalendar is passed in, the chronology used will be GJ, but if a Date is passed in the chronology will be ISO.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateTimeParser().
org.joda.time.DateTime.DateTime	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology.  If the chronology is null, ISO in the default time zone is used. Any chronology implied by the object (such as GregorianCalendar does) is ignored.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateTimeParser().
org.joda.time.DateTime.DateTime	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified.  If the object implies a chronology (such as GregorianCalendar does), then that chronology will be used, but with the time zone adjusted. Otherwise, ISO is used in the specified time zone. If the specified time zone is null, the default zone is used. Thus if a GregorianCalendar is passed in, the chronology used will be GJ, but if a Date is passed in the chronology will be ISO.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateTimeParser().
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	): Constructs an instance from datetime field values using ISOChronology in the default time zone.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	Chronology	): Constructs an instance from datetime field values using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	DateTimeZone	): Constructs an instance from datetime field values using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	int	): Constructs an instance from datetime field values using ISOChronology in the default time zone.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	int	Chronology	): Constructs an instance from datetime field values using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	int	DateTimeZone	): Constructs an instance from datetime field values using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	int	int	): Constructs an instance from datetime field values using ISOChronology in the default time zone.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	int	int	Chronology	): Constructs an instance from datetime field values using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateTime.DateTime	(	int	int	int	int	int	int	int	DateTimeZone	): Constructs an instance from datetime field values using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.DateTime.DateTime	(	long	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the default time zone.
org.joda.time.DateTime.DateTime	(	long	Chronology	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.DateTime.DateTime	(	long	DateTimeZone	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.DateTime.Property: DateTime.Property binds a DateTime to a DateTimeField allowing powerful datetime functionality to be easily accessed.  The simplest use of this class is as an alternative get method, here used to get the year '1972' (as an int) and the month 'December' (as a String).  DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0); int year = dt.year().get(); String monthStr = dt.month().getAsText();   Methods are also provided that allow date modification. These return new instances of DateTime - they do not modify the original. The example below yields two independent immutable date objects 20 years apart.  DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0); DateTime dt20 = dt.year().addToCopy(20);  Serious modification of dates (ie. more than just changing one or two fields) should use the org.joda.time.MutableDateTime MutableDateTime class.  DateTime.Propery itself is thread-safe and immutable, as well as the DateTime being operated on.
org.joda.time.DateTime.Property.Property	(	DateTime	DateTimeField	): Constructor.
org.joda.time.DateTime.Property.addToCopy	(	int	): Adds to this field in a copy of this DateTime.  The DateTime attached to this property is unchanged by this call. This operation is faster than converting a DateTime to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateTime.Property.addToCopy	(	long	): Adds to this field in a copy of this DateTime.  The DateTime attached to this property is unchanged by this call. This operation is faster than converting a DateTime to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateTime.Property.addWrapFieldToCopy	(	int	): Adds to this field, possibly wrapped, in a copy of this DateTime. A wrapped operation only changes this field. Thus 31st January addWrapField one day goes to the 1st January.  The DateTime attached to this property is unchanged by this call. This operation is faster than converting a DateTime to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateTime.Property.getChronology	(	): Gets the chronology of the datetime that this property is linked to.
org.joda.time.DateTime.Property.getDateTime	(	): Gets the datetime being used.
org.joda.time.DateTime.Property.getField	(	): Gets the field being used.
org.joda.time.DateTime.Property.getMillis	(	): Gets the milliseconds of the datetime that this property is linked to.
org.joda.time.DateTime.Property.readObject	(	ObjectInputStream	): Reads the property from a safe serialization format.
org.joda.time.DateTime.Property.roundCeilingCopy	(	): Rounds to the highest whole unit of this field on a copy of this DateTime.
org.joda.time.DateTime.Property.roundFloorCopy	(	): Rounds to the lowest whole unit of this field on a copy of this DateTime.
org.joda.time.DateTime.Property.roundHalfCeilingCopy	(	): Rounds to the nearest whole unit of this field on a copy of this DateTime, favoring the ceiling if halfway.
org.joda.time.DateTime.Property.roundHalfEvenCopy	(	): Rounds to the nearest whole unit of this field on a copy of this DateTime. If halfway, the ceiling is favored over the floor only if it makes this field's value even.
org.joda.time.DateTime.Property.roundHalfFloorCopy	(	): Rounds to the nearest whole unit of this field on a copy of this DateTime, favoring the floor if halfway.
org.joda.time.DateTime.Property.setCopy	(	String	): Sets this field in a copy of the DateTime to a parsed text value.  The DateTime attached to this property is unchanged by this call. This operation is faster than converting a DateTime to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateTime.Property.setCopy	(	String	Locale	): Sets this field in a copy of the DateTime to a parsed text value.  The DateTime attached to this property is unchanged by this call. This operation is faster than converting a DateTime to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateTime.Property.setCopy	(	int	): Sets this field in a copy of the DateTime.  The DateTime attached to this property is unchanged by this call. This operation is faster than converting a DateTime to a MutableDateTime and back again when setting one field. When setting multiple fields, it is generally quicker to make the conversion to MutableDateTime.
org.joda.time.DateTime.Property.withMaximumValue	(	): Returns a new DateTime with this field set to the maximum value for this field.  This operation is useful for obtaining a DateTime on the last day of the month, as month lengths vary.  DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();   Where possible, the offset from UTC will be retained, thus applications may need to call withLaterOffsetAtOverlap() on the result to force the later time during a DST overlap if desired.  From v2.2, this method handles a daylight savings time gap, setting the time to the last instant before the gap.  The DateTime attached to this property is unchanged by this call.
org.joda.time.DateTime.Property.withMinimumValue	(	): Returns a new DateTime with this field set to the minimum value for this field.  Where possible, the offset from UTC will be retained, thus applications may need to call withEarlierOffsetAtOverlap() on the result to force the earlier time during a DST overlap if desired.  From v2.2, this method handles a daylight savings time gap, setting the time to the first instant after the gap.  The DateTime attached to this property is unchanged by this call.
org.joda.time.DateTime.Property.writeObject	(	ObjectOutputStream	): Writes the property in a safe serialization format.
org.joda.time.DateTime.centuryOfEra	(	): Get the century of era property which provides access to advanced functionality.
org.joda.time.DateTime.dayOfMonth	(	): Get the day of month property which provides access to advanced functionality.
org.joda.time.DateTime.dayOfWeek	(	): Get the day of week property which provides access to advanced functionality.
org.joda.time.DateTime.dayOfYear	(	): Get the day of year property which provides access to advanced functionality.
org.joda.time.DateTime.era	(	): Get the era property which provides access to advanced functionality.
org.joda.time.DateTime.hourOfDay	(	): Get the hour of day field property which provides access to advanced functionality.
org.joda.time.DateTime.millisOfDay	(	): Get the millis of day property which provides access to advanced functionality.
org.joda.time.DateTime.millisOfSecond	(	): Get the millis of second property which provides access to advanced functionality.
org.joda.time.DateTime.minus	(	ReadableDuration	): Returns a copy of this datetime with the specified duration taken away.  If the amount is zero or null, then this is returned. This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minus	(	ReadablePeriod	): Returns a copy of this datetime with the specified period taken away.  This method will subtract each element of the period one by one, from largest to smallest, adjusting the datetime to be accurate between each.  Thus, subtracting a period of one month and one day from 2007-05-31 will work as follows: First subtract one month and adjust, resulting in 2007-04-30 Then subtract one day and adjust, resulting in 2007-04-29. Note that the day has been adjusted by two.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusYears().  If the amount is zero or null, then this is returned. This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minus	(	long	): Returns a copy of this datetime with the specified duration taken away.  If the amount is zero or null, then this is returned. This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusDays	(	int	): Returns a copy of this datetime minus the specified number of days.  The calculation will do its best to only change the day field retaining the same time of day. However, in certain circumstances, typically daylight savings cutover, it may be necessary to alter the time fields.  In spring an hour is typically removed. If subtracting one day results in the time being within the cutover then the time is adjusted to be within summer time. For example, if the cutover is from 01:59 to 03:00 and the result of this method would have been 02:30, then the result will be adjusted to 03:30.  The following three lines are identical in effect:  DateTime subtracted = dt.minusDays(6); DateTime subtracted = dt.minus(Period.days(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusHours	(	int	): Returns a copy of this datetime minus the specified number of hours.  The calculation will subtract a duration equivalent to the number of hours expressed in milliseconds.  For example, if a spring daylight savings cutover is from 01:59 to 03:00 then subtracting one hour from 03:30 will result in 01:30. This is a duration of one hour earlier, even though the hour field value changed from 3 to 1.  The following three lines are identical in effect:  DateTime subtracted = dt.minusHours(6); DateTime subtracted = dt.minus(Period.hours(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusMillis	(	int	): Returns a copy of this datetime minus the specified number of millis.  The calculation will subtract a duration equivalent to the number of milliseconds.  The following three lines are identical in effect:  DateTime subtracted = dt.minusMillis(6); DateTime subtracted = dt.minus(Period.millis(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusMinutes	(	int	): Returns a copy of this datetime minus the specified number of minutes.  The calculation will subtract a duration equivalent to the number of minutes expressed in milliseconds.  The following three lines are identical in effect:  DateTime subtracted = dt.minusMinutes(6); DateTime subtracted = dt.minus(Period.minutes(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusMonths	(	int	): Returns a copy of this datetime minus the specified number of months.  The calculation will do its best to only change the month field retaining the same day of month. However, in certain circumstances, it may be necessary to alter smaller fields. For example, 2007-05-31 minus one month cannot result in 2007-04-31, so the day of month is adjusted to 2007-04-30.  The following three lines are identical in effect:  DateTime subtracted = dt.minusMonths(6); DateTime subtracted = dt.minus(Period.months(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusSeconds	(	int	): Returns a copy of this datetime minus the specified number of seconds.  The calculation will subtract a duration equivalent to the number of seconds expressed in milliseconds.  The following three lines are identical in effect:  DateTime subtracted = dt.minusSeconds(6); DateTime subtracted = dt.minus(Period.seconds(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusWeeks	(	int	): Returns a copy of this datetime minus the specified number of weeks.  The calculation operates as if it were subtracting the equivalent in days.  The following three lines are identical in effect:  DateTime subtracted = dt.minusWeeks(6); DateTime subtracted = dt.minus(Period.weeks(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minusYears	(	int	): Returns a copy of this datetime minus the specified number of years.  The calculation will do its best to only change the year field retaining the same month of year. However, in certain circumstances, it may be necessary to alter smaller fields. For example, 2008-02-29 minus one year cannot result in 2007-02-29, so the day of month is adjusted to 2007-02-28.  The following three lines are identical in effect:  DateTime subtracted = dt.minusYears(6); DateTime subtracted = dt.minus(Period.years(6)); DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.minuteOfDay	(	): Get the minute of day property which provides access to advanced functionality.
org.joda.time.DateTime.minuteOfHour	(	): Get the minute of hour field property which provides access to advanced functionality.
org.joda.time.DateTime.monthOfYear	(	): Get the month of year property which provides access to advanced functionality.
org.joda.time.DateTime.now	(	): Obtains a DateTime set to the current system millisecond time using ISOChronology in the default time zone.
org.joda.time.DateTime.now	(	Chronology	): Obtains a DateTime set to the current system millisecond time using the specified chronology.
org.joda.time.DateTime.now	(	DateTimeZone	): Obtains a DateTime set to the current system millisecond time using ISOChronology in the specified time zone.
org.joda.time.DateTime.parse	(	String	): Parses a DateTime from the specified string.  This uses dateTimeParser().withOffsetParsed() which is different to passing a String to the constructor.  Sometimes this method and new DateTime(str) return different results. This can be confusing as the difference is not visible in toString().  When passed a date-time string without an offset, such as '2010-06-30T01:20', both the constructor and this method use the default time-zone. As such, DateTime.parse("2010-06-30T01:20") and new DateTime("2010-06-30T01:20")) are equal.  However, when this method is passed a date-time string with an offset, the offset is directly parsed and stored. As such, DateTime.parse("2010-06-30T01:20+02:00") and new DateTime("2010-06-30T01:20+02:00")) are NOT equal. The object produced via this method has a zone of DateTimeZone.forOffsetHours(2). The object produced via the constructor has a zone of DateTimeZone.getDefault().
org.joda.time.DateTime.parse	(	String	DateTimeFormatter	): Parses a DateTime from the specified string using a formatter.
org.joda.time.DateTime.plus	(	ReadableDuration	): Returns a copy of this datetime with the specified duration added.  If the amount is zero or null, then this is returned. This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plus	(	ReadablePeriod	): Returns a copy of this datetime with the specified period added.  This method will add each element of the period one by one, from largest to smallest, adjusting the datetime to be accurate between each.  Thus, adding a period of one month and one day to 2007-03-31 will work as follows: First add one month and adjust, resulting in 2007-04-30 Then add one day and adjust, resulting in 2007-05-01.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusYears().  If the amount is zero or null, then this is returned. This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plus	(	long	): Returns a copy of this datetime with the specified duration added.  If the amount is zero or null, then this is returned. This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusDays	(	int	): Returns a copy of this datetime plus the specified number of days.  The calculation will do its best to only change the day field retaining the same time of day. However, in certain circumstances, typically daylight savings cutover, it may be necessary to alter the time fields.  In spring an hour is typically removed. If adding one day results in the time being within the cutover then the time is adjusted to be within summer time. For example, if the cutover is from 01:59 to 03:00 and the result of this method would have been 02:30, then the result will be adjusted to 03:30.  The following three lines are identical in effect:  DateTime added = dt.plusDays(6); DateTime added = dt.plus(Period.days(6)); DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusHours	(	int	): Returns a copy of this datetime plus the specified number of hours.  The calculation will add a duration equivalent to the number of hours expressed in milliseconds.  For example, if a spring daylight savings cutover is from 01:59 to 03:00 then adding one hour to 01:30 will result in 03:30. This is a duration of one hour later, even though the hour field value changed from 1 to 3.  The following three lines are identical in effect:  DateTime added = dt.plusHours(6); DateTime added = dt.plus(Period.hours(6)); DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusMillis	(	int	): Returns a copy of this datetime plus the specified number of millis.  The calculation will add a duration equivalent to the number of milliseconds.  The following three lines are identical in effect:  DateTime added = dt.plusMillis(6); DateTime added = dt.plus(Period.millis(6)); DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusMinutes	(	int	): Returns a copy of this datetime plus the specified number of minutes.  The calculation will add a duration equivalent to the number of minutes expressed in milliseconds.  The following three lines are identical in effect:  DateTime added = dt.plusMinutes(6); DateTime added = dt.plus(Period.minutes(6)); DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusMonths	(	int	): Returns a copy of this datetime plus the specified number of months.  The calculation will do its best to only change the month field retaining the same day of month. However, in certain circumstances, it may be necessary to alter smaller fields. For example, 2007-03-31 plus one month cannot result in 2007-04-31, so the day of month is adjusted to 2007-04-30.  The following three lines are identical in effect:  DateTime added = dt.plusMonths(6); DateTime added = dt.plus(Period.months(6)); DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusSeconds	(	int	): Returns a copy of this datetime plus the specified number of seconds.  The calculation will add a duration equivalent to the number of seconds expressed in milliseconds.  The following three lines are identical in effect:  DateTime added = dt.plusSeconds(6); DateTime added = dt.plus(Period.seconds(6)); DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusWeeks	(	int	): Returns a copy of this datetime plus the specified number of weeks.  The calculation operates as if it were adding the equivalent in days.  The following three lines are identical in effect:  DateTime added = dt.plusWeeks(6); DateTime added = dt.plus(Period.weeks(6)); DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.plusYears	(	int	): Returns a copy of this datetime plus the specified number of years.  The calculation will do its best to only change the year field retaining the same month of year. However, in certain circumstances, it may be necessary to alter smaller fields. For example, 2008-02-29 plus one year cannot result in 2009-02-29, so the day of month is adjusted to 2009-02-28.  The following three lines are identical in effect:  DateTime added = dt.plusYears(6); DateTime added = dt.plus(Period.years(6)); DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);   This datetime instance is immutable and unaffected by this method call.
org.joda.time.DateTime.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.DateTime.secondOfDay	(	): Get the second of day property which provides access to advanced functionality.
org.joda.time.DateTime.secondOfMinute	(	): Get the second of minute field property which provides access to advanced functionality.
org.joda.time.DateTime.toDateMidnight	(	): Converts this object to a DateMidnight using the same millis and chronology.
org.joda.time.DateTime.toDateTime	(	): Get this object as a DateTime by returning this.
org.joda.time.DateTime.toDateTime	(	Chronology	): Get this object as a DateTime, returning this if possible.
org.joda.time.DateTime.toDateTime	(	DateTimeZone	): Get this object as a DateTime, returning this if possible.
org.joda.time.DateTime.toDateTimeISO	(	): Get this object as a DateTime using ISOChronology in the default zone, returning this if possible.
org.joda.time.DateTime.toLocalDate	(	): Converts this object to a LocalDate with the same date and chronology.
org.joda.time.DateTime.toLocalDateTime	(	): Converts this object to a LocalDateTime with the same datetime and chronology.
org.joda.time.DateTime.toLocalTime	(	): Converts this object to a LocalTime with the same time and chronology.
org.joda.time.DateTime.toTimeOfDay	(	): Converts this object to a TimeOfDay using the same millis and chronology.
org.joda.time.DateTime.toYearMonthDay	(	): Converts this object to a YearMonthDay using the same millis and chronology.
org.joda.time.DateTime.weekOfWeekyear	(	): Get the week of a week based year property which provides access to advanced functionality.
org.joda.time.DateTime.weekyear	(	): Get the year of a week based year property which provides access to advanced functionality.
org.joda.time.DateTime.withCenturyOfEra	(	int	): Returns a copy of this datetime with the century of era field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
org.joda.time.DateTime.withChronology	(	Chronology	): Returns a copy of this datetime with a different chronology.  The returned object will be either be a new instance or this. Only the chronology will change, the millis are kept.
org.joda.time.DateTime.withDate	(	LocalDate	): Returns a copy of this datetime with the specified date, retaining the time fields.  If the time is invalid on the new date due to the time-zone, the time will be adjusted.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withDate	(	int	int	int	): Returns a copy of this datetime with the specified date, retaining the time fields.  If the date is already the date passed in, then this is returned.  To set a single field use the properties, for example:  DateTime set = monthOfYear().setCopy(6);   If the time is invalid on the new date due to the time-zone, the time will be adjusted.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withDayOfMonth	(	int	): Returns a copy of this datetime with the day of month field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of month changed.
org.joda.time.DateTime.withDayOfWeek	(	int	): Returns a copy of this datetime with the day of week field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of week changed.
org.joda.time.DateTime.withDayOfYear	(	int	): Returns a copy of this datetime with the day of year field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of year changed.
org.joda.time.DateTime.withDurationAdded	(	ReadableDuration	int	): Returns a copy of this datetime with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.DateTime.withDurationAdded	(	long	int	): Returns a copy of this datetime with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.DateTime.withEarlierOffsetAtOverlap	(	): Returns a copy of this ZonedDateTime changing the zone offset to the earlier of the two valid offsets at a local time-line overlap.  This method only has any effect when the local time-line overlaps, such as at an autumn daylight savings cutover. In this scenario, there are two valid offsets for the local date-time. Calling this method will return a date-time with the earlier of the two selected.  If this method is called when it is not an overlap, this is returned.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withEra	(	int	): Returns a copy of this datetime with the era field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of era changed.
org.joda.time.DateTime.withField	(	DateTimeFieldType	int	): Returns a copy of this datetime with the specified field set to a new value.  For example, if the field type is hourOfDay then the hour of day field would be changed in the returned instance. If the field type is null, then this is returned.  These three lines are equivalent:  DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6); DateTime updated = dt.dayOfMonth().setCopy(6); DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6); 
org.joda.time.DateTime.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this datetime with the value of the specified field increased.  If the addition is zero or the field is null, then this is returned.  These three lines are equivalent:  DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6); DateTime added = dt.plusYears(6); DateTime added = dt.plus(Period.years(6)); 
org.joda.time.DateTime.withFields	(	ReadablePartial	): Returns a copy of this datetime with the partial set of fields replacing those from this instance.  For example, if the partial is a TimeOfDay then the time fields would be changed in the returned instance. If the partial is null, then this is returned.
org.joda.time.DateTime.withHourOfDay	(	int	): Returns a copy of this datetime with the hour of day field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of hour of day changed.
org.joda.time.DateTime.withLaterOffsetAtOverlap	(	): Returns a copy of this ZonedDateTime changing the zone offset to the later of the two valid offsets at a local time-line overlap.  This method only has any effect when the local time-line overlaps, such as at an autumn daylight savings cutover. In this scenario, there are two valid offsets for the local date-time. Calling this method will return a date-time with the later of the two selected.  If this method is called when it is not an overlap, this is returned.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withMillis	(	long	): Returns a copy of this datetime with different millis.  The returned object will be either be a new instance or this. Only the millis will change, the chronology and time zone are kept.
org.joda.time.DateTime.withMillisOfDay	(	int	): Returns a copy of this datetime with the millis of day field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of day changed.
org.joda.time.DateTime.withMillisOfSecond	(	int	): Returns a copy of this datetime with the millis of second field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of second changed.
org.joda.time.DateTime.withMinuteOfHour	(	int	): Returns a copy of this datetime with the minute of hour updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of minute of hour changed.
org.joda.time.DateTime.withMonthOfYear	(	int	): Returns a copy of this datetime with the month of year field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.DateTime.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this datetime with the specified period added.  If the addition is zero, then this is returned.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusYears().
org.joda.time.DateTime.withSecondOfMinute	(	int	): Returns a copy of this datetime with the second of minute field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of second of minute changed.
org.joda.time.DateTime.withTime	(	LocalTime	): Returns a copy of this datetime with the specified time, retaining the date fields.  If the new time is invalid due to the time-zone, the time will be adjusted.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withTime	(	int	int	int	int	): Returns a copy of this datetime with the specified time, retaining the date fields.  If the time is already the time passed in, then this is returned.  To set a single field use the properties, for example:  DateTime set = dt.hourOfDay().setCopy(6);   If the new time is invalid due to the time-zone, the time will be adjusted.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withTimeAtStartOfDay	(	): Returns a copy of this datetime with the time set to the start of the day.  The time will normally be midnight, as that is the earliest time on any given day. However, in some time zones when Daylight Savings Time starts, there is no midnight because time jumps from 11:59 to 01:00. This method handles that situation by returning 01:00 on that date.  This instance is immutable and unaffected by this method call.
org.joda.time.DateTime.withWeekOfWeekyear	(	int	): Returns a copy of this datetime with the week of weekyear field updated.  This field is associated with the "weekyear" via withWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of week of weekyear changed.
org.joda.time.DateTime.withWeekyear	(	int	): Returns a copy of this datetime with the weekyear field updated.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of weekyear changed.
org.joda.time.DateTime.withYear	(	int	): Returns a copy of this datetime with the year field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year changed.
org.joda.time.DateTime.withYearOfCentury	(	int	): Returns a copy of this datetime with the year of century field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of century changed.
org.joda.time.DateTime.withYearOfEra	(	int	): Returns a copy of this datetime with the year of era field updated.  DateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of era changed.
org.joda.time.DateTime.withZone	(	DateTimeZone	): Returns a copy of this datetime with a different time zone, preserving the millisecond instant.  This method is useful for finding the local time in another timezone. For example, if this instant holds 12:30 in Europe/London, the result from this method with Europe/Paris would be 13:30.  The returned object will be a new instance of the same implementation type. This method changes the time zone, and does not change the millisecond instant, with the effect that the field values usually change. The returned object will be either be a new instance or this.
org.joda.time.DateTime.withZoneRetainFields	(	DateTimeZone	): Returns a copy of this datetime with a different time zone, preserving the field values.  This method is useful for finding the millisecond time in another timezone. For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z), the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).  The returned object will be a new instance of the same implementation type. This method changes the time zone and the millisecond instant to keep the field values the same. The returned object will be either be a new instance or this.
org.joda.time.DateTime.year	(	): Get the year property which provides access to advanced functionality.
org.joda.time.DateTime.yearOfCentury	(	): Get the year of century property which provides access to advanced functionality.
org.joda.time.DateTime.yearOfEra	(	): Get the year of era property which provides access to advanced functionality.
org.joda.time.DateTimeComparator: DateTimeComparator provides comparators to compare one date with another.  Dates may be specified using any object recognised by the org.joda.time.convert.ConverterManager ConverterManager class.  The default objects recognised by the comparator are:  ReadableInstant String Calendar Date Long (milliseconds) null (now)   DateTimeComparator is thread-safe and immutable.
org.joda.time.DateTimeComparator.DateTimeComparator	(	DateTimeFieldType	DateTimeFieldType	): Restricted constructor.
org.joda.time.DateTimeComparator.compare	(	Object	Object	): Compare two objects against only the range of date time fields as specified in the constructor.
org.joda.time.DateTimeComparator.equals	(	Object	): Compares this comparator to another.
org.joda.time.DateTimeComparator.getDateOnlyInstance	(	): Returns a comparator that only considers date fields. Time of day is ignored.  The time-zone is considered when using this comparator. The input millis are rounded down to the start of the day in the time-zone of that input value. Thus, two inputs with different time-zones will typically not be equal
org.joda.time.DateTimeComparator.getInstance	(	): Returns a DateTimeComparator the compares the entire date time value.
org.joda.time.DateTimeComparator.getInstance	(	DateTimeFieldType	): Returns a DateTimeComparator with a lower limit only. Fields of a magnitude less than the lower limit are excluded from comparisons.  The time-zone is considered when using this comparator. The input millis are truncated using the time-zone of that input value. Thus, two inputs with different time-zones will typically not be equal
org.joda.time.DateTimeComparator.getInstance	(	DateTimeFieldType	DateTimeFieldType	): Returns a DateTimeComparator with a lower and upper limit. Fields of a magnitude less than the lower limit are excluded from comparisons. Fields of a magnitude greater than or equal to the upper limit are also excluded from comparisons. Either limit may be specified as null, which indicates an unbounded limit.  The time-zone is considered when using this comparator unless both limits are null. The input millis are rounded/truncated using the time-zone of that input value. Thus, two inputs with different time-zones will typically not be equal
org.joda.time.DateTimeComparator.getLowerLimit	(	): Gets the field type that represents the lower limit of comparison.
org.joda.time.DateTimeComparator.getTimeOnlyInstance	(	): Returns a comparator that only considers time fields. Date is ignored.  The time-zone is considered when using this comparator. The input millis are truncated to be within the day in the time-zone of that input value. Thus, two inputs with different time-zones will typically not be equal
org.joda.time.DateTimeComparator.getUpperLimit	(	): Gets the field type that represents the upper limit of comparison.
org.joda.time.DateTimeComparator.hashCode	(	): Gets a suitable hashcode.
org.joda.time.DateTimeComparator.readResolve	(	): Support serialization singletons.
org.joda.time.DateTimeComparator.toString	(	): Gets a debugging string.
org.joda.time.DateTimeConstants: DateTimeConstants is a non-instantiable class of constants used in the date time system. These are the ISO8601 constants, but should be used by all chronologies.  DateTimeConstants is thread-safe and immutable.
org.joda.time.DateTimeConstants.DateTimeConstants	(	): Restrictive constructor
org.joda.time.DateTimeField: Defines the calculation engine for date and time fields. The interface defines a set of methods that manipulate a millisecond datetime with regards to a single field, such as monthOfYear or secondOfMinute.  This design is extensible so, if you wish, you can extract a different field from the milliseconds. A number of standard implementations are provided to assist.
org.joda.time.DateTimeField.add	(	ReadablePartial	int	int[]	int	): Adds a value (which may be negative) to the partial instant, throwing an exception if the maximum size of the instant is reached.  The value will be added to this field, overflowing into larger fields if necessary. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  Partial instants only contain some fields. This may result in a maximum possible value, such as TimeOfDay being limited to 23:59:59:999. If this limit is breached by the add an exception is thrown.  For example, in the ISO chronology: 2000-08-20 add six months is 2000-02-20 2000-08-20 add twenty months is 2000-04-20 2000-08-20 add minus nine months is 2000-11-20 2001-01-31 add one month is 2001-02-28 2001-01-31 add two months is 2001-03-31
org.joda.time.DateTimeField.add	(	long	int	): Adds a value (which may be negative) to the millis value, overflowing into larger fields if necessary.  The value will be added to this field. If the value is too large to be added solely to this field, larger fields will increase as required. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  For example, in the ISO chronology: 2000-08-20 add six months is 2001-02-20 2000-08-20 add twenty months is 2002-04-20 2000-08-20 add minus nine months is 1999-11-20 2001-01-31 add one month is 2001-02-28 2001-01-31 add two months is 2001-03-31
org.joda.time.DateTimeField.add	(	long	long	): Adds a value (which may be negative) to the millis value, overflowing into larger fields if necessary.
org.joda.time.DateTimeField.addWrapField	(	ReadablePartial	int	int[]	int	): Adds a value (which may be negative) to the partial instant, wrapping within this field.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps. Larger fields are always unaffected. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  For example, in the ISO chronology: 2000-08-20 addWrapField six months is 2000-02-20 2000-08-20 addWrapField twenty months is 2000-04-20 2000-08-20 addWrapField minus nine months is 2000-11-20 2001-01-31 addWrapField one month is 2001-02-28 2001-01-31 addWrapField two months is 2001-03-31
org.joda.time.DateTimeField.addWrapField	(	long	int	): Adds a value (which may be negative) to the millis value, wrapping within this field.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps. Larger fields are always unaffected. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  For example, in the ISO chronology: 2000-08-20 addWrapField six months is 2000-02-20 2000-08-20 addWrapField twenty months is 2000-04-20 2000-08-20 addWrapField minus nine months is 2000-11-20 2001-01-31 addWrapField one month is 2001-02-28 2001-01-31 addWrapField two months is 2001-03-31
org.joda.time.DateTimeField.addWrapPartial	(	ReadablePartial	int	int[]	int	): Adds a value (which may be negative) to the partial instant, wrapping the whole partial if the maximum size of the partial is reached.  The value will be added to this field, overflowing into larger fields if necessary. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  Partial instants only contain some fields. This may result in a maximum possible value, such as TimeOfDay normally being limited to 23:59:59:999. If this limit is reached by the addition, this method will wrap back to 00:00:00.000. In fact, you would generally only use this method for classes that have a limitation such as this.  For example, in the ISO chronology: 10:20:30 add 20 minutes is 10:40:30 10:20:30 add 45 minutes is 11:05:30 10:20:30 add 16 hours is 02:20:30
org.joda.time.DateTimeField.get	(	long	): Get the value of this field from the milliseconds.
org.joda.time.DateTimeField.getAsShortText	(	ReadablePartial	Locale	): Get the human-readable, short text value of this field from a partial instant. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsShortText	(	ReadablePartial	int	Locale	): Get the human-readable, short text value of this field from a partial instant. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsShortText	(	int	Locale	): Get the human-readable, short text value of this field from the field value. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsShortText	(	long	): Get the human-readable, short text value of this field from the milliseconds.
org.joda.time.DateTimeField.getAsShortText	(	long	Locale	): Get the human-readable, short text value of this field from the milliseconds. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsText	(	ReadablePartial	Locale	): Get the human-readable, text value of this field from a partial instant. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsText	(	ReadablePartial	int	Locale	): Get the human-readable, text value of this field from a partial instant. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsText	(	int	Locale	): Get the human-readable, text value of this field from the field value. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getAsText	(	long	): Get the human-readable, text value of this field from the milliseconds.
org.joda.time.DateTimeField.getAsText	(	long	Locale	): Get the human-readable, text value of this field from the milliseconds. If the specified locale is null, the default locale is used.
org.joda.time.DateTimeField.getDifference	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... int v = ... int age = getDifference(add(instant, v), instant);  The value 'age' is the same as the value 'v'.
org.joda.time.DateTimeField.getDifferenceAsLong	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... long v = ... long age = getDifferenceAsLong(add(instant, v), instant);  The value 'age' is the same as the value 'v'.
org.joda.time.DateTimeField.getDurationField	(	): Returns the duration per unit value of this field. For example, if this field represents "hour of day", then the duration is an hour.
org.joda.time.DateTimeField.getLeapAmount	(	long	): Gets the amount by which this field is 'leap' for the specified instant.  For example, a leap year would return one, a non leap year would return zero.
org.joda.time.DateTimeField.getLeapDurationField	(	): If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned.
org.joda.time.DateTimeField.getMaximumShortTextLength	(	Locale	): Get the maximum short text value for this field.
org.joda.time.DateTimeField.getMaximumTextLength	(	Locale	): Get the maximum text value for this field.
org.joda.time.DateTimeField.getMaximumValue	(	): Get the maximum allowable value for this field.
org.joda.time.DateTimeField.getMaximumValue	(	ReadablePartial	): Get the maximum value for this field evaluated at the specified time.
org.joda.time.DateTimeField.getMaximumValue	(	ReadablePartial	int[]	): Get the maximum value for this field using the partial instant and the specified values.
org.joda.time.DateTimeField.getMaximumValue	(	long	): Get the maximum value for this field evaluated at the specified time.
org.joda.time.DateTimeField.getMinimumValue	(	): Get the minimum allowable value for this field.
org.joda.time.DateTimeField.getMinimumValue	(	ReadablePartial	): Get the minimum value for this field evaluated at the specified time.
org.joda.time.DateTimeField.getMinimumValue	(	ReadablePartial	int[]	): Get the minimum value for this field using the partial instant and the specified values.
org.joda.time.DateTimeField.getMinimumValue	(	long	): Get the minimum value for this field evaluated at the specified time.
org.joda.time.DateTimeField.getName	(	): Get the name of the field.  By convention, names follow a pattern of "dddOfRrr", where "ddd" represents the (singular) duration unit field name and "Rrr" represents the (singular) duration range field name. If the range field is not applicable, then the name of the field is simply the (singular) duration field name.
org.joda.time.DateTimeField.getRangeDurationField	(	): Returns the range duration of this field. For example, if this field represents "hour of day", then the range duration is a day.
org.joda.time.DateTimeField.getType	(	): Get the type of the field.
org.joda.time.DateTimeField.isLeap	(	long	): Returns whether this field is 'leap' for the specified instant.  For example, a leap year would return true, a non leap year would return false.
org.joda.time.DateTimeField.isLenient	(	): Returns true if the set method is lenient. If so, it accepts values that are out of bounds. For example, a lenient day of month field accepts 32 for January, converting it to February 1.
org.joda.time.DateTimeField.isSupported	(	): Returns true if this field is supported.
org.joda.time.DateTimeField.remainder	(	long	): Returns the fractional duration milliseconds of this field. In other words, calling remainder returns the duration that roundFloor would subtract.  For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by hour is 34 minutes and 56.789 seconds.
org.joda.time.DateTimeField.roundCeiling	(	long	): Round to the highest whole unit of this field. The value of this field and all fields of a higher magnitude may be incremented in order to achieve this result. The fractional millis that cannot be expressed in whole increments of this field are set to minimum.  For example, a datetime of 2002-11-02T23:34:56.789, rounded to the highest whole hour is 2002-11-03T00:00:00.000.
org.joda.time.DateTimeField.roundFloor	(	long	): Round to the lowest whole unit of this field. After rounding, the value of this field and all fields of a higher magnitude are retained. The fractional millis that cannot be expressed in whole increments of this field are set to minimum.  For example, a datetime of 2002-11-02T23:34:56.789, rounded to the lowest whole hour is 2002-11-02T23:00:00.000.
org.joda.time.DateTimeField.roundHalfCeiling	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like roundFloor. If the millisecond value is closer to the ceiling or is exactly halfway, this function behaves like roundCeiling.
org.joda.time.DateTimeField.roundHalfEven	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like roundFloor. If the millisecond value is closer to the ceiling, this function behaves like roundCeiling.  If the millisecond value is exactly halfway between the floor and ceiling, the ceiling is chosen over the floor only if it makes this field's value even.
org.joda.time.DateTimeField.roundHalfFloor	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor or is exactly halfway, this function behaves like roundFloor. If the millisecond value is closer to the ceiling, this function behaves like roundCeiling.
org.joda.time.DateTimeField.set	(	ReadablePartial	int	int[]	String	Locale	): Sets a value in the milliseconds supplied from a human-readable, text value. If the specified locale is null, the default locale is used.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.DateTimeField.set	(	ReadablePartial	int	int[]	int	): Sets a value using the specified partial instant.  The value of this field (specified by the index) will be set. If the value is invalid, an exception if thrown.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.DateTimeField.set	(	long	String	): Sets a value in the milliseconds supplied from a human-readable, text value.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.DateTimeField.set	(	long	String	Locale	): Sets a value in the milliseconds supplied from a human-readable, text value. If the specified locale is null, the default locale is used.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.DateTimeField.set	(	long	int	): Sets a value in the milliseconds supplied.  The value of this field will be set. If the value is invalid, an exception if thrown.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.DateTimeField.setExtended	(	long	int	): Sets a value in the milliseconds supplied, allowing a little leniency at the margins.  This is primarily an internal method used by parsing.
org.joda.time.DateTimeField.toString	(	): Get a suitable debug string.
org.joda.time.DateTimeFieldType: Identifies a field, such as year or minuteOfHour, in a chronology-neutral way.  A field type defines the type of the field, such as hourOfDay. If does not directly enable any calculations, however it does provide a getField() method that returns the actual calculation engine for a particular chronology. It also provides access to the related DurationFieldTypes.  Instances of DateTimeFieldType are singletons. They can be compared using ==.  If required, you can create your own field, for example a quarterOfYear. You must create a subclass of DateTimeFieldType that defines the field type. This class returns the actual calculation engine from getField(). The subclass should implement equals and hashCode.
org.joda.time.DateTimeFieldType.DateTimeFieldType	(	String	): Constructor.
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.StandardDateTimeFieldType	(	String	byte	DurationFieldType	DurationFieldType	): Constructor.
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.equals	(	Object	): 
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getDurationType	(	): Get the duration unit of the field.
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getField	(	Chronology	): Gets a suitable field for this type from the given Chronology.
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getRangeDurationType	(	): Get the duration range of the field.
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.hashCode	(	): 
org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.readResolve	(	): Ensure a singleton is returned.
org.joda.time.DateTimeFieldType.centuryOfEra	(	): Get the century of era field type.
org.joda.time.DateTimeFieldType.clockhourOfDay	(	): Get the hour of day (offset to 1-24) field type.
org.joda.time.DateTimeFieldType.clockhourOfHalfday	(	): Get the hour of am/pm (offset to 1-12) field type.
org.joda.time.DateTimeFieldType.dayOfMonth	(	): Get the day of month field type.
org.joda.time.DateTimeFieldType.dayOfWeek	(	): Get the day of week field type.
org.joda.time.DateTimeFieldType.dayOfYear	(	): Get the day of year field type.
org.joda.time.DateTimeFieldType.era	(	): Get the era field type.
org.joda.time.DateTimeFieldType.getDurationType	(	): Get the duration unit of the field.
org.joda.time.DateTimeFieldType.getField	(	Chronology	): Gets a suitable field for this type from the given Chronology.
org.joda.time.DateTimeFieldType.getName	(	): Get the name of the field.  By convention, names follow a pattern of "dddOfRrr", where "ddd" represents the (singular) duration unit field name and "Rrr" represents the (singular) duration range field name. If the range field is not applicable, then the name of the field is simply the (singular) duration field name.
org.joda.time.DateTimeFieldType.getRangeDurationType	(	): Get the duration range of the field.
org.joda.time.DateTimeFieldType.halfdayOfDay	(	): Get the AM(0) PM(1) field type.
org.joda.time.DateTimeFieldType.hourOfDay	(	): Get the hour of day (0-23) field type.
org.joda.time.DateTimeFieldType.hourOfHalfday	(	): Get the hour of am/pm (0-11) field type.
org.joda.time.DateTimeFieldType.isSupported	(	Chronology	): Checks whether this field supported in the given Chronology.
org.joda.time.DateTimeFieldType.millisOfDay	(	): Get the millis of day field type.  This measures the milliseconds from the start of the day on the local time-line. On a daylight saving date, this means that some values will be missed (in spring) or duplicated (in autumn/fall).
org.joda.time.DateTimeFieldType.millisOfSecond	(	): Get the millis of second field type.
org.joda.time.DateTimeFieldType.minuteOfDay	(	): Get the minute of day field type.  This measures the minutes from the start of the day on the local time-line. On a daylight saving date, this means that some values will be missed (in spring) or duplicated (in autumn/fall).
org.joda.time.DateTimeFieldType.minuteOfHour	(	): Get the minute of hour field type.
org.joda.time.DateTimeFieldType.monthOfYear	(	): Get the month of year field type.
org.joda.time.DateTimeFieldType.secondOfDay	(	): Get the second of day field type.  This measures the seconds from the start of the day on the local time-line. On a daylight saving date, this means that some values will be missed (in spring) or duplicated (in autumn/fall).
org.joda.time.DateTimeFieldType.secondOfMinute	(	): Get the second of minute field type.
org.joda.time.DateTimeFieldType.toString	(	): Get a suitable debug string.
org.joda.time.DateTimeFieldType.weekOfWeekyear	(	): Get the week of a week based year field type.
org.joda.time.DateTimeFieldType.weekyear	(	): Get the year of a week based year field type.
org.joda.time.DateTimeFieldType.weekyearOfCentury	(	): Get the year of a week based year within a century field type.
org.joda.time.DateTimeFieldType.year	(	): Get the year field type.
org.joda.time.DateTimeFieldType.yearOfCentury	(	): Get the year of century field type.
org.joda.time.DateTimeFieldType.yearOfEra	(	): Get the year of era field type.
org.joda.time.DateTimeUtils: DateTimeUtils provide public utility methods for the date-time library.  DateTimeUtils uses shared static variables which are declared as volatile for thread-safety. These can be changed during the lifetime of the application however doing so is generally a bad idea.
org.joda.time.DateTimeUtils.DateTimeUtils	(	): Restrictive constructor
org.joda.time.DateTimeUtils.FixedMillisProvider: Fixed millisecond provider.
org.joda.time.DateTimeUtils.FixedMillisProvider.FixedMillisProvider	(	long	): Constructor.
org.joda.time.DateTimeUtils.FixedMillisProvider.getMillis	(	): Gets the current time.
org.joda.time.DateTimeUtils.MillisProvider: A millisecond provider, allowing control of the system clock.
org.joda.time.DateTimeUtils.MillisProvider.getMillis	(	): Gets the current time.  Implementations of this method must be thread-safe.
org.joda.time.DateTimeUtils.OffsetMillisProvider: Offset from system millis provider.
org.joda.time.DateTimeUtils.OffsetMillisProvider.OffsetMillisProvider	(	long	): Constructor.
org.joda.time.DateTimeUtils.OffsetMillisProvider.getMillis	(	): Gets the current time.
org.joda.time.DateTimeUtils.SystemMillisProvider: System millis provider.
org.joda.time.DateTimeUtils.SystemMillisProvider.getMillis	(	): Gets the current time.
org.joda.time.DateTimeUtils.checkPermission	(	): Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.
org.joda.time.DateTimeUtils.currentTimeMillis	(	): Gets the current time in milliseconds.  By default this returns System.currentTimeMillis(). This may be changed using other methods in this class.
org.joda.time.DateTimeUtils.fromJulianDay	(	double	): Creates a date-time from a Julian Day.  Returns the DateTime object equal to the specified Julian Day.
org.joda.time.DateTimeUtils.getChronology	(	Chronology	): Gets the chronology handling null.  If the chronology is null, getInstance() will be returned. Otherwise, the chronology is returned.
org.joda.time.DateTimeUtils.getDateFormatSymbols	(	Locale	): Gets the DateFormatSymbols based on the given locale.  If JDK 6 or newer is being used, DateFormatSymbols.getInstance(locale) will be used in order to allow the use of locales defined as extensions. Otherwise, new DateFormatSymbols(locale) will be used. See JDK 6 DateFormatSymbols for further information.
org.joda.time.DateTimeUtils.getDefaultTimeZoneNames	(	): Gets the default map of time zone names.  This can be changed by setDefaultTimeZoneNames.  The default set of short time zone names is as follows:  UT - UTC UTC - UTC GMT - UTC EST - America/New_York EDT - America/New_York CST - America/Chicago CDT - America/Chicago MST - America/Denver MDT - America/Denver PST - America/Los_Angeles PDT - America/Los_Angeles 
org.joda.time.DateTimeUtils.getDurationMillis	(	ReadableDuration	): Gets the millisecond duration from the specified duration object handling null.  If the duration object is null, zero will be returned. Otherwise, the millis from the object are returned.
org.joda.time.DateTimeUtils.getInstantChronology	(	ReadableInstant	): Gets the chronology from the specified instant object handling null.  If the instant object is null, or the instant's chronology is null, getInstance() will be returned. Otherwise, the chronology from the object is returned.
org.joda.time.DateTimeUtils.getInstantMillis	(	ReadableInstant	): Gets the millisecond instant from the specified instant object handling null.  If the instant object is null, the currentTimeMillis() will be returned. Otherwise, the millis from the object are returned.
org.joda.time.DateTimeUtils.getIntervalChronology	(	ReadableInstant	ReadableInstant	): Gets the chronology from the specified instant based interval handling null.  The chronology is obtained from the start if that is not null, or from the end if the start is null. The result is additionally checked, and if still null then getInstance() will be returned.
org.joda.time.DateTimeUtils.getIntervalChronology	(	ReadableInterval	): Gets the chronology from the specified interval object handling null.  If the interval object is null, or the interval's chronology is null, getInstance() will be returned. Otherwise, the chronology from the object is returned.
org.joda.time.DateTimeUtils.getPeriodType	(	PeriodType	): Gets the period type handling null.  If the zone is null, standard() will be returned. Otherwise, the type specified is returned.
org.joda.time.DateTimeUtils.getReadableInterval	(	ReadableInterval	): Gets the interval handling null.  If the interval is null, an interval representing now to now in the getInstance() ISOChronology will be returned. Otherwise, the interval specified is returned.
org.joda.time.DateTimeUtils.getZone	(	DateTimeZone	): Gets the zone handling null.  If the zone is null, getDefault() will be returned. Otherwise, the zone specified is returned.
org.joda.time.DateTimeUtils.isContiguous	(	ReadablePartial	): Checks whether the partial is contiguous.  A partial is contiguous if one field starts where another ends.  For example LocalDate is contiguous because DayOfMonth has the same range (Month) as the unit of the next field (MonthOfYear), and MonthOfYear has the same range (Year) as the unit of the next field (Year).  Similarly, LocalTime is contiguous, as it consists of MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how the names of each field 'join up').  However, a Year/HourOfDay partial is not contiguous because the range field Day is not equal to the next field Year. Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because the range Month is not equal to the next field Day.
org.joda.time.DateTimeUtils.setCurrentMillisFixed	(	long	): Sets the current time to return a fixed millisecond time.  This method changes the behaviour of currentTimeMillis(). Whenever the current time is queried, the same millisecond time will be returned.
org.joda.time.DateTimeUtils.setCurrentMillisOffset	(	long	): Sets the current time to return the system time plus an offset.  This method changes the behaviour of currentTimeMillis(). Whenever the current time is queried, currentTimeMillis() is used and then offset by adding the millisecond value specified here.
org.joda.time.DateTimeUtils.setCurrentMillisProvider	(	MillisProvider	): Sets the provider of the current time to class specified.  This method changes the behaviour of currentTimeMillis(). Whenever the current time is queried, the specified class will be called.
org.joda.time.DateTimeUtils.setCurrentMillisSystem	(	): Resets the current time to return the system time.  This method changes the behaviour of currentTimeMillis(). Whenever the current time is queried, currentTimeMillis() is used.
org.joda.time.DateTimeUtils.setDefaultTimeZoneNames	(	Map	): Sets the default map of time zone names.  The map is copied before storage.
org.joda.time.DateTimeUtils.toJulianDay	(	long	): Calculates the astronomical Julian Day for an instant.  The Julian day is a well-known system of time measurement for scientific use by the astronomy community. It expresses the interval of time in days and fractions of a day since January 1, 4713 BC (Julian) Greenwich noon.  Each day starts at midday (not midnight) and time is expressed as a fraction. Thus the fraction 0.25 is 18:00. equal to one quarter of the day from midday to midday.  Note that this method has nothing to do with the day-of-year.
org.joda.time.DateTimeUtils.toJulianDayNumber	(	long	): Calculates the astronomical Julian Day Number for an instant.  The toJulianDay() method calculates the astronomical Julian Day with a fraction based on days starting at midday. This method calculates the variant where days start at midnight. JDN 0 is used for the date equivalent to Monday January 1, 4713 BC (Julian). Thus these days start 12 hours before those of the fractional Julian Day.  Note that this method has nothing to do with the day-of-year.
org.joda.time.DateTimeZone: DateTimeZone represents a time zone.  A time zone is a system of rules to convert time from one geographic location to another. For example, Paris, France is one hour ahead of London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.  All time zone rules are expressed, for historical reasons, relative to Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean Time (GMT). This is similar, but not precisely identical, to Universal Coordinated Time, or UTC. This library only uses the term UTC.  Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00 in the summer. The offset -08:00 indicates that America/Los_Angeles time is obtained from UTC by adding -08:00, that is, by subtracting 8 hours.  The offset differs in the summer because of daylight saving time, or DST. The following definitions of time are generally used:  UTC - The reference time. Standard Time - The local time without a daylight saving time offset. For example, in Paris, standard time is UTC+01:00. Daylight Saving Time - The local time with a daylight saving time offset. This offset is typically one hour, but not always. It is typically used in most countries away from the equator. In Paris, daylight saving time is UTC+02:00. Wall Time - This is what a local clock on the wall reads. This will be either Standard Time or Daylight Saving Time depending on the time of year and whether the location uses Daylight Saving Time.   Unlike the Java TimeZone class, DateTimeZone is immutable. It also only supports long format time zone ids. Thus EST and ECT are not accepted. However, the factory that accepts a TimeZone will attempt to convert from the old short id to a suitable long id.  There are four approaches to loading time-zone data, which are tried in this order:  load the specific Provider specified by the system property org.joda.time.DateTimeZone.Provider. load ZoneInfoProvider using the data in the filing system folder pointed to by system property org.joda.time.DateTimeZone.Folder. load ZoneInfoProvider using the data in the classpath location org/joda/time/tz/data. load UTCProvider   Unless you override the standard behaviour, the default if the third approach.  DateTimeZone is thread-safe and immutable, and all subclasses must be as well.
org.joda.time.DateTimeZone.DateTimeZone	(	String	): Constructor.
org.joda.time.DateTimeZone.LazyInit: Lazy initialization to avoid a synchronization lock.
org.joda.time.DateTimeZone.Stub: Used to serialize DateTimeZones by id.
org.joda.time.DateTimeZone.Stub.Stub	(	String	): Constructor.
org.joda.time.DateTimeZone.adjustOffset	(	long	boolean	): Adjusts the offset to be the earlier or later one during an overlap.
org.joda.time.DateTimeZone.convertLocalToUTC	(	long	boolean	): Converts a local instant to a standard UTC instant with the same local time. This conversion is used after performing a calculation where the calculation was done using a simple local zone.
org.joda.time.DateTimeZone.convertLocalToUTC	(	long	boolean	long	): Converts a local instant to a standard UTC instant with the same local time attempting to use the same offset as the original.  This conversion is used after performing a calculation where the calculation was done using a simple local zone. Whenever possible, the same offset as the original offset will be used. This is most significant during a daylight savings overlap.
org.joda.time.DateTimeZone.convertUTCToLocal	(	long	): Converts a standard UTC instant to a local instant with the same local time. This conversion is used before performing a calculation so that the calculation can be done using a simple local zone.
org.joda.time.DateTimeZone.equals	(	Object	): Compare this datetime zone with another.
org.joda.time.DateTimeZone.fixedOffsetZone	(	String	int	): Gets the zone using a fixed offset amount.
org.joda.time.DateTimeZone.forID	(	String	): Gets a time zone instance for the specified time zone id.  The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by java.util.TimeZone, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id.  Alternatively a locale independent, fixed offset, datetime zone can be specified. The form [+-]hh:mm can be used.
org.joda.time.DateTimeZone.forOffsetHours	(	int	): Gets a time zone instance for the specified offset to UTC in hours. This method assumes standard length hours.  This factory is a convenient way of constructing zones with a fixed offset.
org.joda.time.DateTimeZone.forOffsetHoursMinutes	(	int	int	): Gets a time zone instance for the specified offset to UTC in hours and minutes. This method assumes 60 minutes in an hour, and standard length minutes.  This factory is a convenient way of constructing zones with a fixed offset. The hours value must be in the range -23 to +23. The minutes value must be in the range -59 to +59. The following combinations of sign for the hour and minute are possible:  Hour Minute Example Result +ve +ve (2, 15) +02:15 +ve zero (2, 0) +02:00 +ve -ve (2, -15) IllegalArgumentException zero +ve (0, 15) +00:15 zero zero (0, 0) +00:00 zero -ve (0, -15) -00:15 -ve +ve (-2, 15) -02:15 -ve zero (-2, 0) -02:00 -ve -ve (-2, -15) -02:15  Note that in versions before 2.3, the minutes had to be zero or positive.
org.joda.time.DateTimeZone.forOffsetMillis	(	int	): Gets a time zone instance for the specified offset to UTC in milliseconds.
org.joda.time.DateTimeZone.forTimeZone	(	TimeZone	): Gets a time zone instance for a JDK TimeZone.  DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This method will attempt to convert between time zones created using the short IDs and the full version.  This method is not designed to parse time zones with rules created by applications using SimpleTimeZone directly.
org.joda.time.DateTimeZone.getAvailableIDs	(	): Gets all the available IDs supported.
org.joda.time.DateTimeZone.getConvertedId	(	String	): Converts an old style id to a new style id.
org.joda.time.DateTimeZone.getDefault	(	): Gets the default time zone.  The default time zone is derived from the system property user.timezone. If that is null or is not a valid identifier, then the value of the JDK TimeZone default is converted. If that fails, UTC is used.  NOTE: If the java.util.TimeZone default is updated after calling this method, then the change will not be picked up here.
org.joda.time.DateTimeZone.getDefaultNameProvider	(	): Gets the default name provider.  Tries the system property org.joda.time.DateTimeZone.NameProvider. Then uses DefaultNameProvider.
org.joda.time.DateTimeZone.getDefaultProvider	(	): Gets the default zone provider.  This tries four approaches to loading data:  loads the provider identifier by the system property org.joda.time.DateTimeZone.Provider. load ZoneInfoProvider using the data in the filing system folder pointed to by system property org.joda.time.DateTimeZone.Folder. loads ZoneInfoProvider using the data in the classpath location org/joda/time/tz/data. loads UTCProvider.   Unless you override the standard behaviour, the default if the third approach.
org.joda.time.DateTimeZone.getID	(	): Gets the ID of this datetime zone.
org.joda.time.DateTimeZone.getMillisKeepLocal	(	DateTimeZone	long	): Gets the millisecond instant in another zone keeping the same local time.  The conversion is performed by converting the specified UTC millis to local millis in this zone, then converting back to UTC millis in the new zone.
org.joda.time.DateTimeZone.getName	(	long	): Gets the long name of this datetime zone suitable for display using the default locale.  If the name is not available for the locale, then this method returns a string in the format [+-]hh:mm.
org.joda.time.DateTimeZone.getName	(	long	Locale	): Gets the long name of this datetime zone suitable for display using the specified locale.  If the name is not available for the locale, then this method returns a string in the format [+-]hh:mm.
org.joda.time.DateTimeZone.getNameKey	(	long	): Returns a non-localized name that is unique to this time zone. It can be combined with id to form a unique key for fetching localized names.
org.joda.time.DateTimeZone.getNameProvider	(	): Gets the name provider factory.  The name provider is a pluggable instance factory that supplies the names of each DateTimeZone.
org.joda.time.DateTimeZone.getOffset	(	ReadableInstant	): Gets the millisecond offset to add to UTC to get local time.
org.joda.time.DateTimeZone.getOffset	(	long	): Gets the millisecond offset to add to UTC to get local time.
org.joda.time.DateTimeZone.getOffsetFromLocal	(	long	): Gets the millisecond offset to subtract from local time to get UTC time. This offset can be used to undo adding the offset obtained by getOffset.  millisLocal == millisUTC + getOffset(millisUTC) millisUTC == millisLocal - getOffsetFromLocal(millisLocal)  NOTE: After calculating millisLocal, some error may be introduced. At offset transitions (due to DST or other historical changes), ranges of local times may map to different UTC times.  For overlaps (where the local time is ambiguous), this method returns the offset applicable before the gap. The effect of this is that any instant calculated using the offset from an overlap will be in "summer" time.  For gaps, this method returns the offset applicable before the gap, ie "winter" offset. However, the effect of this is that any instant calculated using the offset from a gap will be after the gap, in "summer" time.  For example, consider a zone with a gap from 01:00 to 01:59: Input: 00:00 (before gap) Output: Offset applicable before gap DateTime: 00:00 Input: 00:30 (before gap) Output: Offset applicable before gap DateTime: 00:30 Input: 01:00 (in gap) Output: Offset applicable before gap DateTime: 02:00 Input: 01:30 (in gap) Output: Offset applicable before gap DateTime: 02:30 Input: 02:00 (after gap) Output: Offset applicable after gap DateTime: 02:00 Input: 02:30 (after gap) Output: Offset applicable after gap DateTime: 02:30  NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere. Prior to v1.5, the DST gap behaviour was also not defined. In v2.4, the documentation was clarified again.
org.joda.time.DateTimeZone.getProvider	(	): Gets the zone provider factory.  The zone provider is a pluggable instance factory that supplies the actual instances of DateTimeZone.
org.joda.time.DateTimeZone.getShortName	(	long	): Gets the short name of this datetime zone suitable for display using the default locale.  If the name is not available for the locale, then this method returns a string in the format [+-]hh:mm.
org.joda.time.DateTimeZone.getShortName	(	long	Locale	): Gets the short name of this datetime zone suitable for display using the specified locale.  If the name is not available for the locale, then this method returns a string in the format [+-]hh:mm.
org.joda.time.DateTimeZone.getStandardOffset	(	long	): Gets the standard millisecond offset to add to UTC to get local time, when standard time is in effect.
org.joda.time.DateTimeZone.hashCode	(	): Gets a hash code compatible with equals.
org.joda.time.DateTimeZone.isFixed	(	): Returns true if this time zone has no transitions.
org.joda.time.DateTimeZone.isLocalDateTimeGap	(	LocalDateTime	): Checks if the given LocalDateTime is within a gap.  When switching from standard time to Daylight Savings Time there is typically a gap where a clock hour is missing. This method identifies whether the local datetime refers to such a gap.
org.joda.time.DateTimeZone.isStandardOffset	(	long	): Checks whether, at a particular instant, the offset is standard or not.  This method can be used to determine whether Summer Time (DST) applies. As a general rule, if the offset at the specified instant is standard, then either Winter time applies, or there is no Summer Time. If the instant is not standard, then Summer Time applies.  The implementation of the method is simply whether getOffset() equals getStandardOffset() at the specified instant.
org.joda.time.DateTimeZone.nextTransition	(	long	): Advances the given instant to where the time zone offset or name changes. If the instant returned is exactly the same as passed in, then no changes occur after the given instant.
org.joda.time.DateTimeZone.parseOffset	(	String	): Parses an offset from the string.
org.joda.time.DateTimeZone.previousTransition	(	long	): Retreats the given instant to where the time zone offset or name changes. If the instant returned is exactly the same as passed in, then no changes occur before the given instant.
org.joda.time.DateTimeZone.printOffset	(	int	): Formats a timezone offset string.  This method is kept separate from the formatting classes to speed and simplify startup and classloading.
org.joda.time.DateTimeZone.setDefault	(	DateTimeZone	): Sets the default time zone.  NOTE: Calling this method does not set the java.util.TimeZone default.
org.joda.time.DateTimeZone.setNameProvider	(	NameProvider	): Sets the name provider factory.  The name provider is a pluggable instance factory that supplies the names of each DateTimeZone.
org.joda.time.DateTimeZone.setProvider	(	Provider	): Sets the zone provider factory.  The zone provider is a pluggable instance factory that supplies the actual instances of DateTimeZone.
org.joda.time.DateTimeZone.toString	(	): Gets the datetime zone as a string, which is simply its ID.
org.joda.time.DateTimeZone.toTimeZone	(	): Get the datetime zone as a java.util.TimeZone.
org.joda.time.DateTimeZone.validateProvider	(	Provider	): Sets the zone provider factory without performing the security check.
org.joda.time.DateTimeZone.writeReplace	(	): By default, when DateTimeZones are serialized, only a "stub" object referring to the id is written out. When the stub is read in, it replaces itself with a DateTimeZone object.
org.joda.time.Days: An immutable time period representing a number of days.  Days is an immutable period that can only store days. It does not store years, months or hours for example. As such it is a type-safe way of representing a number of days in an application.  The number of days is set in the constructor, and may be queried using getDays(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Days is thread-safe and immutable.
org.joda.time.Days.Days	(	int	): Creates a new instance representing a number of days. You should consider using the factory method days() instead of the constructor.
org.joda.time.Days.days	(	int	): Obtains an instance of Days that may be cached. Days is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Days.daysBetween	(	ReadableInstant	ReadableInstant	): Creates a Days representing the number of whole days between the two specified datetimes. This method correctly handles any daylight savings time changes that may occur during the interval.
org.joda.time.Days.daysBetween	(	ReadablePartial	ReadablePartial	): Creates a Days representing the number of whole days between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalDate objects.
org.joda.time.Days.daysIn	(	ReadableInterval	): Creates a Days representing the number of whole days in the specified interval. This method correctly handles any daylight savings time changes that may occur during the interval.
org.joda.time.Days.dividedBy	(	int	): Returns a new instance with the days divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Days.getDays	(	): Gets the number of days that this period represents.
org.joda.time.Days.getFieldType	(	): Gets the duration field type, which is days.
org.joda.time.Days.getPeriodType	(	): Gets the period type, which is days.
org.joda.time.Days.isGreaterThan	(	Days	): Is this days instance greater than the specified number of days.
org.joda.time.Days.isLessThan	(	Days	): Is this days instance less than the specified number of days.
org.joda.time.Days.minus	(	Days	): Returns a new instance with the specified number of days taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Days.minus	(	int	): Returns a new instance with the specified number of days taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Days.multipliedBy	(	int	): Returns a new instance with the days multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Days.negated	(	): Returns a new instance with the days value negated.
org.joda.time.Days.parseDays	(	String	): Creates a new Days by parsing a string in the ISO8601 format 'PnD'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the days component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Days.plus	(	Days	): Returns a new instance with the specified number of days added.  This instance is immutable and unaffected by this method call.
org.joda.time.Days.plus	(	int	): Returns a new instance with the specified number of days added.  This instance is immutable and unaffected by this method call.
org.joda.time.Days.readResolve	(	): Resolves singletons.
org.joda.time.Days.standardDaysIn	(	ReadablePeriod	): Creates a new Days representing the number of complete standard length days in the specified period.  This factory method converts all fields from the period to hours using standardised durations for each field. Only those fields which have a precise duration in the ISO UTC chronology can be converted.  One week consists of 7 days. One day consists of 24 hours. One hour consists of 60 minutes. One minute consists of 60 seconds. One second consists of 1000 milliseconds.  Months and Years are imprecise and periods containing these values cannot be converted.
org.joda.time.Days.toStandardDuration	(	): Converts this period in days to a duration in milliseconds assuming a 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert from a period to a duration. However to achieve this it makes the assumption that all days are 24 hours long, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Days.toStandardHours	(	): Converts this period in days to a period in hours assuming a 24 hour day.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all days are 24 hours long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Days.toStandardMinutes	(	): Converts this period in days to a period in minutes assuming a 24 hour day and 60 minute hour.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all days are 24 hours long and all hours are 60 minutes long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Days.toStandardSeconds	(	): Converts this period in days to a period in seconds assuming a 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all days are 24 hours long, all hours are 60 minutes long and all minutes are 60 seconds long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Days.toStandardWeeks	(	): Converts this period in days to a period in weeks assuming a 7 day week.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Days.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "P4D" represents 4 days.
org.joda.time.Duration: An immutable duration specifying a length of time in milliseconds.  A duration is defined by a fixed number of milliseconds. There is no concept of fields, such as days or seconds, as these fields can vary in length.  A duration may be converted to a Period to obtain field values. This conversion will typically cause a loss of precision.  Duration is thread-safe and immutable.
org.joda.time.Duration.Duration	(	Object	): Creates a duration from the specified object using the org.joda.time.convert.ConverterManager ConverterManager.
org.joda.time.Duration.Duration	(	ReadableInstant	ReadableInstant	): Creates a duration from the given interval endpoints.
org.joda.time.Duration.Duration	(	long	): Creates a duration from the given millisecond duration.
org.joda.time.Duration.Duration	(	long	long	): Creates a duration from the given interval endpoints.
org.joda.time.Duration.dividedBy	(	long	): Returns a new duration with this length divided by the specified divisor. This instance is immutable and is not altered.  If the divisor is one, this instance is returned.
org.joda.time.Duration.dividedBy	(	long	RoundingMode	): Returns a new duration with its length divided by the specified divisor. RoundingMode can be specified. This instance is immutable and is not altered.  If the divisor is one, this instance is returned.
org.joda.time.Duration.getStandardDays	(	): Gets the length of this duration in days assuming that there are the standard number of milliseconds in a day.  This method assumes that there are 24 hours in a day, 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in a second. This will be true for most days, however days with Daylight Savings changes will not have 24 hours, so use this method with care.  This returns getMillis() / MILLIS_PER_DAY. The result is an integer division, thus excess milliseconds are truncated.
org.joda.time.Duration.getStandardHours	(	): Gets the length of this duration in hours assuming that there are the standard number of milliseconds in an hour.  This method assumes that there are 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in a second. All currently supplied chronologies use this definition.  This returns getMillis() / MILLIS_PER_HOUR. The result is an integer division, thus excess milliseconds are truncated.
org.joda.time.Duration.getStandardMinutes	(	): Gets the length of this duration in minutes assuming that there are the standard number of milliseconds in a minute.  This method assumes that there are 60 seconds in a minute and 1000 milliseconds in a second. All currently supplied chronologies use this definition.  This returns getMillis() / MILLIS_PER_MINUTE. The result is an integer division, thus excess milliseconds are truncated.
org.joda.time.Duration.getStandardSeconds	(	): Gets the length of this duration in seconds assuming that there are the standard number of milliseconds in a second.  This method assumes that there are 1000 milliseconds in a second. All currently supplied chronologies use this definition.  This returns getMillis() / 1000. The result is an integer division, so 2999 millis returns 2 seconds.
org.joda.time.Duration.millis	(	long	): Create a duration with the specified number of milliseconds.
org.joda.time.Duration.minus	(	ReadableDuration	): Returns a new duration with this length minus that specified. This instance is immutable and is not altered.  If the amount is zero, this instance is returned.
org.joda.time.Duration.minus	(	long	): Returns a new duration with this length minus that specified. This instance is immutable and is not altered.  If the addition is zero, this instance is returned.
org.joda.time.Duration.multipliedBy	(	long	): Returns a new duration with this length multiplied by the specified multiplicand. This instance is immutable and is not altered.  If the multiplicand is one, this instance is returned.
org.joda.time.Duration.negated	(	): Returns a new duration with this length negated. This instance is immutable and is not altered.
org.joda.time.Duration.parse	(	String	): Parses a Duration from the specified string.  This parses the format PTa.bS, as per toString().
org.joda.time.Duration.plus	(	ReadableDuration	): Returns a new duration with this length plus that specified. This instance is immutable and is not altered.  If the amount is zero, this instance is returned.
org.joda.time.Duration.plus	(	long	): Returns a new duration with this length plus that specified. This instance is immutable and is not altered.  If the addition is zero, this instance is returned.
org.joda.time.Duration.standardDays	(	long	): Create a duration with the specified number of days assuming that there are the standard number of milliseconds in a day.  This method assumes that there are 24 hours in a day, 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in a second. This will be true for most days, however days with Daylight Savings changes will not have 24 hours, so use this method with care.  A Duration is a representation of an amount of time. If you want to express the concept of 'days' you should consider using the Days class.
org.joda.time.Duration.standardHours	(	long	): Create a duration with the specified number of hours assuming that there are the standard number of milliseconds in an hour.  This method assumes that there are 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in a second. All currently supplied chronologies use this definition.  A Duration is a representation of an amount of time. If you want to express the concept of 'hours' you should consider using the Hours class.
org.joda.time.Duration.standardMinutes	(	long	): Create a duration with the specified number of minutes assuming that there are the standard number of milliseconds in a minute.  This method assumes that there are 60 seconds in a minute and 1000 milliseconds in a second. All currently supplied chronologies use this definition.  A Duration is a representation of an amount of time. If you want to express the concept of 'minutes' you should consider using the Minutes class.
org.joda.time.Duration.standardSeconds	(	long	): Create a duration with the specified number of seconds assuming that there are the standard number of milliseconds in a second.  This method assumes that there are 1000 milliseconds in a second. All currently supplied chronologies use this definition.  A Duration is a representation of an amount of time. If you want to express the concept of 'seconds' you should consider using the Seconds class.
org.joda.time.Duration.toDuration	(	): Get this duration as an immutable Duration object by returning this.
org.joda.time.Duration.toStandardDays	(	): Converts this duration to a period in days assuming that there are the standard number of milliseconds in a day.  This method assumes that there are 24 hours in a day, 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in a second. This will be true for most days, however days with Daylight Savings changes will not have 24 hours, so use this method with care.
org.joda.time.Duration.toStandardHours	(	): Converts this duration to a period in hours assuming that there are the standard number of milliseconds in an hour.  This method assumes that there are 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in a second. All currently supplied chronologies use this definition.
org.joda.time.Duration.toStandardMinutes	(	): Converts this duration to a period in minutes assuming that there are the standard number of milliseconds in a minute.  This method assumes that there are 60 seconds in a minute and 1000 milliseconds in a second. All currently supplied chronologies use this definition.
org.joda.time.Duration.toStandardSeconds	(	): Converts this duration to a period in seconds assuming that there are the standard number of milliseconds in a second.  This method assumes that there are 1000 milliseconds in a second. All currently supplied chronologies use this definition.
org.joda.time.Duration.withDurationAdded	(	ReadableDuration	int	): Returns a new duration with this length plus that specified multiplied by the scalar. This instance is immutable and is not altered.  If the addition is zero, this instance is returned.
org.joda.time.Duration.withDurationAdded	(	long	int	): Returns a new duration with this length plus that specified multiplied by the scalar. This instance is immutable and is not altered.  If the addition is zero, this instance is returned.
org.joda.time.Duration.withMillis	(	long	): Creates a new Duration instance with a different millisecond length.
org.joda.time.DurationField: Defines the calculation engine for duration fields. The interface defines a set of methods that manipulate a millisecond duration with regards to a single field, such as months or seconds.  This design is extensible so, if you wish, you can extract a different field from the millisecond duration. A number of standard implementations are provided to assist.
org.joda.time.DurationField.add	(	long	int	): Adds a duration value (which may be negative) to the instant.
org.joda.time.DurationField.add	(	long	long	): Adds a duration value (which may be negative) to the instant.
org.joda.time.DurationField.getDifference	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... int v = ... int age = getDifference(add(instant, v), instant);  The value 'age' is the same as the value 'v'.
org.joda.time.DurationField.getDifferenceAsLong	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... long v = ... long age = getDifferenceAsLong(add(instant, v), instant);  The value 'age' is the same as the value 'v'.
org.joda.time.DurationField.getMillis	(	int	): Get the millisecond duration of this field from its value, which is approximate if this field is imprecise.
org.joda.time.DurationField.getMillis	(	int	long	): Get the millisecond duration of this field from its value relative to an instant. For precise fields this method produces the same result as for the single argument getMillis method.  If the value is positive, then the instant is treated as a "start instant". If negative, the instant is treated as an "end instant".
org.joda.time.DurationField.getMillis	(	long	): Get the millisecond duration of this field from its value, which is approximate if this field is imprecise.
org.joda.time.DurationField.getMillis	(	long	long	): Get the millisecond duration of this field from its value relative to an instant. For precise fields this method produces the same result as for the single argument getMillis method.  If the value is positive, then the instant is treated as a "start instant". If negative, the instant is treated as an "end instant".
org.joda.time.DurationField.getName	(	): Get the name of the field.  By convention, names are plural.
org.joda.time.DurationField.getType	(	): Get the type of the field.
org.joda.time.DurationField.getUnitMillis	(	): Returns the amount of milliseconds per unit value of this field. For example, if this field represents "seconds", then this returns the milliseconds in one second.  For imprecise fields, the unit size is variable, and so this method returns a suitable average value.
org.joda.time.DurationField.getValue	(	long	): Get the value of this field from the milliseconds, which is approximate if this field is imprecise.
org.joda.time.DurationField.getValue	(	long	long	): Get the value of this field from the milliseconds relative to an instant. For precise fields this method produces the same result as for the single argument get method.  If the millisecond duration is positive, then the instant is treated as a "start instant". If negative, the instant is treated as an "end instant".
org.joda.time.DurationField.getValueAsLong	(	long	): Get the value of this field from the milliseconds, which is approximate if this field is imprecise.
org.joda.time.DurationField.getValueAsLong	(	long	long	): Get the value of this field from the milliseconds relative to an instant. For precise fields this method produces the same result as for the single argument get method.  If the millisecond duration is positive, then the instant is treated as a "start instant". If negative, the instant is treated as an "end instant".
org.joda.time.DurationField.isPrecise	(	): Is this field precise. A precise field can calculate its value from milliseconds without needing a reference date. Put another way, a precise field's unit size is not variable.
org.joda.time.DurationField.isSupported	(	): Returns true if this field is supported.
org.joda.time.DurationField.subtract	(	long	int	): Subtracts a duration value (which may be negative) from the instant.
org.joda.time.DurationField.subtract	(	long	long	): Subtracts a duration value (which may be negative) from the instant.
org.joda.time.DurationField.toString	(	): Get a suitable debug string.
org.joda.time.DurationFieldType: Identifies a duration field, such as years or minutes, in a chronology-neutral way.  A duration field type defines the type of the field, such as hours. If does not directly enable any calculations, however it does provide a getField() method that returns the actual calculation engine for a particular chronology.  Instances of DurationFieldType are singletons. They can be compared using ==.  If required, you can create your own field, for example a quarters. You must create a subclass of DurationFieldType that defines the field type. This class returns the actual calculation engine from getField().
org.joda.time.DurationFieldType.DurationFieldType	(	String	): Constructor.
org.joda.time.DurationFieldType.StandardDurationFieldType.StandardDurationFieldType	(	String	byte	): Constructor.
org.joda.time.DurationFieldType.StandardDurationFieldType.equals	(	Object	): 
org.joda.time.DurationFieldType.StandardDurationFieldType.hashCode	(	): 
org.joda.time.DurationFieldType.StandardDurationFieldType.readResolve	(	): Ensure a singleton is returned.
org.joda.time.DurationFieldType.centuries	(	): Get the centuries field type.
org.joda.time.DurationFieldType.days	(	): Get the days field type.
org.joda.time.DurationFieldType.eras	(	): Get the eras field type.
org.joda.time.DurationFieldType.getField	(	Chronology	): Gets a suitable field for this type from the given Chronology.
org.joda.time.DurationFieldType.getName	(	): Get the name of the field. By convention, names are plural.
org.joda.time.DurationFieldType.halfdays	(	): Get the halfdays field type.
org.joda.time.DurationFieldType.hours	(	): Get the hours field type.
org.joda.time.DurationFieldType.isSupported	(	Chronology	): Checks whether this field supported in the given Chronology.
org.joda.time.DurationFieldType.millis	(	): Get the millis field type.
org.joda.time.DurationFieldType.minutes	(	): Get the minutes field type.
org.joda.time.DurationFieldType.months	(	): Get the months field type.
org.joda.time.DurationFieldType.seconds	(	): Get the seconds field type.
org.joda.time.DurationFieldType.toString	(	): Get a suitable debug string.
org.joda.time.DurationFieldType.weeks	(	): Get the weeks field type.
org.joda.time.DurationFieldType.weekyears	(	): Get the weekyears field type.
org.joda.time.DurationFieldType.years	(	): Get the years field type.
org.joda.time.Hours: An immutable time period representing a number of hours.  Hours is an immutable period that can only store hours. It does not store years, months or minutes for example. As such it is a type-safe way of representing a number of hours in an application.  The number of hours is set in the constructor, and may be queried using getHours(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Hours is thread-safe and immutable.
org.joda.time.Hours.Hours	(	int	): Creates a new instance representing a number of hours. You should consider using the factory method hours() instead of the constructor.
org.joda.time.Hours.dividedBy	(	int	): Returns a new instance with the hours divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Hours.getFieldType	(	): Gets the duration field type, which is hours.
org.joda.time.Hours.getHours	(	): Gets the number of hours that this period represents.
org.joda.time.Hours.getPeriodType	(	): Gets the period type, which is hours.
org.joda.time.Hours.hours	(	int	): Obtains an instance of Hours that may be cached. Hours is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Hours.hoursBetween	(	ReadableInstant	ReadableInstant	): Creates a Hours representing the number of whole hours between the two specified datetimes.
org.joda.time.Hours.hoursBetween	(	ReadablePartial	ReadablePartial	): Creates a Hours representing the number of whole hours between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalTime objects.
org.joda.time.Hours.hoursIn	(	ReadableInterval	): Creates a Hours representing the number of whole hours in the specified interval.
org.joda.time.Hours.isGreaterThan	(	Hours	): Is this hours instance greater than the specified number of hours.
org.joda.time.Hours.isLessThan	(	Hours	): Is this hours instance less than the specified number of hours.
org.joda.time.Hours.minus	(	Hours	): Returns a new instance with the specified number of hours taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Hours.minus	(	int	): Returns a new instance with the specified number of hours taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Hours.multipliedBy	(	int	): Returns a new instance with the hours multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Hours.negated	(	): Returns a new instance with the hours value negated.
org.joda.time.Hours.parseHours	(	String	): Creates a new Hours by parsing a string in the ISO8601 format 'PTnH'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the hours component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Hours.plus	(	Hours	): Returns a new instance with the specified number of hours added.  This instance is immutable and unaffected by this method call.
org.joda.time.Hours.plus	(	int	): Returns a new instance with the specified number of hours added.  This instance is immutable and unaffected by this method call.
org.joda.time.Hours.readResolve	(	): Resolves singletons.
org.joda.time.Hours.standardHoursIn	(	ReadablePeriod	): Creates a new Hours representing the number of complete standard length hours in the specified period.  This factory method converts all fields from the period to hours using standardised durations for each field. Only those fields which have a precise duration in the ISO UTC chronology can be converted.  One week consists of 7 days. One day consists of 24 hours. One hour consists of 60 minutes. One minute consists of 60 seconds. One second consists of 1000 milliseconds.  Months and Years are imprecise and periods containing these values cannot be converted.
org.joda.time.Hours.toStandardDays	(	): Converts this period in hours to a period in days assuming a 24 hour day.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all days are 24 hours long. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Hours.toStandardDuration	(	): Converts this period in hours to a duration in milliseconds assuming a 60 minute hour and 60 second minute.  This method allows you to convert from a period to a duration. However to achieve this it makes the assumption that all hours are 60 minutes and all minutes are 60 seconds. This might not be true for an unusual chronology, for example one that takes leap seconds into account. However, the method is included as it is a useful operation for many applications and business rules.
org.joda.time.Hours.toStandardMinutes	(	): Converts this period in hours to a period in minutes assuming a 60 minute hour.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all hours are 60 minutes long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Hours.toStandardSeconds	(	): Converts this period in hours to a period in seconds assuming a 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all hours are 60 minutes long and all minutes are 60 seconds long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Hours.toStandardWeeks	(	): Converts this period in hours to a period in weeks assuming a 7 day week and 24 hour day.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long and all days are 24 hours long. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Hours.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "PT4H" represents 4 hours.
org.joda.time.IllegalFieldValueException: Exception thrown when attempting to set a field outside its supported range.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	DateTimeFieldType	Number	Number	Number	): Constructor.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	DateTimeFieldType	Number	String	): Constructor.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	DateTimeFieldType	String	): Constructor.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	DurationFieldType	Number	Number	Number	): Constructor.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	DurationFieldType	String	): Constructor.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	String	Number	Number	Number	): Constructor.
org.joda.time.IllegalFieldValueException.IllegalFieldValueException	(	String	String	): Constructor.
org.joda.time.IllegalFieldValueException.createMessage	(	String	Number	Number	Number	String	): Creates a message for the exception.
org.joda.time.IllegalFieldValueException.createMessage	(	String	String	): Creates a message for the exception.
org.joda.time.IllegalFieldValueException.getDateTimeFieldType	(	): Returns the DateTimeFieldType whose value was invalid, or null if not applicable.
org.joda.time.IllegalFieldValueException.getDurationFieldType	(	): Returns the DurationFieldType whose value was invalid, or null if not applicable.
org.joda.time.IllegalFieldValueException.getFieldName	(	): Returns the name of the field whose value was invalid.
org.joda.time.IllegalFieldValueException.getIllegalNumberValue	(	): Returns the illegal integer value assigned to the field, or null if not applicable.
org.joda.time.IllegalFieldValueException.getIllegalStringValue	(	): Returns the illegal string value assigned to the field, or null if not applicable.
org.joda.time.IllegalFieldValueException.getIllegalValueAsString	(	): Returns the illegal value assigned to the field as a non-null string.
org.joda.time.IllegalFieldValueException.getLowerBound	(	): Returns the lower bound of the legal value range, or null if not applicable.
org.joda.time.IllegalFieldValueException.getUpperBound	(	): Returns the upper bound of the legal value range, or null if not applicable.
org.joda.time.IllegalFieldValueException.prependMessage	(	String	): Provide additional detail by prepending a message to the existing message. A colon is separator is automatically inserted between the messages.
org.joda.time.IllegalInstantException: Exception thrown when attempting to create an instant or date-time that cannot exist.  Classes like DateTime only store valid date-times. One of the cases where validity is important is handling daylight savings time (DST). In many places DST is used, where the local clock moves forward by an hour in spring and back by an hour in autumn/fall. This means that in spring, there is a "gap" where a local time does not exist.  This exception refers to this gap, and it means that your application tried to create a date-time inside the gap - a time that did not exist. Since Joda-Time objects must be valid, this is not allowed.  Possible solutions may be as follows: Use LocalDateTime, as all local date-times are valid. When converting a LocalDate to a DateTime, then use toDateTimeAsStartOfDay() as this handles and manages any gaps. When parsing, use parseLocalDateTime() if the string being parsed has no time-zone.
org.joda.time.IllegalInstantException.IllegalInstantException	(	String	): Constructor.
org.joda.time.IllegalInstantException.IllegalInstantException	(	long	String	): Constructor.
org.joda.time.IllegalInstantException.isIllegalInstant	(	Throwable	): Checks if the exception is, or has a cause, of IllegalInstantException.
org.joda.time.Instant: Instant is the standard implementation of a fully immutable instant in time.  Instant is an implementation of ReadableInstant. As with all instants, it represents an exact point on the time-line, but limited to the precision of milliseconds. An Instant should be used to represent a point in time irrespective of any other factor, such as chronology or time zone.  Internally, the class holds one piece of data, the instant as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.  For example, an Instant can be used to compare two DateTime objects irrespective of chronology or time zone.  boolean sameInstant = dt1.toInstant().equals(dt2.toInstant());  Note that the following code will also perform the same check:  boolean sameInstant = dt1.isEqual(dt2);   Instant is thread-safe and immutable.
org.joda.time.Instant.Instant	(	): Constructs an instance set to the current system millisecond time.
org.joda.time.Instant.Instant	(	Object	): Constructs an instance from an Object that represents a datetime.  The recognised object types are defined in ConverterManager and include String, Calendar and Date.
org.joda.time.Instant.Instant	(	long	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.
org.joda.time.Instant.getChronology	(	): Gets the chronology of the instant, which is ISO in the UTC zone.  This method returns getInstanceUTC() which corresponds to the definition of the Java epoch 1970-01-01T00:00:00Z.
org.joda.time.Instant.getMillis	(	): Gets the milliseconds of the instant.
org.joda.time.Instant.minus	(	ReadableDuration	): Gets a copy of this instant with the specified duration taken away.  If the amount is zero or null, then this is returned.
org.joda.time.Instant.minus	(	long	): Gets a copy of this instant with the specified duration taken away.  If the amount is zero or null, then this is returned.
org.joda.time.Instant.now	(	): Obtains an Instant set to the current system millisecond time.
org.joda.time.Instant.parse	(	String	): Parses an Instant from the specified string.  This uses dateTimeParser().
org.joda.time.Instant.parse	(	String	DateTimeFormatter	): Parses an Instant from the specified string using a formatter.
org.joda.time.Instant.plus	(	ReadableDuration	): Gets a copy of this instant with the specified duration added.  If the amount is zero or null, then this is returned.
org.joda.time.Instant.plus	(	long	): Gets a copy of this instant with the specified duration added.  If the amount is zero or null, then this is returned.
org.joda.time.Instant.toDateTime	(	): Get this object as a DateTime using ISOChronology in the default zone.  This method returns a DateTime object in the default zone. This differs from the similarly named method on DateTime, DateMidnight or MutableDateTime which retains the time zone. The difference is because Instant really represents a time without a zone, thus calling this method we really have no zone to 'retain' and hence expect to switch to the default zone.  This method definition preserves compatibility with earlier versions of Joda-Time.
org.joda.time.Instant.toDateTimeISO	(	): Get this object as a DateTime using ISOChronology in the default zone. This method is identical to toDateTime().  This method returns a DateTime object in the default zone. This differs from the similarly named method on DateTime, DateMidnight or MutableDateTime which retains the time zone. The difference is because Instant really represents a time without a zone, thus calling this method we really have no zone to 'retain' and hence expect to switch to the default zone.  This method is deprecated because it is a duplicate of toDateTime(). However, removing it would cause the superclass implementation to be used, which would create silent bugs in any caller depending on this implementation. As such, the method itself is not currently planned to be removed.  This method definition preserves compatibility with earlier versions of Joda-Time.
org.joda.time.Instant.toInstant	(	): Get this object as an Instant by returning this.
org.joda.time.Instant.toMutableDateTime	(	): Get this object as a MutableDateTime using ISOChronology in the default zone.  This method returns a MutableDateTime object in the default zone. This differs from the similarly named method on DateTime, DateMidnight or MutableDateTime which retains the time zone. The difference is because Instant really represents a time without a zone, thus calling this method we really have no zone to 'retain' and hence expect to switch to the default zone.  This method definition preserves compatibility with earlier versions of Joda-Time.
org.joda.time.Instant.toMutableDateTimeISO	(	): Get this object as a MutableDateTime using ISOChronology in the default zone. This method is identical to toMutableDateTime().  This method returns a MutableDateTime object in the default zone. This differs from the similarly named method on DateTime, DateMidnight or MutableDateTime which retains the time zone. The difference is because Instant really represents a time without a zone, thus calling this method we really have no zone to 'retain' and hence expect to switch to the default zone.  This method is deprecated because it is a duplicate of toMutableDateTime(). However, removing it would cause the superclass implementation to be used, which would create silent bugs in any caller depending on this implementation. As such, the method itself is not currently planned to be removed.  This method definition preserves compatibility with earlier versions of Joda-Time.
org.joda.time.Instant.withDurationAdded	(	ReadableDuration	int	): Gets a copy of this instant with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.Instant.withDurationAdded	(	long	int	): Gets a copy of this instant with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.Instant.withMillis	(	long	): Gets a copy of this instant with different millis.  The returned object will be either be a new Instant or this.  Note that this replaces the entire state of the Instant. To manage the sub-second part of the instant, use toDateTime() and withMillisOfSecond().
org.joda.time.Interval: Interval is the standard implementation of an immutable time interval.  A time interval represents a period of time between two instants. Intervals are inclusive of the start instant and exclusive of the end. The end instant is always greater than or equal to the start instant.  Intervals have a fixed millisecond duration. This is the difference between the start and end instants. The duration is represented separately by ReadableDuration. As a result, intervals are not comparable. To compare the length of two intervals, you should compare their durations.  An interval can also be converted to a ReadablePeriod. This represents the difference between the start and end points in terms of fields such as years and days.  Interval is thread-safe and immutable.
org.joda.time.Interval.Interval	(	Object	): Constructs a time interval by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInterval and String. The String formats are described by dateTimeParser() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.
org.joda.time.Interval.Interval	(	Object	Chronology	): Constructs a time interval by converting or copying from another object, overriding the chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInterval and String. The String formats are described by dateTimeParser() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.
org.joda.time.Interval.Interval	(	ReadableDuration	ReadableInstant	): Constructs an interval from a millisecond duration and an end instant.
org.joda.time.Interval.Interval	(	ReadableInstant	ReadableDuration	): Constructs an interval from a start instant and a duration.
org.joda.time.Interval.Interval	(	ReadableInstant	ReadableInstant	): Constructs an interval from a start and end instant.  The chronology used is that of the start instant.
org.joda.time.Interval.Interval	(	ReadableInstant	ReadablePeriod	): Constructs an interval from a start instant and a time period.  When forming the interval, the chronology from the instant is used if present, otherwise the chronology of the period is used.
org.joda.time.Interval.Interval	(	ReadablePeriod	ReadableInstant	): Constructs an interval from a time period and an end instant.  When forming the interval, the chronology from the instant is used if present, otherwise the chronology of the period is used.
org.joda.time.Interval.Interval	(	long	long	): Constructs an interval from a start and end instant with the ISO default chronology in the default time zone.
org.joda.time.Interval.Interval	(	long	long	Chronology	): Constructs an interval from a start and end instant with the specified chronology.
org.joda.time.Interval.Interval	(	long	long	DateTimeZone	): Constructs an interval from a start and end instant with the ISO default chronology in the specified time zone.
org.joda.time.Interval.abuts	(	ReadableInterval	): Does this interval abut with the interval specified.  Intervals are inclusive of the start instant and exclusive of the end. An interval abuts if it starts immediately after, or ends immediately before this interval without overlap. A zero duration interval abuts with itself.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The abuts state takes precedence over the other two, thus a zero duration interval at the start of a larger interval abuts and does not overlap.  For example:  [09:00 to 10:00) abuts [08:00 to 08:30) = false (completely before) [09:00 to 10:00) abuts [08:00 to 09:00) = true [09:00 to 10:00) abuts [08:00 to 09:01) = false (overlaps) [09:00 to 10:00) abuts [09:00 to 09:00) = true [09:00 to 10:00) abuts [09:00 to 09:01) = false (overlaps) [09:00 to 10:00) abuts [10:00 to 10:00) = true [09:00 to 10:00) abuts [10:00 to 10:30) = true [09:00 to 10:00) abuts [10:30 to 11:00) = false (completely after) [14:00 to 14:00) abuts [14:00 to 14:00) = true [14:00 to 14:00) abuts [14:00 to 15:00) = true [14:00 to 14:00) abuts [13:00 to 14:00) = true 
org.joda.time.Interval.gap	(	ReadableInterval	): Gets the gap between this interval and another interval. The other interval can be either before or after this interval.  Intervals are inclusive of the start instant and exclusive of the end. An interval has a gap to another interval if there is a non-zero duration between them. This method returns the amount of the gap only if the intervals do actually have a gap between them. If the intervals overlap or abut, then null is returned.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The abuts state takes precedence over the other two, thus a zero duration interval at the start of a larger interval abuts and does not overlap.  The chronology of the returned interval is the same as that of this interval (the chronology of the interval parameter is not used). Note that the use of the chronology was only correctly implemented in version 1.3.
org.joda.time.Interval.overlap	(	ReadableInterval	): Gets the overlap between this interval and another interval.  Intervals are inclusive of the start instant and exclusive of the end. An interval overlaps another if it shares some common part of the datetime continuum. This method returns the amount of the overlap, only if the intervals actually do overlap. If the intervals do not overlap, then null is returned.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The abuts state takes precedence over the other two, thus a zero duration interval at the start of a larger interval abuts and does not overlap.  The chronology of the returned interval is the same as that of this interval (the chronology of the interval parameter is not used). Note that the use of the chronology was only correctly implemented in version 1.3.
org.joda.time.Interval.parse	(	String	): Parses an Interval from the specified string.  The String formats are described by dateTimeParser() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.  This method operates by parsing in the default time-zone. Any offset contained within the string being parsed will be normalised to the offset of the default time-zone. See also parseWithOffset().
org.joda.time.Interval.parseWithOffset	(	String	): Parses an Interval from the specified string, using any offset it contains.  The String formats are described by dateTimeParser().withOffsetParsed() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.  Sometimes this method and new Interval(str) return different results. This can be confusing as the difference is not visible in toString().  When passed a string without an offset, such as '2010-06-30T01:20/P1D', both the constructor and this method use the default time-zone. As such, Interval.parseWithOffset("2010-06-30T01:20/P1D") and new Interval("2010-06-30T01:20/P1D")) are equal.  However, when this method is passed a string with an offset, the offset is directly parsed and stored. As such, Interval.parseWithOffset("2010-06-30T01:20+02:00/P1D") and new Interval("2010-06-30T01:20+02:00/P1D")) are NOT equal. The object produced via this method has a zone of DateTimeZone.forOffsetHours(2). The object produced via the constructor has a zone of DateTimeZone.getDefault().
org.joda.time.Interval.toInterval	(	): Get this interval as an immutable Interval object by returning this.
org.joda.time.Interval.withChronology	(	Chronology	): Creates a new interval with the same start and end, but a different chronology.
org.joda.time.Interval.withDurationAfterStart	(	ReadableDuration	): Creates a new interval with the specified duration after the start instant.
org.joda.time.Interval.withDurationBeforeEnd	(	ReadableDuration	): Creates a new interval with the specified duration before the end instant.
org.joda.time.Interval.withEnd	(	ReadableInstant	): Creates a new interval with the specified end instant.
org.joda.time.Interval.withEndMillis	(	long	): Creates a new interval with the specified end millisecond instant.
org.joda.time.Interval.withPeriodAfterStart	(	ReadablePeriod	): Creates a new interval with the specified period after the start instant.
org.joda.time.Interval.withPeriodBeforeEnd	(	ReadablePeriod	): Creates a new interval with the specified period before the end instant.
org.joda.time.Interval.withStart	(	ReadableInstant	): Creates a new interval with the specified start instant.
org.joda.time.Interval.withStartMillis	(	long	): Creates a new interval with the specified start millisecond instant.
org.joda.time.JodaTimePermission: JodaTimePermission is used for securing global method calls in the Joda-Time library. Since this class extends BasicPermission, asterisks may be used to denote wildcard permissions. The following permissions are supported:  DateTimeZone .setDefault Allows a default DateTimeZone to be set .setProvider Allows the DateTimeZone instance provider to be set .setNameProvider Allows the DateTimeZone name provider to be set ConverterManager .alterInstantConverters Allows an instant converter to be added or removed .alterPartialConverters Allows a partial converter to be added or removed .alterDurationConverters Allows a duration converter to be added or removed .alterPeriodConverters Allows a period converter to be added or removed .alterIntervalConverters Allows an interval converter to be added or removed CurrentTime.setProvider Allows the current time provider to be set   JodaTimePermission is thread-safe and immutable.
org.joda.time.JodaTimePermission.JodaTimePermission	(	String	): Constructs a new permission object.
org.joda.time.LocalDate: LocalDate is an immutable datetime class representing a date without a time zone.  LocalDate implements the ReadablePartial interface. To do this, the interface methods focus on the key fields - Year, MonthOfYear and DayOfMonth. However, all date fields may in fact be queried.  LocalDate differs from DateMidnight in that this class does not have a time zone and does not represent a single instant in time.  Calculations on LocalDate are performed using a Chronology. This chronology will be set internally to be in the UTC time zone for all calculations. Each individual field can be queried in two ways:  getMonthOfYear() monthOfYear().get()  The second technique also provides access to other useful methods on the field:  numeric value text value short text value maximum/minimum values add/subtract set rounding   LocalDate is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.LocalDate.LocalDate	(	): Constructs an instance set to the current local time evaluated using ISO chronology in the default zone.  Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDate.LocalDate	(	Chronology	): Constructs an instance set to the current local time evaluated using specified chronology.  If the chronology is null, ISO chronology in the default time zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDate.LocalDate	(	DateTimeZone	): Constructs an instance set to the current local time evaluated using ISO chronology in the specified zone.  If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDate.LocalDate	(	Object	): Constructs an instance from an Object that represents a datetime. The time zone will be retrieved from the object if possible, otherwise the default time zone will be used.  If the object contains no chronology, ISOChronology is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalDate.LocalDate	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology.  If the chronology is null, ISO in the default time zone is used. Once the constructor is completed, the zone is no longer used. If the instant contains a chronology, it will be ignored. For example, passing a LocalDate and a different chronology will return a date with the year/month/day from the date applied unaltered to the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalDate.LocalDate	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified.  If the object contains no chronology, ISOChronology is used. If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalDate.LocalDate	(	int	int	int	): Constructs an instance set to the specified date and time using ISOChronology.
org.joda.time.LocalDate.LocalDate	(	int	int	int	Chronology	): Constructs an instance set to the specified date and time using the specified chronology, whose zone is ignored.  If the chronology is null, ISOChronology is used.
org.joda.time.LocalDate.LocalDate	(	long	): Constructs an instance set to the local time defined by the specified instant evaluated using ISO chronology in the default zone.  Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDate.LocalDate	(	long	Chronology	): Constructs an instance set to the local time defined by the specified instant evaluated using the specified chronology.  If the chronology is null, ISO chronology in the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDate.LocalDate	(	long	DateTimeZone	): Constructs an instance set to the local time defined by the specified instant evaluated using ISO chronology in the specified zone.  If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDate.Property: LocalDate.Property binds a LocalDate to a DateTimeField allowing powerful datetime functionality to be easily accessed.  The simplest use of this class is as an alternative get method, here used to get the year '1972' (as an int) and the month 'December' (as a String).  LocalDate dt = new LocalDate(1972, 12, 3, 0, 0); int year = dt.year().get(); String monthStr = dt.month().getAsText();   Methods are also provided that allow date modification. These return new instances of LocalDate - they do not modify the original. The example below yields two independent immutable date objects 20 years apart.  LocalDate dt = new LocalDate(1972, 12, 3); LocalDate dt1920 = dt.year().setCopy(1920);   LocalDate.Property itself is thread-safe and immutable, as well as the LocalDate being operated on.
org.joda.time.LocalDate.Property.Property	(	LocalDate	DateTimeField	): Constructor.
org.joda.time.LocalDate.Property.addToCopy	(	int	): Adds to this field in a copy of this LocalDate.  The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.addWrapFieldToCopy	(	int	): Adds to this field, possibly wrapped, in a copy of this LocalDate. A field wrapped operation only changes this field. Thus 31st January addWrapField one day goes to the 1st January.  The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.getChronology	(	): Gets the chronology of the datetime that this property is linked to.
org.joda.time.LocalDate.Property.getField	(	): Gets the field being used.
org.joda.time.LocalDate.Property.getLocalDate	(	): Gets the LocalDate object linked to this property.
org.joda.time.LocalDate.Property.getMillis	(	): Gets the milliseconds of the date that this property is linked to.
org.joda.time.LocalDate.Property.readObject	(	ObjectInputStream	): Reads the property from a safe serialization format.
org.joda.time.LocalDate.Property.roundCeilingCopy	(	): Rounds to the highest whole unit of this field on a copy of this LocalDate.  For example, rounding floor on the hourOfDay field of a LocalDate where the time is 10:30 would result in new LocalDate with the time of 11:00.
org.joda.time.LocalDate.Property.roundFloorCopy	(	): Rounds to the lowest whole unit of this field on a copy of this LocalDate.  For example, rounding floor on the hourOfDay field of a LocalDate where the time is 10:30 would result in new LocalDate with the time of 10:00.
org.joda.time.LocalDate.Property.roundHalfCeilingCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalDate, favoring the ceiling if halfway.
org.joda.time.LocalDate.Property.roundHalfEvenCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalDate. If halfway, the ceiling is favored over the floor only if it makes this field's value even.
org.joda.time.LocalDate.Property.roundHalfFloorCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalDate, favoring the floor if halfway.
org.joda.time.LocalDate.Property.setCopy	(	String	): Sets this field in a copy of the LocalDate to a parsed text value.  The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.setCopy	(	String	Locale	): Sets this field in a copy of the LocalDate to a parsed text value.  The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.setCopy	(	int	): Sets this field in a copy of the LocalDate.  The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.withMaximumValue	(	): Returns a new LocalDate with this field set to the maximum value for this field.  This operation is useful for obtaining a LocalDate on the last day of the month, as month lengths vary.  LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();   The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.withMinimumValue	(	): Returns a new LocalDate with this field set to the minimum value for this field.  The LocalDate attached to this property is unchanged by this call.
org.joda.time.LocalDate.Property.writeObject	(	ObjectOutputStream	): Writes the property in a safe serialization format.
org.joda.time.LocalDate.centuryOfEra	(	): Get the century of era property which provides access to advanced functionality.
org.joda.time.LocalDate.compareTo	(	ReadablePartial	): Compares this partial with another returning an integer indicating the order.  The fields are compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.  The specified object must be a partial instance whose field types match those of this partial.
org.joda.time.LocalDate.dayOfMonth	(	): Get the day of month property which provides access to advanced functionality.
org.joda.time.LocalDate.dayOfWeek	(	): Get the day of week property which provides access to advanced functionality.
org.joda.time.LocalDate.dayOfYear	(	): Get the day of year property which provides access to advanced functionality.
org.joda.time.LocalDate.equals	(	Object	): Compares this ReadablePartial with another returning true if the chronology, field types and values are equal.
org.joda.time.LocalDate.era	(	): Get the era property which provides access to advanced functionality.
org.joda.time.LocalDate.fromCalendarFields	(	Calendar	): Constructs a LocalDate from a java.util.Calendar using exactly the same field values.  Each field is queried from the Calendar and assigned to the LocalDate. This is useful if you have been using the Calendar as a local date, ignoring the zone.  One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data.  This factory method ignores the type of the calendar and always creates a LocalDate with ISO chronology. It is expected that you will only pass in instances of GregorianCalendar however this is not validated.
org.joda.time.LocalDate.fromDateFields	(	Date	): Constructs a LocalDate from a java.util.Date using exactly the same field values.  Each field is queried from the Date and assigned to the LocalDate. This is useful if you have been using the Date as a local date, ignoring the zone.  One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data.  This factory method always creates a LocalDate with ISO chronology.
org.joda.time.LocalDate.get	(	DateTimeFieldType	): Get the value of one of the fields of a datetime.  This method gets the value of the specified field. For example:  LocalDate dt = LocalDate.nowDefaultZone(); int year = dt.get(DateTimeFieldType.year()); 
org.joda.time.LocalDate.getCenturyOfEra	(	): Get the year of era field value.
org.joda.time.LocalDate.getChronology	(	): Gets the chronology of the date.
org.joda.time.LocalDate.getDayOfMonth	(	): Get the day of month field value.  The values for the day of month are defined in org.joda.time.DateTimeConstants.
org.joda.time.LocalDate.getDayOfWeek	(	): Get the day of week field value.  The values for the day of week are defined in org.joda.time.DateTimeConstants.
org.joda.time.LocalDate.getDayOfYear	(	): Get the day of year field value.
org.joda.time.LocalDate.getEra	(	): Get the era field value.
org.joda.time.LocalDate.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.LocalDate.getLocalMillis	(	): Gets the local milliseconds from the Java epoch of 1970-01-01T00:00:00 (not fixed to any specific time zone).
org.joda.time.LocalDate.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.LocalDate.getValue	(	int	): Gets the value of the field at the specified index.  This method is required to support the ReadablePartial interface. The supported fields are Year, MonthOfYear and DayOfMonth. Note that all fields from day and above may in fact be queried via other methods.
org.joda.time.LocalDate.getWeekOfWeekyear	(	): Get the week of weekyear field value.  This field is associated with the "weekyear" via getWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.
org.joda.time.LocalDate.getWeekyear	(	): Get the weekyear field value.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.
org.joda.time.LocalDate.getYear	(	): Get the year field value.
org.joda.time.LocalDate.getYearOfCentury	(	): Get the year of century field value.
org.joda.time.LocalDate.getYearOfEra	(	): Get the year of era field value.
org.joda.time.LocalDate.hashCode	(	): Gets a hash code for the instant as defined in ReadablePartial.
org.joda.time.LocalDate.isSupported	(	DateTimeFieldType	): Checks if the field type specified is supported by this local date and chronology. This can be used to avoid exceptions in get().
org.joda.time.LocalDate.isSupported	(	DurationFieldType	): Checks if the duration type specified is supported by this local date and chronology.
org.joda.time.LocalDate.minus	(	ReadablePeriod	): Returns a copy of this date with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusYears().  Unsupported time fields are ignored, thus subtracting a period of 24 hours will not have any effect.
org.joda.time.LocalDate.minusDays	(	int	): Returns a copy of this date minus the specified number of days.  This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate subtracted = dt.minusDays(6); LocalDate subtracted = dt.minus(Period.days(6)); LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6); 
org.joda.time.LocalDate.minusMonths	(	int	): Returns a copy of this date minus the specified number of months.  This subtracts the specified number of months from the date. The subtraction may change the year, but the day-of-month is normally unchanged. If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month. This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate subtracted = dt.minusMonths(6); LocalDate subtracted = dt.minus(Period.months(6)); LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6); 
org.joda.time.LocalDate.minusWeeks	(	int	): Returns a copy of this date minus the specified number of weeks.  This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate subtracted = dt.minusWeeks(6); LocalDate subtracted = dt.minus(Period.weeks(6)); LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6); 
org.joda.time.LocalDate.minusYears	(	int	): Returns a copy of this date minus the specified number of years.  This subtracts the specified number of years from the date. If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month. This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate subtracted = dt.minusYears(6); LocalDate subtracted = dt.minus(Period.years(6)); LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6); 
org.joda.time.LocalDate.monthOfYear	(	): Get the month of year property which provides access to advanced functionality.
org.joda.time.LocalDate.now	(	): Obtains a LocalDate set to the current system millisecond time using ISOChronology in the default time zone.
org.joda.time.LocalDate.now	(	Chronology	): Obtains a LocalDate set to the current system millisecond time using the specified chronology.
org.joda.time.LocalDate.now	(	DateTimeZone	): Obtains a LocalDate set to the current system millisecond time using ISOChronology in the specified time zone.
org.joda.time.LocalDate.parse	(	String	): Parses a LocalDate from the specified string.  This uses localDateParser().
org.joda.time.LocalDate.parse	(	String	DateTimeFormatter	): Parses a LocalDate from the specified string using a formatter.
org.joda.time.LocalDate.plus	(	ReadablePeriod	): Returns a copy of this date with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusYears().  Unsupported time fields are ignored, thus adding a period of 24 hours will not have any effect.
org.joda.time.LocalDate.plusDays	(	int	): Returns a copy of this date plus the specified number of days.  This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate added = dt.plusDays(6); LocalDate added = dt.plus(Period.days(6)); LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6); 
org.joda.time.LocalDate.plusMonths	(	int	): Returns a copy of this date plus the specified number of months.  This adds the specified number of months to the date. The addition may change the year, but the day-of-month is normally unchanged. If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month. This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate added = dt.plusMonths(6); LocalDate added = dt.plus(Period.months(6)); LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6); 
org.joda.time.LocalDate.plusWeeks	(	int	): Returns a copy of this date plus the specified number of weeks.  This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate added = dt.plusWeeks(6); LocalDate added = dt.plus(Period.weeks(6)); LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6); 
org.joda.time.LocalDate.plusYears	(	int	): Returns a copy of this date plus the specified number of years.  This adds the specified number of years to the date. If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month. This LocalDate instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDate added = dt.plusYears(6); LocalDate added = dt.plus(Period.years(6)); LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6); 
org.joda.time.LocalDate.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.LocalDate.readResolve	(	): Handle broken serialization from other tools.
org.joda.time.LocalDate.size	(	): Gets the number of fields in this partial, which is three. The supported fields are Year, MonthOfYear and DayOfMonth. Note that all fields from day and above may in fact be queried via other methods.
org.joda.time.LocalDate.toDate	(	): Get the date time as a java.util.Date.  The Date object created has exactly the same year, month and day as this date. The time will be set to the earliest valid time for that date.  Converting to a JDK Date is full of complications as the JDK Date constructor doesn't behave as you might expect around DST transitions. This method works by taking a first guess and then adjusting the JDK date until it has the earliest valid instant. This also handles the situation where the JDK time zone data differs from the Joda-Time time zone data.
org.joda.time.LocalDate.toDateMidnight	(	): Converts this LocalDate to a DateMidnight in the default time zone.  As from v1.5, you are recommended to avoid DateMidnight and use toDateTimeAtStartOfDay() instead because of the exception detailed below.  This method will throw an exception if the default time zone switches to Daylight Savings Time at midnight and this LocalDate represents that switchover date. The problem is that there is no such time as midnight on the required date, and as such an exception is thrown.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateMidnight	(	DateTimeZone	): Converts this LocalDate to a DateMidnight.  As from v1.5, you are recommended to avoid DateMidnight and use toDateTimeAtStartOfDay() instead because of the exception detailed below.  This method will throw an exception if the time zone switches to Daylight Savings Time at midnight and this LocalDate represents that switchover date. The problem is that there is no such time as midnight on the required date, and as such an exception is thrown.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTime	(	LocalTime	): Converts this object to a DateTime using a LocalTime to fill in the missing fields and using the default time zone.  The resulting chronology is determined by the chronology of this LocalDate. The chronology of the time must match.  If the time is null, this method delegates to toDateTimeAtCurrentTime() and the following documentation does not apply.  When the time zone is applied, the local date-time may be affected by daylight saving. In a daylight saving gap, when the local time does not exist, this method will throw an exception. In a daylight saving overlap, when the same local time occurs twice, this method returns the first occurrence of the local time.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTime	(	LocalTime	DateTimeZone	): Converts this object to a DateTime using a LocalTime to fill in the missing fields.  The resulting chronology is determined by the chronology of this LocalDate plus the time zone. The chronology of the time must match.  If the time is null, this method delegates to toDateTimeAtCurrentTime() and the following documentation does not apply.  When the time zone is applied, the local date-time may be affected by daylight saving. In a daylight saving gap, when the local time does not exist, this method will throw an exception. In a daylight saving overlap, when the same local time occurs twice, this method returns the first occurrence of the local time.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTimeAtCurrentTime	(	): Converts this LocalDate to a full datetime using the default time zone setting the date fields from this instance and the time fields from the current time.  This method will throw an exception if the datetime that would be created does not exist when the time zone is taken into account.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTimeAtCurrentTime	(	DateTimeZone	): Converts this LocalDate to a full datetime using the specified time zone setting the date fields from this instance and the time fields from the current time.  This method uses the chronology from this instance plus the time zone specified.  This method will throw an exception if the datetime that would be created does not exist when the time zone is taken into account.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTimeAtMidnight	(	): Converts this LocalDate to a full datetime at midnight using the default time zone.  This method will throw an exception if the default time zone switches to Daylight Savings Time at midnight and this LocalDate represents that switchover date. The problem is that there is no such time as midnight on the required date, and as such an exception is thrown.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTimeAtMidnight	(	DateTimeZone	): Converts this LocalDate to a full datetime at midnight using the specified time zone.  This method will throw an exception if the time zone switches to Daylight Savings Time at midnight and this LocalDate represents that switchover date. The problem is that there is no such time as midnight on the required date, and as such an exception is thrown.  This method uses the chronology from this instance plus the time zone specified.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTimeAtStartOfDay	(	): Converts this LocalDate to a full datetime at the earliest valid time for the date using the default time zone.  The time will normally be midnight, as that is the earliest time on any given day. However, in some time zones when Daylight Savings Time starts, there is no midnight because time jumps from 11:59 to 01:00. This method handles that situation by returning 01:00 on that date.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toDateTimeAtStartOfDay	(	DateTimeZone	): Converts this LocalDate to a full datetime at the earliest valid time for the date using the specified time zone.  The time will normally be midnight, as that is the earliest time on any given day. However, in some time zones when Daylight Savings Time starts, there is no midnight because time jumps from 11:59 to 01:00. This method handles that situation by returning 01:00 on that date.  This method uses the chronology from this instance plus the time zone specified.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toInterval	(	): Converts this object to an Interval representing the whole day in the default time zone.  The interval may have more or less than 24 hours if this is a daylight savings cutover date.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toInterval	(	DateTimeZone	): Converts this object to an Interval representing the whole day.  The interval may have more or less than 24 hours if this is a daylight savings cutover date.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toLocalDateTime	(	LocalTime	): Converts this object to a LocalDateTime using a LocalTime to fill in the missing fields.  The resulting chronology is determined by the chronology of this LocalDate. The chronology of the time must also match. If the time is null an exception is thrown.  This instance is immutable and unaffected by this method call.
org.joda.time.LocalDate.toString	(	): Output the date time in ISO8601 format (yyyy-MM-dd).
org.joda.time.LocalDate.toString	(	String	): Output the date using the specified format pattern.
org.joda.time.LocalDate.toString	(	String	Locale	): Output the date using the specified format pattern.
org.joda.time.LocalDate.weekOfWeekyear	(	): Get the week of a week based year property which provides access to advanced functionality.
org.joda.time.LocalDate.weekyear	(	): Get the weekyear property which provides access to advanced functionality.
org.joda.time.LocalDate.withCenturyOfEra	(	int	): Returns a copy of this date with the century of era field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
org.joda.time.LocalDate.withDayOfMonth	(	int	): Returns a copy of this date with the day of month field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of month changed.
org.joda.time.LocalDate.withDayOfWeek	(	int	): Returns a copy of this date with the day of week field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of week changed.
org.joda.time.LocalDate.withDayOfYear	(	int	): Returns a copy of this date with the day of year field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of year changed.
org.joda.time.LocalDate.withEra	(	int	): Returns a copy of this date with the era field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of era changed.
org.joda.time.LocalDate.withField	(	DateTimeFieldType	int	): Returns a copy of this date with the specified field set to a new value.  For example, if the field type is monthOfYear then the month of year field will be changed in the returned instance. If the field type is null, then this is returned.  These two lines are equivalent:  LocalDate updated = dt.withDayOfMonth(6); LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6); 
org.joda.time.LocalDate.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this date with the value of the specified field increased.  If the addition is zero or the field is null, then this is returned.  These three lines are equivalent:  LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6); LocalDate added = dt.plusYears(6); LocalDate added = dt.plus(Period.years(6)); 
org.joda.time.LocalDate.withFields	(	ReadablePartial	): Returns a copy of this date with the partial set of fields replacing those from this instance.  For example, if the partial contains a year and a month then those two fields will be changed in the returned instance. Unsupported fields are ignored. If the partial is null, then this is returned.
org.joda.time.LocalDate.withLocalMillis	(	long	): Returns a copy of this date with different local millis.  The returned object will be a new instance of the same type. Only the millis will change, the chronology is kept. The returned object will be either be a new instance or this.
org.joda.time.LocalDate.withMonthOfYear	(	int	): Returns a copy of this date with the month of year field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.LocalDate.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this date with the specified period added.  If the addition is zero, then this is returned.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusYears().  Unsupported time fields are ignored, thus adding a period of 24 hours will not have any effect.
org.joda.time.LocalDate.withWeekOfWeekyear	(	int	): Returns a copy of this date with the week of weekyear field updated.  This field is associated with the "weekyear" via withWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of week of weekyear changed.
org.joda.time.LocalDate.withWeekyear	(	int	): Returns a copy of this date with the weekyear field updated.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of weekyear changed.
org.joda.time.LocalDate.withYear	(	int	): Returns a copy of this date with the year field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year changed.
org.joda.time.LocalDate.withYearOfCentury	(	int	): Returns a copy of this date with the year of century field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of century changed.
org.joda.time.LocalDate.withYearOfEra	(	int	): Returns a copy of this date with the year of era field updated.  LocalDate is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of era changed.
org.joda.time.LocalDate.year	(	): Get the year property which provides access to advanced functionality.
org.joda.time.LocalDate.yearOfCentury	(	): Get the year of century property which provides access to advanced functionality.
org.joda.time.LocalDate.yearOfEra	(	): Get the year of era property which provides access to advanced functionality.
org.joda.time.LocalDateTime: LocalDateTime is an unmodifiable datetime class representing a datetime without a time zone.  LocalDateTime implements the ReadablePartial interface. To do this, certain methods focus on key fields Year, MonthOfYear, DayOfYear and MillisOfDay. However, all fields may in fact be queried.  Internally, LocalDateTime uses a single millisecond-based value to represent the local datetime. This value is only used internally and is not exposed to applications.  Calculations on LocalDateTime are performed using a Chronology. This chronology will be set internally to be in the UTC time zone for all calculations. Each individual field can be queried in two ways:  getHourOfDay() hourOfDay().get()  The second technique also provides access to other useful methods on the field:  numeric value text value short text value maximum/minimum values add/subtract set rounding   LocalDateTime is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.LocalDateTime.LocalDateTime	(	): Constructs an instance set to the current local time evaluated using ISO chronology in the default zone.  Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDateTime.LocalDateTime	(	Chronology	): Constructs an instance set to the current local time evaluated using specified chronology.  If the chronology is null, ISO chronology in the default time zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDateTime.LocalDateTime	(	DateTimeZone	): Constructs an instance set to the current local time evaluated using ISO chronology in the specified zone.  If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDateTime.LocalDateTime	(	Object	): Constructs an instance from an Object that represents a datetime.  If the object contains no chronology, ISOChronology is used. If the object contains no time zone, the default zone is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localDateOptionalTimeParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalDateTime.LocalDateTime	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology.  If the chronology is null, ISO in the default time zone is used. Once the constructor is completed, the zone is no longer used. If the instant contains a chronology, it will be ignored. For example, passing a LocalDate and a different chronology will return a date with the year/month/day from the date applied unaltered to the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localDateOptionalTimeParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalDateTime.LocalDateTime	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified.  If the object contains no chronology, ISOChronology is used. If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localDateOptionalTimeParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalDateTime.LocalDateTime	(	int	int	int	int	int	): Constructs an instance set to the specified date and time using ISOChronology.
org.joda.time.LocalDateTime.LocalDateTime	(	int	int	int	int	int	int	): Constructs an instance set to the specified date and time using ISOChronology.
org.joda.time.LocalDateTime.LocalDateTime	(	int	int	int	int	int	int	int	): Constructs an instance set to the specified date and time using ISOChronology.
org.joda.time.LocalDateTime.LocalDateTime	(	int	int	int	int	int	int	int	Chronology	): Constructs an instance set to the specified date and time using the specified chronology, whose zone is ignored.  If the chronology is null, ISOChronology is used.
org.joda.time.LocalDateTime.LocalDateTime	(	long	): Constructs an instance set to the local time defined by the specified instant evaluated using ISO chronology in the default zone.  Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDateTime.LocalDateTime	(	long	Chronology	): Constructs an instance set to the local time defined by the specified instant evaluated using the specified chronology.  If the chronology is null, ISO chronology in the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDateTime.LocalDateTime	(	long	DateTimeZone	): Constructs an instance set to the local time defined by the specified instant evaluated using ISO chronology in the specified zone.  If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalDateTime.Property: LocalDateTime.Property binds a LocalDateTime to a DateTimeField allowing powerful datetime functionality to be easily accessed.  The simplest use of this class is as an alternative get method, here used to get the year '1972' (as an int) and the month 'December' (as a String).  LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0); int year = dt.year().get(); String monthStr = dt.month().getAsText();   Methods are also provided that allow date modification. These return new instances of LocalDateTime - they do not modify the original. The example below yields two independent immutable date objects 20 years apart.  LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0); LocalDateTime dt1920 = dt.year().setCopy(1920);   LocalDateTime.Property itself is thread-safe and immutable, as well as the LocalDateTime being operated on.
org.joda.time.LocalDateTime.Property.Property	(	LocalDateTime	DateTimeField	): Constructor.
org.joda.time.LocalDateTime.Property.addToCopy	(	int	): Adds to this field in a copy of this LocalDateTime.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.addToCopy	(	long	): Adds to this field in a copy of this LocalDateTime.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.addWrapFieldToCopy	(	int	): Adds to this field, possibly wrapped, in a copy of this LocalDateTime. A field wrapped operation only changes this field. Thus 31st January addWrapField one day goes to the 1st January.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.getChronology	(	): Gets the chronology of the datetime that this property is linked to.
org.joda.time.LocalDateTime.Property.getField	(	): Gets the field being used.
org.joda.time.LocalDateTime.Property.getLocalDateTime	(	): Gets the LocalDateTime object linked to this property.
org.joda.time.LocalDateTime.Property.getMillis	(	): Gets the milliseconds of the datetime that this property is linked to.
org.joda.time.LocalDateTime.Property.readObject	(	ObjectInputStream	): Reads the property from a safe serialization format.
org.joda.time.LocalDateTime.Property.roundCeilingCopy	(	): Rounds to the highest whole unit of this field on a copy of this LocalDateTime.  For example, rounding floor on the hourOfDay field of a LocalDateTime where the time is 10:30 would result in new LocalDateTime with the time of 11:00.
org.joda.time.LocalDateTime.Property.roundFloorCopy	(	): Rounds to the lowest whole unit of this field on a copy of this LocalDateTime.  For example, rounding floor on the hourOfDay field of a LocalDateTime where the time is 10:30 would result in new LocalDateTime with the time of 10:00.
org.joda.time.LocalDateTime.Property.roundHalfCeilingCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalDateTime, favoring the ceiling if halfway.
org.joda.time.LocalDateTime.Property.roundHalfEvenCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalDateTime. If halfway, the ceiling is favored over the floor only if it makes this field's value even.
org.joda.time.LocalDateTime.Property.roundHalfFloorCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalDateTime, favoring the floor if halfway.
org.joda.time.LocalDateTime.Property.setCopy	(	String	): Sets this field in a copy of the LocalDateTime to a parsed text value.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.setCopy	(	String	Locale	): Sets this field in a copy of the LocalDateTime to a parsed text value.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.setCopy	(	int	): Sets this field in a copy of the LocalDateTime.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.withMaximumValue	(	): Returns a new LocalDateTime with this field set to the maximum value for this field.  This operation is useful for obtaining a LocalDateTime on the last day of the month, as month lengths vary.  LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();   The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.withMinimumValue	(	): Returns a new LocalDateTime with this field set to the minimum value for this field.  The LocalDateTime attached to this property is unchanged by this call.
org.joda.time.LocalDateTime.Property.writeObject	(	ObjectOutputStream	): Writes the property in a safe serialization format.
org.joda.time.LocalDateTime.centuryOfEra	(	): Get the century of era property which provides access to advanced functionality.
org.joda.time.LocalDateTime.compareTo	(	ReadablePartial	): Compares this partial with another returning an integer indicating the order.  The fields are compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.  The specified object must be a partial instance whose field types match those of this partial.
org.joda.time.LocalDateTime.correctDstTransition	(	Date	TimeZone	): Correct date in case of DST overlap.  The Date object created has exactly the same fields as this date-time, except when the time would be invalid due to a daylight savings gap. In that case, the time will be set to the earliest valid time after the gap.  In the case of a daylight savings overlap, the earlier instant is selected.  Converting to a JDK Date is full of complications as the JDK Date constructor doesn't behave as you might expect around DST transitions. This method works by taking a first guess and then adjusting. This also handles the situation where the JDK time zone data differs from the Joda-Time time zone data.
org.joda.time.LocalDateTime.dayOfMonth	(	): Get the day of month property which provides access to advanced functionality.
org.joda.time.LocalDateTime.dayOfWeek	(	): Get the day of week property which provides access to advanced functionality.
org.joda.time.LocalDateTime.dayOfYear	(	): Get the day of year property which provides access to advanced functionality.
org.joda.time.LocalDateTime.equals	(	Object	): Compares this ReadablePartial with another returning true if the chronology, field types and values are equal.
org.joda.time.LocalDateTime.era	(	): Get the era property which provides access to advanced functionality.
org.joda.time.LocalDateTime.fromCalendarFields	(	Calendar	): Constructs a LocalDateTime from a java.util.Calendar using exactly the same field values.  Each field is queried from the Calendar and assigned to the LocalDateTime. This is useful if you have been using the Calendar as a local date, ignoring the zone.  One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data.  This factory method ignores the type of the calendar and always creates a LocalDateTime with ISO chronology. It is expected that you will only pass in instances of GregorianCalendar however this is not validated.
org.joda.time.LocalDateTime.fromDateFields	(	Date	): Constructs a LocalDateTime from a java.util.Date using exactly the same field values.  Each field is queried from the Date and assigned to the LocalDateTime. This is useful if you have been using the Date as a local date, ignoring the zone.  One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data.  This factory method always creates a LocalDateTime with ISO chronology.
org.joda.time.LocalDateTime.get	(	DateTimeFieldType	): Get the value of one of the fields of a datetime.  This method gets the value of the specified field. For example:  DateTime dt = new DateTime(); int year = dt.get(DateTimeFieldType.year()); 
org.joda.time.LocalDateTime.getCenturyOfEra	(	): Get the year of era field value.
org.joda.time.LocalDateTime.getChronology	(	): Gets the chronology of the datetime.
org.joda.time.LocalDateTime.getDayOfMonth	(	): Get the day of month field value.  The values for the day of month are defined in org.joda.time.DateTimeConstants.
org.joda.time.LocalDateTime.getDayOfWeek	(	): Get the day of week field value.  The values for the day of week are defined in org.joda.time.DateTimeConstants.
org.joda.time.LocalDateTime.getDayOfYear	(	): Get the day of year field value.
org.joda.time.LocalDateTime.getEra	(	): Get the era field value.
org.joda.time.LocalDateTime.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.LocalDateTime.getHourOfDay	(	): Get the hour of day field value.
org.joda.time.LocalDateTime.getLocalMillis	(	): Gets the milliseconds of the datetime instant from the Java epoch of 1970-01-01T00:00:00 (not fixed to any specific time zone).
org.joda.time.LocalDateTime.getMillisOfDay	(	): Get the millis of day field value.
org.joda.time.LocalDateTime.getMillisOfSecond	(	): Get the millis of second field value.
org.joda.time.LocalDateTime.getMinuteOfHour	(	): Get the minute of hour field value.
org.joda.time.LocalDateTime.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.LocalDateTime.getSecondOfMinute	(	): Get the second of minute field value.
org.joda.time.LocalDateTime.getValue	(	int	): Gets the value of the field at the specified index.  This method is required to support the ReadablePartial interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
org.joda.time.LocalDateTime.getWeekOfWeekyear	(	): Get the week of weekyear field value.  This field is associated with the "weekyear" via getWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.
org.joda.time.LocalDateTime.getWeekyear	(	): Get the weekyear field value.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.
org.joda.time.LocalDateTime.getYear	(	): Get the year field value.
org.joda.time.LocalDateTime.getYearOfCentury	(	): Get the year of century field value.
org.joda.time.LocalDateTime.getYearOfEra	(	): Get the year of era field value.
org.joda.time.LocalDateTime.hourOfDay	(	): Get the hour of day field property which provides access to advanced functionality.
org.joda.time.LocalDateTime.isSupported	(	DateTimeFieldType	): Checks if the field type specified is supported by this local datetime and chronology. This can be used to avoid exceptions in get().
org.joda.time.LocalDateTime.isSupported	(	DurationFieldType	): Checks if the duration type specified is supported by this local datetime and chronology.
org.joda.time.LocalDateTime.millisOfDay	(	): Get the millis of day property which provides access to advanced functionality.
org.joda.time.LocalDateTime.millisOfSecond	(	): Get the millis of second property which provides access to advanced functionality.
org.joda.time.LocalDateTime.minus	(	ReadableDuration	): Returns a copy of this datetime with the specified duration taken away.  If the amount is zero or null, then this is returned.
org.joda.time.LocalDateTime.minus	(	ReadablePeriod	): Returns a copy of this datetime with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusYears().
org.joda.time.LocalDateTime.minusDays	(	int	): Returns a copy of this datetime minus the specified number of days.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusDays(6); LocalDateTime subtracted = dt.minus(Period.days(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6); 
org.joda.time.LocalDateTime.minusHours	(	int	): Returns a copy of this datetime minus the specified number of hours.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusHours(6); LocalDateTime subtracted = dt.minus(Period.hours(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6); 
org.joda.time.LocalDateTime.minusMillis	(	int	): Returns a copy of this datetime minus the specified number of millis.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusMillis(6); LocalDateTime subtracted = dt.minus(Period.millis(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6); 
org.joda.time.LocalDateTime.minusMinutes	(	int	): Returns a copy of this datetime minus the specified number of minutes.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusMinutes(6); LocalDateTime subtracted = dt.minus(Period.minutes(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6); 
org.joda.time.LocalDateTime.minusMonths	(	int	): Returns a copy of this datetime minus the specified number of months.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusMonths(6); LocalDateTime subtracted = dt.minus(Period.months(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6); 
org.joda.time.LocalDateTime.minusSeconds	(	int	): Returns a copy of this datetime minus the specified number of seconds.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusSeconds(6); LocalDateTime subtracted = dt.minus(Period.seconds(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6); 
org.joda.time.LocalDateTime.minusWeeks	(	int	): Returns a copy of this datetime minus the specified number of weeks.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusWeeks(6); LocalDateTime subtracted = dt.minus(Period.weeks(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6); 
org.joda.time.LocalDateTime.minusYears	(	int	): Returns a copy of this datetime minus the specified number of years.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime subtracted = dt.minusYears(6); LocalDateTime subtracted = dt.minus(Period.years(6)); LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6); 
org.joda.time.LocalDateTime.minuteOfHour	(	): Get the minute of hour field property which provides access to advanced functionality.
org.joda.time.LocalDateTime.monthOfYear	(	): Get the month of year property which provides access to advanced functionality.
org.joda.time.LocalDateTime.now	(	): Obtains a LocalDateTime set to the current system millisecond time using ISOChronology in the default time zone. The resulting object does not use the zone.
org.joda.time.LocalDateTime.now	(	Chronology	): Obtains a LocalDateTime set to the current system millisecond time using the specified chronology. The resulting object does not use the zone.
org.joda.time.LocalDateTime.now	(	DateTimeZone	): Obtains a LocalDateTime set to the current system millisecond time using ISOChronology in the specified time zone. The resulting object does not use the zone.
org.joda.time.LocalDateTime.parse	(	String	): Parses a LocalDateTime from the specified string.  This uses localDateOptionalTimeParser().
org.joda.time.LocalDateTime.parse	(	String	DateTimeFormatter	): Parses a LocalDateTime from the specified string using a formatter.
org.joda.time.LocalDateTime.plus	(	ReadableDuration	): Returns a copy of this datetime with the specified duration added.  If the amount is zero or null, then this is returned.
org.joda.time.LocalDateTime.plus	(	ReadablePeriod	): Returns a copy of this datetime with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusYears().
org.joda.time.LocalDateTime.plusDays	(	int	): Returns a copy of this datetime plus the specified number of days.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusDays(6); LocalDateTime added = dt.plus(Period.days(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6); 
org.joda.time.LocalDateTime.plusHours	(	int	): Returns a copy of this datetime plus the specified number of hours.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusHours(6); LocalDateTime added = dt.plus(Period.hours(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6); 
org.joda.time.LocalDateTime.plusMillis	(	int	): Returns a copy of this datetime plus the specified number of millis.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusMillis(6); LocalDateTime added = dt.plus(Period.millis(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6); 
org.joda.time.LocalDateTime.plusMinutes	(	int	): Returns a copy of this datetime plus the specified number of minutes.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusMinutes(6); LocalDateTime added = dt.plus(Period.minutes(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6); 
org.joda.time.LocalDateTime.plusMonths	(	int	): Returns a copy of this datetime plus the specified number of months.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusMonths(6); LocalDateTime added = dt.plus(Period.months(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6); 
org.joda.time.LocalDateTime.plusSeconds	(	int	): Returns a copy of this datetime plus the specified number of seconds.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusSeconds(6); LocalDateTime added = dt.plus(Period.seconds(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6); 
org.joda.time.LocalDateTime.plusWeeks	(	int	): Returns a copy of this datetime plus the specified number of weeks.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusWeeks(6); LocalDateTime added = dt.plus(Period.weeks(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6); 
org.joda.time.LocalDateTime.plusYears	(	int	): Returns a copy of this datetime plus the specified number of years.  This LocalDateTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalDateTime added = dt.plusYears(6); LocalDateTime added = dt.plus(Period.years(6)); LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6); 
org.joda.time.LocalDateTime.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.LocalDateTime.readResolve	(	): Handle broken serialization from other tools.
org.joda.time.LocalDateTime.secondOfMinute	(	): Get the second of minute field property which provides access to advanced functionality.
org.joda.time.LocalDateTime.size	(	): Gets the number of fields in this partial, which is four. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.
org.joda.time.LocalDateTime.toDate	(	): Get the date time as a java.util.Date.  The Date object created has exactly the same fields as this date-time, except when the time would be invalid due to a daylight savings gap. In that case, the time will be set to the earliest valid time after the gap.  In the case of a daylight savings overlap, the earlier instant is selected.  Converting to a JDK Date is full of complications as the JDK Date constructor doesn't behave as you might expect around DST transitions. This method works by taking a first guess and then adjusting. This also handles the situation where the JDK time zone data differs from the Joda-Time time zone data.
org.joda.time.LocalDateTime.toDate	(	TimeZone	): Get the date time as a java.util.Date using the specified time zone.  The Date object created has exactly the same fields as this date-time, except when the time would be invalid due to a daylight savings gap. In that case, the time will be set to the earliest valid time after the gap.  In the case of a daylight savings overlap, the earlier instant is selected.  Converting to a JDK Date is full of complications as the JDK Date constructor doesn't behave as you might expect around DST transitions. This method works by taking a first guess and then adjusting. This also handles the situation where the JDK time zone data differs from the Joda-Time time zone data.  Unlike toDate(), this implementation does not rely on Java's synchronized time zone initialization logic, and should demonstrate better concurrent performance characteristics.
org.joda.time.LocalDateTime.toDateTime	(	): Converts this object to a DateTime using the default zone.  When the time zone is applied, the local date-time may be affected by daylight saving. In a daylight saving gap, when the local time does not exist, this method will throw an exception. In a daylight saving overlap, when the same local time occurs twice, this method returns the first occurrence of the local time.
org.joda.time.LocalDateTime.toDateTime	(	DateTimeZone	): Converts this object to a DateTime using the specified zone.  When the time zone is applied, the local date-time may be affected by daylight saving. In a daylight saving gap, when the local time does not exist, this method will throw an exception. In a daylight saving overlap, when the same local time occurs twice, this method returns the first occurrence of the local time.
org.joda.time.LocalDateTime.toLocalDate	(	): Converts this object to a LocalDate with the same date and chronology.
org.joda.time.LocalDateTime.toLocalTime	(	): Converts this object to a LocalTime with the same time and chronology.
org.joda.time.LocalDateTime.toString	(	): Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSS).
org.joda.time.LocalDateTime.toString	(	String	): Output the date using the specified format pattern.
org.joda.time.LocalDateTime.toString	(	String	Locale	): Output the date using the specified format pattern.
org.joda.time.LocalDateTime.weekOfWeekyear	(	): Get the week of a week based year property which provides access to advanced functionality.
org.joda.time.LocalDateTime.weekyear	(	): Get the weekyear property which provides access to advanced functionality.
org.joda.time.LocalDateTime.withCenturyOfEra	(	int	): Returns a copy of this datetime with the century of era field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of century of era changed.
org.joda.time.LocalDateTime.withDate	(	int	int	int	): Returns a copy of this datetime with the specified date, retaining the time fields.  If the date is already the date passed in, then this is returned.  To set a single field use the properties, for example:  DateTime set = dt.monthOfYear().setCopy(6); 
org.joda.time.LocalDateTime.withDayOfMonth	(	int	): Returns a copy of this datetime with the day of month field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of month changed.
org.joda.time.LocalDateTime.withDayOfWeek	(	int	): Returns a copy of this datetime with the day of week field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of week changed.
org.joda.time.LocalDateTime.withDayOfYear	(	int	): Returns a copy of this datetime with the day of year field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of year changed.
org.joda.time.LocalDateTime.withDurationAdded	(	ReadableDuration	int	): Returns a copy of this datetime with the specified duration added.  If the addition is zero, then this is returned.
org.joda.time.LocalDateTime.withEra	(	int	): Returns a copy of this datetime with the era field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of era changed.
org.joda.time.LocalDateTime.withField	(	DateTimeFieldType	int	): Returns a copy of this datetime with the specified field set to a new value.  For example, if the field type is hourOfDay then the hour of day field would be changed in the returned instance. If the field type is null, then this is returned.  These three lines are equivalent:  LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6); LocalDateTime updated = dt.dayOfMonth().setCopy(6); LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6); 
org.joda.time.LocalDateTime.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this datetime with the value of the specified field increased.  If the addition is zero or the field is null, then this is returned.  These three lines are equivalent:  LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6); LocalDateTime added = dt.plusYears(6); LocalDateTime added = dt.plus(Period.years(6)); 
org.joda.time.LocalDateTime.withFields	(	ReadablePartial	): Returns a copy of this datetime with the partial set of fields replacing those from this instance.  For example, if the partial is a TimeOfDay then the time fields would be changed in the returned instance. If the partial is null, then this is returned.
org.joda.time.LocalDateTime.withHourOfDay	(	int	): Returns a copy of this datetime with the hour of day field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of hour of day changed.
org.joda.time.LocalDateTime.withLocalMillis	(	long	): Returns a copy of this datetime with different local millis.  The returned object will be a new instance of the same type. Only the millis will change, the chronology is kept. The returned object will be either be a new instance or this.
org.joda.time.LocalDateTime.withMillisOfDay	(	int	): Returns a copy of this datetime with the millis of day field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of day changed.
org.joda.time.LocalDateTime.withMillisOfSecond	(	int	): Returns a copy of this datetime with the millis of second field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of second changed.
org.joda.time.LocalDateTime.withMinuteOfHour	(	int	): Returns a copy of this datetime with the minute of hour field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of minute of hour changed.
org.joda.time.LocalDateTime.withMonthOfYear	(	int	): Returns a copy of this datetime with the month of year field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.LocalDateTime.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this datetime with the specified period added.  If the addition is zero, then this is returned.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusYears().
org.joda.time.LocalDateTime.withSecondOfMinute	(	int	): Returns a copy of this datetime with the second of minute field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of second of minute changed.
org.joda.time.LocalDateTime.withTime	(	int	int	int	int	): Returns a copy of this datetime with the specified time, retaining the date fields.  If the time is already the time passed in, then this is returned.  To set a single field use the properties, for example:  LocalDateTime set = dt.hourOfDay().setCopy(6); 
org.joda.time.LocalDateTime.withWeekOfWeekyear	(	int	): Returns a copy of this datetime with the week of weekyear field updated.  This field is associated with the "weekyear" via withWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of week of weekyear changed.
org.joda.time.LocalDateTime.withWeekyear	(	int	): Returns a copy of this datetime with the weekyear field updated.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of weekyear changed.
org.joda.time.LocalDateTime.withYear	(	int	): Returns a copy of this datetime with the year field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year changed.
org.joda.time.LocalDateTime.withYearOfCentury	(	int	): Returns a copy of this datetime with the year of century field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of century changed.
org.joda.time.LocalDateTime.withYearOfEra	(	int	): Returns a copy of this datetime with the year of era field updated.  LocalDateTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year of era changed.
org.joda.time.LocalDateTime.year	(	): Get the year property which provides access to advanced functionality.
org.joda.time.LocalDateTime.yearOfCentury	(	): Get the year of century property which provides access to advanced functionality.
org.joda.time.LocalDateTime.yearOfEra	(	): Get the year of era property which provides access to advanced functionality.
org.joda.time.LocalTime: LocalTime is an immutable time class representing a time without a time zone.  LocalTime implements the ReadablePartial interface. To do this, the interface methods focus on the key fields - HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond. However, all time fields may in fact be queried.  Calculations on LocalTime are performed using a Chronology. This chronology will be set internally to be in the UTC time zone for all calculations. Each individual field can be queried in two ways:  getHourOfDay() hourOfDay().get()  The second technique also provides access to other useful methods on the field:  numeric value text value short text value maximum/minimum values add/subtract set rounding   LocalTime is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.LocalTime.LocalTime	(	): Constructs an instance set to the current local time evaluated using ISO chronology in the default zone.  Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalTime.LocalTime	(	Chronology	): Constructs an instance set to the current local time evaluated using specified chronology and zone.  If the chronology is null, ISO chronology in the default time zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalTime.LocalTime	(	DateTimeZone	): Constructs an instance set to the current local time evaluated using ISO chronology in the specified zone.  If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalTime.LocalTime	(	Object	): Constructs an instance from an Object that represents a datetime.  If the object contains no chronology, ISOChronology is used. If the object contains no time zone, the default zone is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localTimeParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalTime.LocalTime	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology.  If the chronology is null, ISO in the default time zone is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localTimeParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalTime.LocalTime	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified.  If the object contains no chronology, ISOChronology is used. If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePartial, ReadableInstant, String, Calendar and Date. The String formats are described by localTimeParser(). The default String converter ignores the zone and only parses the field values.
org.joda.time.LocalTime.LocalTime	(	int	int	): Constructs an instance set to the specified time using ISOChronology.
org.joda.time.LocalTime.LocalTime	(	int	int	int	): Constructs an instance set to the specified time using ISOChronology.
org.joda.time.LocalTime.LocalTime	(	int	int	int	int	): Constructs an instance set to the specified time using ISOChronology.
org.joda.time.LocalTime.LocalTime	(	int	int	int	int	Chronology	): Constructs an instance set to the specified time using the specified chronology, whose zone is ignored.  If the chronology is null, ISOChronology is used.
org.joda.time.LocalTime.LocalTime	(	long	): Constructs an instance set to the local time defined by the specified instant evaluated using ISO chronology in the default zone.  Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalTime.LocalTime	(	long	Chronology	): Constructs an instance set to the local time defined by the specified instant evaluated using the specified chronology.  If the chronology is null, ISO chronology in the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalTime.LocalTime	(	long	DateTimeZone	): Constructs an instance set to the local time defined by the specified instant evaluated using ISO chronology in the specified zone.  If the specified time zone is null, the default zone is used. Once the constructor is completed, the zone is no longer used.
org.joda.time.LocalTime.Property: LocalTime.Property binds a LocalTime to a DateTimeField allowing powerful datetime functionality to be easily accessed.  The simplest use of this class is as an alternative get method, here used to get the minute '30'.  LocalTime dt = new LocalTime(12, 30); int year = dt.minuteOfHour().get();   Methods are also provided that allow time modification. These return new instances of LocalTime - they do not modify the original. The example below yields two independent immutable date objects 2 hours apart.  LocalTime dt1230 = new LocalTime(12, 30); LocalTime dt1430 = dt1230.hourOfDay().setCopy(14);   LocalTime.Property itself is thread-safe and immutable, as well as the LocalTime being operated on.
org.joda.time.LocalTime.Property.Property	(	LocalTime	DateTimeField	): Constructor.
org.joda.time.LocalTime.Property.addCopy	(	int	): Adds to this field in a copy of this LocalTime.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.addCopy	(	long	): Adds to this field in a copy of this LocalTime. If the addition exceeds the maximum value (eg. 23:59) it will wrap to the minimum value (eg. 00:00).  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.addNoWrapToCopy	(	int	): Adds to this field in a copy of this LocalTime. If the addition exceeds the maximum value (eg. 23:59) then an exception will be thrown. Contrast this behaviour to addCopy().  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.addWrapFieldToCopy	(	int	): Adds to this field, possibly wrapped, in a copy of this LocalTime. A field wrapped operation only changes this field. Thus 10:59 plusWrapField one minute goes to 10:00.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.getChronology	(	): Gets the chronology of the datetime that this property is linked to.
org.joda.time.LocalTime.Property.getField	(	): Gets the field being used.
org.joda.time.LocalTime.Property.getLocalTime	(	): Gets the LocalTime object linked to this property.
org.joda.time.LocalTime.Property.getMillis	(	): Gets the milliseconds of the time that this property is linked to.
org.joda.time.LocalTime.Property.readObject	(	ObjectInputStream	): Reads the property from a safe serialization format.
org.joda.time.LocalTime.Property.roundCeilingCopy	(	): Rounds to the highest whole unit of this field on a copy of this LocalTime.  For example, rounding floor on the hourOfDay field of a LocalTime where the time is 10:30 would result in new LocalTime with the time of 11:00.
org.joda.time.LocalTime.Property.roundFloorCopy	(	): Rounds to the lowest whole unit of this field on a copy of this LocalTime.  For example, rounding floor on the hourOfDay field of a LocalTime where the time is 10:30 would result in new LocalTime with the time of 10:00.
org.joda.time.LocalTime.Property.roundHalfCeilingCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalTime, favoring the ceiling if halfway.
org.joda.time.LocalTime.Property.roundHalfEvenCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalTime. If halfway, the ceiling is favored over the floor only if it makes this field's value even.
org.joda.time.LocalTime.Property.roundHalfFloorCopy	(	): Rounds to the nearest whole unit of this field on a copy of this LocalTime, favoring the floor if halfway.
org.joda.time.LocalTime.Property.setCopy	(	String	): Sets this field in a copy of the LocalTime to a parsed text value.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.setCopy	(	String	Locale	): Sets this field in a copy of the LocalTime to a parsed text value.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.setCopy	(	int	): Sets this field in a copy of the LocalTime.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.withMaximumValue	(	): Returns a new LocalTime with this field set to the maximum value for this field.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.withMinimumValue	(	): Returns a new LocalTime with this field set to the minimum value for this field.  The LocalTime attached to this property is unchanged by this call.
org.joda.time.LocalTime.Property.writeObject	(	ObjectOutputStream	): Writes the property in a safe serialization format.
org.joda.time.LocalTime.compareTo	(	ReadablePartial	): Compares this partial with another returning an integer indicating the order.  The fields are compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.  The specified object must be a partial instance whose field types match those of this partial.
org.joda.time.LocalTime.equals	(	Object	): Compares this ReadablePartial with another returning true if the chronology, field types and values are equal.
org.joda.time.LocalTime.fromCalendarFields	(	Calendar	): Constructs a LocalTime from a java.util.Calendar using exactly the same field values.  Each field is queried from the Calendar and assigned to the LocalTime. This is useful if you have been using the Calendar as a local time, ignoring the zone.  One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data.  This factory method ignores the type of the calendar and always creates a LocalTime with ISO chronology. It is expected that you will only pass in instances of GregorianCalendar however this is not validated.
org.joda.time.LocalTime.fromDateFields	(	Date	): Constructs a LocalTime from a java.util.Date using exactly the same field values.  Each field is queried from the Date and assigned to the LocalTime. This is useful if you have been using the Date as a local time, ignoring the zone.  One advantage of this method is that this method is unaffected if the version of the time zone data differs between the JDK and Joda-Time. That is because the local field values are transferred, calculated using the JDK time zone data and without using the Joda-Time time zone data.  This factory method always creates a LocalTime with ISO chronology.
org.joda.time.LocalTime.fromMillisOfDay	(	long	): Constructs a LocalTime from the specified millis of day using the ISO chronology.  The millisOfDay value may exceed the number of millis in one day, but additional days will be ignored. This method uses the UTC time zone internally.
org.joda.time.LocalTime.fromMillisOfDay	(	long	Chronology	): Constructs a LocalTime from the specified millis of day using the specified chronology.  The millisOfDay value may exceed the number of millis in one day, but additional days will be ignored. This method uses the UTC time zone internally.
org.joda.time.LocalTime.get	(	DateTimeFieldType	): Get the value of one of the fields of time.  This method gets the value of the specified field. For example:  DateTime dt = new DateTime(); int hourOfDay = dt.get(DateTimeFieldType.hourOfDay()); 
org.joda.time.LocalTime.getChronology	(	): Gets the chronology of the time.
org.joda.time.LocalTime.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.LocalTime.getHourOfDay	(	): Get the hour of day field value.
org.joda.time.LocalTime.getLocalMillis	(	): Gets the local milliseconds from the Java epoch of 1970-01-01T00:00:00 (not fixed to any specific time zone).
org.joda.time.LocalTime.getMillisOfDay	(	): Get the millis of day field value.
org.joda.time.LocalTime.getMillisOfSecond	(	): Get the millis of second field value.
org.joda.time.LocalTime.getMinuteOfHour	(	): Get the minute of hour field value.
org.joda.time.LocalTime.getSecondOfMinute	(	): Get the second of minute field value.
org.joda.time.LocalTime.getValue	(	int	): Gets the value of the field at the specified index.  This method is required to support the ReadablePartial interface. The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.
org.joda.time.LocalTime.hourOfDay	(	): Get the hour of day field property which provides access to advanced functionality.
org.joda.time.LocalTime.isSupported	(	DateTimeFieldType	): Checks if the field type specified is supported by this local time and chronology. This can be used to avoid exceptions in get().
org.joda.time.LocalTime.isSupported	(	DurationFieldType	): Checks if the duration type specified is supported by this local time and chronology.
org.joda.time.LocalTime.millisOfDay	(	): Get the millis of day property which provides access to advanced functionality.
org.joda.time.LocalTime.millisOfSecond	(	): Get the millis of second property which provides access to advanced functionality.
org.joda.time.LocalTime.minus	(	ReadablePeriod	): Returns a copy of this time with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusHours().
org.joda.time.LocalTime.minusHours	(	int	): Returns a copy of this time minus the specified number of hours.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime subtracted = dt.minusHours(6); LocalTime subtracted = dt.minus(Period.hours(6)); LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6); 
org.joda.time.LocalTime.minusMillis	(	int	): Returns a copy of this time minus the specified number of millis.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime subtracted = dt.minusMillis(6); LocalTime subtracted = dt.minus(Period.millis(6)); LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6); 
org.joda.time.LocalTime.minusMinutes	(	int	): Returns a copy of this time minus the specified number of minutes.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime subtracted = dt.minusMinutes(6); LocalTime subtracted = dt.minus(Period.minutes(6)); LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6); 
org.joda.time.LocalTime.minusSeconds	(	int	): Returns a copy of this time minus the specified number of seconds.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime subtracted = dt.minusSeconds(6); LocalTime subtracted = dt.minus(Period.seconds(6)); LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6); 
org.joda.time.LocalTime.minuteOfHour	(	): Get the minute of hour field property which provides access to advanced functionality.
org.joda.time.LocalTime.now	(	): Obtains a LocalTime set to the current system millisecond time using ISOChronology in the default time zone. The resulting object does not use the zone.
org.joda.time.LocalTime.now	(	Chronology	): Obtains a LocalTime set to the current system millisecond time using the specified chronology. The resulting object does not use the zone.
org.joda.time.LocalTime.now	(	DateTimeZone	): Obtains a LocalTime set to the current system millisecond time using ISOChronology in the specified time zone. The resulting object does not use the zone.
org.joda.time.LocalTime.parse	(	String	): Parses a LocalTime from the specified string.  This uses localTimeParser().
org.joda.time.LocalTime.parse	(	String	DateTimeFormatter	): Parses a LocalTime from the specified string using a formatter.
org.joda.time.LocalTime.plus	(	ReadablePeriod	): Returns a copy of this time with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusHours().
org.joda.time.LocalTime.plusHours	(	int	): Returns a copy of this time plus the specified number of hours.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime added = dt.plusHours(6); LocalTime added = dt.plus(Period.hours(6)); LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6); 
org.joda.time.LocalTime.plusMillis	(	int	): Returns a copy of this time plus the specified number of millis.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime added = dt.plusMillis(6); LocalTime added = dt.plus(Period.millis(6)); LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6); 
org.joda.time.LocalTime.plusMinutes	(	int	): Returns a copy of this time plus the specified number of minutes.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime added = dt.plusMinutes(6); LocalTime added = dt.plus(Period.minutes(6)); LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6); 
org.joda.time.LocalTime.plusSeconds	(	int	): Returns a copy of this time plus the specified number of seconds.  This LocalTime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  LocalTime added = dt.plusSeconds(6); LocalTime added = dt.plus(Period.seconds(6)); LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6); 
org.joda.time.LocalTime.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.LocalTime.readResolve	(	): Handle broken serialization from other tools.
org.joda.time.LocalTime.secondOfMinute	(	): Get the second of minute field property which provides access to advanced functionality.
org.joda.time.LocalTime.size	(	): Gets the number of fields in this partial, which is four. The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.
org.joda.time.LocalTime.toDateTimeToday	(	): Converts this LocalTime to a full datetime using the default time zone setting the time fields from this instance and the date fields from the current date.
org.joda.time.LocalTime.toDateTimeToday	(	DateTimeZone	): Converts this LocalTime to a full datetime using the specified time zone setting the time fields from this instance and the date fields from the current time.  This method uses the chronology from this instance plus the time zone specified.
org.joda.time.LocalTime.toString	(	): Output the time in ISO8601 format (HH:mm:ss.SSS).
org.joda.time.LocalTime.toString	(	String	): Output the time using the specified format pattern.
org.joda.time.LocalTime.toString	(	String	Locale	): Output the time using the specified format pattern.
org.joda.time.LocalTime.withField	(	DateTimeFieldType	int	): Returns a copy of this time with the specified field set to a new value.  For example, if the field type is hourOfDay then the hour of day field would be changed in the returned instance. If the field type is null, then this is returned.  These lines are equivalent:  LocalTime updated = dt.withHourOfDay(6); LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6); 
org.joda.time.LocalTime.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this time with the value of the specified field increased.  If the addition is zero or the field is null, then this is returned.  If the addition causes the maximum value of the field to be exceeded, then the value will wrap. Thus 23:59 plus two minutes yields 00:01.  These lines are equivalent:  LocalTime added = dt.plusHours(6); LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6); 
org.joda.time.LocalTime.withFields	(	ReadablePartial	): Returns a copy of this time with the partial set of fields replacing those from this instance.  For example, if the partial contains an hour and minute then those two fields will be changed in the returned instance. Unsupported fields are ignored. If the partial is null, then this is returned.
org.joda.time.LocalTime.withHourOfDay	(	int	): Returns a copy of this time with the hour of day field updated.  LocalTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of hour of day changed.
org.joda.time.LocalTime.withLocalMillis	(	long	): Returns a copy of this time with different local millis.  The returned object will be a new instance of the same type. Only the millis will change, the chronology is kept. The returned object will be either be a new instance or this.
org.joda.time.LocalTime.withMillisOfDay	(	int	): Returns a copy of this time with the millis of day field updated.  LocalTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of day changed.
org.joda.time.LocalTime.withMillisOfSecond	(	int	): Returns a copy of this time with the millis of second field updated.  LocalTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of second changed.
org.joda.time.LocalTime.withMinuteOfHour	(	int	): Returns a copy of this time with the minute of hour field updated.  LocalTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of minute of hour changed.
org.joda.time.LocalTime.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this time with the specified period added.  If the addition is zero, then this is returned.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusHours().
org.joda.time.LocalTime.withSecondOfMinute	(	int	): Returns a copy of this time with the second of minute field updated.  LocalTime is immutable, so there are no set methods. Instead, this method returns a new instance with the value of second of minute changed.
org.joda.time.Minutes: An immutable time period representing a number of minutes.  Minutes is an immutable period that can only store minutes. It does not store years, months or hours for example. As such it is a type-safe way of representing a number of minutes in an application.  The number of minutes is set in the constructor, and may be queried using getMinutes(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Minutes is thread-safe and immutable.
org.joda.time.Minutes.Minutes	(	int	): Creates a new instance representing a number of minutes. You should consider using the factory method minutes() instead of the constructor.
org.joda.time.Minutes.dividedBy	(	int	): Returns a new instance with the minutes divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Minutes.getFieldType	(	): Gets the duration field type, which is minutes.
org.joda.time.Minutes.getMinutes	(	): Gets the number of minutes that this period represents.
org.joda.time.Minutes.getPeriodType	(	): Gets the period type, which is minutes.
org.joda.time.Minutes.isGreaterThan	(	Minutes	): Is this minutes instance greater than the specified number of minutes.
org.joda.time.Minutes.isLessThan	(	Minutes	): Is this minutes instance less than the specified number of minutes.
org.joda.time.Minutes.minus	(	Minutes	): Returns a new instance with the specified number of minutes taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Minutes.minus	(	int	): Returns a new instance with the specified number of minutes taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Minutes.minutes	(	int	): Obtains an instance of Minutes that may be cached. Minutes is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Minutes.minutesBetween	(	ReadableInstant	ReadableInstant	): Creates a Minutes representing the number of whole minutes between the two specified datetimes.
org.joda.time.Minutes.minutesBetween	(	ReadablePartial	ReadablePartial	): Creates a Minutes representing the number of whole minutes between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalTime objects.
org.joda.time.Minutes.minutesIn	(	ReadableInterval	): Creates a Minutes representing the number of whole minutes in the specified interval.
org.joda.time.Minutes.multipliedBy	(	int	): Returns a new instance with the minutes multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Minutes.negated	(	): Returns a new instance with the minutes value negated.
org.joda.time.Minutes.parseMinutes	(	String	): Creates a new Minutes by parsing a string in the ISO8601 format 'PTnM'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the minutes component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Minutes.plus	(	Minutes	): Returns a new instance with the specified number of minutes added.  This instance is immutable and unaffected by this method call.
org.joda.time.Minutes.plus	(	int	): Returns a new instance with the specified number of minutes added.  This instance is immutable and unaffected by this method call.
org.joda.time.Minutes.readResolve	(	): Resolves singletons.
org.joda.time.Minutes.standardMinutesIn	(	ReadablePeriod	): Creates a new Minutes representing the number of complete standard length minutes in the specified period.  This factory method converts all fields from the period to minutes using standardised durations for each field. Only those fields which have a precise duration in the ISO UTC chronology can be converted.  One week consists of 7 days. One day consists of 24 hours. One hour consists of 60 minutes. One minute consists of 60 seconds. One second consists of 1000 milliseconds.  Months and Years are imprecise and periods containing these values cannot be converted.
org.joda.time.Minutes.toStandardDays	(	): Converts this period in minutes to a period in days assuming a 24 hour day and 60 minute hour.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all days are 24 hours long and all hours are 60 minutes long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Minutes.toStandardDuration	(	): Converts this period in minutes to a duration in milliseconds assuming a 60 second minute.  This method allows you to convert from a period to a duration. However to achieve this it makes the assumption that all minutes are 60 seconds long. This might not be true for an unusual chronology, for example one that takes leap seconds into account. However, the method is included as it is a useful operation for many applications and business rules.
org.joda.time.Minutes.toStandardHours	(	): Converts this period in minutes to a period in hours assuming a 60 minute hour.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all hours are 60 minutes long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Minutes.toStandardSeconds	(	): Converts this period in minutes to a period in seconds assuming a 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all minutes are 60 seconds long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Minutes.toStandardWeeks	(	): Converts this period in minutes to a period in weeks assuming a 7 days week, 24 hour day and 60 minute hour.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long, all days are 24 hours long and all hours are 60 minutes long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Minutes.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "PT4M" represents 4 minutes.
org.joda.time.MockNullZoneChronology: Mock class for unit testing.
org.joda.time.MockPartial: A basic mock testing class for a PartialInstant that doesn't extend AbstractPartialInstant.
org.joda.time.MonthDay: MonthDay is an immutable partial supporting the monthOfYear and dayOfMonth fields.  NOTE: This class only supports the two fields listed above. It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.  Calculations on MonthDay are performed using a Chronology. This chronology is set to be in the UTC time zone for all calculations.  One use case for this class is to store a birthday without the year (to avoid storing the age of the person). This class can be used as the gMonthDay type in XML Schema.  Each individual field can be queried in two ways:  getMonthOfYear() monthOfYear().get()  The second technique also provides access to other useful methods on the field:  numeric value - monthOfYear().get() text value - monthOfYear().getAsText() short text value - monthOfYear().getAsShortText() maximum/minimum values - monthOfYear().getMaximumValue() add/subtract - monthOfYear().addToCopy() set - monthOfYear().setCopy()   MonthDay is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.MonthDay.MonthDay	(	): Constructs a MonthDay with the current monthOfYear, using ISOChronology in the default zone to extract the fields.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.MonthDay	(	Chronology	): Constructs a MonthDay with the current month-day, using the specified chronology and zone to extract the fields.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.MonthDay	(	DateTimeZone	): Constructs a MonthDay with the current month-day, using ISOChronology in the specified zone to extract the fields.  The constructor uses the specified time zone to obtain the current month-day. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.MonthDay	(	MonthDay	Chronology	): Constructs a MonthDay with values from this instance and a new chronology.
org.joda.time.MonthDay.MonthDay	(	MonthDay	int[]	): Constructs a MonthDay with chronology from this instance and new values.
org.joda.time.MonthDay.MonthDay	(	Object	): Constructs a MonthDay from an Object that represents some form of time.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser().  The chronology used will be derived from the object, defaulting to ISO.
org.joda.time.MonthDay.MonthDay	(	Object	Chronology	): Constructs a MonthDay from an Object that represents some form of time, using the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser().  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC). The specified chronology overrides that of the object.
org.joda.time.MonthDay.MonthDay	(	int	int	): Constructs a MonthDay with specified year and month using ISOChronology.  The constructor uses the no time zone initialising the fields as provided. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.MonthDay	(	int	int	Chronology	): Constructs an instance set to the specified monthOfYear and dayOfMonth using the specified chronology, whose zone is ignored.  If the chronology is null, ISOChronology is used.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.MonthDay	(	long	): Constructs a MonthDay extracting the partial fields from the specified milliseconds using the ISOChronology in the default zone.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.MonthDay	(	long	Chronology	): Constructs a MonthDay extracting the partial fields from the specified milliseconds using the chronology provided.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.MonthDay.Property: The property class for MonthDay.  This class binds a YearMonth to a DateTimeField.
org.joda.time.MonthDay.Property.Property	(	MonthDay	int	): Constructs a property.
org.joda.time.MonthDay.Property.addToCopy	(	int	): Adds to the value of this field in a copy of this MonthDay.  The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected.  The MonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.MonthDay.Property.addWrapFieldToCopy	(	int	): Adds to the value of this field in a copy of this MonthDay wrapping within this field if the maximum value is reached.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps within this field. Other fields are unaffected.  For example, --12-30 addWrapField one month returns --01-30.  The MonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.MonthDay.Property.get	(	): Gets the value of this field.
org.joda.time.MonthDay.Property.getField	(	): Gets the field that this property uses.
org.joda.time.MonthDay.Property.getMonthDay	(	): Gets the partial that this property belongs to.
org.joda.time.MonthDay.Property.getReadablePartial	(	): Gets the partial that this property belongs to.
org.joda.time.MonthDay.Property.setCopy	(	String	): Sets this field in a copy of the MonthDay to a parsed text value.  The MonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.MonthDay.Property.setCopy	(	String	Locale	): Sets this field in a copy of the MonthDay to a parsed text value.  The MonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.MonthDay.Property.setCopy	(	int	): Sets this field in a copy of the MonthDay.  The MonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.MonthDay.dayOfMonth	(	): Get the day of month field property which provides access to advanced functionality.
org.joda.time.MonthDay.fromCalendarFields	(	Calendar	): Constructs a MonthDay from a java.util.Calendar using exactly the same field values avoiding any time zone effects.  Each field is queried from the Calendar and assigned to the MonthDay.  This factory method ignores the type of the calendar and always creates a MonthDay with ISO chronology. It is expected that you will only pass in instances of GregorianCalendar however this is not validated.
org.joda.time.MonthDay.fromDateFields	(	Date	): Constructs a MonthDay from a java.util.Date using exactly the same field values avoiding any time zone effects.  Each field is queried from the Date and assigned to the MonthDay.  This factory method always creates a MonthDay with ISO chronology.
org.joda.time.MonthDay.getDayOfMonth	(	): Get the day of month field value.
org.joda.time.MonthDay.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.MonthDay.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.MonthDay.getFieldTypes	(	): Gets an array of the field type of each of the fields that this partial supports.  The fields are returned largest to smallest, Month, Day.
org.joda.time.MonthDay.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.MonthDay.minus	(	ReadablePeriod	): Returns a copy of this month-day with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusMonths().
org.joda.time.MonthDay.minusDays	(	int	): Returns a copy of this month-day minus the specified number of months.  This month-day instance is immutable and unaffected by this method call. The month will wrap at the end of the year from January to December.  The following three lines are identical in effect:  MonthDay subtracted = md.minusDays(6); MonthDay subtracted = md.minus(Period.days(6)); MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6); 
org.joda.time.MonthDay.minusMonths	(	int	): Returns a copy of this month-day minus the specified number of months.  This MonthDay instance is immutable and unaffected by this method call. The month will wrap at the end of the year from January to December. The day will be adjusted to the last valid value if necessary.  The following three lines are identical in effect:  MonthDay subtracted = md.minusMonths(6); MonthDay subtracted = md.minus(Period.months(6)); MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6); 
org.joda.time.MonthDay.monthOfYear	(	): Get the month of year field property which provides access to advanced functionality.
org.joda.time.MonthDay.now	(	): Obtains a MonthDay set to the current system millisecond time using ISOChronology in the default time zone. The resulting object does not use the zone.
org.joda.time.MonthDay.now	(	Chronology	): Obtains a MonthDay set to the current system millisecond time using the specified chronology. The resulting object does not use the zone.
org.joda.time.MonthDay.now	(	DateTimeZone	): Obtains a MonthDay set to the current system millisecond time using ISOChronology in the specified time zone. The resulting object does not use the zone.
org.joda.time.MonthDay.parse	(	String	): Parses a MonthDay from the specified string.  This uses localDateParser() or the format --MM-dd.
org.joda.time.MonthDay.parse	(	String	DateTimeFormatter	): Parses a MonthDay from the specified string using a formatter.
org.joda.time.MonthDay.plus	(	ReadablePeriod	): Returns a copy of this month-day with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusMonths().
org.joda.time.MonthDay.plusDays	(	int	): Returns a copy of this month-day plus the specified number of days.  This month-day instance is immutable and unaffected by this method call. The month will wrap at the end of the year from December to January.  If the number of days added requires wrapping past the end of February, the wrapping will be calculated assuming February has 29 days.  The following three lines are identical in effect:  MonthDay added = md.plusDays(6); MonthDay added = md.plus(Period.days(6)); MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6); 
org.joda.time.MonthDay.plusMonths	(	int	): Returns a copy of this month-day plus the specified number of months.  This month-day instance is immutable and unaffected by this method call. The month will wrap at the end of the year from December to January. The day will be adjusted to the last valid value if necessary.  The following three lines are identical in effect:  MonthDay added = md.plusMonths(6); MonthDay added = md.plus(Period.months(6)); MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6); 
org.joda.time.MonthDay.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.MonthDay.readResolve	(	): Handle broken serialization from other tools.
org.joda.time.MonthDay.size	(	): Gets the number of fields in this partial, which is two. The supported fields are MonthOfYear and DayOfMonth. Note that only these fields may be queried.
org.joda.time.MonthDay.toLocalDate	(	int	): Converts this object to a LocalDate with the same month-day and chronology.
org.joda.time.MonthDay.toString	(	): Output the month-day in ISO8601 format (--MM-dd).
org.joda.time.MonthDay.toString	(	String	): Output the month-day using the specified format pattern.
org.joda.time.MonthDay.toString	(	String	Locale	): Output the month-day using the specified format pattern.
org.joda.time.MonthDay.withChronologyRetainFields	(	Chronology	): Returns a copy of this month-day with the specified chronology. This instance is immutable and unaffected by this method call.  This method retains the values of the fields, thus the result will typically refer to a different instant.  The time zone of the specified chronology is ignored, as MonthDay operates without a time zone.
org.joda.time.MonthDay.withDayOfMonth	(	int	): Returns a copy of this month-day with the day of month field updated.  MonthDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of month changed.
org.joda.time.MonthDay.withField	(	DateTimeFieldType	int	): Returns a copy of this month-day with the specified field set to a new value.  For example, if the field type is dayOfMonth then the day would be changed in the returned instance.  These three lines are equivalent:  MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6); MonthDay updated = md.dayOfMonth().setCopy(6); MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6); 
org.joda.time.MonthDay.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this month-day with the value of the specified field increased.  If the addition is zero, then this is returned.  These three lines are equivalent:  MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6); MonthDay added = md.plusDays(6); MonthDay added = md.dayOfMonth().addToCopy(6); 
org.joda.time.MonthDay.withMonthOfYear	(	int	): Returns a copy of this month-day with the month of year field updated.  MonthDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.MonthDay.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this month-day with the specified period added.  If the addition is zero, then this is returned. Fields in the period that aren't present in the partial are ignored.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusMonths().
org.joda.time.Months: An immutable time period representing a number of months.  Months is an immutable period that can only store months. It does not store years, days or hours for example. As such it is a type-safe way of representing a number of months in an application.  The number of months is set in the constructor, and may be queried using getMonths(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Months is thread-safe and immutable.
org.joda.time.Months.Months	(	int	): Creates a new instance representing a number of months. You should consider using the factory method months() instead of the constructor.
org.joda.time.Months.dividedBy	(	int	): Returns a new instance with the months divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Months.getFieldType	(	): Gets the duration field type, which is months.
org.joda.time.Months.getMonths	(	): Gets the number of months that this period represents.
org.joda.time.Months.getPeriodType	(	): Gets the period type, which is months.
org.joda.time.Months.isGreaterThan	(	Months	): Is this months instance greater than the specified number of months.
org.joda.time.Months.isLessThan	(	Months	): Is this months instance less than the specified number of months.
org.joda.time.Months.minus	(	Months	): Returns a new instance with the specified number of months taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Months.minus	(	int	): Returns a new instance with the specified number of months taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Months.months	(	int	): Obtains an instance of Months that may be cached. Months is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Months.monthsBetween	(	ReadableInstant	ReadableInstant	): Creates a Months representing the number of whole months between the two specified datetimes. This method correctly handles any daylight savings time changes that may occur during the interval.  This method calculates by adding months to the start date until the result is past the end date. As such, a period from the end of a "long" month to the end of a "short" month is counted as a whole month.
org.joda.time.Months.monthsBetween	(	ReadablePartial	ReadablePartial	): Creates a Months representing the number of whole months between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalDate objects.  This method calculates by adding months to the start date until the result is past the end date. As such, a period from the end of a "long" month to the end of a "short" month is counted as a whole month.
org.joda.time.Months.monthsIn	(	ReadableInterval	): Creates a Months representing the number of whole months in the specified interval. This method correctly handles any daylight savings time changes that may occur during the interval.
org.joda.time.Months.multipliedBy	(	int	): Returns a new instance with the months multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Months.negated	(	): Returns a new instance with the months value negated.
org.joda.time.Months.parseMonths	(	String	): Creates a new Months by parsing a string in the ISO8601 format 'PnM'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the months component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Months.plus	(	Months	): Returns a new instance with the specified number of months added.  This instance is immutable and unaffected by this method call.
org.joda.time.Months.plus	(	int	): Returns a new instance with the specified number of months added.  This instance is immutable and unaffected by this method call.
org.joda.time.Months.readResolve	(	): Resolves singletons.
org.joda.time.Months.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "P4M" represents 4 months.
org.joda.time.MutableDateTime: MutableDateTime is the standard implementation of a modifiable datetime class. It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.  This class uses a Chronology internally. The Chronology determines how the millisecond instant value is converted into the date time fields. The default Chronology is ISOChronology which is the agreed international standard and compatible with the modern Gregorian calendar.  Each individual field can be accessed in two ways:  getHourOfDay() hourOfDay().get()  The second technique also provides access to other useful methods on the field:  get numeric value set numeric value add to numeric value add to numeric value wrapping with the field get text value get short text value set text value field maximum value field minimum value   MutableDateTime is mutable and not thread-safe, unless concurrent threads are not invoking mutator methods.
org.joda.time.MutableDateTime.MutableDateTime	(	): Constructs an instance set to the current system millisecond time using ISOChronology in the default time zone.
org.joda.time.MutableDateTime.MutableDateTime	(	Chronology	): Constructs an instance set to the current system millisecond time using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.MutableDateTime.MutableDateTime	(	DateTimeZone	): Constructs an instance set to the current system millisecond time using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.MutableDateTime.MutableDateTime	(	Object	): Constructs an instance from an Object that represents a datetime.  If the object implies a chronology (such as GregorianCalendar does), then that chronology will be used. Otherwise, ISO default is used. Thus if a GregorianCalendar is passed in, the chronology used will be GJ, but if a Date is passed in the chronology will be ISO.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.
org.joda.time.MutableDateTime.MutableDateTime	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology.  If the chronology is null, ISO in the default time zone is used. Any chronology implied by the object (such as GregorianCalendar does) is ignored.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.
org.joda.time.MutableDateTime.MutableDateTime	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified.  If the object implies a chronology (such as GregorianCalendar does), then that chronology will be used, but with the time zone adjusted. Otherwise, ISO is used in the specified time zone. If the specified time zone is null, the default zone is used. Thus if a GregorianCalendar is passed in, the chronology used will be GJ, but if a Date is passed in the chronology will be ISO.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.
org.joda.time.MutableDateTime.MutableDateTime	(	int	int	int	int	int	int	int	): Constructs an instance from datetime field values using ISOChronology in the default time zone.
org.joda.time.MutableDateTime.MutableDateTime	(	int	int	int	int	int	int	int	Chronology	): Constructs an instance from datetime field values using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.MutableDateTime.MutableDateTime	(	int	int	int	int	int	int	int	DateTimeZone	): Constructs an instance from datetime field values using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.MutableDateTime.MutableDateTime	(	long	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the default time zone.
org.joda.time.MutableDateTime.MutableDateTime	(	long	Chronology	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.MutableDateTime.MutableDateTime	(	long	DateTimeZone	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.MutableDateTime.Property: MutableDateTime.Property binds a MutableDateTime to a DateTimeField allowing powerful datetime functionality to be easily accessed.  The example below shows how to use the property to change the value of a MutableDateTime object.  MutableDateTime dt = new MutableDateTime(1972, 12, 3, 13, 32, 19, 123); dt.year().add(20); dt.second().roundFloor().minute().set(10);   MutableDateTime.Propery itself is thread-safe and immutable, but the MutableDateTime being operated on is not.
org.joda.time.MutableDateTime.Property.Property	(	MutableDateTime	DateTimeField	): Constructor.
org.joda.time.MutableDateTime.Property.add	(	int	): Adds a value to the millis value.
org.joda.time.MutableDateTime.Property.add	(	long	): Adds a value to the millis value.
org.joda.time.MutableDateTime.Property.addWrapField	(	int	): Adds a value, possibly wrapped, to the millis value.
org.joda.time.MutableDateTime.Property.getChronology	(	): Gets the chronology of the datetime that this property is linked to.
org.joda.time.MutableDateTime.Property.getField	(	): Gets the field being used.
org.joda.time.MutableDateTime.Property.getMillis	(	): Gets the milliseconds of the datetime that this property is linked to.
org.joda.time.MutableDateTime.Property.getMutableDateTime	(	): Gets the mutable datetime being used.
org.joda.time.MutableDateTime.Property.readObject	(	ObjectInputStream	): Reads the property from a safe serialization format.
org.joda.time.MutableDateTime.Property.roundCeiling	(	): Round to the highest whole unit of this field.
org.joda.time.MutableDateTime.Property.roundFloor	(	): Round to the lowest whole unit of this field.
org.joda.time.MutableDateTime.Property.roundHalfCeiling	(	): Round to the nearest whole unit of this field, favoring the ceiling if halfway.
org.joda.time.MutableDateTime.Property.roundHalfEven	(	): Round to the nearest whole unit of this field. If halfway, the ceiling is favored over the floor only if it makes this field's value even.
org.joda.time.MutableDateTime.Property.roundHalfFloor	(	): Round to the nearest whole unit of this field, favoring the floor if halfway.
org.joda.time.MutableDateTime.Property.set	(	String	): Sets a text value.
org.joda.time.MutableDateTime.Property.set	(	String	Locale	): Sets a text value.
org.joda.time.MutableDateTime.Property.set	(	int	): Sets a value.
org.joda.time.MutableDateTime.Property.writeObject	(	ObjectOutputStream	): Writes the property in a safe serialization format.
org.joda.time.MutableDateTime.add	(	DurationFieldType	int	): Adds to the instant specifying the duration and multiple to add.
org.joda.time.MutableDateTime.add	(	ReadableDuration	): Adds a duration to this instant.  This will typically change the value of most fields.
org.joda.time.MutableDateTime.add	(	ReadableDuration	int	): Adds a duration to this instant specifying how many times to add.  This will typically change the value of most fields.
org.joda.time.MutableDateTime.add	(	ReadablePeriod	): Adds a period to this instant.  This will typically change the value of most fields.
org.joda.time.MutableDateTime.add	(	ReadablePeriod	int	): Adds a period to this instant specifying how many times to add.  This will typically change the value of most fields.
org.joda.time.MutableDateTime.add	(	long	): Add an amount of time to the datetime.
org.joda.time.MutableDateTime.addDays	(	int	): Add a number of days to the date.
org.joda.time.MutableDateTime.addHours	(	int	): Add a number of hours to the date.
org.joda.time.MutableDateTime.addMillis	(	int	): Add a number of milliseconds to the date. The implementation of this method differs from the add() method in that a DateTimeField performs the addition.
org.joda.time.MutableDateTime.addMinutes	(	int	): Add a number of minutes to the date.
org.joda.time.MutableDateTime.addMonths	(	int	): Add a number of months to the date.
org.joda.time.MutableDateTime.addSeconds	(	int	): Add a number of seconds to the date.
org.joda.time.MutableDateTime.addWeeks	(	int	): Add a number of weeks to the date.
org.joda.time.MutableDateTime.addWeekyears	(	int	): Add a number of weekyears to the date.
org.joda.time.MutableDateTime.addYears	(	int	): Add a number of years to the date.
org.joda.time.MutableDateTime.centuryOfEra	(	): Get the century of era property.
org.joda.time.MutableDateTime.clone	(	): Clone this object.
org.joda.time.MutableDateTime.copy	(	): Clone this object without having to cast the returned object.
org.joda.time.MutableDateTime.dayOfMonth	(	): Get the day of month property.  The values for day of month are defined in DateTimeConstants.
org.joda.time.MutableDateTime.dayOfWeek	(	): Get the day of week property.  The values for day of week are defined in DateTimeConstants.
org.joda.time.MutableDateTime.dayOfYear	(	): Get the day of year property.
org.joda.time.MutableDateTime.era	(	): Get the era property.
org.joda.time.MutableDateTime.getRoundingField	(	): Gets the field used for rounding this instant, returning null if rounding is not enabled.
org.joda.time.MutableDateTime.getRoundingMode	(	): Gets the rounding mode for this instant, returning ROUND_NONE if rounding is not enabled.
org.joda.time.MutableDateTime.hourOfDay	(	): Get the hour of day field property
org.joda.time.MutableDateTime.millisOfDay	(	): Get the millis of day property  Calling a setter on the property will replace the values of milli-of-second, second-of-minute, minute-of-hour and hour-of-day.
org.joda.time.MutableDateTime.millisOfSecond	(	): Get the millis of second property
org.joda.time.MutableDateTime.minuteOfDay	(	): Get the minute of day property  Calling a setter on the property will replace the values of minute-of-hour and hour-of-day.
org.joda.time.MutableDateTime.minuteOfHour	(	): Get the minute of hour field property
org.joda.time.MutableDateTime.monthOfYear	(	): Get the month of year property.
org.joda.time.MutableDateTime.now	(	): Obtains a MutableDateTime set to the current system millisecond time using ISOChronology in the default time zone.
org.joda.time.MutableDateTime.now	(	Chronology	): Obtains a MutableDateTime set to the current system millisecond time using the specified chronology.
org.joda.time.MutableDateTime.now	(	DateTimeZone	): Obtains a MutableDateTime set to the current system millisecond time using ISOChronology in the specified time zone.
org.joda.time.MutableDateTime.parse	(	String	): Parses a MutableDateTime from the specified string.  This uses dateTimeParser().
org.joda.time.MutableDateTime.parse	(	String	DateTimeFormatter	): Parses a MutableDateTime from the specified string using a formatter.
org.joda.time.MutableDateTime.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.MutableDateTime.secondOfDay	(	): Get the second of day property  Calling a setter on the property will replace the values of second-of-minute, minute-of-hour and hour-of-day.
org.joda.time.MutableDateTime.secondOfMinute	(	): Get the second of minute field property
org.joda.time.MutableDateTime.set	(	DateTimeFieldType	int	): Sets the value of one of the fields of the instant, such as hourOfDay.
org.joda.time.MutableDateTime.setChronology	(	Chronology	): Set the chronology of the datetime.  All changes to the chronology occur via this method.
org.joda.time.MutableDateTime.setDate	(	ReadableInstant	): Set the date from another instant. The time part of this object will be unaffected.  If the input is a ReadableDateTime then it is converted to the same time-zone as this object before using the instant millis.
org.joda.time.MutableDateTime.setDate	(	int	int	int	): Set the date from fields. The time part of this object will be unaffected.
org.joda.time.MutableDateTime.setDate	(	long	): Set the date from milliseconds. The time part of this object will be unaffected.
org.joda.time.MutableDateTime.setDateTime	(	int	int	int	int	int	int	int	): Set the date and time from fields.
org.joda.time.MutableDateTime.setDayOfMonth	(	int	): Set the day of the month to the specified value.
org.joda.time.MutableDateTime.setDayOfWeek	(	int	): Set the day of week to the specified value.
org.joda.time.MutableDateTime.setDayOfYear	(	int	): Set the day of year to the specified value.
org.joda.time.MutableDateTime.setHourOfDay	(	int	): Set the hour of the day to the specified value.
org.joda.time.MutableDateTime.setMillis	(	ReadableInstant	): Sets the millisecond instant of this instant from another.  This method does not change the chronology of this instant, just the millisecond instant.
org.joda.time.MutableDateTime.setMillis	(	long	): Set the milliseconds of the datetime.  All changes to the millisecond field occurs via this method.
org.joda.time.MutableDateTime.setMillisOfDay	(	int	): Set the millis of the day to the specified value.  Setting this will replace the values of milli-of-second, second-of-minute, minute-of-hour and hour-of-day.
org.joda.time.MutableDateTime.setMillisOfSecond	(	int	): Set the millis of the second to the specified value.
org.joda.time.MutableDateTime.setMinuteOfDay	(	int	): Set the minute of the day to the specified value.  Setting this will replace the values of minute-of-hour and hour-of-day.
org.joda.time.MutableDateTime.setMinuteOfHour	(	int	): Set the minute of the hour to the specified value.
org.joda.time.MutableDateTime.setMonthOfYear	(	int	): Set the month of the year to the specified value.
org.joda.time.MutableDateTime.setRounding	(	DateTimeField	): Sets the status of rounding to use the specified field and ROUND_FLOOR mode. A null field will disable rounding. Once set, the instant is then rounded using the new field and mode.  Enabling rounding will cause all subsequent calls to setMillis() to be rounded. This can be used to control the precision of the instant, for example by setting a rounding field of minuteOfDay, the seconds and milliseconds will always be zero.
org.joda.time.MutableDateTime.setRounding	(	DateTimeField	int	): Sets the status of rounding to use the specified field and mode. A null field or mode of ROUND_NONE will disable rounding. Once set, the instant is then rounded using the new field and mode.  Enabling rounding will cause all subsequent calls to setMillis() to be rounded. This can be used to control the precision of the instant, for example by setting a rounding field of minuteOfDay, the seconds and milliseconds will always be zero.
org.joda.time.MutableDateTime.setSecondOfDay	(	int	): Set the second of the day to the specified value.  Setting this will replace the values of second-of-minute, minute-of-hour and hour-of-day.
org.joda.time.MutableDateTime.setSecondOfMinute	(	int	): Set the second of the minute to the specified value.
org.joda.time.MutableDateTime.setTime	(	ReadableInstant	): Set the time from another instant. The date part of this object will be unaffected.
org.joda.time.MutableDateTime.setTime	(	int	int	int	int	): Set the time from fields. The date part of this object will be unaffected.
org.joda.time.MutableDateTime.setTime	(	long	): Set the time from milliseconds. The date part of this object will be unaffected.
org.joda.time.MutableDateTime.setWeekOfWeekyear	(	int	): Set the week of weekyear to the specified value.
org.joda.time.MutableDateTime.setWeekyear	(	int	): Set the weekyear to the specified value.
org.joda.time.MutableDateTime.setYear	(	int	): Set the year to the specified value.
org.joda.time.MutableDateTime.setZone	(	DateTimeZone	): Sets the time zone of the datetime, changing the chronology and field values.  Changing the zone using this method retains the millisecond instant. The millisecond instant is adjusted in the new zone to compensate. chronology. Setting the time zone does not affect the millisecond value of this instant.  If the chronology already has this time zone, no change occurs.
org.joda.time.MutableDateTime.setZoneRetainFields	(	DateTimeZone	): Sets the time zone of the datetime, changing the chronology and millisecond.  Changing the zone using this method retains the field values. The millisecond instant is adjusted in the new zone to compensate.  If the chronology already has this time zone, no change occurs.
org.joda.time.MutableDateTime.weekOfWeekyear	(	): Get the week of a week based year property.
org.joda.time.MutableDateTime.weekyear	(	): Get the year of a week based year property.
org.joda.time.MutableDateTime.year	(	): Get the year property.
org.joda.time.MutableDateTime.yearOfCentury	(	): Get the year of century property.
org.joda.time.MutableDateTime.yearOfEra	(	): Get the year of era property.
org.joda.time.MutableInterval: MutableInterval is the standard implementation of a mutable time interval.  A time interval represents a period of time between two instants. Intervals are inclusive of the start instant and exclusive of the end. The end instant is always greater than or equal to the start instant.  Intervals have a fixed millisecond duration. This is the difference between the start and end instants. The duration is represented separately by ReadableDuration. As a result, intervals are not comparable. To compare the length of two intervals, you should compare their durations.  An interval can also be converted to a ReadablePeriod. This represents the difference between the start and end points in terms of fields such as years and days.  If performing significant calculations on an interval, it may be faster to convert an Interval object to a MutableInterval one.  MutableInterval is mutable and not thread-safe, unless concurrent threads are not invoking mutator methods.
org.joda.time.MutableInterval.MutableInterval	(	): Constructs a zero length time interval from 1970-01-01 to 1970-01-01.
org.joda.time.MutableInterval.MutableInterval	(	Object	): Constructs a time interval by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInterval and String. The String formats are described by dateTimeParser() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.
org.joda.time.MutableInterval.MutableInterval	(	Object	Chronology	): Constructs a time interval by converting or copying from another object, overriding the chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInterval and String. The String formats are described by dateTimeParser() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.
org.joda.time.MutableInterval.MutableInterval	(	ReadableDuration	ReadableInstant	): Constructs an interval from a millisecond duration and an end instant.
org.joda.time.MutableInterval.MutableInterval	(	ReadableInstant	ReadableDuration	): Constructs an interval from a start instant and a duration.
org.joda.time.MutableInterval.MutableInterval	(	ReadableInstant	ReadableInstant	): Constructs an interval from a start and end instant.  The chronology used is that of the start instant.
org.joda.time.MutableInterval.MutableInterval	(	ReadableInstant	ReadablePeriod	): Constructs an interval from a start instant and a time period.  When forming the interval, the chronology from the instant is used if present, otherwise the chronology of the period is used.
org.joda.time.MutableInterval.MutableInterval	(	ReadablePeriod	ReadableInstant	): Constructs an interval from a time period and an end instant.  When forming the interval, the chronology from the instant is used if present, otherwise the chronology of the period is used.
org.joda.time.MutableInterval.MutableInterval	(	long	long	): Constructs an interval from a start and end instant with the ISO default chronology.
org.joda.time.MutableInterval.MutableInterval	(	long	long	Chronology	): Constructs an interval from a start and end instant with a chronology.
org.joda.time.MutableInterval.clone	(	): Clone this object.
org.joda.time.MutableInterval.copy	(	): Clone this object without having to cast the returned object.
org.joda.time.MutableInterval.parse	(	String	): Parses a MutableInterval from the specified string.  The String formats are described by dateTimeParser() and standard(), and may be 'datetime/datetime', 'datetime/period' or 'period/datetime'.
org.joda.time.MutableInterval.setChronology	(	Chronology	): Sets the chronology of this time interval.
org.joda.time.MutableInterval.setDurationAfterStart	(	ReadableDuration	): Sets the duration of this time interval, preserving the start instant.
org.joda.time.MutableInterval.setDurationAfterStart	(	long	): Sets the duration of this time interval, preserving the start instant.
org.joda.time.MutableInterval.setDurationBeforeEnd	(	ReadableDuration	): Sets the duration of this time interval, preserving the end instant.
org.joda.time.MutableInterval.setDurationBeforeEnd	(	long	): Sets the duration of this time interval, preserving the end instant.
org.joda.time.MutableInterval.setEnd	(	ReadableInstant	): Sets the end of this time interval as an Instant.
org.joda.time.MutableInterval.setEndMillis	(	long	): Sets the end of this time interval.
org.joda.time.MutableInterval.setInterval	(	ReadableInstant	ReadableInstant	): Sets this interval from two instants, replacing the chronology with that from the start instant.
org.joda.time.MutableInterval.setInterval	(	ReadableInterval	): Sets this interval to be the same as another.
org.joda.time.MutableInterval.setInterval	(	long	long	): Sets this interval from two millisecond instants retaining the chronology.
org.joda.time.MutableInterval.setPeriodAfterStart	(	ReadablePeriod	): Sets the period of this time interval, preserving the start instant and using the ISOChronology in the default zone for calculations.
org.joda.time.MutableInterval.setPeriodBeforeEnd	(	ReadablePeriod	): Sets the period of this time interval, preserving the end instant and using the ISOChronology in the default zone for calculations.
org.joda.time.MutableInterval.setStart	(	ReadableInstant	): Sets the start of this time interval as an Instant.
org.joda.time.MutableInterval.setStartMillis	(	long	): Sets the start of this time interval.
org.joda.time.MutablePeriod: Standard mutable time period implementation.  A time period is divided into a number of fields, such as hours and seconds. Which fields are supported is defined by the PeriodType class. The default is the standard period type, which supports years, months, weeks, days, hours, minutes, seconds and millis.  When this time period is added to an instant, the effect is of adding each field in turn. As a result, this takes into account daylight savings time. Adding a time period of 1 day to the day before daylight savings starts will only add 23 hours rather than 24 to ensure that the time remains the same. If this is not the behaviour you want, then see Duration.  The definition of a period also affects the equals method. A period of 1 day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes. This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary). To compare the actual duration of two periods, convert both to durations using toDuration, an operation that emphasises that the result may differ according to the date you choose.  MutablePeriod is mutable and not thread-safe, unless concurrent threads are not invoking mutator methods.
org.joda.time.MutablePeriod.MutablePeriod	(	): Creates a zero-length period using the standard period type.
org.joda.time.MutablePeriod.MutablePeriod	(	Object	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.MutablePeriod.MutablePeriod	(	Object	Chronology	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.MutablePeriod.MutablePeriod	(	Object	PeriodType	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.MutablePeriod.MutablePeriod	(	Object	PeriodType	Chronology	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.MutablePeriod.MutablePeriod	(	PeriodType	): Creates a zero-length period using the specified period type.
org.joda.time.MutablePeriod.MutablePeriod	(	ReadableDuration	ReadableInstant	): Creates a period from the given duration and end point.
org.joda.time.MutablePeriod.MutablePeriod	(	ReadableDuration	ReadableInstant	PeriodType	): Creates a period from the given duration and end point.
org.joda.time.MutablePeriod.MutablePeriod	(	ReadableInstant	ReadableDuration	): Creates a period from the given start point and the duration.
org.joda.time.MutablePeriod.MutablePeriod	(	ReadableInstant	ReadableDuration	PeriodType	): Creates a period from the given start point and the duration.
org.joda.time.MutablePeriod.MutablePeriod	(	ReadableInstant	ReadableInstant	): Creates a period from the given interval endpoints using the standard set of fields.  The chronology of the start instant is used, unless that is null when the chronology of the end instant is used instead.
org.joda.time.MutablePeriod.MutablePeriod	(	ReadableInstant	ReadableInstant	PeriodType	): Creates a period from the given interval endpoints.  The chronology of the start instant is used, unless that is null when the chronology of the end instant is used instead.
org.joda.time.MutablePeriod.MutablePeriod	(	int	int	int	int	): Create a period from a set of field values using the standard set of fields.
org.joda.time.MutablePeriod.MutablePeriod	(	int	int	int	int	int	int	int	int	): Create a period from a set of field values using the standard set of fields.
org.joda.time.MutablePeriod.MutablePeriod	(	int	int	int	int	int	int	int	int	PeriodType	): Create a period from a set of field values.
org.joda.time.MutablePeriod.MutablePeriod	(	long	): Creates a period from the given millisecond duration using the standard set of fields.  Only precise fields in the period type will be used. For the standard period type this is the time fields only. Thus the year, month, week and day fields will not be populated.  If the duration is small, less than one day, then this method will perform as you might expect and split the fields evenly.  If the duration is larger than one day then all the remaining duration will be stored in the largest available precise field, hours in this case.  For example, a duration equal to (365 + 60 + 5) days will be converted to ((365 + 60 + 5) * 24) hours by this constructor.  For more control over the conversion process, you have two options:  convert the duration to an Interval, and from there obtain the period specify a period type that contains precise definitions of the day and larger fields, such as the UTC or precise types. 
org.joda.time.MutablePeriod.MutablePeriod	(	long	Chronology	): Creates a period from the given millisecond duration using the standard set of fields.  Only precise fields in the period type will be used. Imprecise fields will not be populated.  If the duration is small then this method will perform as you might expect and split the fields evenly.  If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.
org.joda.time.MutablePeriod.MutablePeriod	(	long	PeriodType	): Creates a period from the given millisecond duration.  Only precise fields in the period type will be used. Imprecise fields will not be populated.  If the duration is small then this method will perform as you might expect and split the fields evenly.  If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.
org.joda.time.MutablePeriod.MutablePeriod	(	long	PeriodType	Chronology	): Creates a period from the given millisecond duration.  Only precise fields in the period type will be used. Imprecise fields will not be populated.  If the duration is small then this method will perform as you might expect and split the fields evenly.  If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.
org.joda.time.MutablePeriod.MutablePeriod	(	long	long	): Creates a period from the given interval endpoints using the standard set of fields.
org.joda.time.MutablePeriod.MutablePeriod	(	long	long	Chronology	): Creates a period from the given interval endpoints using the standard set of fields.
org.joda.time.MutablePeriod.MutablePeriod	(	long	long	PeriodType	): Creates a period from the given interval endpoints.
org.joda.time.MutablePeriod.MutablePeriod	(	long	long	PeriodType	Chronology	): Creates a period from the given interval endpoints.
org.joda.time.MutablePeriod.add	(	DurationFieldType	int	): Adds to the value of one of the fields.  The field type specified must be one of those that is supported by the period.
org.joda.time.MutablePeriod.add	(	ReadableDuration	): Adds a duration to this one by dividing the duration into fields and calling add().
org.joda.time.MutablePeriod.add	(	ReadableInterval	): Adds an interval to this one by dividing the interval into fields and calling add().
org.joda.time.MutablePeriod.add	(	ReadablePeriod	): Adds a period to this one by adding each field in turn.
org.joda.time.MutablePeriod.add	(	int	int	int	int	int	int	int	int	): Adds to each field of this period.
org.joda.time.MutablePeriod.add	(	long	): Adds a millisecond duration to this one by dividing the duration into fields and calling add().  When dividing the duration, only precise fields in the period type will be used. For large durations, all the remaining duration will be stored in the largest available precise field.
org.joda.time.MutablePeriod.add	(	long	Chronology	): Adds a millisecond duration to this one by dividing the duration into fields and calling add().  When dividing the duration, only precise fields in the period type will be used. For large durations, all the remaining duration will be stored in the largest available precise field.
org.joda.time.MutablePeriod.addDays	(	int	): Adds the specified days to the number of days in the period.
org.joda.time.MutablePeriod.addHours	(	int	): Adds the specified hours to the number of hours in the period.
org.joda.time.MutablePeriod.addMillis	(	int	): Adds the specified millis to the number of millis in the period.
org.joda.time.MutablePeriod.addMinutes	(	int	): Adds the specified minutes to the number of minutes in the period.
org.joda.time.MutablePeriod.addMonths	(	int	): Adds the specified months to the number of months in the period.
org.joda.time.MutablePeriod.addSeconds	(	int	): Adds the specified seconds to the number of seconds in the period.
org.joda.time.MutablePeriod.addWeeks	(	int	): Adds the specified weeks to the number of weeks in the period.
org.joda.time.MutablePeriod.addYears	(	int	): Adds the specified years to the number of years in the period.
org.joda.time.MutablePeriod.clear	(	): Clears the period, setting all values back to zero.
org.joda.time.MutablePeriod.clone	(	): Clone this object.
org.joda.time.MutablePeriod.copy	(	): Clone this object without having to cast the returned object.
org.joda.time.MutablePeriod.getDays	(	): Gets the days field part of the period.
org.joda.time.MutablePeriod.getHours	(	): Gets the hours field part of the period.
org.joda.time.MutablePeriod.getMillis	(	): Gets the millis field part of the period.
org.joda.time.MutablePeriod.getMinutes	(	): Gets the minutes field part of the period.
org.joda.time.MutablePeriod.getMonths	(	): Gets the months field part of the period.
org.joda.time.MutablePeriod.getSeconds	(	): Gets the seconds field part of the period.
org.joda.time.MutablePeriod.getWeeks	(	): Gets the weeks field part of the period.
org.joda.time.MutablePeriod.getYears	(	): Gets the years field part of the period.
org.joda.time.MutablePeriod.mergePeriod	(	ReadablePeriod	): Merges all the fields from the specified period into this one.  Fields that are not present in the specified period are left unaltered.
org.joda.time.MutablePeriod.parse	(	String	): Parses a MutablePeriod from the specified string.  This uses standard().
org.joda.time.MutablePeriod.parse	(	String	PeriodFormatter	): Parses a MutablePeriod from the specified string using a formatter.
org.joda.time.MutablePeriod.set	(	DurationFieldType	int	): Sets the value of one of the fields.  The field type specified must be one of those that is supported by the period.
org.joda.time.MutablePeriod.setDays	(	int	): Sets the number of days of the period.
org.joda.time.MutablePeriod.setHours	(	int	): Sets the number of hours of the period.
org.joda.time.MutablePeriod.setMillis	(	int	): Sets the number of millis of the period.
org.joda.time.MutablePeriod.setMinutes	(	int	): Sets the number of minutes of the period.
org.joda.time.MutablePeriod.setMonths	(	int	): Sets the number of months of the period.
org.joda.time.MutablePeriod.setPeriod	(	ReadableDuration	): Sets all the fields in one go from a duration dividing the fields using the period type.  When dividing the duration, only precise fields in the period type will be used. For large durations, all the remaining duration will be stored in the largest available precise field.
org.joda.time.MutablePeriod.setPeriod	(	ReadableDuration	Chronology	): Sets all the fields in one go from a duration dividing the fields using the period type.  When dividing the duration, only precise fields in the period type will be used. For large durations, all the remaining duration will be stored in the largest available precise field.
org.joda.time.MutablePeriod.setPeriod	(	ReadableInstant	ReadableInstant	): Sets all the fields in one go from two instants representing an interval.  The chronology of the start instant is used, unless that is null when the chronology of the end instant is used instead.
org.joda.time.MutablePeriod.setPeriod	(	ReadableInterval	): Sets all the fields in one go from an interval using the ISO chronology and dividing the fields using the period type.
org.joda.time.MutablePeriod.setPeriod	(	ReadablePeriod	): Sets all the fields in one go from another ReadablePeriod.
org.joda.time.MutablePeriod.setPeriod	(	int	int	int	int	int	int	int	int	): Sets all the fields in one go.
org.joda.time.MutablePeriod.setPeriod	(	long	): Sets all the fields in one go from a millisecond duration dividing the fields using the period type.  When dividing the duration, only precise fields in the period type will be used. For large durations, all the remaining duration will be stored in the largest available precise field.
org.joda.time.MutablePeriod.setPeriod	(	long	Chronology	): Sets all the fields in one go from a millisecond duration.  When dividing the duration, only precise fields in the period type will be used. For large durations, all the remaining duration will be stored in the largest available precise field.
org.joda.time.MutablePeriod.setPeriod	(	long	long	): Sets all the fields in one go from a millisecond interval using ISOChronology and dividing the fields using the period type.
org.joda.time.MutablePeriod.setPeriod	(	long	long	Chronology	): Sets all the fields in one go from a millisecond interval.
org.joda.time.MutablePeriod.setSeconds	(	int	): Sets the number of seconds of the period.
org.joda.time.MutablePeriod.setValue	(	int	int	): Sets the value of one of the fields by index.
org.joda.time.MutablePeriod.setWeeks	(	int	): Sets the number of weeks of the period.
org.joda.time.MutablePeriod.setYears	(	int	): Sets the number of years of the period.
org.joda.time.Partial: Partial is an immutable partial datetime supporting any set of datetime fields.  A Partial instance can be used to hold any combination of fields. The instance does not contain a time zone, so any datetime is local.  A Partial can be matched against an instant using isMatch(). This method compares each field on this partial with those of the instant and determines if the partial matches the instant. Given this definition, an empty Partial instance represents any datetime and always matches.  Calculations on Partial are performed using a Chronology. This chronology is set to be in the UTC time zone for all calculations.  Each individual field can be queried in two ways:  get(DateTimeFieldType.monthOfYear()) property(DateTimeFieldType.monthOfYear()).get()  The second technique also provides access to other useful methods on the field:  numeric value - monthOfYear().get() text value - monthOfYear().getAsText() short text value - monthOfYear().getAsShortText() maximum/minimum values - monthOfYear().getMaximumValue() add/subtract - monthOfYear().addToCopy() set - monthOfYear().setCopy()   Partial is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.Partial.Partial	(	): Constructs a Partial with no fields or values, which can be considered to represent any date.  This is most useful when constructing partials, for example:  Partial p = new Partial() .with(DateTimeFieldType.dayOfWeek(), 5) .with(DateTimeFieldType.hourOfDay(), 12) .with(DateTimeFieldType.minuteOfHour(), 20);  Note that, although this is a clean way to write code, it is fairly inefficient internally.  The constructor uses the default ISO chronology.
org.joda.time.Partial.Partial	(	Chronology	): Constructs a Partial with no fields or values, which can be considered to represent any date.  This is most useful when constructing partials, for example:  Partial p = new Partial(chrono) .with(DateTimeFieldType.dayOfWeek(), 5) .with(DateTimeFieldType.hourOfDay(), 12) .with(DateTimeFieldType.minuteOfHour(), 20);  Note that, although this is a clean way to write code, it is fairly inefficient internally.
org.joda.time.Partial.Partial	(	Chronology	DateTimeFieldType[]	int[]	): Constructs a Partial with the specified chronology, fields and values. This constructor assigns and performs no validation.
org.joda.time.Partial.Partial	(	DateTimeFieldType	int	): Constructs a Partial with the specified field and value.  The constructor uses the default ISO chronology.
org.joda.time.Partial.Partial	(	DateTimeFieldType	int	Chronology	): Constructs a Partial with the specified field and value.  The constructor uses the specified chronology.
org.joda.time.Partial.Partial	(	DateTimeFieldType[]	int[]	): Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. For year and weekyear fields with equal duration, year is defined as being larger than weekyear.  The constructor uses the specified chronology.
org.joda.time.Partial.Partial	(	DateTimeFieldType[]	int[]	Chronology	): Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. For year and weekyear fields with equal duration, year is defined as being larger than weekyear.  The constructor uses the specified chronology.
org.joda.time.Partial.Partial	(	Partial	int[]	): Constructs a Partial with the specified values. This constructor assigns and performs no validation.
org.joda.time.Partial.Partial	(	ReadablePartial	): Constructs a Partial by copying all the fields and types from another partial.  This is most useful when copying from a YearMonthDay or TimeOfDay.
org.joda.time.Partial.Property: The property class for Partial.  This class binds a Partial to a DateTimeField.
org.joda.time.Partial.Property.Property	(	Partial	int	): Constructs a property.
org.joda.time.Partial.Property.addToCopy	(	int	): Adds to the value of this field in a copy of this Partial.  The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected.  If the result would be too large, beyond the maximum year, then an IllegalArgumentException is thrown.  The Partial attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.Partial.Property.addWrapFieldToCopy	(	int	): Adds to the value of this field in a copy of this Partial wrapping within this field if the maximum value is reached.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps within this field. Other fields are unaffected.  For example, 2004-12-20 addWrapField one month returns 2004-01-20.  The Partial attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.Partial.Property.get	(	): Gets the value of this field.
org.joda.time.Partial.Property.getField	(	): Gets the field that this property uses.
org.joda.time.Partial.Property.getPartial	(	): Gets the partial that this property belongs to.
org.joda.time.Partial.Property.getReadablePartial	(	): Gets the partial that this property belongs to.
org.joda.time.Partial.Property.setCopy	(	String	): Sets this field in a copy of the Partial to a parsed text value.  The Partial attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.Partial.Property.setCopy	(	String	Locale	): Sets this field in a copy of the Partial to a parsed text value.  The Partial attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.Partial.Property.setCopy	(	int	): Sets this field in a copy of the Partial.  The Partial attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.Partial.Property.withMaximumValue	(	): Returns a new Partial with this field set to the maximum value for this field.  The Partial attached to this property is unchanged by this call.
org.joda.time.Partial.Property.withMinimumValue	(	): Returns a new Partial with this field set to the minimum value for this field.  The Partial attached to this property is unchanged by this call.
org.joda.time.Partial.getChronology	(	): Gets the chronology of the partial which is never null.  The Chronology is the calculation engine behind the partial and provides conversion and validation of the fields in a particular calendar system.
org.joda.time.Partial.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.
org.joda.time.Partial.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.Partial.getFieldTypes	(	): Gets an array of the field type of each of the fields that this partial supports.  The fields are returned largest to smallest.
org.joda.time.Partial.getFormatter	(	): Gets a formatter suitable for the fields in this partial.  If there is no appropriate ISO format, null is returned. This method may return a formatter that does not display all the fields of the partial. This might occur when you have overlapping fields, such as dayOfWeek and dayOfMonth.
org.joda.time.Partial.getValue	(	int	): Gets the value of the field at the specified index.
org.joda.time.Partial.getValues	(	): Gets an array of the value of each of the fields that this partial supports.  The fields are returned largest to smallest. Each value corresponds to the same array index as getFieldTypes()
org.joda.time.Partial.isMatch	(	ReadableInstant	): Does this partial match the specified instant.  A match occurs when all the fields of this partial are the same as the corresponding fields on the specified instant.
org.joda.time.Partial.isMatch	(	ReadablePartial	): Does this partial match the specified partial.  A match occurs when all the fields of this partial are the same as the corresponding fields on the specified partial.
org.joda.time.Partial.minus	(	ReadablePeriod	): Gets a copy of this instance with the specified period take away.  If the amount is zero or null, then this is returned.
org.joda.time.Partial.plus	(	ReadablePeriod	): Gets a copy of this instance with the specified period added.  If the amount is zero or null, then this is returned.
org.joda.time.Partial.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods for getting and manipulating the partial.  See also get().
org.joda.time.Partial.size	(	): Gets the number of fields in this partial.
org.joda.time.Partial.toString	(	): Output the date in an appropriate ISO8601 format.  This method will output the partial in one of two ways. If getFormatter()  If there is no appropriate ISO format a dump of the fields is output via toStringList().
org.joda.time.Partial.toString	(	String	): Output the date using the specified format pattern. Unsupported fields will appear as special unicode characters.
org.joda.time.Partial.toString	(	String	Locale	): Output the date using the specified format pattern. Unsupported fields will appear as special unicode characters.
org.joda.time.Partial.toStringList	(	): Gets a string version of the partial that lists all the fields.  This method exists to provide a better debugging toString than the standard toString. This method lists all the fields and their values in a style similar to the collections framework.
org.joda.time.Partial.with	(	DateTimeFieldType	int	): Gets a copy of this date with the specified field set to a new value.  If this partial did not previously support the field, the new one will. Contrast this behaviour with withField().  For example, if the field type is dayOfMonth then the day would be changed/added in the returned instance.
org.joda.time.Partial.withChronologyRetainFields	(	Chronology	): Creates a new Partial instance with the specified chronology. This instance is immutable and unaffected by this method call.  This method retains the values of the fields, thus the result will typically refer to a different instant.  The time zone of the specified chronology is ignored, as Partial operates without a time zone.
org.joda.time.Partial.withField	(	DateTimeFieldType	int	): Gets a copy of this Partial with the specified field set to a new value.  If this partial does not support the field, an exception is thrown. Contrast this behaviour with with().  For example, if the field type is dayOfMonth then the day would be changed in the returned instance if supported.
org.joda.time.Partial.withFieldAddWrapped	(	DurationFieldType	int	): Gets a copy of this Partial with the value of the specified field increased. If this partial does not support the field, an exception is thrown.  If the addition is zero, then this is returned. The addition will overflow into larger fields (eg. minute to hour). If the maximum is reached, the addition will wrap.
org.joda.time.Partial.withFieldAdded	(	DurationFieldType	int	): Gets a copy of this Partial with the value of the specified field increased. If this partial does not support the field, an exception is thrown.  If the addition is zero, then this is returned. The addition will overflow into larger fields (eg. minute to hour). However, it will not wrap around if the top maximum is reached.
org.joda.time.Partial.withPeriodAdded	(	ReadablePeriod	int	): Gets a copy of this Partial with the specified period added.  If the addition is zero, then this is returned. Fields in the period that aren't present in the partial are ignored.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using the method withFieldAdded().
org.joda.time.Partial.without	(	DateTimeFieldType	): Gets a copy of this date with the specified field removed.  If this partial did not previously support the field, no error occurs.
org.joda.time.Period: An immutable time period specifying a set of duration field values.  A time period is divided into a number of fields, such as hours and seconds. Which fields are supported is defined by the PeriodType class. The default is the standard period type, which supports years, months, weeks, days, hours, minutes, seconds and millis.  When this time period is added to an instant, the effect is of adding each field in turn. As a result, this takes into account daylight savings time. Adding a time period of 1 day to the day before daylight savings starts will only add 23 hours rather than 24 to ensure that the time remains the same. If this is not the behaviour you want, then see Duration.  The definition of a period also affects the equals method. A period of 1 day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes. This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary). To compare the actual duration of two periods, convert both to durations using toDuration, an operation that emphasises that the result may differ according to the date you choose.  Period is thread-safe and immutable, provided that the PeriodType is as well. All standard PeriodType classes supplied are thread-safe and immutable.
org.joda.time.Period.Period	(	): Creates a new empty period with the standard set of fields.  One way to initialise a period is as follows:  Period = new Period().withYears(6).withMonths(3).withSeconds(23);  Bear in mind that this creates four period instances in total, three of which are immediately discarded. The alternative is more efficient, but less readable:  Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);  The following is also slightly less wasteful:  Period = Period.years(6).withMonths(3).withSeconds(23); 
org.joda.time.Period.Period	(	Object	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.Period.Period	(	Object	Chronology	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.Period.Period	(	Object	PeriodType	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.Period.Period	(	Object	PeriodType	Chronology	): Creates a period by converting or copying from another object.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadablePeriod, ReadableInterval and String. The String formats are described by standard().
org.joda.time.Period.Period	(	ReadableDuration	ReadableInstant	): Creates a period from the given duration and end point.
org.joda.time.Period.Period	(	ReadableDuration	ReadableInstant	PeriodType	): Creates a period from the given duration and end point.
org.joda.time.Period.Period	(	ReadableInstant	ReadableDuration	): Creates a period from the given start point and the duration.
org.joda.time.Period.Period	(	ReadableInstant	ReadableDuration	PeriodType	): Creates a period from the given start point and the duration.
org.joda.time.Period.Period	(	ReadableInstant	ReadableInstant	): Creates a period between the given instants using the standard set of fields.  Most calculations performed by this method have obvious results. The special case is where the calculation is from a "long" month to a "short" month. Here, the result favours increasing the months field rather than the days. For example, 2013-01-31 to 2013-02-28 is treated as one whole month. By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days (exposed as 4 weeks and 2 days). The results are explained by considering that the start date plus the calculated period result in the end date.  Another special case is around daylight savings. Consider the case where there is a DST gap from 01:00 to 02:00. The period from 00:30 to 02:30 will return one hour, not two, due to the missing hour. However, once the period exceeds one day, a different effect comes into play. Consider the period from 00:30 just before the DST gap to 02:30 one day later. Since this exceeds a day, the algorithm first adds one day following normal period rules, to get 00:30 one day later, and then adds 2 hours to reach 02:30. In this way, the DST gap effectively "disappears". In other words, the addition of days takes precedence over the addition of hours.
org.joda.time.Period.Period	(	ReadableInstant	ReadableInstant	PeriodType	): Creates a period between the given instants.  Most calculations performed by this method have obvious results. The special case is where the calculation is from a "long" month to a "short" month. Here, the result favours increasing the months field rather than the days. For example, 2013-01-31 to 2013-02-28 is treated as one whole month. By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days. The results are explained by considering that the start date plus the calculated period result in the end date.  Another special case is around daylight savings. Consider the case where there is a DST gap from 01:00 to 02:00. The period from 00:30 to 02:30 will return one hour, not two, due to the missing hour. However, once the period exceeds one day, a different effect comes into play. Consider the period from 00:30 just before the DST gap to 02:30 one day later. Since this exceeds a day, the algorithm first adds one day following normal period rules, to get 00:30 one day later, and then adds 2 hours to reach 02:30. In this way, the DST gap effectively "disappears". In other words, the addition of days takes precedence over the addition of hours.
org.joda.time.Period.Period	(	ReadablePartial	ReadablePartial	): Creates a period from two partially specified times.  The two partials must contain the same fields, thus you can specify two LocalDate objects, or two LocalTime objects, but not one of each. As these are Partial objects, time zones have no effect on the result.  The two partials must also both be contiguous - see isContiguous() for a definition. Both LocalDate and LocalTime are contiguous.  Most calculations performed by this method have obvious results. The special case is where the calculation is from a "long" month to a "short" month. Here, the result favours increasing the months field rather than the days. For example, 2013-01-31 to 2013-02-28 is treated as one whole month. By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days (exposed as 4 weeks and 2 days). The results are explained by considering that the start date plus the calculated period result in the end date.  An alternative way of constructing a Period from two Partials is fieldDifference(). That method handles all kinds of partials.
org.joda.time.Period.Period	(	ReadablePartial	ReadablePartial	PeriodType	): Creates a period from two partially specified times.  The two partials must contain the same fields, thus you can specify two LocalDate objects, or two LocalTime objects, but not one of each. As these are Partial objects, time zones have no effect on the result.  The two partials must also both be contiguous - see isContiguous() for a definition. Both LocalDate and LocalTime are contiguous.  Most calculations performed by this method have obvious results. The special case is where the calculation is from a "long" month to a "short" month. Here, the result favours increasing the months field rather than the days. For example, 2013-01-31 to 2013-02-28 is treated as one whole month. By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days. The results are explained by considering that the start date plus the calculated period result in the end date.  An alternative way of constructing a Period from two Partials is fieldDifference(). That method handles all kinds of partials.
org.joda.time.Period.Period	(	int	int	int	int	): Create a period from a set of field values using the standard set of fields. Note that the parameters specify the time fields hours, minutes, seconds and millis, not the date fields.
org.joda.time.Period.Period	(	int	int	int	int	int	int	int	int	): Create a period from a set of field values using the standard set of fields.
org.joda.time.Period.Period	(	int	int	int	int	int	int	int	int	PeriodType	): Create a period from a set of field values.  There is usually little need to use this constructor. The period type is used primarily to define how to split an interval into a period. As this constructor already is split, the period type does no real work.
org.joda.time.Period.Period	(	int[]	PeriodType	): Constructor used when we trust ourselves.
org.joda.time.Period.Period	(	long	): Creates a period from the given millisecond duration using the standard set of fields.  Only precise fields in the period type will be used. For the standard period type this is the time fields only. Thus the year, month, week and day fields will not be populated.  If the duration is small, less than one day, then this method will perform as you might expect and split the fields evenly.  If the duration is larger than one day then all the remaining duration will be stored in the largest available precise field, hours in this case.  For example, a duration equal to (365 + 60 + 5) days will be converted to ((365 + 60 + 5) * 24) hours by this constructor.  For more control over the conversion process, you have two options:  convert the duration to an Interval, and from there obtain the period specify a period type that contains precise definitions of the day and larger fields, such as UTC 
org.joda.time.Period.Period	(	long	Chronology	): Creates a period from the given millisecond duration using the standard set of fields.  Only precise fields in the period type will be used. Imprecise fields will not be populated.  If the duration is small then this method will perform as you might expect and split the fields evenly.  If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.
org.joda.time.Period.Period	(	long	PeriodType	): Creates a period from the given millisecond duration.  Only precise fields in the period type will be used. Imprecise fields will not be populated.  If the duration is small then this method will perform as you might expect and split the fields evenly.  If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.
org.joda.time.Period.Period	(	long	PeriodType	Chronology	): Creates a period from the given millisecond duration.  Only precise fields in the period type will be used. Imprecise fields will not be populated.  If the duration is small then this method will perform as you might expect and split the fields evenly.  If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.
org.joda.time.Period.Period	(	long	long	): Creates a period from the given interval endpoints using the standard set of fields.
org.joda.time.Period.Period	(	long	long	Chronology	): Creates a period from the given interval endpoints using the standard set of fields.
org.joda.time.Period.Period	(	long	long	PeriodType	): Creates a period from the given interval endpoints.
org.joda.time.Period.Period	(	long	long	PeriodType	Chronology	): Creates a period from the given interval endpoints.
org.joda.time.Period.checkYearsAndMonths	(	String	): Check that there are no years or months in the period.
org.joda.time.Period.days	(	int	): Create a period with a specified number of days.  The standard period type is used, thus you can add other fields such as months or weeks using the withXxx() methods. For example, Period.days(2).withHours(6);  If you want a day-based period that cannot have other fields added, then you should consider using Days.
org.joda.time.Period.fieldDifference	(	ReadablePartial	ReadablePartial	): Creates a period from two partially specified times, calculating by field difference.  The two partials must contain the same fields, thus you can specify two LocalDate objects, or two LocalTime objects, but not one of each. Also, the partial may not contain overlapping fields, such as dayOfWeek and dayOfMonth.  Calculation by field difference works by extracting the difference one field at a time and not wrapping into other fields. Thus 2005-06-09/2007-04-12 will yield P2Y-2M3D.  For example, you have an event that always runs from the 27th of each month to the 2nd of the next month. If you calculate this period using a standard constructor, then you will get between P3D and P6D depending on the month. If you use this method, then you will get P1M-25D. This field-difference based period can be successfully applied to each month of the year to obtain the correct end date for a given start date.
org.joda.time.Period.getDays	(	): Gets the days field part of the period.
org.joda.time.Period.getHours	(	): Gets the hours field part of the period.
org.joda.time.Period.getMillis	(	): Gets the millis field part of the period.
org.joda.time.Period.getMinutes	(	): Gets the minutes field part of the period.
org.joda.time.Period.getMonths	(	): Gets the months field part of the period.
org.joda.time.Period.getSeconds	(	): Gets the seconds field part of the period.
org.joda.time.Period.getWeeks	(	): Gets the weeks field part of the period.
org.joda.time.Period.getYears	(	): Gets the years field part of the period.
org.joda.time.Period.hours	(	int	): Create a period with a specified number of hours.  The standard period type is used, thus you can add other fields such as months or days using the withXxx() methods. For example, Period.hours(2).withMinutes(30);  If you want a hour-based period that cannot have other fields added, then you should consider using Hours.
org.joda.time.Period.millis	(	int	): Create a period with a specified number of millis.  The standard period type is used, thus you can add other fields such as days or hours using the withXxx() methods. For example, Period.millis(20).withSeconds(30);
org.joda.time.Period.minus	(	ReadablePeriod	): Returns a new period with the specified period subtracted.  Each field of the period is subtracted separately. Thus a period of 3 hours 30 minutes minus 2 hours 40 minutes will produce a result of 1 hour and -10 minutes - see normalizedStandard().  If the period being added contains a non-zero amount for a field that is not supported in this period then an exception is thrown.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusDays	(	int	): Returns a new period minus the specified number of days taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusHours	(	int	): Returns a new period minus the specified number of hours taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusMillis	(	int	): Returns a new period minus the specified number of millis taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusMinutes	(	int	): Returns a new period minus the specified number of minutes taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusMonths	(	int	): Returns a new period minus the specified number of months taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusSeconds	(	int	): Returns a new period minus the specified number of seconds taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusWeeks	(	int	): Returns a new period minus the specified number of weeks taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minusYears	(	int	): Returns a new period with the specified number of years taken away.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.minutes	(	int	): Create a period with a specified number of minutes.  The standard period type is used, thus you can add other fields such as days or hours using the withXxx() methods. For example, Period.minutes(2).withSeconds(30);  If you want a minute-based period that cannot have other fields added, then you should consider using Minutes.
org.joda.time.Period.months	(	int	): Create a period with a specified number of months.  The standard period type is used, thus you can add other fields such as years or days using the withXxx() methods. For example, Period.months(2).withDays(6);  If you want a month-based period that cannot have other fields added, then you should consider using Months.
org.joda.time.Period.multipliedBy	(	int	): Returns a new instance with each element in this period multiplied by the specified scalar.
org.joda.time.Period.negated	(	): Returns a new instance with each amount in this period negated.
org.joda.time.Period.normalizedStandard	(	): Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days.  The result will always have a PeriodType of standard, thus days will be grouped into weeks.
org.joda.time.Period.normalizedStandard	(	PeriodType	): Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute, providing control over how the result is split into fields.  This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days.  The PeriodType parameter controls how the result is created. It allows you to omit certain fields from the result if desired. For example, you may not want the result to include weeks, in which case you pass in PeriodType.yearMonthDayTime().
org.joda.time.Period.parse	(	String	): Parses a Period from the specified string.  This uses standard().
org.joda.time.Period.parse	(	String	PeriodFormatter	): Parses a Period from the specified string using a formatter.
org.joda.time.Period.plus	(	ReadablePeriod	): Returns a new period with the specified period added.  Each field of the period is added separately. Thus a period of 2 hours 30 minutes plus 3 hours 40 minutes will produce a result of 5 hours 70 minutes - see normalizedStandard().  If the period being added contains a non-zero amount for a field that is not supported in this period then an exception is thrown.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusDays	(	int	): Returns a new period plus the specified number of days added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusHours	(	int	): Returns a new period plus the specified number of hours added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusMillis	(	int	): Returns a new period plus the specified number of millis added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusMinutes	(	int	): Returns a new period plus the specified number of minutes added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusMonths	(	int	): Returns a new period plus the specified number of months added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusSeconds	(	int	): Returns a new period plus the specified number of seconds added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusWeeks	(	int	): Returns a new period plus the specified number of weeks added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.plusYears	(	int	): Returns a new period with the specified number of years added.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.seconds	(	int	): Create a period with a specified number of seconds.  The standard period type is used, thus you can add other fields such as days or hours using the withXxx() methods. For example, Period.seconds(2).withMillis(30);  If you want a second-based period that cannot have other fields added, then you should consider using Seconds.
org.joda.time.Period.toPeriod	(	): Get this period as an immutable Period object by returning this.
org.joda.time.Period.toStandardDays	(	): Converts this period to a period in days assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, an exception will be thrown.
org.joda.time.Period.toStandardDuration	(	): Converts this period to a duration assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert from a period to a duration. However to achieve this it makes the assumption that all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, an exception will be thrown.
org.joda.time.Period.toStandardHours	(	): Converts this period to a period in hours assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, an exception will be thrown.
org.joda.time.Period.toStandardMinutes	(	): Converts this period to a period in minutes assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, an exception will be thrown.
org.joda.time.Period.toStandardSeconds	(	): Converts this period to a period in seconds assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, an exception will be thrown.
org.joda.time.Period.toStandardWeeks	(	): Converts this period to a period in weeks assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.  If the period contains years or months, an exception will be thrown.
org.joda.time.Period.weeks	(	int	): Create a period with a specified number of weeks.  The standard period type is used, thus you can add other fields such as months or days using the withXxx() methods. For example, Period.weeks(2).withDays(6);  If you want a week-based period that cannot have other fields added, then you should consider using Weeks.
org.joda.time.Period.withDays	(	int	): Returns a new period with the specified number of days.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withField	(	DurationFieldType	int	): Creates a new Period instance with the specified field set to a new value.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withFieldAdded	(	DurationFieldType	int	): Creates a new Period instance with the valueToAdd added to the specified field.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withFields	(	ReadablePeriod	): Creates a new Period instance with the fields from the specified period copied on top of those from this period.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withHours	(	int	): Returns a new period with the specified number of hours.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withMillis	(	int	): Returns a new period with the specified number of millis.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withMinutes	(	int	): Returns a new period with the specified number of minutes.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withMonths	(	int	): Returns a new period with the specified number of months.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withPeriodType	(	PeriodType	): Creates a new Period instance with the same field values but different PeriodType.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withSeconds	(	int	): Returns a new period with the specified number of seconds.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withWeeks	(	int	): Returns a new period with the specified number of weeks.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.withYears	(	int	): Returns a new period with the specified number of years.  This period instance is immutable and unaffected by this method call.
org.joda.time.Period.years	(	int	): Create a period with a specified number of years.  The standard period type is used, thus you can add other fields such as months or days using the withXxx() methods. For example, Period.years(2).withMonths(6);  If you want a year-based period that cannot have other fields added, then you should consider using Years.
org.joda.time.PeriodType: Controls a period implementation by specifying which duration fields are to be used.  The following implementations are provided:  Standard - years, months, weeks, days, hours, minutes, seconds, millis YearMonthDayTime - years, months, days, hours, minutes, seconds, millis YearMonthDay - years, months, days YearWeekDayTime - years, weeks, days, hours, minutes, seconds, millis YearWeekDay - years, weeks, days YearDayTime - years, days, hours, minutes, seconds, millis YearDay - years, days, hours DayTime - days, hours, minutes, seconds, millis Time - hours, minutes, seconds, millis plus one for each single type   PeriodType is thread-safe and immutable, and all subclasses must be as well.
org.joda.time.PeriodType.PeriodType	(	String	DurationFieldType[]	int[]	): Constructor.
org.joda.time.PeriodType.addIndexedField	(	ReadablePeriod	int	int[]	int	): Adds to the indexed field part of the period.
org.joda.time.PeriodType.dayTime	(	): Gets a type that defines all standard fields from days downwards.  days hours minutes seconds milliseconds 
org.joda.time.PeriodType.days	(	): Gets a type that defines just the days field.
org.joda.time.PeriodType.equals	(	Object	): Compares this type to another object. To be equal, the object must be a PeriodType with the same set of fields.
org.joda.time.PeriodType.forFields	(	DurationFieldType[]	): Gets a period type that contains the duration types of the array.  Only the 8 standard duration field types are supported.
org.joda.time.PeriodType.getFieldType	(	int	): Gets the field type by index.
org.joda.time.PeriodType.getIndexedField	(	ReadablePeriod	int	): Gets the indexed field part of the period.
org.joda.time.PeriodType.getName	(	): Gets the name of the period type.
org.joda.time.PeriodType.hashCode	(	): Returns a hashcode based on the field types.
org.joda.time.PeriodType.hours	(	): Gets a type that defines just the hours field.
org.joda.time.PeriodType.indexOf	(	DurationFieldType	): Gets the index of the field in this period.
org.joda.time.PeriodType.isSupported	(	DurationFieldType	): Checks whether the field specified is supported by this period.
org.joda.time.PeriodType.millis	(	): Gets a type that defines just the millis field.
org.joda.time.PeriodType.minutes	(	): Gets a type that defines just the minutes field.
org.joda.time.PeriodType.months	(	): Gets a type that defines just the months field.
org.joda.time.PeriodType.seconds	(	): Gets a type that defines just the seconds field.
org.joda.time.PeriodType.setIndexedField	(	ReadablePeriod	int	int[]	int	): Sets the indexed field part of the period.
org.joda.time.PeriodType.size	(	): Gets the number of fields in the period type.
org.joda.time.PeriodType.standard	(	): Gets a type that defines all standard fields.  years months weeks days hours minutes seconds milliseconds 
org.joda.time.PeriodType.time	(	): Gets a type that defines all standard time fields.  hours minutes seconds milliseconds 
org.joda.time.PeriodType.toString	(	): Gets a debugging to string.
org.joda.time.PeriodType.weeks	(	): Gets a type that defines just the weeks field.
org.joda.time.PeriodType.withDaysRemoved	(	): Returns a version of this PeriodType instance that does not support days.
org.joda.time.PeriodType.withFieldRemoved	(	int	String	): Removes the field specified by indices index.
org.joda.time.PeriodType.withHoursRemoved	(	): Returns a version of this PeriodType instance that does not support hours.
org.joda.time.PeriodType.withMillisRemoved	(	): Returns a version of this PeriodType instance that does not support milliseconds.
org.joda.time.PeriodType.withMinutesRemoved	(	): Returns a version of this PeriodType instance that does not support minutes.
org.joda.time.PeriodType.withMonthsRemoved	(	): Returns a version of this PeriodType instance that does not support months.
org.joda.time.PeriodType.withSecondsRemoved	(	): Returns a version of this PeriodType instance that does not support seconds.
org.joda.time.PeriodType.withWeeksRemoved	(	): Returns a version of this PeriodType instance that does not support weeks.
org.joda.time.PeriodType.withYearsRemoved	(	): Returns a version of this PeriodType instance that does not support years.
org.joda.time.PeriodType.yearDay	(	): Gets a type that defines the year and day fields.  years days 
org.joda.time.PeriodType.yearDayTime	(	): Gets a type that defines all standard fields except months and weeks.  years days hours minutes seconds milliseconds 
org.joda.time.PeriodType.yearMonthDay	(	): Gets a type that defines the year, month and day fields.  years months days 
org.joda.time.PeriodType.yearMonthDayTime	(	): Gets a type that defines all standard fields except weeks.  years months days hours minutes seconds milliseconds 
org.joda.time.PeriodType.yearWeekDay	(	): Gets a type that defines year, week and day fields.  years weeks days 
org.joda.time.PeriodType.yearWeekDayTime	(	): Gets a type that defines all standard fields except months.  years weeks days hours minutes seconds milliseconds 
org.joda.time.PeriodType.years	(	): Gets a type that defines just the years field.
org.joda.time.ReadWritableDateTime: Defines an instant in time that can be queried and modified using datetime fields.  The implementation of this interface will be mutable. It may provide more advanced methods than those in the interface.  Methods in your application should be defined using ReadWritableDateTime as a parameter if the method wants to manipulate and change a date in simple ways.
org.joda.time.ReadWritableDateTime.addDays	(	int	): Add a number of days to the date.
org.joda.time.ReadWritableDateTime.addHours	(	int	): Add a number of hours to the date.
org.joda.time.ReadWritableDateTime.addMillis	(	int	): Add a number of milliseconds to the date. The implementation of this method differs from the add() method in that a DateTimeField performs the addition.
org.joda.time.ReadWritableDateTime.addMinutes	(	int	): Add a number of minutes to the date.
org.joda.time.ReadWritableDateTime.addMonths	(	int	): Add a number of months to the date.
org.joda.time.ReadWritableDateTime.addSeconds	(	int	): Add a number of seconds to the date.
org.joda.time.ReadWritableDateTime.addWeeks	(	int	): Add a number of weeks to the date.
org.joda.time.ReadWritableDateTime.addWeekyears	(	int	): Add a number of weekyears to the date.
org.joda.time.ReadWritableDateTime.addYears	(	int	): Add a number of years to the date.
org.joda.time.ReadWritableDateTime.setDate	(	int	int	int	): Set the date from fields. The time part of this object will be unaffected.
org.joda.time.ReadWritableDateTime.setDateTime	(	int	int	int	int	int	int	int	): Set the date and time from fields.
org.joda.time.ReadWritableDateTime.setDayOfMonth	(	int	): Set the day of the month to the specified value.
org.joda.time.ReadWritableDateTime.setDayOfWeek	(	int	): Set the day of week to the specified value.
org.joda.time.ReadWritableDateTime.setDayOfYear	(	int	): Set the day of year to the specified value.
org.joda.time.ReadWritableDateTime.setHourOfDay	(	int	): Set the hour of the day to the specified value.
org.joda.time.ReadWritableDateTime.setMillisOfDay	(	int	): Set the millis of the day to the specified value.
org.joda.time.ReadWritableDateTime.setMillisOfSecond	(	int	): Set the millis of the second to the specified value.
org.joda.time.ReadWritableDateTime.setMinuteOfDay	(	int	): Set the minute of the day to the specified value.
org.joda.time.ReadWritableDateTime.setMinuteOfHour	(	int	): Set the minute of the hour to the specified value.
org.joda.time.ReadWritableDateTime.setMonthOfYear	(	int	): Set the month of the year to the specified value.
org.joda.time.ReadWritableDateTime.setSecondOfDay	(	int	): Set the second of the day to the specified value.
org.joda.time.ReadWritableDateTime.setSecondOfMinute	(	int	): Set the second of the minute to the specified value.
org.joda.time.ReadWritableDateTime.setTime	(	int	int	int	int	): Set the time from fields. The date part of this object will be unaffected.
org.joda.time.ReadWritableDateTime.setWeekOfWeekyear	(	int	): Set the week of weekyear to the specified value.
org.joda.time.ReadWritableDateTime.setWeekyear	(	int	): Set the weekyear to the specified value.
org.joda.time.ReadWritableDateTime.setYear	(	int	): Set the year to the specified value.
org.joda.time.ReadWritableInstant: Defines an instant in the datetime continuum that can be queried and modified. This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.  The implementation of this interface will be mutable. It may provide more advanced methods than those in the interface.
org.joda.time.ReadWritableInstant.add	(	DurationFieldType	int	): Adds to the instant specifying the duration and multiple to add.
org.joda.time.ReadWritableInstant.add	(	ReadableDuration	): Adds a duration to this instant.  This will typically change the value of most fields.
org.joda.time.ReadWritableInstant.add	(	ReadableDuration	int	): Adds a duration to this instant specifying how many times to add.  This will typically change the value of most fields.
org.joda.time.ReadWritableInstant.add	(	ReadablePeriod	): Adds a period to this instant.  This will typically change the value of most fields.
org.joda.time.ReadWritableInstant.add	(	ReadablePeriod	int	): Adds a period to this instant specifying how many times to add.  This will typically change the value of most fields.
org.joda.time.ReadWritableInstant.add	(	long	): Adds a millisecond duration to this instant.  This will typically change the value of ost fields.
org.joda.time.ReadWritableInstant.set	(	DateTimeFieldType	int	): Sets the value of one of the fields of the instant, such as hourOfDay.
org.joda.time.ReadWritableInstant.setChronology	(	Chronology	): Sets the chronology of the datetime, which has no effect if not applicable.
org.joda.time.ReadWritableInstant.setMillis	(	ReadableInstant	): Sets the millisecond instant of this instant from another.  This method does not change the chronology of this instant, just the millisecond instant.
org.joda.time.ReadWritableInstant.setMillis	(	long	): Sets the value as the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.
org.joda.time.ReadWritableInstant.setZone	(	DateTimeZone	): Sets the time zone of the datetime, changing the chronology and field values.  Changing the zone using this method retains the millisecond instant. The millisecond instant is adjusted in the new zone to compensate. chronology. Setting the time zone does not affect the millisecond value of this instant.  If the chronology already has this time zone, no change occurs.
org.joda.time.ReadWritableInstant.setZoneRetainFields	(	DateTimeZone	): Sets the time zone of the datetime, changing the chronology and millisecond.  Changing the zone using this method retains the field values. The millisecond instant is adjusted in the new zone to compensate.  If the chronology already has this time zone, no change occurs.
org.joda.time.ReadWritableInterval: Writable interface for an interval.
org.joda.time.ReadWritableInterval.setChronology	(	Chronology	): Sets the chronology of this time interval.
org.joda.time.ReadWritableInterval.setDurationAfterStart	(	ReadableDuration	): Sets the duration of this time interval, preserving the start instant.
org.joda.time.ReadWritableInterval.setDurationBeforeEnd	(	ReadableDuration	): Sets the duration of this time interval, preserving the end instant.
org.joda.time.ReadWritableInterval.setEnd	(	ReadableInstant	): Sets the end of this time interval as an Instant.
org.joda.time.ReadWritableInterval.setEndMillis	(	long	): Sets the end of this time interval.
org.joda.time.ReadWritableInterval.setInterval	(	ReadableInstant	ReadableInstant	): Sets this interval from two instants.
org.joda.time.ReadWritableInterval.setInterval	(	ReadableInterval	): Sets this interval to be the same as another.
org.joda.time.ReadWritableInterval.setInterval	(	long	long	): Sets this interval from two millisecond instants.
org.joda.time.ReadWritableInterval.setPeriodAfterStart	(	ReadablePeriod	): Sets the period of this time interval, preserving the start instant.
org.joda.time.ReadWritableInterval.setPeriodBeforeEnd	(	ReadablePeriod	): Sets the period of this time interval, preserving the end instant.
org.joda.time.ReadWritableInterval.setStart	(	ReadableInstant	): Sets the start of this time interval as an Instant.
org.joda.time.ReadWritableInterval.setStartMillis	(	long	): Sets the start of this time interval.
org.joda.time.ReadWritablePeriod: Defines a duration of time that can be queried and modified using datetime fields.  The implementation of this interface will be mutable. It may provide more advanced methods than those in the interface.
org.joda.time.ReadWritablePeriod.add	(	DurationFieldType	int	): Adds to the value of one of the fields.  The field type specified must be one of those that is supported by the period.
org.joda.time.ReadWritablePeriod.add	(	ReadableInterval	): Adds an interval to this one by dividing the interval into fields and then adding each field in turn.
org.joda.time.ReadWritablePeriod.add	(	ReadablePeriod	): Adds a period to this one by adding each field in turn.
org.joda.time.ReadWritablePeriod.add	(	int	int	int	int	int	int	int	int	): Adds to each field of this period.
org.joda.time.ReadWritablePeriod.addDays	(	int	): Adds the specified days to the number of days in the period.
org.joda.time.ReadWritablePeriod.addHours	(	int	): Adds the specified hours to the number of hours in the period.
org.joda.time.ReadWritablePeriod.addMillis	(	int	): Adds the specified millis to the number of millis in the period.
org.joda.time.ReadWritablePeriod.addMinutes	(	int	): Adds the specified minutes to the number of minutes in the period.
org.joda.time.ReadWritablePeriod.addMonths	(	int	): Adds the specified months to the number of months in the period.
org.joda.time.ReadWritablePeriod.addSeconds	(	int	): Adds the specified seconds to the number of seconds in the period.
org.joda.time.ReadWritablePeriod.addWeeks	(	int	): Adds the specified weeks to the number of weeks in the period.
org.joda.time.ReadWritablePeriod.addYears	(	int	): Adds the specified years to the number of years in the period.
org.joda.time.ReadWritablePeriod.clear	(	): Clears the period, setting all values back to zero.
org.joda.time.ReadWritablePeriod.set	(	DurationFieldType	int	): Sets the value of one of the fields.  The field type specified must be one of those that is supported by the period.
org.joda.time.ReadWritablePeriod.setDays	(	int	): Sets the number of days of the period.
org.joda.time.ReadWritablePeriod.setHours	(	int	): Sets the number of hours of the period.
org.joda.time.ReadWritablePeriod.setMillis	(	int	): Sets the number of millis of the period.
org.joda.time.ReadWritablePeriod.setMinutes	(	int	): Sets the number of minutes of the period.
org.joda.time.ReadWritablePeriod.setMonths	(	int	): Sets the number of months of the period.
org.joda.time.ReadWritablePeriod.setPeriod	(	ReadableInterval	): Sets all the fields in one go from an interval dividing the fields using the period type.
org.joda.time.ReadWritablePeriod.setPeriod	(	ReadablePeriod	): Sets all the fields in one go from another ReadablePeriod.
org.joda.time.ReadWritablePeriod.setPeriod	(	int	int	int	int	int	int	int	int	): Sets all the fields in one go.
org.joda.time.ReadWritablePeriod.setSeconds	(	int	): Sets the number of seconds of the period.
org.joda.time.ReadWritablePeriod.setValue	(	int	int	): Sets the value of one of the fields by index.
org.joda.time.ReadWritablePeriod.setWeeks	(	int	): Sets the number of weeks of the period.
org.joda.time.ReadWritablePeriod.setYears	(	int	): Sets the number of years of the period.
org.joda.time.ReadableDateTime: Defines an instant in time that can be queried using datetime fields.  The implementation of this interface may be mutable or immutable. This interface only gives access to retrieve data, never to change it.  Methods in your application should be defined using ReadableDateTime as a parameter if the method only wants to read the datetime, and not perform any advanced manipulations.
org.joda.time.ReadableDateTime.getCenturyOfEra	(	): Get the year of era field value.
org.joda.time.ReadableDateTime.getDayOfMonth	(	): Get the day of month field value.
org.joda.time.ReadableDateTime.getDayOfWeek	(	): Get the day of week field value.  The values for the day of week are defined in DateTimeConstants.
org.joda.time.ReadableDateTime.getDayOfYear	(	): Get the day of year field value.
org.joda.time.ReadableDateTime.getEra	(	): Get the era field value.
org.joda.time.ReadableDateTime.getHourOfDay	(	): Get the hour of day field value.
org.joda.time.ReadableDateTime.getMillisOfDay	(	): Get the millis of day field value.
org.joda.time.ReadableDateTime.getMillisOfSecond	(	): Get the millis of second field value.
org.joda.time.ReadableDateTime.getMinuteOfDay	(	): Get the minute of day field value.
org.joda.time.ReadableDateTime.getMinuteOfHour	(	): Get the minute of hour field value.
org.joda.time.ReadableDateTime.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.ReadableDateTime.getSecondOfDay	(	): Get the second of day field value.
org.joda.time.ReadableDateTime.getSecondOfMinute	(	): Get the second of minute field value.
org.joda.time.ReadableDateTime.getWeekOfWeekyear	(	): Get the week of weekyear field value.  This field is associated with the "weekyear" via getWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.
org.joda.time.ReadableDateTime.getWeekyear	(	): Get the weekyear field value.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.
org.joda.time.ReadableDateTime.getYear	(	): Get the year field value.
org.joda.time.ReadableDateTime.getYearOfCentury	(	): Get the year of century field value.
org.joda.time.ReadableDateTime.getYearOfEra	(	): Get the year of era field value.
org.joda.time.ReadableDateTime.toDateTime	(	): Get this object as a DateTime.  If the implementation of the interface is a DateTime, it is returned directly.
org.joda.time.ReadableDateTime.toMutableDateTime	(	): Get this object as a MutableDateTime, always returning a new instance.
org.joda.time.ReadableDateTime.toString	(	String	): Output the instant using the specified format pattern.
org.joda.time.ReadableDateTime.toString	(	String	Locale	): Output the instant using the specified format pattern.
org.joda.time.ReadableDuration: Defines an exact duration of time in milliseconds.  The implementation of this interface may be mutable or immutable. This interface only gives access to retrieve data, never to change it.  Methods that are passed a duration as a parameter will treat null as a zero length duration.  The compareTo method is no longer defined in this class in version 2.0. Instead, the definition is simply inherited from the Comparable interface. This approach is necessary to preserve binary compatibility. The definition of the comparison is ascending order by millisecond duration. Implementors are recommended to extend AbstractInstant instead of this interface.
org.joda.time.ReadableDuration.equals	(	Object	): Compares this object with the specified object for equality based on the millisecond length. All ReadableDuration instances are accepted.
org.joda.time.ReadableDuration.getMillis	(	): Gets the total length of this duration in milliseconds.
org.joda.time.ReadableDuration.hashCode	(	): Gets a hash code for the duration that is compatible with the equals method. The following formula must be used:  long len = getMillis(); return (int) (len ^ (len >>> 32)); 
org.joda.time.ReadableDuration.isEqual	(	ReadableDuration	): Is the length of this duration equal to the duration passed in.
org.joda.time.ReadableDuration.isLongerThan	(	ReadableDuration	): Is the length of this duration longer than the duration passed in.
org.joda.time.ReadableDuration.isShorterThan	(	ReadableDuration	): Is the length of this duration shorter than the duration passed in.
org.joda.time.ReadableDuration.toDuration	(	): Get this duration as an immutable Duration object.  This will either typecast this instance, or create a new Duration.
org.joda.time.ReadableDuration.toPeriod	(	): Converts this duration to a Period instance using the standard period type and the ISO chronology.  Only precise fields in the period type will be used. Thus, only the hour, minute, second and millisecond fields on the period will be used. The year, month, week and day fields will not be populated.  If the duration is small, less than one day, then this method will perform as you might expect and split the fields evenly. If the duration is larger than one day then all the remaining duration will be stored in the largest available field, hours in this case.  For example, a duration effectively equal to (365 + 60 + 5) days will be converted to ((365 + 60 + 5) * 24) hours by this constructor.  For more control over the conversion process, you must pair the duration with an instant, see Period().
org.joda.time.ReadableDuration.toString	(	): Gets the value as a String in the ISO8601 duration format using hours, minutes and seconds (including fractional milliseconds).  For example, "PT6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
org.joda.time.ReadableInstant: Defines an instant in the datetime continuum. This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.  The implementation of this interface may be mutable or immutable. This interface only gives access to retrieve data, never to change it.  Methods in your application should be defined using ReadableInstant as a parameter if the method only wants to read the instant without needing to know the specific datetime fields.  The compareTo method is no longer defined in this class in version 2.0. Instead, the definition is simply inherited from the Comparable interface. This approach is necessary to preserve binary compatibility. The definition of the comparison is ascending order by millisecond instant. Implementors are recommended to extend AbstractInstant instead of this interface.
org.joda.time.ReadableInstant.equals	(	Object	): Compares this object with the specified object for equality based on the millisecond instant and the Chronology. All ReadableInstant instances are accepted.  To compare two instants for absolute time (ie. UTC milliseconds ignoring the chronology), use isEqual() or compareTo().
org.joda.time.ReadableInstant.get	(	DateTimeFieldType	): Get the value of one of the fields of a datetime.  This method uses the chronology of the instant to obtain the value.
org.joda.time.ReadableInstant.getChronology	(	): Gets the chronology of the instant.  The Chronology provides conversion from the millisecond value to meaningful fields in a particular calendar system.
org.joda.time.ReadableInstant.getMillis	(	): Get the value as the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.
org.joda.time.ReadableInstant.getZone	(	): Gets the time zone of the instant from the chronology.
org.joda.time.ReadableInstant.hashCode	(	): Gets a hash code for the instant that is compatible with the equals method.  The formula used must be as follows:  ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode()) 
org.joda.time.ReadableInstant.isAfter	(	ReadableInstant	): Is this instant after the instant passed in comparing solely by millisecond.
org.joda.time.ReadableInstant.isBefore	(	ReadableInstant	): Is this instant before the instant passed in comparing solely by millisecond.
org.joda.time.ReadableInstant.isEqual	(	ReadableInstant	): Is this instant equal to the instant passed in comparing solely by millisecond.
org.joda.time.ReadableInstant.isSupported	(	DateTimeFieldType	): Checks whether the field type specified is supported by this implementation.
org.joda.time.ReadableInstant.toInstant	(	): Get the value as a simple immutable Instant object.  This can be useful if you don't trust the implementation of the interface to be well-behaved, or to get a guaranteed immutable object.
org.joda.time.ReadableInstant.toString	(	): Get the value as a String in a recognisable ISO8601 format.  The string output is in ISO8601 format to enable the String constructor to correctly parse it.
org.joda.time.ReadableInterval: Readable interface for an interval of time between two instants.  A time interval represents a period of time between two instants. Intervals are inclusive of the start instant and exclusive of the end. The end instant is always greater than or equal to the start instant.  Intervals have a fixed millisecond duration. This is the difference between the start and end instants. The duration is represented separately by ReadableDuration. As a result, intervals are not comparable. To compare the length of two intervals, you should compare their durations.  An interval can also be converted to a ReadablePeriod. This represents the difference between the start and end points in terms of fields such as years and days.  Methods that are passed an interval as a parameter will treat null as a zero length interval at the current instant in time.
org.joda.time.ReadableInterval.contains	(	ReadableInstant	): Does this time interval contain the specified instant.  Non-zero duration intervals are inclusive of the start instant and exclusive of the end. A zero duration interval cannot contain anything.  For example:  [09:00 to 10:00) contains 08:59 = false (before start) [09:00 to 10:00) contains 09:00 = true [09:00 to 10:00) contains 09:59 = true [09:00 to 10:00) contains 10:00 = false (equals end) [09:00 to 10:00) contains 10:01 = false (after end) [14:00 to 14:00) contains 14:00 = false (zero duration contains nothing) 
org.joda.time.ReadableInterval.contains	(	ReadableInterval	): Does this time interval contain the specified time interval.  Non-zero duration intervals are inclusive of the start instant and exclusive of the end. The other interval is contained if this interval wholly contains, starts, finishes or equals it. A zero duration interval cannot contain anything.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The contains method is not related to these states. In particular, a zero duration interval is contained at the start of a larger interval, but does not overlap (it abuts instead).  For example:  [09:00 to 10:00) contains [09:00 to 10:00) = true [09:00 to 10:00) contains [09:00 to 09:30) = true [09:00 to 10:00) contains [09:30 to 10:00) = true [09:00 to 10:00) contains [09:15 to 09:45) = true [09:00 to 10:00) contains [09:00 to 09:00) = true [09:00 to 10:00) contains [08:59 to 10:00) = false (otherStart before thisStart) [09:00 to 10:00) contains [09:00 to 10:01) = false (otherEnd after thisEnd) [09:00 to 10:00) contains [10:00 to 10:00) = false (otherStart equals thisEnd) [14:00 to 14:00) contains [14:00 to 14:00) = false (zero duration contains nothing) 
org.joda.time.ReadableInterval.equals	(	Object	): Compares this object with the specified object for equality based on start and end millis plus the chronology. All ReadableInterval instances are accepted.  To compare the duration of two time intervals, use toDuration() to get the durations and compare those.
org.joda.time.ReadableInterval.getChronology	(	): Gets the chronology of the interval, which is the chronology of the first datetime.
org.joda.time.ReadableInterval.getEnd	(	): Gets the end of this time interval, which is exclusive, as a DateTime.
org.joda.time.ReadableInterval.getEndMillis	(	): Gets the end of this time interval which is exclusive.
org.joda.time.ReadableInterval.getStart	(	): Gets the start of this time interval, which is inclusive, as a DateTime.
org.joda.time.ReadableInterval.getStartMillis	(	): Gets the start of this time interval which is inclusive.
org.joda.time.ReadableInterval.hashCode	(	): Gets a hash code for the time interval that is compatible with the equals method.  The formula used must be as follows: int result = 97; result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32))); result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32))); result = 31 * result + getChronology().hashCode(); return result;
org.joda.time.ReadableInterval.isAfter	(	ReadableInstant	): Is this time interval after the specified instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.ReadableInterval.isAfter	(	ReadableInterval	): Is this time interval entirely after the specified interval.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.ReadableInterval.isBefore	(	ReadableInstant	): Is this time interval before the specified instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.ReadableInterval.isBefore	(	ReadableInterval	): Is this time interval entirely before the specified interval.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.ReadableInterval.overlaps	(	ReadableInterval	): Does this time interval overlap the specified time interval.  Intervals are inclusive of the start instant and exclusive of the end. An interval overlaps another if it shares some common part of the datetime continuum.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The abuts state takes precedence over the other two, thus a zero duration interval at the start of a larger interval abuts and does not overlap.  For example:  [09:00 to 10:00) overlaps [08:00 to 08:30) = false (completely before) [09:00 to 10:00) overlaps [08:00 to 09:00) = false (abuts before) [09:00 to 10:00) overlaps [08:00 to 09:30) = true [09:00 to 10:00) overlaps [08:00 to 10:00) = true [09:00 to 10:00) overlaps [08:00 to 11:00) = true [09:00 to 10:00) overlaps [09:00 to 09:00) = false (abuts before) [09:00 to 10:00) overlaps [09:00 to 09:30) = true [09:00 to 10:00) overlaps [09:00 to 10:00) = true [09:00 to 10:00) overlaps [09:00 to 11:00) = true [09:00 to 10:00) overlaps [09:30 to 09:30) = true [09:00 to 10:00) overlaps [09:30 to 10:00) = true [09:00 to 10:00) overlaps [09:30 to 11:00) = true [09:00 to 10:00) overlaps [10:00 to 10:00) = false (abuts after) [09:00 to 10:00) overlaps [10:00 to 11:00) = false (abuts after) [09:00 to 10:00) overlaps [10:30 to 11:00) = false (completely after) [14:00 to 14:00) overlaps [14:00 to 14:00) = false (abuts before and after) [14:00 to 14:00) overlaps [13:00 to 15:00) = true 
org.joda.time.ReadableInterval.toDuration	(	): Gets the millisecond duration of this time interval.
org.joda.time.ReadableInterval.toDurationMillis	(	): Gets the millisecond duration of this time interval.
org.joda.time.ReadableInterval.toInterval	(	): Get this interval as an immutable Interval object.  This will either typecast this instance, or create a new Interval.
org.joda.time.ReadableInterval.toMutableInterval	(	): Get this time interval as a MutableInterval.  This will always return a new MutableInterval with the same interval.
org.joda.time.ReadableInterval.toPeriod	(	): Converts the duration of the interval to a period using the standard period type.  This method should be used to extract the field values describing the difference between the start and end instants.
org.joda.time.ReadableInterval.toPeriod	(	PeriodType	): Converts the duration of the interval to a period using the specified period type.  This method should be used to extract the field values describing the difference between the start and end instants.
org.joda.time.ReadableInterval.toString	(	): Get the value as a String in the ISO8601 interval format.  For example, "2004-06-09T12:30:00.000/2004-07-10T13:30:00.000".
org.joda.time.ReadablePartial: Defines a partial time that does not support every datetime field, and is thus a local time.  A ReadablePartial supports a subset of those fields on the chronology. It cannot be compared to a ReadableInstant, as it does not fully specify an instant in time. The time it does specify is a local time, and does not include a time zone.  A ReadablePartial can be converted to a ReadableInstant using the toDateTime method. This works by providing a full base instant that can be used to 'fill in the gaps' and specify a time zone.  ReadablePartial is Comparable from v2.0. The comparison is based on the fields, compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.
org.joda.time.ReadablePartial.equals	(	Object	): Compares this partial with the specified object for equality based on the supported fields, chronology and values.  Two instances of ReadablePartial are equal if they have the same chronology, same field types (in same order) and same values.
org.joda.time.ReadablePartial.get	(	DateTimeFieldType	): Gets the value of one of the fields.  The field type specified must be one of those that is supported by the partial.
org.joda.time.ReadablePartial.getChronology	(	): Gets the chronology of the partial which is never null.  The Chronology is the calculation engine behind the partial and provides conversion and validation of the fields in a particular calendar system.
org.joda.time.ReadablePartial.getField	(	int	): Gets the field at the specified index.
org.joda.time.ReadablePartial.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.ReadablePartial.getValue	(	int	): Gets the value at the specified index.
org.joda.time.ReadablePartial.hashCode	(	): Gets a hash code for the partial that is compatible with the equals method.  The formula used must be:  int total = 157; for (int i = 0; i < fields.length; i++) { total = 23 * total + values[i]; total = 23 * total + fieldTypes[i].hashCode(); } total += chronology.hashCode(); return total; 
org.joda.time.ReadablePartial.isSupported	(	DateTimeFieldType	): Checks whether the field type specified is supported by this partial.
org.joda.time.ReadablePartial.size	(	): Gets the number of fields that this partial supports.
org.joda.time.ReadablePartial.toDateTime	(	ReadableInstant	): Converts this partial to a full datetime by resolving it against another datetime.  This method takes the specified datetime and sets the fields from this instant on top. The chronology from the base instant is used.  For example, if this partial represents a time, then the result of this method will be the datetime from the specified base instant plus the time from this partial.
org.joda.time.ReadablePartial.toString	(	): Get the value as a String in a recognisable ISO8601 format, only displaying supported fields.  The string output is in ISO8601 format to enable the String constructor to correctly parse it.
org.joda.time.ReadablePeriod: Defines a time period specified in terms of individual duration fields such as years and days.  The implementation of this interface may be mutable or immutable. This interface only gives access to retrieve data, never to change it.  Periods are split up into multiple fields, for example days and seconds. Implementations are not required to evenly distribute the values across the fields. The value for each field may be positive or negative.  When a time period is added to an instant, the effect is to add each field in turn. For example, a time period could be defined as 3 months, 2 days and -1 hours. In most circumstances this would be the same as 3 months, 1 day, and 23 hours. However, when adding across a daylight savings boundary, a day may be 23 or 25 hours long. Thus, the time period is always added field by field to the datetime.  Periods are independent of chronology, and can only be treated as durations when paired with a time via an interval.
org.joda.time.ReadablePeriod.equals	(	Object	): Compares this object with the specified object for equality based on the value and type of each supported field. All ReadablePeriod instances are accepted.  Note that a period of 1 day is not equal to a period of 24 hours, nor is 1 hour equal to 60 minutes. Only periods with the same amount in each field are equal.  This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary).  To compare the actual duration of two periods, convert both to Durations, an operation that emphasises that the result may differ according to the date you choose.
org.joda.time.ReadablePeriod.get	(	DurationFieldType	): Gets the value of one of the fields.  If the field type specified is not supported by the period then zero is returned.
org.joda.time.ReadablePeriod.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.ReadablePeriod.getPeriodType	(	): Gets the period type that defines which fields are included in the period.
org.joda.time.ReadablePeriod.getValue	(	int	): Gets the value at the specified index.
org.joda.time.ReadablePeriod.hashCode	(	): Gets a hash code for the period that is compatible with the equals method. The hashcode is calculated as follows:  int total = 17; for (int i = 0; i < fields.length; i++) { total = 27 * total + getValue(i); total = 27 * total + getFieldType(i).hashCode(); } return total; 
org.joda.time.ReadablePeriod.isSupported	(	DurationFieldType	): Checks whether the field type specified is supported by this period.
org.joda.time.ReadablePeriod.size	(	): Gets the number of fields that this period supports.
org.joda.time.ReadablePeriod.toMutablePeriod	(	): Get this object as a MutablePeriod.  This will always return a new MutablePeriod with the same fields.
org.joda.time.ReadablePeriod.toPeriod	(	): Get this period as an immutable Period object.  This will either typecast this instance, or create a new Period.
org.joda.time.ReadablePeriod.toString	(	): Gets the value as a String in the style of the ISO8601 duration format. Technically, the output can breach the ISO specification as weeks may be included.  For example, "PT6H3M5S" represents 6 hours, 3 minutes, 5 seconds.
org.joda.time.Seconds: An immutable time period representing a number of seconds.  Seconds is an immutable period that can only store seconds. It does not store years, months or hours for example. As such it is a type-safe way of representing a number of seconds in an application.  The number of seconds is set in the constructor, and may be queried using getSeconds(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Seconds is thread-safe and immutable.
org.joda.time.Seconds.Seconds	(	int	): Creates a new instance representing a number of seconds. You should consider using the factory method seconds() instead of the constructor.
org.joda.time.Seconds.dividedBy	(	int	): Returns a new instance with the seconds divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Seconds.getFieldType	(	): Gets the duration field type, which is seconds.
org.joda.time.Seconds.getPeriodType	(	): Gets the period type, which is seconds.
org.joda.time.Seconds.getSeconds	(	): Gets the number of seconds that this period represents.
org.joda.time.Seconds.isGreaterThan	(	Seconds	): Is this seconds instance greater than the specified number of seconds.
org.joda.time.Seconds.isLessThan	(	Seconds	): Is this seconds instance less than the specified number of seconds.
org.joda.time.Seconds.minus	(	Seconds	): Returns a new instance with the specified number of seconds taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Seconds.minus	(	int	): Returns a new instance with the specified number of seconds taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Seconds.multipliedBy	(	int	): Returns a new instance with the seconds multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Seconds.negated	(	): Returns a new instance with the seconds value negated.
org.joda.time.Seconds.parseSeconds	(	String	): Creates a new Seconds by parsing a string in the ISO8601 format 'PTnS'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the seconds component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Seconds.plus	(	Seconds	): Returns a new instance with the specified number of seconds added.  This instance is immutable and unaffected by this method call.
org.joda.time.Seconds.plus	(	int	): Returns a new instance with the specified number of seconds added.  This instance is immutable and unaffected by this method call.
org.joda.time.Seconds.readResolve	(	): Resolves singletons.
org.joda.time.Seconds.seconds	(	int	): Obtains an instance of Seconds that may be cached. Seconds is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Seconds.secondsBetween	(	ReadableInstant	ReadableInstant	): Creates a Seconds representing the number of whole seconds between the two specified datetimes.
org.joda.time.Seconds.secondsBetween	(	ReadablePartial	ReadablePartial	): Creates a Seconds representing the number of whole seconds between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalTime objects.
org.joda.time.Seconds.secondsIn	(	ReadableInterval	): Creates a Seconds representing the number of whole seconds in the specified interval.
org.joda.time.Seconds.standardSecondsIn	(	ReadablePeriod	): Creates a new Seconds representing the number of complete standard length seconds in the specified period.  This factory method converts all fields from the period to hours using standardised durations for each field. Only those fields which have a precise duration in the ISO UTC chronology can be converted.  One week consists of 7 days. One day consists of 24 hours. One hour consists of 60 minutes. One minute consists of 60 seconds. One second consists of 1000 milliseconds.  Months and Years are imprecise and periods containing these values cannot be converted.
org.joda.time.Seconds.toStandardDays	(	): Converts this period in seconds to a period in days assuming a 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all days are 24 hours long, all hours are 60 minutes long and all minutes are 60 seconds long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Seconds.toStandardDuration	(	): Converts this period in seconds to a duration in milliseconds assuming a 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert from a period to a duration. However to achieve this it makes the assumption that all seconds are 24 hours long, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Seconds.toStandardHours	(	): Converts this period in seconds to a period in hours assuming a 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all hours are 60 minutes long and all minutes are 60 seconds long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Seconds.toStandardMinutes	(	): Converts this period in seconds to a period in minutes assuming a 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all minutes are 60 seconds long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Seconds.toStandardWeeks	(	): Converts this period in seconds to a period in weeks assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long, all days are 24 hours long, all hours are 60 minutes long and all minutes are 60 seconds long. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Seconds.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "PT4S" represents 4 seconds.
org.joda.time.TestAbstractPartial: This class is a Junit unit test for YearMonthDay.
org.joda.time.TestAll: Entry point for all tests in this package.
org.joda.time.TestAllPackages: Entry point for all tests in Joda-Time.
org.joda.time.TestBasePartial: This class is a Junit unit test for YearMonthDay.
org.joda.time.TestBaseSingleFieldPeriod: This class is a Junit unit test for BaseSingleFieldPeriod.
org.joda.time.TestBaseSingleFieldPeriod.Single: Test class. 
org.joda.time.TestChronology: This class is a Junit unit test for Chronology.
org.joda.time.TestDateMidnight_Basics: This class is a Junit unit test for DateMidnight.
org.joda.time.TestDateMidnight_Constructors: This class is a Junit unit test for DateMidnight.
org.joda.time.TestDateMidnight_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestDateMidnight_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_Object	(	): Test constructor (Object)
org.joda.time.TestDateMidnight_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_Object_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_Object_nullDateTimeZone	(	): Test constructor (Object, DateTimeZone=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_badconverterObject	(	): Test constructor (Object=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_badconverterObject_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_badconverterObject_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_int_int_int	(	): Test constructor (int, int, int)
org.joda.time.TestDateMidnight_Constructors.testConstructor_int_int_int_Chronology	(	): Test constructor (int, int, int, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_int_int_int_DateTimeZone	(	): Test constructor (int, int, int, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_int_int_int_nullChronology	(	): Test constructor (int, int, int, Chronology=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_int_int_int_nullDateTimeZone	(	): Test constructor (int, int, int, DateTimeZone=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_invalidObject	(	): Test constructor (Object)
org.joda.time.TestDateMidnight_Constructors.testConstructor_invalidObject_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_invalidObject_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long1_DateTimeZone	(	): Test constructor (long, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long2_DateTimeZone	(	): Test constructor (long, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_long_nullDateTimeZone	(	): Test constructor (long, DateTimeZone=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullObject	(	): Test constructor (Object=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullObject_DateTimeZone	(	): Test constructor (Object=null, DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestDateMidnight_Constructors.testConstructor_nullObject_nullDateTimeZone	(	): Test constructor (Object=null, DateTimeZone=null)
org.joda.time.TestDateMidnight_Constructors.test_now	(	): Test now ()
org.joda.time.TestDateMidnight_Constructors.test_now_Chronology	(	): Test now (Chronology)
org.joda.time.TestDateMidnight_Constructors.test_now_DateTimeZone	(	): Test now (DateTimeZone)
org.joda.time.TestDateMidnight_Constructors.test_now_nullChronology	(	): Test now (Chronology=null)
org.joda.time.TestDateMidnight_Constructors.test_now_nullDateTimeZone	(	): Test now (DateTimeZone=null)
org.joda.time.TestDateMidnight_Properties: This class is a Junit unit test for DateTime.
org.joda.time.TestDateTimeComparator: This class is a Junit unit test for the org.joda.time.DateTimeComparator class.
org.joda.time.TestDateTimeComparator.getADate	(	String	): Creates a date to test with.
org.joda.time.TestDateTimeComparator.isListSorted	(	List	): Check if the list is sorted.
org.joda.time.TestDateTimeComparator.loadAList	(	String[]	): Load a string array.
org.joda.time.TestDateTimeComparator.setUp	(	): Junit setUp() method.
org.joda.time.TestDateTimeComparator.tearDown	(	): Junit tearDown() method.
org.joda.time.TestDateTimeComparator.testBasicComps1	(	): Test all basic comparator operation with DateTime objects.
org.joda.time.TestDateTimeComparator.testBasicComps2	(	): Test all basic comparator operation with ReadableInstant objects.
org.joda.time.TestDateTimeComparator.testBasicComps3	(	): Test all basic comparator operation with java Date objects.
org.joda.time.TestDateTimeComparator.testBasicComps4	(	): Test all basic comparator operation with Long objects.
org.joda.time.TestDateTimeComparator.testBasicComps5	(	): Test all basic comparator operation with Calendar objects.
org.joda.time.TestDateTimeComparator.testDOM	(	): Test unequal comparisons with day of month comparators.
org.joda.time.TestDateTimeComparator.testDOW	(	): Test unequal comparisons with day of week comparators.
org.joda.time.TestDateTimeComparator.testDOY	(	): Test unequal comparisons with day of year comparators.
org.joda.time.TestDateTimeComparator.testHour	(	): Test unequal comparisons with hour comparators.
org.joda.time.TestDateTimeComparator.testInvalidObj	(	): Test comparator operation with an invalid object type.
org.joda.time.TestDateTimeComparator.testListBasic	(	): Test sorting with full default comparator.
org.joda.time.TestDateTimeComparator.testListDOM	(	): Test sorting with day of month comparator.
org.joda.time.TestDateTimeComparator.testListDOW	(	): Test sorting with day of week comparator.
org.joda.time.TestDateTimeComparator.testListDOY	(	): Test sorting with day of year comparator.
org.joda.time.TestDateTimeComparator.testListDate	(	): Test sorting with date only comparator.
org.joda.time.TestDateTimeComparator.testListHour	(	): Test sorting with hour comparator.
org.joda.time.TestDateTimeComparator.testListMillis	(	): Test sorting with millis of second comparator.
org.joda.time.TestDateTimeComparator.testListMinute	(	): Test sorting with minute comparator.
org.joda.time.TestDateTimeComparator.testListMonth	(	): Test sorting with month comparator.
org.joda.time.TestDateTimeComparator.testListSecond	(	): Test sorting with second comparator.
org.joda.time.TestDateTimeComparator.testListTime	(	): Test sorting with time only comparator.
org.joda.time.TestDateTimeComparator.testListWOW	(	): Test sorting with week of weekyear comparator.
org.joda.time.TestDateTimeComparator.testListYOYY	(	): Test sorting with year (given week) comparator.
org.joda.time.TestDateTimeComparator.testListYear	(	): Test sorting with year comparator.
org.joda.time.TestDateTimeComparator.testMillis	(	): Test unequal comparisons with millis of second comparators.
org.joda.time.TestDateTimeComparator.testMinute	(	): Test unequal comparisons with minute comparators.
org.joda.time.TestDateTimeComparator.testMonth	(	): Test unequal comparisons with month comparators.
org.joda.time.TestDateTimeComparator.testNullDT	(	): Test comparator operation with null object(s).
org.joda.time.TestDateTimeComparator.testSecond	(	): Test unequal comparisons with second comparators.
org.joda.time.TestDateTimeComparator.testWOW	(	): Test unequal comparisons with week of weekyear comparators.
org.joda.time.TestDateTimeComparator.testWOYY	(	): Test unequal comparisons with year given the week comparators.
org.joda.time.TestDateTimeComparator.testYear	(	): Test unequal comparisons with year comparators.
org.joda.time.TestDateTimeConstants: Test case.
org.joda.time.TestDateTimeConstants.TestDateTimeConstants	(	String	): TestDateTimeComparator constructor.
org.joda.time.TestDateTimeConstants.main	(	String[]	): The main method for this test program.
org.joda.time.TestDateTimeConstants.suite	(	): TestSuite is a junit required method.
org.joda.time.TestDateTimeFieldType: This class is a Junit unit test for Chronology.
org.joda.time.TestDateTimeUtils: This class is a Junit unit test for DateTimeUtils.
org.joda.time.TestDateTimeZone: This class is a JUnit test for DateTimeZone.
org.joda.time.TestDateTimeZoneCutover: This class is a JUnit test for DateTimeZone.
org.joda.time.TestDateTime_Basics: This class is a Junit unit test for DateTime.
org.joda.time.TestDateTime_Constructors: This class is a Junit unit test for DateTime.
org.joda.time.TestDateTime_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestDateTime_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_Object	(	): Test constructor (Object)
org.joda.time.TestDateTime_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_Object_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_Object_nullDateTimeZone	(	): Test constructor (Object, DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.testConstructor_badconverterObject	(	): Test constructor (Object=null)
org.joda.time.TestDateTime_Constructors.testConstructor_badconverterObject_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_badconverterObject_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int	(	): Test constructor (int, int, int, int, int)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_Chronology	(	): Test constructor (int, int, int, int, int, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_DateTimeZone	(	): Test constructor (int, int, int, int, int, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int	(	): Test constructor (int, int, int, int, int, int)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_Chronology	(	): Test constructor (int, int, int, int, int, int, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_DateTimeZone	(	): Test constructor (int, int, int, int, int, int, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int	(	): Test constructor (int, int, int)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_Chronology	(	): Test constructor (int, int, int, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_DateTimeZone	(	): Test constructor (int, int, int, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullChronology	(	): Test constructor (int, int, int, Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullDateTimeZone	(	): Test constructor (int, int, int, DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_nullChronology	(	): Test constructor (int, int, int, int, int, int, Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_nullDateTimeZone	(	): Test constructor (int, int, int, int, int, int, DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_nullChronology	(	): Test constructor (int, int, int, int, int, Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_int_int_int_int_int_nullDateTimeZone	(	): Test constructor (int, int, int, int, int, DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.testConstructor_invalidObject	(	): Test constructor (Object)
org.joda.time.TestDateTime_Constructors.testConstructor_invalidObject_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_invalidObject_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestDateTime_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_long1_DateTimeZone	(	): Test constructor (long, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestDateTime_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_long2_DateTimeZone	(	): Test constructor (long, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_long_nullDateTimeZone	(	): Test constructor (long, DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.testConstructor_nullObject	(	): Test constructor (Object=null)
org.joda.time.TestDateTime_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestDateTime_Constructors.testConstructor_nullObject_DateTimeZone	(	): Test constructor (Object=null, DateTimeZone)
org.joda.time.TestDateTime_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestDateTime_Constructors.testConstructor_nullObject_nullDateTimeZone	(	): Test constructor (Object=null, DateTimeZone=null)
org.joda.time.TestDateTime_Constructors.test_now	(	): Test now ()
org.joda.time.TestDateTime_Constructors.test_now_Chronology	(	): Test now (Chronology)
org.joda.time.TestDateTime_Constructors.test_now_DateTimeZone	(	): Test now (DateTimeZone)
org.joda.time.TestDateTime_Constructors.test_now_nullChronology	(	): Test now (Chronology=null)
org.joda.time.TestDateTime_Constructors.test_now_nullDateTimeZone	(	): Test now (DateTimeZone=null)
org.joda.time.TestDateTime_Properties: This class is a Junit unit test for DateTime.
org.joda.time.TestDays: This class is a Junit unit test for Days.
org.joda.time.TestDurationField: This class is a Junit unit test for DurationField.
org.joda.time.TestDurationFieldType: This class is a Junit unit test for DurationFieldType.
org.joda.time.TestDuration_Basics: This class is a Junit unit test for Duration.
org.joda.time.TestDuration_Constructors: This class is a JUnit test for Duration.
org.joda.time.TestDuration_Constructors.testConstructor_Object1	(	): Test constructor (Object)
org.joda.time.TestDuration_Constructors.testConstructor_Overflow1	(	): Test constructor overflow
org.joda.time.TestDuration_Constructors.testZERO	(	): Test constructor ()
org.joda.time.TestHours: This class is a Junit unit test for Hours.
org.joda.time.TestIllegalFieldValueException: Tests IllegalFieldValueException by triggering it from other methods.
org.joda.time.TestInstant_Basics: This class is a Junit unit test for Instant.
org.joda.time.TestInstant_Constructors: This class is a Junit unit test for Instant.
org.joda.time.TestInstant_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestInstant_Constructors.testConstructor_Object	(	): Test constructor (Object)
org.joda.time.TestInstant_Constructors.testConstructor_badconverterObject	(	): Test constructor (Object=null)
org.joda.time.TestInstant_Constructors.testConstructor_invalidObject	(	): Test constructor (Object)
org.joda.time.TestInstant_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestInstant_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestInstant_Constructors.testConstructor_nullObject	(	): Test constructor (Object=null)
org.joda.time.TestInstant_Constructors.test_now	(	): Test now ()
org.joda.time.TestInterval_Basics: This class is a Junit unit test for Instant.
org.joda.time.TestInterval_Constructors: This class is a JUnit test for Interval.
org.joda.time.TestLocalDateTime_Basics: This class is a Junit unit test for LocalDate.
org.joda.time.TestLocalDateTime_Constructors: This class is a Junit unit test for LocalDateTime.
org.joda.time.TestLocalDateTime_Properties: This class is a Junit unit test for LocalDateTime.
org.joda.time.TestLocalDate_Basics: This class is a Junit unit test for LocalDate.
org.joda.time.TestLocalDate_Constructors: This class is a Junit unit test for LocalDate.
org.joda.time.TestLocalDate_Properties: This class is a Junit unit test for YearMonthDay.
org.joda.time.TestLocalTime_Basics: This class is a Junit unit test for LocalTime.
org.joda.time.TestLocalTime_Constructors: This class is a Junit unit test for LocalTime.
org.joda.time.TestLocalTime_Constructors.testConstantMidnight	(	): Test constructor ()
org.joda.time.TestLocalTime_Properties: This class is a Junit unit test for TimeOfDay.
org.joda.time.TestMinMaxLong: This class is a Junit unit test for min/max long values.
org.joda.time.TestMinutes: This class is a Junit unit test for Minutes.
org.joda.time.TestMonthDay_Basics: This class is a Junit unit test for MonthDay. Based on TestYearMonth_Basics 
org.joda.time.TestMonthDay_Constructors: This class is a Junit unit test for MonthDay. Based on TestYearMonth_Constuctors 
org.joda.time.TestMonthDay_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestMonthDay_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestMonthDay_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestMonthDay_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestMonthDay_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestMonthDay_Constructors.testConstructor_int_int	(	): Test constructor (int, int)
org.joda.time.TestMonthDay_Constructors.testConstructor_int_int_Chronology	(	): Test constructor (int, int, Chronology)
org.joda.time.TestMonthDay_Constructors.testConstructor_int_int_nullChronology	(	): Test constructor (int, int, Chronology=null)
org.joda.time.TestMonthDay_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestMonthDay_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestMonthDay_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestMonthDay_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestMonthDay_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestMonthDay_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestMonthDay_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestMonthDay_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestMonthDay_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestMonthDay_Properties: This class is a Junit unit test for MonthDay. Based on TestYearMonth_Propeties 
org.joda.time.TestMonths: This class is a Junit unit test for Months.
org.joda.time.TestMutableDateTime_Adds: This class is a JUnit test for MutableDateTime.
org.joda.time.TestMutableDateTime_Basics: This class is a JUnit test for MutableDateTime.
org.joda.time.TestMutableDateTime_Constructors: This class is a Junit unit test for MutableDateTime.
org.joda.time.TestMutableDateTime_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestMutableDateTime_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_Object	(	): Test constructor (Object)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_Object_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_Object_nullDateTimeZone	(	): Test constructor (Object, DateTimeZone=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_badconverterObject	(	): Test constructor (Object=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_badconverterObject_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_badconverterObject_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int	(	): Test constructor (int, int, int)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_Chronology	(	): Test constructor (int, int, int, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_DateTimeZone	(	): Test constructor (int, int, int, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullChronology	(	): Test constructor (int, int, int, Chronology=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullDateTimeZone	(	): Test constructor (int, int, int, DateTimeZone=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_invalidObject	(	): Test constructor (Object)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_invalidObject_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_invalidObject_DateTimeZone	(	): Test constructor (Object, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long1_DateTimeZone	(	): Test constructor (long, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long2_DateTimeZone	(	): Test constructor (long, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_long_nullDateTimeZone	(	): Test constructor (long, DateTimeZone=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullObject	(	): Test constructor (Object=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullObject_DateTimeZone	(	): Test constructor (Object=null, DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestMutableDateTime_Constructors.testConstructor_nullObject_nullDateTimeZone	(	): Test constructor (Object=null, DateTimeZone=null)
org.joda.time.TestMutableDateTime_Constructors.test_now	(	): Test now ()
org.joda.time.TestMutableDateTime_Constructors.test_now_Chronology	(	): Test now (Chronology)
org.joda.time.TestMutableDateTime_Constructors.test_now_DateTimeZone	(	): Test now (DateTimeZone)
org.joda.time.TestMutableDateTime_Constructors.test_now_nullChronology	(	): Test now (Chronology=null)
org.joda.time.TestMutableDateTime_Constructors.test_now_nullDateTimeZone	(	): Test now (DateTimeZone=null)
org.joda.time.TestMutableDateTime_Properties: This class is a Junit unit test for DateTime.
org.joda.time.TestMutableDateTime_Sets: This class is a JUnit test for MutableDateTime.
org.joda.time.TestMutableInterval_Basics: This class is a Junit unit test for Instant.
org.joda.time.TestMutableInterval_Constructors: This class is a JUnit test for Interval.
org.joda.time.TestMutableInterval_Updates: This class is a Junit unit test for Instant.
org.joda.time.TestMutablePeriod_Basics: This class is a Junit unit test for MutableDuration.
org.joda.time.TestMutablePeriod_Constructors: This class is a JUnit test for MutableDuration.
org.joda.time.TestMutablePeriod_Constructors.testConstructor1	(	): Test constructor ()
org.joda.time.TestMutablePeriod_Constructors.testConstructor_4int1	(	): Test constructor (4ints)
org.joda.time.TestMutablePeriod_Constructors.testConstructor_8int1	(	): Test constructor (8ints)
org.joda.time.TestMutablePeriod_Constructors.testConstructor_8int__PeriodType1	(	): Test constructor (8ints)
org.joda.time.TestMutablePeriod_Constructors.testConstructor_Object1	(	): Test constructor (Object)
org.joda.time.TestMutablePeriod_Constructors.testConstructor_Object_PeriodType1	(	): Test constructor (Object,PeriodType)
org.joda.time.TestMutablePeriod_Constructors.testConstructor_PeriodType1	(	): Test constructor (PeriodType)
org.joda.time.TestMutablePeriod_Updates: This class is a JUnit test for MutableDuration.
org.joda.time.TestPartial_Basics: This class is a Junit unit test for Partial.
org.joda.time.TestPartial_Constructors: This class is a Junit unit test for Partial.
org.joda.time.TestPartial_Constructors.assertMessageContains	(	Exception	String	): Checks if the exception message is valid.
org.joda.time.TestPartial_Constructors.assertMessageContains	(	Exception	String	String	): Checks if the exception message is valid.
org.joda.time.TestPartial_Constructors.testConstructor	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor2_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx1_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx1_Type_int	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx2_Type_int	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx2_Type_int_Chrono	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx3_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx5_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx6_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx7_TypeArray_intArray_inOrder	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx8_TypeArray_intArray_duplicate	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx9_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx_Partial	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructorEx_Type_int_Chrono	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_Chrono	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_Partial	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_TypeArray_intArray	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_TypeArray_intArray_Chrono	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_TypeArray_intArray_year_weekyear	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_Type_int	(	): Test constructor
org.joda.time.TestPartial_Constructors.testConstructor_Type_int_Chrono	(	): Test constructor
org.joda.time.TestPartial_Match: This class is a Junit unit test for Partial.
org.joda.time.TestPartial_Properties: This class is a Junit unit test for Partial.
org.joda.time.TestPeriodType: This class is a JUnit test for PeriodType.
org.joda.time.TestPeriod_Basics: This class is a Junit unit test for Duration.
org.joda.time.TestPeriod_Constructors: This class is a JUnit test for Duration.
org.joda.time.TestPeriod_Constructors.testConstructor_4int1	(	): Test constructor (4ints)
org.joda.time.TestPeriod_Constructors.testConstructor_8int1	(	): Test constructor (8ints)
org.joda.time.TestPeriod_Constructors.testConstructor_8int__PeriodType1	(	): Test constructor (8ints)
org.joda.time.TestPeriod_Constructors.testConstructor_Object1	(	): Test constructor (Object)
org.joda.time.TestPeriod_Constructors.testConstructor_Object_PeriodType1	(	): Test constructor (Object)
org.joda.time.TestSeconds: This class is a Junit unit test for Seconds.
org.joda.time.TestSerialization: This class is a Junit unit test for serialization.
org.joda.time.TestStringConvert: Test string conversion.
org.joda.time.TestTimeOfDay_Basics: This class is a Junit unit test for TimeOfDay.
org.joda.time.TestTimeOfDay_Constructors: This class is a Junit unit test for TimeOfDay.
org.joda.time.TestTimeOfDay_Constructors.testConstantMidnight	(	): Test constructor ()
org.joda.time.TestTimeOfDay_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestTimeOfDay_Constructors.testConstructor2_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_Object1	(	): Test constructor (Object)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_Object2	(	): Test constructor (Object)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int	(	): Test constructor (int, int)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_Chronology	(	): Test constructor (int, int, int, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_int	(	): Test constructor (int, int, int)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_int_Chronology	(	): Test constructor (int, int, int, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_int_int	(	): Test constructor (int, int, int, int)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_int_int_Chronology	(	): Test constructor (int, int, int, int, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_int_int_nullChronology	(	): Test constructor (int, int, int, int, Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_int_nullChronology	(	): Test constructor (int, int, int, Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_int_int_nullChronology	(	): Test constructor (int, int, int, Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_nullObject	(	): Test constructor (Object=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestTimeOfDay_Constructors.testConstructor_todObject	(	): Test constructor (Object)
org.joda.time.TestTimeOfDay_Constructors.testFactoryMillisOfDay_long1	(	): Test factory (long)
org.joda.time.TestTimeOfDay_Constructors.testFactoryMillisOfDay_long1_Chronology	(	): Test factory (long, Chronology)
org.joda.time.TestTimeOfDay_Constructors.testFactoryMillisOfDay_long_nullChronology	(	): Test factory (long, Chronology=null)
org.joda.time.TestTimeOfDay_Properties: This class is a Junit unit test for TimeOfDay.
org.joda.time.TestWeeks: This class is a Junit unit test for Weeks.
org.joda.time.TestYearMonthDay_Basics: This class is a Junit unit test for YearMonthDay.
org.joda.time.TestYearMonthDay_Constructors: This class is a Junit unit test for YearMonthDay.
org.joda.time.TestYearMonthDay_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestYearMonthDay_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_int_int_int	(	): Test constructor (int, int, int)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_int_int_int_Chronology	(	): Test constructor (int, int, int, Chronology)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_int_int_int_nullChronology	(	): Test constructor (int, int, int, Chronology=null)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestYearMonthDay_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestYearMonthDay_Properties: This class is a Junit unit test for YearMonthDay.
org.joda.time.TestYearMonth_Basics: This class is a Junit unit test for YearMonth.
org.joda.time.TestYearMonth_Constructors: This class is a Junit unit test for YearMonth.
org.joda.time.TestYearMonth_Constructors.testConstructor	(	): Test constructor ()
org.joda.time.TestYearMonth_Constructors.testConstructor_Chronology	(	): Test constructor (Chronology)
org.joda.time.TestYearMonth_Constructors.testConstructor_DateTimeZone	(	): Test constructor (DateTimeZone)
org.joda.time.TestYearMonth_Constructors.testConstructor_Object_Chronology	(	): Test constructor (Object, Chronology)
org.joda.time.TestYearMonth_Constructors.testConstructor_Object_nullChronology	(	): Test constructor (Object, Chronology=null)
org.joda.time.TestYearMonth_Constructors.testConstructor_int_int	(	): Test constructor (int, int)
org.joda.time.TestYearMonth_Constructors.testConstructor_int_int_Chronology	(	): Test constructor (int, int, Chronology)
org.joda.time.TestYearMonth_Constructors.testConstructor_int_int_nullChronology	(	): Test constructor (int, int, Chronology=null)
org.joda.time.TestYearMonth_Constructors.testConstructor_long1	(	): Test constructor (long)
org.joda.time.TestYearMonth_Constructors.testConstructor_long1_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestYearMonth_Constructors.testConstructor_long2	(	): Test constructor (long)
org.joda.time.TestYearMonth_Constructors.testConstructor_long2_Chronology	(	): Test constructor (long, Chronology)
org.joda.time.TestYearMonth_Constructors.testConstructor_long_nullChronology	(	): Test constructor (long, Chronology=null)
org.joda.time.TestYearMonth_Constructors.testConstructor_nullChronology	(	): Test constructor (Chronology=null)
org.joda.time.TestYearMonth_Constructors.testConstructor_nullDateTimeZone	(	): Test constructor (DateTimeZone=null)
org.joda.time.TestYearMonth_Constructors.testConstructor_nullObject_Chronology	(	): Test constructor (Object=null, Chronology)
org.joda.time.TestYearMonth_Constructors.testConstructor_nullObject_nullChronology	(	): Test constructor (Object=null, Chronology=null)
org.joda.time.TestYearMonth_Properties: This class is a Junit unit test for YearMonth.
org.joda.time.TestYears: This class is a Junit unit test for Years.
org.joda.time.TimeOfDay: TimeOfDay is an immutable partial supporting the hour, minute, second and millisecond fields.  NOTE: This class only supports the four fields listed above. Thus, you cannot query the millisOfDay or secondOfDay fields for example. The new LocalTime class removes this restriction.  Calculations on TimeOfDay are performed using a Chronology. This chronology is set to be in the UTC time zone for all calculations.  Each individual field can be queried in two ways:  getHourOfDay() hourOfDay().get()  The second technique also provides access to other useful methods on the field:  numeric value - hourOfDay().get() text value - hourOfDay().getAsText() short text value - hourOfDay().getAsShortText() maximum/minimum values - hourOfDay().getMaximumValue() add/subtract - hourOfDay().addToCopy() set - hourOfDay().setCopy()   TimeOfDay is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.TimeOfDay.Property: The property class for TimeOfDay.  This class binds a TimeOfDay to a DateTimeField.
org.joda.time.TimeOfDay.Property.Property	(	TimeOfDay	int	): Constructs a property.
org.joda.time.TimeOfDay.Property.addNoWrapToCopy	(	int	): Adds to the value of this field in a copy of this TimeOfDay, throwing an Exception if the bounds are exceeded.  The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected.  If the result would be too large (beyond 23:59:59:999) or too small (less than 00:00:00.000) then an Exception is thrown. For the alternate behaviour which wraps to the next 'day', see addToCopy().  The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.TimeOfDay.Property.addToCopy	(	int	): Adds to the value of this field in a copy of this TimeOfDay, wrapping to what would be the next day if necessary.  The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected.  If the result would be too large, beyond 23:59:59:999, then the calculation wraps to 00:00:00.000. For the alternate strict behaviour with no wrapping see addNoWrapToCopy().  The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.TimeOfDay.Property.addWrapFieldToCopy	(	int	): Adds to the value of this field in a copy of this TimeOfDay wrapping within this field if the maximum value is reached.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps within this field. Other fields are unaffected.  For example, 12:59:37 addWrapField one minute returns 12:00:37.  The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.TimeOfDay.Property.get	(	): Gets the value of this field.
org.joda.time.TimeOfDay.Property.getField	(	): Gets the field that this property uses.
org.joda.time.TimeOfDay.Property.getReadablePartial	(	): Gets the partial that this property belongs to.
org.joda.time.TimeOfDay.Property.getTimeOfDay	(	): Gets the partial that this property belongs to.
org.joda.time.TimeOfDay.Property.setCopy	(	String	): Sets this field in a copy of the TimeOfDay to a parsed text value.  The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.TimeOfDay.Property.setCopy	(	String	Locale	): Sets this field in a copy of the TimeOfDay to a parsed text value.  The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.TimeOfDay.Property.setCopy	(	int	): Sets this field in a copy of the TimeOfDay.  The TimeOfDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.TimeOfDay.Property.withMaximumValue	(	): Returns a new TimeOfDay with this field set to the maximum value for this field.  The TimeOfDay attached to this property is unchanged by this call.
org.joda.time.TimeOfDay.Property.withMinimumValue	(	): Returns a new TimeOfDay with this field set to the minimum value for this field.  The TimeOfDay attached to this property is unchanged by this call.
org.joda.time.TimeOfDay.TimeOfDay	(	): Constructs a TimeOfDay with the current time, using ISOChronology in the default zone to extract the fields.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	Chronology	): Constructs a TimeOfDay with the current time, using the specified chronology and zone to extract the fields.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	DateTimeZone	): Constructs a TimeOfDay with the current time, using ISOChronology in the specified zone to extract the fields.  The constructor uses the specified time zone to obtain the current time. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	Object	): Constructs a TimeOfDay from an Object that represents a time.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by timeParser().  The chronology used will be derived from the object, defaulting to ISO.  NOTE: Prior to v1.3 the string format was described by dateTimeParser(). Dates are now rejected.
org.joda.time.TimeOfDay.TimeOfDay	(	Object	Chronology	): Constructs a TimeOfDay from an Object that represents a time, using the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by timeParser().  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC). The specified chronology overrides that of the object.  NOTE: Prior to v1.3 the string format was described by dateTimeParser(). Dates are now rejected.
org.joda.time.TimeOfDay.TimeOfDay	(	TimeOfDay	Chronology	): Constructs a TimeOfDay with values from this instance and a new chronology.
org.joda.time.TimeOfDay.TimeOfDay	(	TimeOfDay	int[]	): Constructs a TimeOfDay with chronology from this instance and new values.
org.joda.time.TimeOfDay.TimeOfDay	(	int	int	): Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds using ISOChronology in the default zone.  The constructor uses the no time zone initialising the fields as provided. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	int	int	Chronology	): Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	int	int	int	): Constructs a TimeOfDay with specified time field values and zero milliseconds using ISOChronology in the default zone.  The constructor uses the no time zone initialising the fields as provided. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	int	int	int	Chronology	): Constructs a TimeOfDay with specified time field values and zero milliseconds.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	int	int	int	int	): Constructs a TimeOfDay with specified time field values using ISOChronology in the default zone.  The constructor uses the no time zone initialising the fields as provided. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	int	int	int	int	Chronology	): Constructs a TimeOfDay with specified time field values and chronology.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	long	): Constructs a TimeOfDay extracting the partial fields from the specified milliseconds using the ISOChronology in the default zone.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.TimeOfDay	(	long	Chronology	): Constructs a TimeOfDay extracting the partial fields from the specified milliseconds using the chronology provided.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.TimeOfDay.fromCalendarFields	(	Calendar	): Constructs a TimeOfDay from a java.util.Calendar using exactly the same field values avoiding any time zone effects.  Each field is queried from the Calendar and assigned to the TimeOfDay. This is useful to ensure that the field values are the same in the created TimeOfDay no matter what the time zone is. For example, if the Calendar states that the time is 04:29, then the created TimeOfDay will always have the time 04:29 irrespective of time zone issues.  This factory method ignores the type of the calendar and always creates a TimeOfDay with ISO chronology.
org.joda.time.TimeOfDay.fromDateFields	(	Date	): Constructs a TimeOfDay from a java.util.Date using exactly the same field values avoiding any time zone effects.  Each field is queried from the Date and assigned to the TimeOfDay. This is useful to ensure that the field values are the same in the created TimeOfDay no matter what the time zone is. For example, if the Calendar states that the time is 04:29, then the created TimeOfDay will always have the time 04:29 irrespective of time zone issues.  This factory method always creates a TimeOfDay with ISO chronology.
org.joda.time.TimeOfDay.fromMillisOfDay	(	long	): Constructs a TimeOfDay from the specified millis of day using the ISO chronology.  The millisOfDay value may exceed the number of millis in one day, but additional days will be ignored. This method uses the UTC time zone internally.
org.joda.time.TimeOfDay.fromMillisOfDay	(	long	Chronology	): Constructs a TimeOfDay from the specified millis of day using the specified chronology.  The millisOfDay value may exceed the number of millis in one day, but additional days will be ignored. This method uses the UTC time zone internally.
org.joda.time.TimeOfDay.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.TimeOfDay.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.TimeOfDay.getFieldTypes	(	): Gets an array of the field type of each of the fields that this partial supports.  The fields are returned largest to smallest, Hour, Minute, Second, Millis.
org.joda.time.TimeOfDay.getHourOfDay	(	): Get the hour of day (0-23) field value.
org.joda.time.TimeOfDay.getMillisOfSecond	(	): Get the millis of second field value.
org.joda.time.TimeOfDay.getMinuteOfHour	(	): Get the minute of hour field value.
org.joda.time.TimeOfDay.getSecondOfMinute	(	): Get the second of minute field value.
org.joda.time.TimeOfDay.hourOfDay	(	): Get the hour of day field property which provides access to advanced functionality.
org.joda.time.TimeOfDay.millisOfSecond	(	): Get the millis of second property which provides access to advanced functionality.
org.joda.time.TimeOfDay.minus	(	ReadablePeriod	): Returns a copy of this time with the specified period taken away, wrapping to what would be a new day if required.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusHours().
org.joda.time.TimeOfDay.minusHours	(	int	): Returns a copy of this time minus the specified number of hours.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay subtracted = dt.minusHours(6); TimeOfDay subtracted = dt.minus(Period.hours(6)); TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6); 
org.joda.time.TimeOfDay.minusMillis	(	int	): Returns a copy of this time minus the specified number of millis.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay subtracted = dt.minusMillis(6); TimeOfDay subtracted = dt.minus(Period.millis(6)); TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6); 
org.joda.time.TimeOfDay.minusMinutes	(	int	): Returns a copy of this time minus the specified number of minutes.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay subtracted = dt.minusMinutes(6); TimeOfDay subtracted = dt.minus(Period.minutes(6)); TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6); 
org.joda.time.TimeOfDay.minusSeconds	(	int	): Returns a copy of this time minus the specified number of seconds.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay subtracted = dt.minusSeconds(6); TimeOfDay subtracted = dt.minus(Period.seconds(6)); TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6); 
org.joda.time.TimeOfDay.minuteOfHour	(	): Get the minute of hour field property which provides access to advanced functionality.
org.joda.time.TimeOfDay.plus	(	ReadablePeriod	): Returns a copy of this time with the specified period added, wrapping to what would be a new day if required.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusHours().
org.joda.time.TimeOfDay.plusHours	(	int	): Returns a copy of this time plus the specified number of hours.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay added = dt.plusHours(6); TimeOfDay added = dt.plus(Period.hours(6)); TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6); 
org.joda.time.TimeOfDay.plusMillis	(	int	): Returns a copy of this time plus the specified number of millis.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay added = dt.plusMillis(6); TimeOfDay added = dt.plus(Period.millis(6)); TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6); 
org.joda.time.TimeOfDay.plusMinutes	(	int	): Returns a copy of this time plus the specified number of minutes.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay added = dt.plusMinutes(6); TimeOfDay added = dt.plus(Period.minutes(6)); TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6); 
org.joda.time.TimeOfDay.plusSeconds	(	int	): Returns a copy of this time plus the specified number of seconds.  This time instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  TimeOfDay added = dt.plusSeconds(6); TimeOfDay added = dt.plus(Period.seconds(6)); TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6); 
org.joda.time.TimeOfDay.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.TimeOfDay.secondOfMinute	(	): Get the second of minute field property which provides access to advanced functionality.
org.joda.time.TimeOfDay.size	(	): Gets the number of fields in this partial.
org.joda.time.TimeOfDay.toDateTimeToday	(	): Converts this partial to a full datetime using the default time zone setting the time fields from this instance and the date fields from the current time.
org.joda.time.TimeOfDay.toDateTimeToday	(	DateTimeZone	): Converts this partial to a full datetime using the specified time zone setting the time fields from this instance and the date fields from the current time.  This method uses the chronology from this instance plus the time zone specified.
org.joda.time.TimeOfDay.toLocalTime	(	): Converts this object to a LocalTime with the same time and chronology.
org.joda.time.TimeOfDay.toString	(	): Output the time in the ISO8601 format THH:mm:ss.SSS.
org.joda.time.TimeOfDay.withChronologyRetainFields	(	Chronology	): Returns a copy of this time with the specified chronology. This instance is immutable and unaffected by this method call.  This method retains the values of the fields, thus the result will typically refer to a different instant.  The time zone of the specified chronology is ignored, as TimeOfDay operates without a time zone.
org.joda.time.TimeOfDay.withField	(	DateTimeFieldType	int	): Returns a copy of this time with the specified field set to a new value.  For example, if the field type is minuteOfHour then the day would be changed in the returned instance.  These three lines are equivalent:  TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6); TimeOfDay updated = tod.minuteOfHour().setCopy(6); TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6); 
org.joda.time.TimeOfDay.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this time with the value of the specified field increased, wrapping to what would be a new day if required.  If the addition is zero, then this is returned.  These three lines are equivalent:  TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6); TimeOfDay added = tod.plusMinutes(6); TimeOfDay added = tod.minuteOfHour().addToCopy(6); 
org.joda.time.TimeOfDay.withHourOfDay	(	int	): Returns a copy of this time with the hour of day field updated.  TimeOfDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of hour of day changed.
org.joda.time.TimeOfDay.withMillisOfSecond	(	int	): Returns a copy of this time with the millis of second field updated.  TimeOfDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of millis of second changed.
org.joda.time.TimeOfDay.withMinuteOfHour	(	int	): Returns a copy of this time with the minute of hour field updated.  TimeOfDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of minute of hour changed.
org.joda.time.TimeOfDay.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this time with the specified period added, wrapping to what would be a new day if required.  If the addition is zero, then this is returned. Fields in the period that aren't present in the partial are ignored.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusHours().
org.joda.time.TimeOfDay.withSecondOfMinute	(	int	): Returns a copy of this time with the second of minute field updated.  TimeOfDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of second of minute changed.
org.joda.time.UTCDateTimeZone: A DateTimeZone implementation for UTC.  This exists instead of using FixedDateTimeZone to avoid deadlocks. https://github.com/JodaOrg/joda-time/issues/171
org.joda.time.Weeks: An immutable time period representing a number of weeks.  Weeks is an immutable period that can only store weeks. It does not store years, months or hours for example. As such it is a type-safe way of representing a number of weeks in an application.  The number of weeks is set in the constructor, and may be queried using getWeeks(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Weeks is thread-safe and immutable.
org.joda.time.Weeks.Weeks	(	int	): Creates a new instance representing a number of weeks. You should consider using the factory method weeks() instead of the constructor.
org.joda.time.Weeks.dividedBy	(	int	): Returns a new instance with the weeks divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Weeks.getFieldType	(	): Gets the duration field type, which is weeks.
org.joda.time.Weeks.getPeriodType	(	): Gets the period type, which is weeks.
org.joda.time.Weeks.getWeeks	(	): Gets the number of weeks that this period represents.
org.joda.time.Weeks.isGreaterThan	(	Weeks	): Is this weeks instance greater than the specified number of weeks.
org.joda.time.Weeks.isLessThan	(	Weeks	): Is this weeks instance less than the specified number of weeks.
org.joda.time.Weeks.minus	(	Weeks	): Returns a new instance with the specified number of weeks taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Weeks.minus	(	int	): Returns a new instance with the specified number of weeks taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Weeks.multipliedBy	(	int	): Returns a new instance with the weeks multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Weeks.negated	(	): Returns a new instance with the weeks value negated.
org.joda.time.Weeks.parseWeeks	(	String	): Creates a new Weeks by parsing a string in the ISO8601 format 'PnW'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the weeks component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Weeks.plus	(	Weeks	): Returns a new instance with the specified number of weeks added.  This instance is immutable and unaffected by this method call.
org.joda.time.Weeks.plus	(	int	): Returns a new instance with the specified number of weeks added.  This instance is immutable and unaffected by this method call.
org.joda.time.Weeks.readResolve	(	): Resolves singletons.
org.joda.time.Weeks.standardWeeksIn	(	ReadablePeriod	): Creates a new Weeks representing the number of complete standard length weeks in the specified period.  This factory method converts all fields from the period to hours using standardised durations for each field. Only those fields which have a precise duration in the ISO UTC chronology can be converted.  One week consists of 7 days. One day consists of 24 hours. One hour consists of 60 minutes. One minute consists of 60 weeks. One second consists of 1000 milliseconds.  Months and Years are imprecise and periods containing these values cannot be converted.
org.joda.time.Weeks.toStandardDays	(	): Converts this period in weeks to a period in days assuming a 7 day week.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long. This may not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Weeks.toStandardDuration	(	): Converts this period in weeks to a duration in milliweeks assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert from a period to a duration. However to achieve this it makes the assumption that all weeks are 7 days long, all days are 24 hours long, all hours are 60 minutes long and all minutes are 60 seconds long. This is not true when daylight savings time is considered, and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Weeks.toStandardHours	(	): Converts this period in weeks to a period in hours assuming a 7 day week and 24 hour day.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long and all days are 24 hours long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Weeks.toStandardMinutes	(	): Converts this period in weeks to a period in minutes assuming a 7 day week, 24 hour day and 60 minute hour.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long, all days are 24 hours long and all hours are 60 minutes long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Weeks.toStandardSeconds	(	): Converts this period in weeks to a period in seconds assuming a 7 day week, 24 hour day, 60 minute hour and 60 second minute.  This method allows you to convert between different types of period. However to achieve this it makes the assumption that all weeks are 7 days long, all days are 24 hours long, all hours are 60 minutes long and all minutes are 60 seconds long. This is not true when daylight savings is considered and may also not be true for some unusual chronologies. However, it is included as it is a useful operation for many applications and business rules.
org.joda.time.Weeks.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "P4W" represents 4 weeks.
org.joda.time.Weeks.weeks	(	int	): Obtains an instance of Weeks that may be cached. Weeks is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Weeks.weeksBetween	(	ReadableInstant	ReadableInstant	): Creates a Weeks representing the number of whole weeks between the two specified datetimes.
org.joda.time.Weeks.weeksBetween	(	ReadablePartial	ReadablePartial	): Creates a Weeks representing the number of whole weeks between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalDate objects.
org.joda.time.Weeks.weeksIn	(	ReadableInterval	): Creates a Weeks representing the number of whole weeks in the specified interval.
org.joda.time.YearMonth: YearMonth is an immutable partial supporting the year and monthOfYear fields.  NOTE: This class only supports the two fields listed above. It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.  Calculations on YearMonth are performed using a Chronology. This chronology is set to be in the UTC time zone for all calculations.  One use case for this class is to store a credit card expiry date, as that only references the year and month. This class can be used as the gYearMonth type in XML Schema.  Each individual field can be queried in two ways:  getMonthOfYear() monthOfYear().get()  The second technique also provides access to other useful methods on the field:  numeric value - monthOfYear().get() text value - monthOfYear().getAsText() short text value - monthOfYear().getAsShortText() maximum/minimum values - monthOfYear().getMaximumValue() add/subtract - monthOfYear().addToCopy() set - monthOfYear().setCopy()   YearMonth is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.YearMonth.Property: The property class for YearMonth.  This class binds a YearMonth to a DateTimeField.
org.joda.time.YearMonth.Property.Property	(	YearMonth	int	): Constructs a property.
org.joda.time.YearMonth.Property.addToCopy	(	int	): Adds to the value of this field in a copy of this YearMonth.  The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected.  If the result would be too large, beyond the maximum year, then an IllegalArgumentException is thrown.  The YearMonth attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonth.Property.addWrapFieldToCopy	(	int	): Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps within this field. Other fields are unaffected.  For example, 2004-12 addWrapField one month returns 2004-01.  The YearMonth attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonth.Property.get	(	): Gets the value of this field.
org.joda.time.YearMonth.Property.getField	(	): Gets the field that this property uses.
org.joda.time.YearMonth.Property.getReadablePartial	(	): Gets the partial that this property belongs to.
org.joda.time.YearMonth.Property.getYearMonth	(	): Gets the partial that this property belongs to.
org.joda.time.YearMonth.Property.setCopy	(	String	): Sets this field in a copy of the YearMonth to a parsed text value.  The YearMonth attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonth.Property.setCopy	(	String	Locale	): Sets this field in a copy of the YearMonth to a parsed text value.  The YearMonth attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonth.Property.setCopy	(	int	): Sets this field in a copy of the YearMonth.  The YearMonth attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonth.YearMonth	(	): Constructs a YearMonth with the current year-month, using ISOChronology in the default zone to extract the fields.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.YearMonth	(	Chronology	): Constructs a YearMonth with the current year-month, using the specified chronology and zone to extract the fields.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.YearMonth	(	DateTimeZone	): Constructs a YearMonth with the current year-month, using ISOChronology in the specified zone to extract the fields.  The constructor uses the specified time zone to obtain the current year-month. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.YearMonth	(	Object	): Constructs a YearMonth from an Object that represents some form of time.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser().  The chronology used will be derived from the object, defaulting to ISO.
org.joda.time.YearMonth.YearMonth	(	Object	Chronology	): Constructs a YearMonth from an Object that represents some form of time, using the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by localDateParser().  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC). The specified chronology overrides that of the object.
org.joda.time.YearMonth.YearMonth	(	YearMonth	Chronology	): Constructs a YearMonth with values from this instance and a new chronology.
org.joda.time.YearMonth.YearMonth	(	YearMonth	int[]	): Constructs a YearMonth with chronology from this instance and new values.
org.joda.time.YearMonth.YearMonth	(	int	int	): Constructs a YearMonth with specified year and month using ISOChronology.  The constructor uses the no time zone initialising the fields as provided. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.YearMonth	(	int	int	Chronology	): Constructs an instance set to the specified year and month using the specified chronology, whose zone is ignored.  If the chronology is null, ISOChronology is used.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.YearMonth	(	long	): Constructs a YearMonth extracting the partial fields from the specified milliseconds using the ISOChronology in the default zone.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.YearMonth	(	long	Chronology	): Constructs a YearMonth extracting the partial fields from the specified milliseconds using the chronology provided.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a time-zone (by switching to UTC).
org.joda.time.YearMonth.fromCalendarFields	(	Calendar	): Constructs a YearMonth from a java.util.Calendar using exactly the same field values avoiding any time zone effects.  Each field is queried from the Calendar and assigned to the YearMonth.  This factory method ignores the type of the calendar and always creates a YearMonth with ISO chronology. It is expected that you will only pass in instances of GregorianCalendar however this is not validated.
org.joda.time.YearMonth.fromDateFields	(	Date	): Constructs a YearMonth from a java.util.Date using exactly the same field values avoiding any time zone effects.  Each field is queried from the Date and assigned to the YearMonth.  This factory method always creates a YearMonth with ISO chronology.
org.joda.time.YearMonth.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.YearMonth.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.YearMonth.getFieldTypes	(	): Gets an array of the field type of each of the fields that this partial supports.  The fields are returned largest to smallest, Year, Month.
org.joda.time.YearMonth.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.YearMonth.getYear	(	): Get the year field value.
org.joda.time.YearMonth.minus	(	ReadablePeriod	): Returns a copy of this year-month with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusYears().
org.joda.time.YearMonth.minusMonths	(	int	): Returns a copy of this year-month minus the specified number of months.  This year-month instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonth subtracted = ym.minusMonths(6); YearMonth subtracted = ym.minus(Period.months(6)); YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6); 
org.joda.time.YearMonth.minusYears	(	int	): Returns a copy of this year-month minus the specified number of years.  This year-month instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonth subtracted = ym.minusYears(6); YearMonth subtracted = ym.minus(Period.years(6)); YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6); 
org.joda.time.YearMonth.monthOfYear	(	): Get the month of year field property which provides access to advanced functionality.
org.joda.time.YearMonth.now	(	): Obtains a YearMonth set to the current system millisecond time using ISOChronology in the default time zone. The resulting object does not use the zone.
org.joda.time.YearMonth.now	(	Chronology	): Obtains a YearMonth set to the current system millisecond time using the specified chronology. The resulting object does not use the zone.
org.joda.time.YearMonth.now	(	DateTimeZone	): Obtains a YearMonth set to the current system millisecond time using ISOChronology in the specified time zone. The resulting object does not use the zone.
org.joda.time.YearMonth.parse	(	String	): Parses a YearMonth from the specified string.  This uses localDateParser().
org.joda.time.YearMonth.parse	(	String	DateTimeFormatter	): Parses a YearMonth from the specified string using a formatter.
org.joda.time.YearMonth.plus	(	ReadablePeriod	): Returns a copy of this year-month with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusYears().
org.joda.time.YearMonth.plusMonths	(	int	): Returns a copy of this year-month plus the specified number of months.  This year-month instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonth added = ym.plusMonths(6); YearMonth added = ym.plus(Period.months(6)); YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6); 
org.joda.time.YearMonth.plusYears	(	int	): Returns a copy of this year-month plus the specified number of years.  This year-month instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonth added = ym.plusYears(6); YearMonth added = ym.plus(Period.years(6)); YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6); 
org.joda.time.YearMonth.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.YearMonth.readResolve	(	): Handle broken serialization from other tools.
org.joda.time.YearMonth.size	(	): Gets the number of fields in this partial, which is two. The supported fields are Year and MonthOfYear. Note that only these fields may be queried.
org.joda.time.YearMonth.toInterval	(	): Converts this object to an Interval representing the whole month.  The interval will use the chronology of the year-month in the default zone.  This instance is immutable and unaffected by this method call.
org.joda.time.YearMonth.toInterval	(	DateTimeZone	): Converts this object to an Interval representing the whole month.  The interval will use the chronology of the year-month in the specified zone.  This instance is immutable and unaffected by this method call.
org.joda.time.YearMonth.toLocalDate	(	int	): Converts this object to a LocalDate with the same year-month and chronology.
org.joda.time.YearMonth.toString	(	): Output the year-month in ISO8601 format (yyyy-MM).
org.joda.time.YearMonth.toString	(	String	): Output the year-month using the specified format pattern.
org.joda.time.YearMonth.toString	(	String	Locale	): Output the year-month using the specified format pattern.
org.joda.time.YearMonth.withChronologyRetainFields	(	Chronology	): Returns a copy of this year-month with the specified chronology. This instance is immutable and unaffected by this method call.  This method retains the values of the fields, thus the result will typically refer to a different instant.  The time zone of the specified chronology is ignored, as YearMonth operates without a time zone.
org.joda.time.YearMonth.withField	(	DateTimeFieldType	int	): Returns a copy of this year-month with the specified field set to a new value.  For example, if the field type is monthOfYear then the month would be changed in the returned instance.  These three lines are equivalent:  YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6); YearMonth updated = ym.monthOfYear().setCopy(6); YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6); 
org.joda.time.YearMonth.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this year-month with the value of the specified field increased.  If the addition is zero, then this is returned.  These three lines are equivalent:  YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6); YearMonth added = ym.plusMonths(6); YearMonth added = ym.monthOfYear().addToCopy(6); 
org.joda.time.YearMonth.withMonthOfYear	(	int	): Returns a copy of this year-month with the month of year field updated.  YearMonth is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.YearMonth.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this year-month with the specified period added.  If the addition is zero, then this is returned. Fields in the period that aren't present in the partial are ignored.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusYears().
org.joda.time.YearMonth.withYear	(	int	): Returns a copy of this year-month with the year field updated.  YearMonth is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year changed.
org.joda.time.YearMonth.year	(	): Get the year field property which provides access to advanced functionality.
org.joda.time.YearMonthDay: YearMonthDay is an immutable partial supporting the year, monthOfYear and dayOfMonth fields.  NOTE: This class only supports the three fields listed above. Thus, you cannot query the dayOfWeek or centuryOfEra fields for example. The new LocalDate class removes this restriction.  Calculations on YearMonthDay are performed using a Chronology. This chronology is set to be in the UTC time zone for all calculations.  Each individual field can be queried in two ways:  getMonthOfYear() monthOfYear().get()  The second technique also provides access to other useful methods on the field:  numeric value - monthOfYear().get() text value - monthOfYear().getAsText() short text value - monthOfYear().getAsShortText() maximum/minimum values - monthOfYear().getMaximumValue() add/subtract - monthOfYear().addToCopy() set - monthOfYear().setCopy()   YearMonthDay is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.
org.joda.time.YearMonthDay.Property: The property class for YearMonthDay.  This class binds a YearMonthDay to a DateTimeField.
org.joda.time.YearMonthDay.Property.Property	(	YearMonthDay	int	): Constructs a property.
org.joda.time.YearMonthDay.Property.addToCopy	(	int	): Adds to the value of this field in a copy of this YearMonthDay.  The value will be added to this field. If the value is too large to be added solely to this field then it will affect larger fields. Smaller fields are unaffected.  If the result would be too large, beyond the maximum year, then an IllegalArgumentException is thrown.  The YearMonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonthDay.Property.addWrapFieldToCopy	(	int	): Adds to the value of this field in a copy of this YearMonthDay wrapping within this field if the maximum value is reached.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps within this field. Other fields are unaffected.  For example, 2004-12-20 addWrapField one month returns 2004-01-20.  The YearMonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonthDay.Property.get	(	): Gets the value of this field.
org.joda.time.YearMonthDay.Property.getField	(	): Gets the field that this property uses.
org.joda.time.YearMonthDay.Property.getReadablePartial	(	): Gets the partial that this property belongs to.
org.joda.time.YearMonthDay.Property.getYearMonthDay	(	): Gets the partial that this property belongs to.
org.joda.time.YearMonthDay.Property.setCopy	(	String	): Sets this field in a copy of the YearMonthDay to a parsed text value.  The YearMonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonthDay.Property.setCopy	(	String	Locale	): Sets this field in a copy of the YearMonthDay to a parsed text value.  The YearMonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonthDay.Property.setCopy	(	int	): Sets this field in a copy of the YearMonthDay.  The YearMonthDay attached to this property is unchanged by this call. Instead, a new instance is returned.
org.joda.time.YearMonthDay.Property.withMaximumValue	(	): Returns a new YearMonthDay with this field set to the maximum value for this field.  This operation is useful for obtaining a DateTime on the last day of the month, as month lengths vary.  YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();   The YearMonthDay attached to this property is unchanged by this call.
org.joda.time.YearMonthDay.Property.withMinimumValue	(	): Returns a new YearMonthDay with this field set to the minimum value for this field.  The YearMonthDay attached to this property is unchanged by this call.
org.joda.time.YearMonthDay.YearMonthDay	(	): Constructs a YearMonthDay with the current date, using ISOChronology in the default zone to extract the fields.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.YearMonthDay	(	Chronology	): Constructs a YearMonthDay with the current date, using the specified chronology and zone to extract the fields.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.YearMonthDay	(	DateTimeZone	): Constructs a YearMonthDay with the current date, using ISOChronology in the specified zone to extract the fields.  The constructor uses the specified time zone to obtain the current date. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.YearMonthDay	(	Object	): Constructs a YearMonthDay from an Object that represents a time.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateOptionalTimeParser().  The chronology used will be derived from the object, defaulting to ISO.  NOTE: Prior to v1.3 the string format was described by dateTimeParser(). Time only strings are now rejected.
org.joda.time.YearMonthDay.YearMonthDay	(	Object	Chronology	): Constructs a YearMonthDay from an Object that represents a time, using the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date. The String formats are described by dateOptionalTimeParser().  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC). The specified chronology overrides that of the object.  NOTE: Prior to v1.3 the string format was described by dateTimeParser(). Time only strings are now rejected.
org.joda.time.YearMonthDay.YearMonthDay	(	YearMonthDay	Chronology	): Constructs a YearMonthDay with values from this instance and a new chronology.
org.joda.time.YearMonthDay.YearMonthDay	(	YearMonthDay	int[]	): Constructs a YearMonthDay with chronology from this instance and new values.
org.joda.time.YearMonthDay.YearMonthDay	(	int	int	int	): Constructs a YearMonthDay with specified time field values using ISOChronology in the default zone.  The constructor uses the no time zone initialising the fields as provided. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.YearMonthDay	(	int	int	int	Chronology	): Constructs a YearMonthDay with specified time field values.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.YearMonthDay	(	long	): Constructs a YearMonthDay extracting the partial fields from the specified milliseconds using the ISOChronology in the default zone.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.YearMonthDay	(	long	Chronology	): Constructs a YearMonthDay extracting the partial fields from the specified milliseconds using the chronology provided.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.YearMonthDay.dayOfMonth	(	): Get the day of month field property which provides access to advanced functionality.
org.joda.time.YearMonthDay.fromCalendarFields	(	Calendar	): Constructs a YearMonthDay from a java.util.Calendar using exactly the same field values avoiding any time zone effects.  Each field is queried from the Calendar and assigned to the YearMonthDay. This is useful if you have been using the Calendar as a local date, ignoring the zone.  This factory method ignores the type of the calendar and always creates a YearMonthDay with ISO chronology. It is expected that you will only pass in instances of GregorianCalendar however this is not validated.
org.joda.time.YearMonthDay.fromDateFields	(	Date	): Constructs a YearMonthDay from a java.util.Date using exactly the same field values avoiding any time zone effects.  Each field is queried from the Date and assigned to the YearMonthDay. This is useful if you have been using the Date as a local date, ignoring the zone.  This factory method always creates a YearMonthDay with ISO chronology.
org.joda.time.YearMonthDay.getDayOfMonth	(	): Get the day of month field value.
org.joda.time.YearMonthDay.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.YearMonthDay.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.YearMonthDay.getFieldTypes	(	): Gets an array of the field type of each of the fields that this partial supports.  The fields are returned largest to smallest, Year, Month, Day
org.joda.time.YearMonthDay.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.YearMonthDay.getYear	(	): Get the year field value.
org.joda.time.YearMonthDay.minus	(	ReadablePeriod	): Returns a copy of this date with the specified period taken away.  If the amount is zero or null, then this is returned.  This method is typically used to subtract complex period instances. Subtracting one field is best achieved using methods like minusYears().
org.joda.time.YearMonthDay.minusDays	(	int	): Returns a copy of this date minus the specified number of days.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonthDay subtracted = dt.minusDays(6); YearMonthDay subtracted = dt.minus(Period.days(6)); YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6); 
org.joda.time.YearMonthDay.minusMonths	(	int	): Returns a copy of this date minus the specified number of months.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonthDay subtracted = dt.minusMonths(6); YearMonthDay subtracted = dt.minus(Period.months(6)); YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6); 
org.joda.time.YearMonthDay.minusYears	(	int	): Returns a copy of this date minus the specified number of years.  This datetime instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonthDay subtracted = dt.minusYears(6); YearMonthDay subtracted = dt.minus(Period.years(6)); YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6); 
org.joda.time.YearMonthDay.monthOfYear	(	): Get the month of year field property which provides access to advanced functionality.
org.joda.time.YearMonthDay.plus	(	ReadablePeriod	): Returns a copy of this date with the specified period added.  If the amount is zero or null, then this is returned.  This method is typically used to add complex period instances. Adding one field is best achieved using methods like plusYears().
org.joda.time.YearMonthDay.plusDays	(	int	): Returns a copy of this date plus the specified number of days.  This date instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonthDay added = dt.plusDays(6); YearMonthDay added = dt.plus(Period.days(6)); YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6); 
org.joda.time.YearMonthDay.plusMonths	(	int	): Returns a copy of this date plus the specified number of months.  This date instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonthDay added = dt.plusMonths(6); YearMonthDay added = dt.plus(Period.months(6)); YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6); 
org.joda.time.YearMonthDay.plusYears	(	int	): Returns a copy of this date plus the specified number of years.  This date instance is immutable and unaffected by this method call.  The following three lines are identical in effect:  YearMonthDay added = dt.plusYears(6); YearMonthDay added = dt.plus(Period.years(6)); YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6); 
org.joda.time.YearMonthDay.property	(	DateTimeFieldType	): Gets the property object for the specified type, which contains many useful methods.
org.joda.time.YearMonthDay.size	(	): Gets the number of fields in this partial.
org.joda.time.YearMonthDay.toDateMidnight	(	): Converts this object to a DateMidnight in the default time zone.
org.joda.time.YearMonthDay.toDateMidnight	(	DateTimeZone	): Converts this object to a DateMidnight.
org.joda.time.YearMonthDay.toDateTime	(	TimeOfDay	): Converts this object to a DateTime using a TimeOfDay to fill in the missing fields and using the default time zone. This instance is immutable and unaffected by this method call.  The resulting chronology is determined by the chronology of this YearMonthDay plus the time zone. The chronology of the time is ignored - only the field values are used.
org.joda.time.YearMonthDay.toDateTime	(	TimeOfDay	DateTimeZone	): Converts this object to a DateTime using a TimeOfDay to fill in the missing fields. This instance is immutable and unaffected by this method call.  The resulting chronology is determined by the chronology of this YearMonthDay plus the time zone. The chronology of the time is ignored - only the field values are used.
org.joda.time.YearMonthDay.toDateTimeAtCurrentTime	(	): Converts this partial to a full datetime using the default time zone setting the date fields from this instance and the time fields from the current time.
org.joda.time.YearMonthDay.toDateTimeAtCurrentTime	(	DateTimeZone	): Converts this partial to a full datetime using the specified time zone setting the date fields from this instance and the time fields from the current time.  This method uses the chronology from this instance plus the time zone specified.
org.joda.time.YearMonthDay.toDateTimeAtMidnight	(	): Converts this YearMonthDay to a full datetime at midnight using the default time zone.
org.joda.time.YearMonthDay.toDateTimeAtMidnight	(	DateTimeZone	): Converts this YearMonthDay to a full datetime at midnight using the specified time zone.  This method uses the chronology from this instance plus the time zone specified.
org.joda.time.YearMonthDay.toInterval	(	): Converts this object to an Interval representing the whole day in the default time zone.
org.joda.time.YearMonthDay.toInterval	(	DateTimeZone	): Converts this object to an Interval representing the whole day.
org.joda.time.YearMonthDay.toLocalDate	(	): Converts this object to a LocalDate with the same date and chronology.
org.joda.time.YearMonthDay.toString	(	): Output the date in the ISO8601 format YYYY-MM-DD.
org.joda.time.YearMonthDay.withChronologyRetainFields	(	Chronology	): Returns a copy of this date with the specified chronology. This instance is immutable and unaffected by this method call.  This method retains the values of the fields, thus the result will typically refer to a different instant.  The time zone of the specified chronology is ignored, as YearMonthDay operates without a time zone.
org.joda.time.YearMonthDay.withDayOfMonth	(	int	): Returns a copy of this date with the day of month field updated.  YearMonthDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of day of month changed.
org.joda.time.YearMonthDay.withField	(	DateTimeFieldType	int	): Returns a copy of this date with the specified field set to a new value.  For example, if the field type is dayOfMonth then the day would be changed in the returned instance.  These three lines are equivalent:  YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6); YearMonthDay updated = ymd.dayOfMonth().setCopy(6); YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6); 
org.joda.time.YearMonthDay.withFieldAdded	(	DurationFieldType	int	): Returns a copy of this date with the value of the specified field increased.  If the addition is zero, then this is returned.  These three lines are equivalent:  YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6); YearMonthDay added = ymd.plusDays(6); YearMonthDay added = ymd.dayOfMonth().addToCopy(6); 
org.joda.time.YearMonthDay.withMonthOfYear	(	int	): Returns a copy of this date with the month of year field updated.  YearMonthDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of month of year changed.
org.joda.time.YearMonthDay.withPeriodAdded	(	ReadablePeriod	int	): Returns a copy of this date with the specified period added.  If the addition is zero, then this is returned. Fields in the period that aren't present in the partial are ignored.  This method is typically used to add multiple copies of complex period instances. Adding one field is best achieved using methods like withFieldAdded() or plusYears().
org.joda.time.YearMonthDay.withYear	(	int	): Returns a copy of this date with the year field updated.  YearMonthDay is immutable, so there are no set methods. Instead, this method returns a new instance with the value of year changed.
org.joda.time.YearMonthDay.year	(	): Get the year field property which provides access to advanced functionality.
org.joda.time.Years: An immutable time period representing a number of years.  Years is an immutable period that can only store years. It does not store months, days or hours for example. As such it is a type-safe way of representing a number of years in an application.  The number of years is set in the constructor, and may be queried using getYears(). Basic mathematical operations are provided - plus(), minus(), multipliedBy() and dividedBy().  Years is thread-safe and immutable.
org.joda.time.Years.Years	(	int	): Creates a new instance representing a number of years. You should consider using the factory method years() instead of the constructor.
org.joda.time.Years.dividedBy	(	int	): Returns a new instance with the years divided by the specified divisor. The calculation uses integer division, thus 3 divided by 2 is 1.  This instance is immutable and unaffected by this method call.
org.joda.time.Years.getFieldType	(	): Gets the duration field type, which is years.
org.joda.time.Years.getPeriodType	(	): Gets the period type, which is years.
org.joda.time.Years.getYears	(	): Gets the number of years that this period represents.
org.joda.time.Years.isGreaterThan	(	Years	): Is this years instance greater than the specified number of years.
org.joda.time.Years.isLessThan	(	Years	): Is this years instance less than the specified number of years.
org.joda.time.Years.minus	(	Years	): Returns a new instance with the specified number of years taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Years.minus	(	int	): Returns a new instance with the specified number of years taken away.  This instance is immutable and unaffected by this method call.
org.joda.time.Years.multipliedBy	(	int	): Returns a new instance with the years multiplied by the specified scalar.  This instance is immutable and unaffected by this method call.
org.joda.time.Years.negated	(	): Returns a new instance with the years value negated.
org.joda.time.Years.parseYears	(	String	): Creates a new Years by parsing a string in the ISO8601 format 'PnY'.  The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the years component may be non-zero. If any other component is non-zero, an exception will be thrown.
org.joda.time.Years.plus	(	Years	): Returns a new instance with the specified number of years added.  This instance is immutable and unaffected by this method call.
org.joda.time.Years.plus	(	int	): Returns a new instance with the specified number of years added.  This instance is immutable and unaffected by this method call.
org.joda.time.Years.readResolve	(	): Resolves singletons.
org.joda.time.Years.toString	(	): Gets this instance as a String in the ISO8601 duration format.  For example, "P4Y" represents 4 years.
org.joda.time.Years.years	(	int	): Obtains an instance of Years that may be cached. Years is immutable, so instances can be cached and shared. This factory method provides access to shared instances.
org.joda.time.Years.yearsBetween	(	ReadableInstant	ReadableInstant	): Creates a Years representing the number of whole years between the two specified datetimes. This method correctly handles any daylight savings time changes that may occur during the interval.
org.joda.time.Years.yearsBetween	(	ReadablePartial	ReadablePartial	): Creates a Years representing the number of whole years between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalDate objects.
org.joda.time.Years.yearsIn	(	ReadableInterval	): Creates a Years representing the number of whole years in the specified interval. This method correctly handles any daylight savings time changes that may occur during the interval.
org.joda.time.base.AbstractDateTime: AbstractDateTime provides the common behaviour for datetime classes.  This class should generally not be used directly by API users. The ReadableDateTime interface should be used when different kinds of date/time objects are to be referenced.  Whenever you want to implement ReadableDateTime you should extend this class.  AbstractDateTime subclasses may be mutable and not thread-safe.
org.joda.time.base.AbstractDateTime.AbstractDateTime	(	): Constructor.
org.joda.time.base.AbstractDateTime.get	(	DateTimeFieldType	): Get the value of one of the fields of a datetime.  This method uses the chronology of the datetime to obtain the value. It is essentially a generic way of calling one of the get methods.
org.joda.time.base.AbstractDateTime.getCenturyOfEra	(	): Get the year of era field value.
org.joda.time.base.AbstractDateTime.getDayOfMonth	(	): Get the day of month field value.  The values for the day of month are defined in org.joda.time.DateTimeConstants.
org.joda.time.base.AbstractDateTime.getDayOfWeek	(	): Get the day of week field value.  The values for the day of week are defined in org.joda.time.DateTimeConstants.
org.joda.time.base.AbstractDateTime.getDayOfYear	(	): Get the day of year field value.
org.joda.time.base.AbstractDateTime.getEra	(	): Get the era field value.
org.joda.time.base.AbstractDateTime.getHourOfDay	(	): Get the hour of day field value.
org.joda.time.base.AbstractDateTime.getMillisOfDay	(	): Get the millis of day field value.
org.joda.time.base.AbstractDateTime.getMillisOfSecond	(	): Get the millis of second field value.
org.joda.time.base.AbstractDateTime.getMinuteOfDay	(	): Get the minute of day field value.
org.joda.time.base.AbstractDateTime.getMinuteOfHour	(	): Get the minute of hour field value.
org.joda.time.base.AbstractDateTime.getMonthOfYear	(	): Get the month of year field value.
org.joda.time.base.AbstractDateTime.getSecondOfDay	(	): Get the second of day field value.
org.joda.time.base.AbstractDateTime.getSecondOfMinute	(	): Get the second of minute field value.
org.joda.time.base.AbstractDateTime.getWeekOfWeekyear	(	): Get the week of weekyear field value.  This field is associated with the "weekyear" via getWeekyear(). In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year.
org.joda.time.base.AbstractDateTime.getWeekyear	(	): Get the weekyear field value.  The weekyear is the year that matches with the weekOfWeekyear field. In the standard ISO8601 week algorithm, the first week of the year is that in which at least 4 days are in the year. As a result of this definition, day 1 of the first week may be in the previous year. The weekyear allows you to query the effective year for that day.
org.joda.time.base.AbstractDateTime.getYear	(	): Get the year field value.
org.joda.time.base.AbstractDateTime.getYearOfCentury	(	): Get the year of century field value.
org.joda.time.base.AbstractDateTime.getYearOfEra	(	): Get the year of era field value.
org.joda.time.base.AbstractDateTime.toCalendar	(	Locale	): Get the date time as a java.util.Calendar, assigning exactly the same millisecond instant. The locale is passed in, enabling Calendar to select the correct localized subclass.  The JDK and Joda-Time both have time zone implementations and these differ in accuracy. Joda-Time's implementation is generally more up to date and thus more accurate - for example JDK1.3 has no historical data. The effect of this is that the field values of the Calendar may differ from those of this object, even though the millisecond value is the same. Most of the time this just means that the JDK field values are wrong, as our time zone information is more up to date.
org.joda.time.base.AbstractDateTime.toGregorianCalendar	(	): Get the date time as a java.util.GregorianCalendar, assigning exactly the same millisecond instant.  The JDK and Joda-Time both have time zone implementations and these differ in accuracy. Joda-Time's implementation is generally more up to date and thus more accurate - for example JDK1.3 has no historical data. The effect of this is that the field values of the Calendar may differ from those of this object, even though the millisecond value is the same. Most of the time this just means that the JDK field values are wrong, as our time zone information is more up to date.
org.joda.time.base.AbstractDateTime.toString	(	): Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).  Note that this method does not output the chronology or time-zone. This can be confusing, as the equals and hashCode methods use both chronology and time-zone. If two objects are not equal but have the same toString then either the chronology or time-zone differs.
org.joda.time.base.AbstractDateTime.toString	(	String	): Output the instant using the specified format pattern.
org.joda.time.base.AbstractDateTime.toString	(	String	Locale	): Output the instant using the specified format pattern.
org.joda.time.base.AbstractDuration: AbstractDuration provides the common behaviour for duration classes.  This class should generally not be used directly by API users. The ReadableDuration interface should be used when different kinds of durations are to be referenced.  AbstractDuration subclasses may be mutable and not thread-safe.
org.joda.time.base.AbstractDuration.AbstractDuration	(	): Constructor.
org.joda.time.base.AbstractDuration.compareTo	(	ReadableDuration	): Compares this duration with the specified duration based on length.
org.joda.time.base.AbstractDuration.equals	(	Object	): Compares this object with the specified object for equality based on the millisecond length. All ReadableDuration instances are accepted.
org.joda.time.base.AbstractDuration.hashCode	(	): Gets a hash code for the duration that is compatible with the equals method.
org.joda.time.base.AbstractDuration.isEqual	(	ReadableDuration	): Is the length of this duration equal to the duration passed in.
org.joda.time.base.AbstractDuration.isLongerThan	(	ReadableDuration	): Is the length of this duration longer than the duration passed in.
org.joda.time.base.AbstractDuration.isShorterThan	(	ReadableDuration	): Is the length of this duration shorter than the duration passed in.
org.joda.time.base.AbstractDuration.toDuration	(	): Get this duration as an immutable Duration object.
org.joda.time.base.AbstractDuration.toPeriod	(	): Converts this duration to a Period instance using the standard period type and the ISO chronology.  Only precise fields in the period type will be used. Thus, only the hour, minute, second and millisecond fields on the period will be used. The year, month, week and day fields will not be populated.  If the duration is small, less than one day, then this method will perform as you might expect and split the fields evenly. If the duration is larger than one day then all the remaining duration will be stored in the largest available field, hours in this case.  For example, a duration effectively equal to (365 + 60 + 5) days will be converted to ((365 + 60 + 5) * 24) hours by this constructor.  For more control over the conversion process, you must pair the duration with an instant, see Period().
org.joda.time.base.AbstractDuration.toString	(	): Gets the value as a String in the ISO8601 duration format including only seconds and milliseconds.  For example, "PT72.345S" represents 1 minute, 12 seconds and 345 milliseconds.  For more control over the output, see org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder.
org.joda.time.base.AbstractInstant: AbstractInstant provides the common behaviour for instant classes.  This class has no concept of a chronology, all methods work on the millisecond instant.  This class should generally not be used directly by API users. The ReadableInstant interface should be used when different kinds of date/time objects are to be referenced.  Whenever you want to implement ReadableInstant you should extend this class.  AbstractInstant itself is thread-safe and immutable, but subclasses may be mutable and not thread-safe.
org.joda.time.base.AbstractInstant.AbstractInstant	(	): Constructor.
org.joda.time.base.AbstractInstant.compareTo	(	ReadableInstant	): Compares this object with the specified object for ascending millisecond instant order. This ordering is inconsistent with equals, as it ignores the Chronology.  All ReadableInstant instances are accepted.
org.joda.time.base.AbstractInstant.equals	(	Object	): Compares this object with the specified object for equality based on the millisecond instant, chronology and time zone.  Two objects which represent the same instant in time, but are in different time zones (based on time zone id), will be considered to be different. Only two objects with the same DateTimeZone, Chronology and instant are equal.  See isEqual() for an equals method that ignores the Chronology and time zone.  All ReadableInstant instances are accepted.
org.joda.time.base.AbstractInstant.get	(	DateTimeField	): Get the value of one of the fields of a datetime.  This could be used to get a field using a different Chronology. For example:  Instant dt = new Instant(); int gjYear = dt.get(Chronology.getCoptic().year()); 
org.joda.time.base.AbstractInstant.get	(	DateTimeFieldType	): Get the value of one of the fields of a datetime using the chronology of the instant.  This method uses the chronology of the instant to obtain the value. For example:  DateTime dt = new DateTime(); int year = dt.get(DateTimeFieldType.year()); 
org.joda.time.base.AbstractInstant.getZone	(	): Gets the time zone of the instant from the chronology.
org.joda.time.base.AbstractInstant.hashCode	(	): Gets a hash code for the instant as defined in ReadableInstant.
org.joda.time.base.AbstractInstant.isAfter	(	ReadableInstant	): Is this instant strictly after the instant passed in comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isAfter	(	long	): Is this instant strictly after the millisecond instant passed in comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isAfterNow	(	): Is this instant strictly after the current instant comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isBefore	(	ReadableInstant	): Is this instant strictly before the instant passed in comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isBefore	(	long	): Is this instant strictly before the millisecond instant passed in comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isBeforeNow	(	): Is this instant strictly before the current instant comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isEqual	(	ReadableInstant	): Is this instant equal to the instant passed in comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isEqual	(	long	): Is this instant equal to the millisecond instant passed in comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isEqualNow	(	): Is this instant equal to the current instant comparing solely by millisecond.
org.joda.time.base.AbstractInstant.isSupported	(	DateTimeFieldType	): Checks if the field type specified is supported by this instant and chronology. This can be used to avoid exceptions in get().
org.joda.time.base.AbstractInstant.toDate	(	): Get the date time as a java.util.Date.  The Date object created has exactly the same millisecond instant as this object.
org.joda.time.base.AbstractInstant.toDateTime	(	): Get this object as a DateTime in the same zone.
org.joda.time.base.AbstractInstant.toDateTime	(	Chronology	): Get this object as a DateTime using the given chronology and its zone.
org.joda.time.base.AbstractInstant.toDateTime	(	DateTimeZone	): Get this object as a DateTime using the same chronology but a different zone.
org.joda.time.base.AbstractInstant.toDateTimeISO	(	): Get this object as a DateTime using ISOChronology in the same zone.
org.joda.time.base.AbstractInstant.toInstant	(	): Get this object as an Instant.
org.joda.time.base.AbstractInstant.toMutableDateTime	(	): Get this object as a MutableDateTime in the same zone.
org.joda.time.base.AbstractInstant.toMutableDateTime	(	Chronology	): Get this object as a MutableDateTime using the given chronology and its zone.
org.joda.time.base.AbstractInstant.toMutableDateTime	(	DateTimeZone	): Get this object as a MutableDateTime using the same chronology but a different zone.
org.joda.time.base.AbstractInstant.toMutableDateTimeISO	(	): Get this object as a MutableDateTime using ISOChronology in the same zone.
org.joda.time.base.AbstractInstant.toString	(	): Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
org.joda.time.base.AbstractInstant.toString	(	DateTimeFormatter	): Uses the specified formatter to convert this partial to a String.
org.joda.time.base.AbstractInterval: AbstractInterval provides the common behaviour for time intervals.  This class should generally not be used directly by API users. The ReadableInterval interface should be used when different kinds of intervals are to be referenced.  AbstractInterval subclasses may be mutable and not thread-safe.
org.joda.time.base.AbstractInterval.AbstractInterval	(	): Constructor.
org.joda.time.base.AbstractInterval.checkInterval	(	long	long	): Validates an interval.
org.joda.time.base.AbstractInterval.contains	(	ReadableInstant	): Does this time interval contain the specified instant.  Non-zero duration intervals are inclusive of the start instant and exclusive of the end. A zero duration interval cannot contain anything.  For example:  [09:00 to 10:00) contains 08:59 = false (before start) [09:00 to 10:00) contains 09:00 = true [09:00 to 10:00) contains 09:59 = true [09:00 to 10:00) contains 10:00 = false (equals end) [09:00 to 10:00) contains 10:01 = false (after end) [14:00 to 14:00) contains 14:00 = false (zero duration contains nothing)  Passing in a null parameter will have the same effect as calling containsNow().
org.joda.time.base.AbstractInterval.contains	(	ReadableInterval	): Does this time interval contain the specified time interval.  Non-zero duration intervals are inclusive of the start instant and exclusive of the end. The other interval is contained if this interval wholly contains, starts, finishes or equals it. A zero duration interval cannot contain anything.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The contains method is not related to these states. In particular, a zero duration interval is contained at the start of a larger interval, but does not overlap (it abuts instead).  For example:  [09:00 to 10:00) contains [09:00 to 10:00) = true [09:00 to 10:00) contains [09:00 to 09:30) = true [09:00 to 10:00) contains [09:30 to 10:00) = true [09:00 to 10:00) contains [09:15 to 09:45) = true [09:00 to 10:00) contains [09:00 to 09:00) = true [09:00 to 10:00) contains [08:59 to 10:00) = false (otherStart before thisStart) [09:00 to 10:00) contains [09:00 to 10:01) = false (otherEnd after thisEnd) [09:00 to 10:00) contains [10:00 to 10:00) = false (otherStart equals thisEnd) [14:00 to 14:00) contains [14:00 to 14:00) = false (zero duration contains nothing)  Passing in a null parameter will have the same effect as calling containsNow().
org.joda.time.base.AbstractInterval.contains	(	long	): Does this time interval contain the specified millisecond instant.  Non-zero duration intervals are inclusive of the start instant and exclusive of the end. A zero duration interval cannot contain anything.
org.joda.time.base.AbstractInterval.containsNow	(	): Does this time interval contain the current instant.  Non-zero duration intervals are inclusive of the start instant and exclusive of the end. A zero duration interval cannot contain anything.
org.joda.time.base.AbstractInterval.equals	(	Object	): Compares this object with the specified object for equality based on start and end millis plus the chronology. All ReadableInterval instances are accepted.  To compare the duration of two time intervals, use toDuration() to get the durations and compare those.
org.joda.time.base.AbstractInterval.getEnd	(	): Gets the end of this time interval, which is exclusive, as a DateTime.
org.joda.time.base.AbstractInterval.getStart	(	): Gets the start of this time interval, which is inclusive, as a DateTime.
org.joda.time.base.AbstractInterval.hashCode	(	): Hashcode compatible with equals method.
org.joda.time.base.AbstractInterval.isAfter	(	ReadableInstant	): Is this time interval after the specified instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isAfter	(	ReadableInterval	): Is this time interval entirely after the specified interval.  Intervals are inclusive of the start instant and exclusive of the end. Only the end time of the specified interval is used in the comparison.
org.joda.time.base.AbstractInterval.isAfter	(	long	): Is this time interval after the specified millisecond instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isAfterNow	(	): Is this time interval after the current instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isBefore	(	ReadableInstant	): Is this time interval before the specified instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isBefore	(	ReadableInterval	): Is this time interval entirely before the specified instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isBefore	(	long	): Is this time interval before the specified millisecond instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isBeforeNow	(	): Is this time interval before the current instant.  Intervals are inclusive of the start instant and exclusive of the end.
org.joda.time.base.AbstractInterval.isEqual	(	ReadableInterval	): Is this interval equal to the specified interval ignoring the chronology.  This compares the underlying instants, ignoring the chronology.
org.joda.time.base.AbstractInterval.overlaps	(	ReadableInterval	): Does this time interval overlap the specified time interval.  Intervals are inclusive of the start instant and exclusive of the end. An interval overlaps another if it shares some common part of the datetime continuum.  When two intervals are compared the result is one of three states: (a) they abut, (b) there is a gap between them, (c) they overlap. The abuts state takes precedence over the other two, thus a zero duration interval at the start of a larger interval abuts and does not overlap.  For example:  [09:00 to 10:00) overlaps [08:00 to 08:30) = false (completely before) [09:00 to 10:00) overlaps [08:00 to 09:00) = false (abuts before) [09:00 to 10:00) overlaps [08:00 to 09:30) = true [09:00 to 10:00) overlaps [08:00 to 10:00) = true [09:00 to 10:00) overlaps [08:00 to 11:00) = true [09:00 to 10:00) overlaps [09:00 to 09:00) = false (abuts before) [09:00 to 10:00) overlaps [09:00 to 09:30) = true [09:00 to 10:00) overlaps [09:00 to 10:00) = true [09:00 to 10:00) overlaps [09:00 to 11:00) = true [09:00 to 10:00) overlaps [09:30 to 09:30) = true [09:00 to 10:00) overlaps [09:30 to 10:00) = true [09:00 to 10:00) overlaps [09:30 to 11:00) = true [09:00 to 10:00) overlaps [10:00 to 10:00) = false (abuts after) [09:00 to 10:00) overlaps [10:00 to 11:00) = false (abuts after) [09:00 to 10:00) overlaps [10:30 to 11:00) = false (completely after) [14:00 to 14:00) overlaps [14:00 to 14:00) = false (abuts before and after) [14:00 to 14:00) overlaps [13:00 to 15:00) = true 
org.joda.time.base.AbstractInterval.toDuration	(	): Gets the duration of this time interval.  The duration is equal to the end millis minus the start millis.
org.joda.time.base.AbstractInterval.toDurationMillis	(	): Gets the duration of this time interval in milliseconds.  The duration is equal to the end millis minus the start millis.
org.joda.time.base.AbstractInterval.toInterval	(	): Get this interval as an immutable Interval object.
org.joda.time.base.AbstractInterval.toMutableInterval	(	): Get this time interval as a MutableInterval.  This will always return a new MutableInterval with the same interval.
org.joda.time.base.AbstractInterval.toPeriod	(	): Converts the duration of the interval to a Period using the All period type.  This method should be used to extract the field values describing the difference between the start and end instants.
org.joda.time.base.AbstractInterval.toPeriod	(	PeriodType	): Converts the duration of the interval to a Period using the specified period type.  This method should be used to extract the field values describing the difference between the start and end instants.
org.joda.time.base.AbstractInterval.toString	(	): Output a string in ISO8601 interval format.  From version 2.1, the string includes the time zone offset.
org.joda.time.base.AbstractPartial: AbstractPartial provides a standard base implementation of most methods in the ReadablePartial interface.  Calculations on are performed using a Chronology. This chronology is set to be in the UTC time zone for all calculations.  The methods on this class use size(), getField() and getValue() to calculate their results. Subclasses may have a better implementation.  AbstractPartial allows subclasses may be mutable and not thread-safe.
org.joda.time.base.AbstractPartial.AbstractPartial	(	): Constructor.
org.joda.time.base.AbstractPartial.compareTo	(	ReadablePartial	): Compares this partial with another returning an integer indicating the order.  The fields are compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.  The specified object must be a partial instance whose field types match those of this partial.  NOTE: Prior to v2.0, the Comparable interface was only implemented in this class and not in the ReadablePartial interface.
org.joda.time.base.AbstractPartial.equals	(	Object	): Compares this ReadablePartial with another returning true if the chronology, field types and values are equal.
org.joda.time.base.AbstractPartial.get	(	DateTimeFieldType	): Get the value of one of the fields of a datetime.  The field specified must be one of those that is supported by the partial.
org.joda.time.base.AbstractPartial.getField	(	int	): Gets the field at the specified index.
org.joda.time.base.AbstractPartial.getField	(	int	Chronology	): Gets the field for a specific index in the chronology specified.  This method must not use any instance variables.
org.joda.time.base.AbstractPartial.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.base.AbstractPartial.getFieldTypes	(	): Gets an array of the field types that this partial supports.  The fields are returned largest to smallest, for example Hour, Minute, Second.
org.joda.time.base.AbstractPartial.getFields	(	): Gets an array of the fields that this partial supports.  The fields are returned largest to smallest, for example Hour, Minute, Second.
org.joda.time.base.AbstractPartial.getValues	(	): Gets an array of the value of each of the fields that this partial supports.  The fields are returned largest to smallest, for example Hour, Minute, Second. Each value corresponds to the same array index as getFields()
org.joda.time.base.AbstractPartial.hashCode	(	): Gets a hash code for the ReadablePartial that is compatible with the equals method.
org.joda.time.base.AbstractPartial.indexOf	(	DateTimeFieldType	): Gets the index of the specified field, or -1 if the field is unsupported.
org.joda.time.base.AbstractPartial.indexOf	(	DurationFieldType	): Gets the index of the first fields to have the specified duration, or -1 if the field is unsupported.
org.joda.time.base.AbstractPartial.indexOfSupported	(	DateTimeFieldType	): Gets the index of the specified field, throwing an exception if the field is unsupported.
org.joda.time.base.AbstractPartial.indexOfSupported	(	DurationFieldType	): Gets the index of the first fields to have the specified duration, throwing an exception if the field is unsupported.
org.joda.time.base.AbstractPartial.isAfter	(	ReadablePartial	): Is this partial later than the specified partial.  The fields are compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.  You may not pass null into this method. This is because you need a time zone to accurately determine the current date.
org.joda.time.base.AbstractPartial.isBefore	(	ReadablePartial	): Is this partial earlier than the specified partial.  The fields are compared in order, from largest to smallest. The first field that is non-equal is used to determine the result.  You may not pass null into this method. This is because you need a time zone to accurately determine the current date.
org.joda.time.base.AbstractPartial.isEqual	(	ReadablePartial	): Is this partial the same as the specified partial.  The fields are compared in order, from largest to smallest. If all fields are equal, the result is true.  You may not pass null into this method. This is because you need a time zone to accurately determine the current date.
org.joda.time.base.AbstractPartial.isSupported	(	DateTimeFieldType	): Checks whether the field specified is supported by this partial.
org.joda.time.base.AbstractPartial.toDateTime	(	ReadableInstant	): Resolves this partial against another complete instant to create a new full instant. The combination is performed using the chronology of the specified instant.  For example, if this partial represents a time, then the result of this method will be the datetime from the specified base instant plus the time from this partial.
org.joda.time.base.AbstractPartial.toString	(	DateTimeFormatter	): Uses the specified formatter to convert this partial to a String.
org.joda.time.base.AbstractPeriod: AbstractPeriod provides the common behaviour for period classes.  This class should generally not be used directly by API users. The ReadablePeriod interface should be used when different kinds of periods are to be referenced.  AbstractPeriod subclasses may be mutable and not thread-safe.
org.joda.time.base.AbstractPeriod.AbstractPeriod	(	): Constructor.
org.joda.time.base.AbstractPeriod.equals	(	Object	): Compares this object with the specified object for equality based on the value of each field. All ReadablePeriod instances are accepted.  Note that a period of 1 day is not equal to a period of 24 hours, nor is 1 hour equal to 60 minutes. Only periods with the same amount in each field are equal.  This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary).  To compare the actual duration of two periods, convert both to org.joda.time.Duration Durations, an operation that emphasises that the result may differ according to the date you choose.
org.joda.time.base.AbstractPeriod.get	(	DurationFieldType	): Gets the value of one of the fields.  If the field type specified is not supported by the period then zero is returned.
org.joda.time.base.AbstractPeriod.getFieldType	(	int	): Gets the field type at the specified index.
org.joda.time.base.AbstractPeriod.getFieldTypes	(	): Gets an array of the field types that this period supports.  The fields are returned largest to smallest, for example Hours, Minutes, Seconds.
org.joda.time.base.AbstractPeriod.getValues	(	): Gets an array of the value of each of the fields that this period supports.  The fields are returned largest to smallest, for example Hours, Minutes, Seconds. Each value corresponds to the same array index as getFields()
org.joda.time.base.AbstractPeriod.hashCode	(	): Gets a hash code for the period as defined by ReadablePeriod.
org.joda.time.base.AbstractPeriod.indexOf	(	DurationFieldType	): Gets the index of the field in this period.
org.joda.time.base.AbstractPeriod.isSupported	(	DurationFieldType	): Checks whether the field specified is supported by this period.
org.joda.time.base.AbstractPeriod.size	(	): Gets the number of fields that this period supports.
org.joda.time.base.AbstractPeriod.toMutablePeriod	(	): Get this object as a MutablePeriod.  This will always return a new MutablePeriod with the same fields.
org.joda.time.base.AbstractPeriod.toPeriod	(	): Get this period as an immutable Period object.
org.joda.time.base.AbstractPeriod.toString	(	): Gets the value as a String in the ISO8601 duration format.  For example, "PT6H3M7S" represents 6 hours, 3 minutes, 7 seconds.  For more control over the output, see org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder.
org.joda.time.base.AbstractPeriod.toString	(	PeriodFormatter	): Uses the specified formatter to convert this period to a String.
org.joda.time.base.BaseDateTime: BaseDateTime is an abstract implementation of ReadableDateTime that stores data in long and Chronology fields.  This class should generally not be used directly by API users. The ReadableDateTime interface should be used when different kinds of date/time objects are to be referenced.  BaseDateTime subclasses may be mutable and not thread-safe.
org.joda.time.base.BaseDateTime.BaseDateTime	(	): Constructs an instance set to the current system millisecond time using ISOChronology in the default time zone.
org.joda.time.base.BaseDateTime.BaseDateTime	(	Chronology	): Constructs an instance set to the current system millisecond time using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.base.BaseDateTime.BaseDateTime	(	DateTimeZone	): Constructs an instance set to the current system millisecond time using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.base.BaseDateTime.BaseDateTime	(	Object	Chronology	): Constructs an instance from an Object that represents a datetime, using the specified chronology.  If the chronology is null, ISO in the default time zone is used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.
org.joda.time.base.BaseDateTime.BaseDateTime	(	Object	DateTimeZone	): Constructs an instance from an Object that represents a datetime, forcing the time zone to that specified.  If the object contains no chronology, ISOChronology is used. If the specified time zone is null, the default zone is used.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.
org.joda.time.base.BaseDateTime.BaseDateTime	(	int	int	int	int	int	int	int	): Constructs an instance from datetime field values using ISOChronology in the default time zone.
org.joda.time.base.BaseDateTime.BaseDateTime	(	int	int	int	int	int	int	int	Chronology	): Constructs an instance from datetime field values using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.base.BaseDateTime.BaseDateTime	(	int	int	int	int	int	int	int	DateTimeZone	): Constructs an instance from datetime field values using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.base.BaseDateTime.BaseDateTime	(	long	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the default time zone.
org.joda.time.base.BaseDateTime.BaseDateTime	(	long	Chronology	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using the specified chronology.  If the chronology is null, ISOChronology in the default time zone is used.
org.joda.time.base.BaseDateTime.BaseDateTime	(	long	DateTimeZone	): Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z using ISOChronology in the specified time zone.  If the specified time zone is null, the default zone is used.
org.joda.time.base.BaseDateTime.checkChronology	(	Chronology	): Checks the specified chronology before storing it, potentially altering it. This method must not access any instance variables.  This implementation converts nulls to ISOChronology in the default zone.
org.joda.time.base.BaseDateTime.checkInstant	(	long	Chronology	): Checks the specified instant before storing it, potentially altering it. This method must not access any instance variables.  This implementation simply returns the instant.
org.joda.time.base.BaseDateTime.getChronology	(	): Gets the chronology of the datetime.
org.joda.time.base.BaseDateTime.getMillis	(	): Gets the milliseconds of the datetime instant from the Java epoch of 1970-01-01T00:00:00Z.
org.joda.time.base.BaseDateTime.setChronology	(	Chronology	): Sets the chronology of the datetime.  All changes to the chronology field occurs via this method. Override and block this method to make a subclass immutable.
org.joda.time.base.BaseDateTime.setMillis	(	long	): Sets the milliseconds of the datetime.  All changes to the millisecond field occurs via this method. Override and block this method to make a subclass immutable.
org.joda.time.base.BaseDuration: BaseDuration is an abstract implementation of ReadableDuration that stores data in a long duration milliseconds field.  This class should generally not be used directly by API users. The ReadableDuration interface should be used when different kinds of duration objects are to be referenced.  BaseDuration subclasses may be mutable and not thread-safe.
org.joda.time.base.BaseDuration.BaseDuration	(	Object	): Creates a duration from the specified object using the org.joda.time.convert.ConverterManager ConverterManager.
org.joda.time.base.BaseDuration.BaseDuration	(	ReadableInstant	ReadableInstant	): Creates a duration from the given interval endpoints.
org.joda.time.base.BaseDuration.BaseDuration	(	long	): Creates a duration from the given millisecond duration.
org.joda.time.base.BaseDuration.BaseDuration	(	long	long	): Creates a duration from the given interval endpoints.
org.joda.time.base.BaseDuration.getMillis	(	): Gets the length of this duration in milliseconds.
org.joda.time.base.BaseDuration.setMillis	(	long	): Sets the length of this duration in milliseconds.
org.joda.time.base.BaseDuration.toIntervalFrom	(	ReadableInstant	): Converts this duration to an Interval starting at the specified instant.
org.joda.time.base.BaseDuration.toIntervalTo	(	ReadableInstant	): Converts this duration to an Interval ending at the specified instant.
org.joda.time.base.BaseDuration.toPeriod	(	Chronology	): Converts this duration to a Period instance using the standard period type and the specified chronology.  Only precise fields in the period type will be used. Exactly which fields are precise depends on the chronology. Only the time fields are precise for ISO chronology with a time zone. However, ISO UTC also has precise days and weeks.  For more control over the conversion process, you must pair the duration with an instant, see toPeriodFrom() and toPeriodTo()
org.joda.time.base.BaseDuration.toPeriod	(	PeriodType	): Converts this duration to a Period instance using the specified period type and the ISO chronology.  Only precise fields in the period type will be used. At most these are hours, minutes, seconds and millis - the period type may restrict the selection further.  For more control over the conversion process, you must pair the duration with an instant, see toPeriodFrom().
org.joda.time.base.BaseDuration.toPeriod	(	PeriodType	Chronology	): Converts this duration to a Period instance using the specified period type and chronology.  Only precise fields in the period type will be used. Exactly which fields are precise depends on the chronology. Only the time fields are precise for ISO chronology with a time zone. However, ISO UTC also has precise days and weeks.  For more control over the conversion process, you must pair the duration with an instant, see toPeriodFrom() and toPeriodTo()
org.joda.time.base.BaseDuration.toPeriodFrom	(	ReadableInstant	): Converts this duration to a Period instance by adding the duration to a start instant to obtain an interval using the standard period type.  This conversion will determine the fields of a period accurately. The results are based on the instant millis, the chronology of the instant, the standard period type and the length of this duration.
org.joda.time.base.BaseDuration.toPeriodFrom	(	ReadableInstant	PeriodType	): Converts this duration to a Period instance by adding the duration to a start instant to obtain an interval.  This conversion will determine the fields of a period accurately. The results are based on the instant millis, the chronology of the instant, the period type and the length of this duration.
org.joda.time.base.BaseDuration.toPeriodTo	(	ReadableInstant	): Converts this duration to a Period instance by subtracting the duration from an end instant to obtain an interval using the standard period type.  This conversion will determine the fields of a period accurately. The results are based on the instant millis, the chronology of the instant, the standard period type and the length of this duration.
org.joda.time.base.BaseDuration.toPeriodTo	(	ReadableInstant	PeriodType	): Converts this duration to a Period instance by subtracting the duration from an end instant to obtain an interval using the standard period type.  This conversion will determine the fields of a period accurately. The results are based on the instant millis, the chronology of the instant, the period type and the length of this duration.
org.joda.time.base.BaseInterval: BaseInterval is an abstract implementation of ReadableInterval that stores data in two long millisecond fields.  This class should generally not be used directly by API users. The ReadableInterval interface should be used when different kinds of interval objects are to be referenced.  BaseInterval subclasses may be mutable and not thread-safe.
org.joda.time.base.BaseInterval.BaseInterval	(	Object	Chronology	): Constructs a time interval converting or copying from another object that describes an interval.
org.joda.time.base.BaseInterval.BaseInterval	(	ReadableDuration	ReadableInstant	): Constructs an interval from a millisecond duration and an end instant.
org.joda.time.base.BaseInterval.BaseInterval	(	ReadableInstant	ReadableDuration	): Constructs an interval from a start instant and a duration.
org.joda.time.base.BaseInterval.BaseInterval	(	ReadableInstant	ReadableInstant	): Constructs an interval from a start and end instant.
org.joda.time.base.BaseInterval.BaseInterval	(	ReadableInstant	ReadablePeriod	): Constructs an interval from a start instant and a time period.  When forming the interval, the chronology from the instant is used if present, otherwise the chronology of the period is used.
org.joda.time.base.BaseInterval.BaseInterval	(	ReadablePeriod	ReadableInstant	): Constructs an interval from a time period and an end instant.  When forming the interval, the chronology from the instant is used if present, otherwise the chronology of the period is used.
org.joda.time.base.BaseInterval.BaseInterval	(	long	long	Chronology	): Constructs an interval from a start and end instant.
org.joda.time.base.BaseInterval.getChronology	(	): Gets the chronology of this interval.
org.joda.time.base.BaseInterval.getEndMillis	(	): Gets the end of this time interval which is exclusive.
org.joda.time.base.BaseInterval.getStartMillis	(	): Gets the start of this time interval which is inclusive.
org.joda.time.base.BaseInterval.setInterval	(	long	long	Chronology	): Sets this interval from two millisecond instants and a chronology.
org.joda.time.base.BaseLocal: BaseLocal is an abstract implementation of ReadablePartial that use a local milliseconds internal representation.  This class should generally not be used directly by API users. The org.joda.time.ReadablePartial interface should be used when different kinds of partial objects are to be referenced.  BasePartial subclasses may be mutable and not thread-safe.
org.joda.time.base.BaseLocal.BaseLocal	(	): Constructs a partial with the current time, using ISOChronology in the default zone to extract the fields.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BaseLocal.getLocalMillis	(	): Gets the local milliseconds from the Java epoch of 1970-01-01T00:00:00 (not fixed to any specific time zone).  This method is useful in certain circumstances for high performance access to the datetime fields.
org.joda.time.base.BasePartial: BasePartial is an abstract implementation of ReadablePartial that stores data in array and Chronology fields.  This class should generally not be used directly by API users. The org.joda.time.ReadablePartial interface should be used when different kinds of partial objects are to be referenced.  BasePartial subclasses may be mutable and not thread-safe.
org.joda.time.base.BasePartial.BasePartial	(	): Constructs a partial with the current time, using ISOChronology in the default zone to extract the fields.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BasePartial.BasePartial	(	BasePartial	Chronology	): Private constructor to be used by subclasses only which performs no validation.  Data is assigned (not cloned) to the new instance. This should not be used by mutable subclasses.
org.joda.time.base.BasePartial.BasePartial	(	BasePartial	int[]	): Private constructor to be used by subclasses only which performs no validation.  Data is assigned (not cloned) to the new instance.
org.joda.time.base.BasePartial.BasePartial	(	Chronology	): Constructs a partial with the current time, using the specified chronology and zone to extract the fields.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BasePartial.BasePartial	(	Object	Chronology	): Constructs a partial from an Object that represents a time, using the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BasePartial.BasePartial	(	Object	Chronology	DateTimeFormatter	): Constructs a partial from an Object that represents a time, using the specified chronology.  The recognised object types are defined in org.joda.time.convert.ConverterManager ConverterManager and include ReadableInstant, String, Calendar and Date.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BasePartial.BasePartial	(	int[]	Chronology	): Constructs a partial with specified time field values and chronology.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).  The array of values is assigned (not cloned) to the new instance.
org.joda.time.base.BasePartial.BasePartial	(	long	): Constructs a partial extracting the partial fields from the specified milliseconds using the ISOChronology in the default zone.  The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BasePartial.BasePartial	(	long	Chronology	): Constructs a partial extracting the partial fields from the specified milliseconds using the chronology provided.  The constructor uses the time zone of the chronology specified. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC).
org.joda.time.base.BasePartial.getChronology	(	): Gets the chronology of the partial which is never null.  The Chronology is the calculation engine behind the partial and provides conversion and validation of the fields in a particular calendar system.
org.joda.time.base.BasePartial.getValue	(	int	): Gets the value of the field at the specified index.
org.joda.time.base.BasePartial.getValues	(	): Gets an array of the value of each of the fields that this partial supports.  The fields are returned largest to smallest, for example Hour, Minute, Second. Each value corresponds to the same array index as getFields()
org.joda.time.base.BasePartial.setValue	(	int	int	): Sets the value of the field at the specified index.  In version 2.0 and later, this method copies the array into the original. This is because the instance variable has been changed to be final to satisfy the Java Memory Model. This only impacts subclasses that are mutable.
org.joda.time.base.BasePartial.setValues	(	int[]	): Sets the values of all fields.  In version 2.0 and later, this method copies the array into the original. This is because the instance variable has been changed to be final to satisfy the Java Memory Model. This only impacts subclasses that are mutable.
org.joda.time.base.BasePartial.toString	(	String	): Output the date using the specified format pattern.
org.joda.time.base.BasePartial.toString	(	String	Locale	): Output the date using the specified format pattern.
org.joda.time.base.BasePeriod: BasePeriod is an abstract implementation of ReadablePeriod that stores data in a PeriodType and an int[].  This class should generally not be used directly by API users. The ReadablePeriod interface should be used when different kinds of period objects are to be referenced.  BasePeriod subclasses may be mutable and not thread-safe.
org.joda.time.base.BasePeriod.BasePeriod	(	Object	PeriodType	Chronology	): Creates a new period based on another using the ConverterManager.
org.joda.time.base.BasePeriod.BasePeriod	(	ReadableDuration	ReadableInstant	PeriodType	): Creates a period from the given duration and end point.
org.joda.time.base.BasePeriod.BasePeriod	(	ReadableInstant	ReadableDuration	PeriodType	): Creates a period from the given start point and duration.
org.joda.time.base.BasePeriod.BasePeriod	(	ReadableInstant	ReadableInstant	PeriodType	): Creates a period from the given interval endpoints.
org.joda.time.base.BasePeriod.BasePeriod	(	ReadablePartial	ReadablePartial	PeriodType	): Creates a period from the given duration and end point.  The two partials must contain the same fields, thus you can specify two LocalDate objects, or two LocalTime objects, but not one of each. As these are Partial objects, time zones have no effect on the result.  The two partials must also both be contiguous - see isContiguous() for a definition. Both LocalDate and LocalTime are contiguous.
org.joda.time.base.BasePeriod.BasePeriod	(	int	int	int	int	int	int	int	int	PeriodType	): Creates a period from a set of field values.
org.joda.time.base.BasePeriod.BasePeriod	(	int[]	PeriodType	): Constructor used when we trust ourselves. Do not expose publicly.
org.joda.time.base.BasePeriod.BasePeriod	(	long	): Creates a period from the given millisecond duration with the standard period type and ISO rules, ensuring that the calculation is performed with the time-only period type.  The calculation uses the hour, minute, second and millisecond fields.
org.joda.time.base.BasePeriod.BasePeriod	(	long	PeriodType	Chronology	): Creates a period from the given millisecond duration, which is only really suitable for durations less than one day.  Only fields that are precise will be used. Thus the largest precise field may have a large value.
org.joda.time.base.BasePeriod.BasePeriod	(	long	long	PeriodType	Chronology	): Creates a period from the given interval endpoints.
org.joda.time.base.BasePeriod.addField	(	DurationFieldType	int	): Adds the value of a field in this period.
org.joda.time.base.BasePeriod.addFieldInto	(	int[]	DurationFieldType	int	): Adds the value of a field in this period.
org.joda.time.base.BasePeriod.addPeriod	(	ReadablePeriod	): Adds the fields from another period.
org.joda.time.base.BasePeriod.addPeriodInto	(	int[]	ReadablePeriod	): Adds the fields from another period.
org.joda.time.base.BasePeriod.checkAndUpdate	(	DurationFieldType	int[]	int	): Checks whether a field type is supported, and if so adds the new value to the relevant index in the specified array.
org.joda.time.base.BasePeriod.checkPeriodType	(	PeriodType	): Validates a period type, converting nulls to a default value and checking the type is suitable for this instance.
org.joda.time.base.BasePeriod.getPeriodType	(	): Gets the period type.
org.joda.time.base.BasePeriod.getValue	(	int	): Gets the value at the specified index.
org.joda.time.base.BasePeriod.mergePeriod	(	ReadablePeriod	): Merges the fields from another period.
org.joda.time.base.BasePeriod.mergePeriodInto	(	int[]	ReadablePeriod	): Merges the fields from another period.
org.joda.time.base.BasePeriod.setField	(	DurationFieldType	int	): Sets the value of a field in this period.
org.joda.time.base.BasePeriod.setFieldInto	(	int[]	DurationFieldType	int	): Sets the value of a field in this period.
org.joda.time.base.BasePeriod.setPeriod	(	ReadablePeriod	): Sets all the fields of this period from another.
org.joda.time.base.BasePeriod.setPeriod	(	int	int	int	int	int	int	int	int	): Sets the eight standard the fields in one go.
org.joda.time.base.BasePeriod.setPeriodInternal	(	ReadablePeriod	): Private method called from constructor.
org.joda.time.base.BasePeriod.setPeriodInternal	(	int	int	int	int	int	int	int	int	): Private method called from constructor.
org.joda.time.base.BasePeriod.setValue	(	int	int	): Sets the value of the field at the specified index.
org.joda.time.base.BasePeriod.setValues	(	int[]	): Sets the values of all fields.  In version 2.0 and later, this method copies the array into the original. This is because the instance variable has been changed to be final to satisfy the Java Memory Model. This only impacts subclasses that are mutable.
org.joda.time.base.BasePeriod.toDurationFrom	(	ReadableInstant	): Gets the total millisecond duration of this period relative to a start instant.  This method adds the period to the specified instant in order to calculate the duration.  An instant must be supplied as the duration of a period varies. For example, a period of 1 month could vary between the equivalent of 28 and 31 days in milliseconds due to different length months. Similarly, a day can vary at Daylight Savings cutover, typically between 23 and 25 hours.
org.joda.time.base.BasePeriod.toDurationTo	(	ReadableInstant	): Gets the total millisecond duration of this period relative to an end instant.  This method subtracts the period from the specified instant in order to calculate the duration.  An instant must be supplied as the duration of a period varies. For example, a period of 1 month could vary between the equivalent of 28 and 31 days in milliseconds due to different length months. Similarly, a day can vary at Daylight Savings cutover, typically between 23 and 25 hours.
org.joda.time.base.BaseSingleFieldPeriod: BaseSingleFieldPeriod is an abstract implementation of ReadablePeriod that manages a single duration field, such as days or minutes.  This class should generally not be used directly by API users. The ReadablePeriod interface should be used when different kinds of period objects are to be referenced.  BaseSingleFieldPeriod subclasses may be mutable and not thread-safe.
org.joda.time.base.BaseSingleFieldPeriod.BaseSingleFieldPeriod	(	int	): Creates a new instance representing the specified period.
org.joda.time.base.BaseSingleFieldPeriod.between	(	ReadableInstant	ReadableInstant	DurationFieldType	): Calculates the number of whole units between the two specified datetimes.
org.joda.time.base.BaseSingleFieldPeriod.between	(	ReadablePartial	ReadablePartial	ReadablePeriod	): Calculates the number of whole units between the two specified partial datetimes.  The two partials must contain the same fields, for example you can specify two LocalDate objects.
org.joda.time.base.BaseSingleFieldPeriod.compareTo	(	BaseSingleFieldPeriod	): Compares this period to another object of the same class.
org.joda.time.base.BaseSingleFieldPeriod.equals	(	Object	): Compares this object with the specified object for equality based on the value of each field. All ReadablePeriod instances are accepted, but only those with a matching PeriodType can return true.
org.joda.time.base.BaseSingleFieldPeriod.get	(	DurationFieldType	): Gets the value of a duration field represented by this period.  If the field type specified does not match the type used by this class then zero is returned.
org.joda.time.base.BaseSingleFieldPeriod.getFieldType	(	): Gets the single duration field type.
org.joda.time.base.BaseSingleFieldPeriod.getFieldType	(	int	): Gets the field type at the specified index.  The only index supported by this period is zero which returns the field type of this class.
org.joda.time.base.BaseSingleFieldPeriod.getPeriodType	(	): Gets the period type which matches the duration field type.
org.joda.time.base.BaseSingleFieldPeriod.getValue	(	): Gets the amount of this period.
org.joda.time.base.BaseSingleFieldPeriod.getValue	(	int	): Gets the value at the specified index.  The only index supported by this period is zero.
org.joda.time.base.BaseSingleFieldPeriod.hashCode	(	): Gets a hash code for the period as defined by ReadablePeriod.
org.joda.time.base.BaseSingleFieldPeriod.isSupported	(	DurationFieldType	): Checks whether the duration field specified is supported by this period.
org.joda.time.base.BaseSingleFieldPeriod.setValue	(	int	): Sets the amount of this period. To make a subclass immutable you must declare it final, or block this method.
org.joda.time.base.BaseSingleFieldPeriod.size	(	): Gets the number of fields that this period supports, which is one.
org.joda.time.base.BaseSingleFieldPeriod.standardPeriodIn	(	ReadablePeriod	long	): Creates a new instance representing the number of complete standard length units in the specified period.  This factory method converts all fields from the period to hours using standardised durations for each field. Only those fields which have a precise duration in the ISO UTC chronology can be converted.  One week consists of 7 days. One day consists of 24 hours. One hour consists of 60 minutes. One minute consists of 60 seconds. One second consists of 1000 milliseconds.  Months and Years are imprecise and periods containing these values cannot be converted.
org.joda.time.base.BaseSingleFieldPeriod.toMutablePeriod	(	): Get this object as a MutablePeriod.  This will always return a new MutablePeriod with the same fields. The period will use PeriodType.standard().
org.joda.time.base.BaseSingleFieldPeriod.toPeriod	(	): Get this period as an immutable Period object. The period will use PeriodType.standard().
org.joda.time.chrono.AssembledChronology: Abstract Chronology that enables chronologies to be assembled from a container of fields.  AssembledChronology is thread-safe and immutable.
org.joda.time.chrono.AssembledChronology.AssembledChronology	(	Chronology	Object	): Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field.  Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.
org.joda.time.chrono.AssembledChronology.Fields: A container of fields used for assembling a chronology.
org.joda.time.chrono.AssembledChronology.Fields.copyFieldsFrom	(	Chronology	): Copy the supported fields from a chronology into this container.
org.joda.time.chrono.AssembledChronology.assemble	(	Fields	): Invoked by the constructor and after deserialization to allow subclasses to define all of its supported fields. All unset fields default to unsupported instances.
org.joda.time.chrono.AssembledChronology.getBase	(	): Returns the same base chronology as passed into the constructor.
org.joda.time.chrono.AssembledChronology.getParam	(	): Returns the same param object as passed into the constructor.
org.joda.time.chrono.BaseChronology: BaseChronology provides a skeleton implementation for chronology classes. Many utility methods are defined, but all fields are unsupported.  BaseChronology is thread-safe and immutable, and all subclasses must be as well.
org.joda.time.chrono.BaseChronology.BaseChronology	(	): Restricted constructor.
org.joda.time.chrono.BaseChronology.add	(	ReadablePeriod	long	int	): Adds the period to the instant, specifying the number of times to add.
org.joda.time.chrono.BaseChronology.add	(	long	long	int	): Adds the duration to the instant, specifying the number of times to add.
org.joda.time.chrono.BaseChronology.centuries	(	): Get the centuries duration field for this chronology.
org.joda.time.chrono.BaseChronology.centuryOfEra	(	): Get the century of era field for this chronology.
org.joda.time.chrono.BaseChronology.clockhourOfDay	(	): Get the hour of day (offset to 1-24) field for this chronology.
org.joda.time.chrono.BaseChronology.clockhourOfHalfday	(	): Get the hour of am/pm (offset to 1-12) field for this chronology.
org.joda.time.chrono.BaseChronology.dayOfMonth	(	): Get the day of month field for this chronology.
org.joda.time.chrono.BaseChronology.dayOfWeek	(	): Get the day of week field for this chronology. DayOfWeek values are defined in org.joda.time.DateTimeConstants DateTimeConstants. They use the ISO definitions, where 1 is Monday and 7 is Sunday.
org.joda.time.chrono.BaseChronology.dayOfYear	(	): Get the day of year field for this chronology.
org.joda.time.chrono.BaseChronology.days	(	): Get the days duration field for this chronology.
org.joda.time.chrono.BaseChronology.era	(	): Get the era field for this chronology.
org.joda.time.chrono.BaseChronology.eras	(	): Get the eras duration field for this chronology.
org.joda.time.chrono.BaseChronology.get	(	ReadablePartial	long	): Gets the values of a partial from an instant.
org.joda.time.chrono.BaseChronology.get	(	ReadablePeriod	long	): Gets the values of a period from an interval.
org.joda.time.chrono.BaseChronology.get	(	ReadablePeriod	long	long	): Gets the values of a period from an interval.
org.joda.time.chrono.BaseChronology.getDateTimeMillis	(	int	int	int	int	): Returns a datetime millisecond instant, formed from the given year, month, day, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.  The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.chrono.BaseChronology.getDateTimeMillis	(	int	int	int	int	int	int	int	): Returns a datetime millisecond instant, formed from the given year, month, day, hour, minute, second, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.  The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.chrono.BaseChronology.getDateTimeMillis	(	long	int	int	int	int	): Returns a datetime millisecond instant, from from the given instant, hour, minute, second, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown.  The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.chrono.BaseChronology.getZone	(	): Returns the DateTimeZone that this Chronology operates in, or null if unspecified.
org.joda.time.chrono.BaseChronology.halfdayOfDay	(	): Get the AM(0) PM(1) field for this chronology.
org.joda.time.chrono.BaseChronology.halfdays	(	): Get the halfdays duration field for this chronology.
org.joda.time.chrono.BaseChronology.hourOfDay	(	): Get the hour of day (0-23) field for this chronology.
org.joda.time.chrono.BaseChronology.hourOfHalfday	(	): Get the hour of am/pm (0-11) field for this chronology.
org.joda.time.chrono.BaseChronology.hours	(	): Get the hours duration field for this chronology.
org.joda.time.chrono.BaseChronology.millis	(	): Get the millis duration field for this chronology.
org.joda.time.chrono.BaseChronology.millisOfDay	(	): Get the millis of day field for this chronology.
org.joda.time.chrono.BaseChronology.millisOfSecond	(	): Get the millis of second field for this chronology.
org.joda.time.chrono.BaseChronology.minuteOfDay	(	): Get the minute of day field for this chronology.
org.joda.time.chrono.BaseChronology.minuteOfHour	(	): Get the minute of hour field for this chronology.
org.joda.time.chrono.BaseChronology.minutes	(	): Get the minutes duration field for this chronology.
org.joda.time.chrono.BaseChronology.monthOfYear	(	): Get the month of year field for this chronology.
org.joda.time.chrono.BaseChronology.months	(	): Get the months duration field for this chronology.
org.joda.time.chrono.BaseChronology.secondOfDay	(	): Get the second of day field for this chronology.
org.joda.time.chrono.BaseChronology.secondOfMinute	(	): Get the second of minute field for this chronology.
org.joda.time.chrono.BaseChronology.seconds	(	): Get the seconds duration field for this chronology.
org.joda.time.chrono.BaseChronology.set	(	ReadablePartial	long	): Sets the partial into the instant.
org.joda.time.chrono.BaseChronology.toString	(	): Gets a debugging toString.
org.joda.time.chrono.BaseChronology.validate	(	ReadablePartial	int[]	): Validates whether the fields stored in a partial instant are valid.  This implementation uses getMinimumValue() and getMaximumValue().
org.joda.time.chrono.BaseChronology.weekOfWeekyear	(	): Get the week of a week based year field for this chronology.
org.joda.time.chrono.BaseChronology.weeks	(	): Get the weeks duration field for this chronology.
org.joda.time.chrono.BaseChronology.weekyear	(	): Get the year of a week based year field for this chronology.
org.joda.time.chrono.BaseChronology.weekyearOfCentury	(	): Get the year of a week based year in a century field for this chronology.
org.joda.time.chrono.BaseChronology.weekyears	(	): Get the weekyears duration field for this chronology.
org.joda.time.chrono.BaseChronology.withUTC	(	): Returns an instance of this Chronology that operates in the UTC time zone. Chronologies that do not operate in a time zone or are already UTC must return themselves.
org.joda.time.chrono.BaseChronology.withZone	(	DateTimeZone	): Returns an instance of this Chronology that operates in any time zone.
org.joda.time.chrono.BaseChronology.year	(	): Get the year field for this chronology.
org.joda.time.chrono.BaseChronology.yearOfCentury	(	): Get the year of century field for this chronology.
org.joda.time.chrono.BaseChronology.yearOfEra	(	): Get the year of era field for this chronology.
org.joda.time.chrono.BaseChronology.years	(	): Get the years duration field for this chronology.
org.joda.time.chrono.BasicChronology: Abstract implementation for calendar systems that use a typical day/month/year/leapYear model. Most of the utility methods required by subclasses are package-private, reflecting the intention that they be defined in the same package.  BasicChronology is thread-safe and immutable, and all subclasses must be as well.
org.joda.time.chrono.BasicChronology.calculateFirstDayOfYearMillis	(	int	): Gets the millisecond value of the first day of the year.
org.joda.time.chrono.BasicChronology.equals	(	Object	): Checks if this chronology instance equals another.
org.joda.time.chrono.BasicChronology.getApproxMillisAtEpochDividedByTwo	(	): Returns a constant representing the approximate number of milliseconds elapsed from year 0 of this chronology, divided by two. This constant must be defined as:  (yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch) / 2  where epoch is 1970-01-01 (Gregorian).
org.joda.time.chrono.BasicChronology.getAverageMillisPerMonth	(	): Gets an average value for the milliseconds per month.
org.joda.time.chrono.BasicChronology.getAverageMillisPerYear	(	): Gets an average value for the milliseconds per year.
org.joda.time.chrono.BasicChronology.getAverageMillisPerYearDividedByTwo	(	): Gets an average value for the milliseconds per year, divided by two.
org.joda.time.chrono.BasicChronology.getDateMidnightMillis	(	int	int	int	): Gets the milliseconds for a date at midnight.
org.joda.time.chrono.BasicChronology.getDayOfMonth	(	long	): 
org.joda.time.chrono.BasicChronology.getDayOfMonth	(	long	int	): 
org.joda.time.chrono.BasicChronology.getDayOfMonth	(	long	int	int	): 
org.joda.time.chrono.BasicChronology.getDayOfWeek	(	long	): 
org.joda.time.chrono.BasicChronology.getDayOfYear	(	long	): 
org.joda.time.chrono.BasicChronology.getDayOfYear	(	long	int	): 
org.joda.time.chrono.BasicChronology.getDaysInMonthMax	(	): Gets the maximum number of days in any month.
org.joda.time.chrono.BasicChronology.getDaysInMonthMax	(	int	): Gets the maximum days in the specified month.
org.joda.time.chrono.BasicChronology.getDaysInMonthMax	(	long	): Gets the maximum number of days in the month specified by the instant.
org.joda.time.chrono.BasicChronology.getDaysInMonthMaxForSet	(	long	int	): Gets the maximum number of days in the month specified by the instant. The value represents what the user is trying to set, and can be used to optimise this method.
org.joda.time.chrono.BasicChronology.getDaysInYear	(	int	): Get the number of days in the year.
org.joda.time.chrono.BasicChronology.getDaysInYearMax	(	): Get the number of days in the year.
org.joda.time.chrono.BasicChronology.getDaysInYearMonth	(	int	int	): Gets the number of days in the specified month and year.
org.joda.time.chrono.BasicChronology.getFirstWeekOfYearMillis	(	int	): Get the millis for the first week of a year.
org.joda.time.chrono.BasicChronology.getMaxMonth	(	): Gets the maximum number of months.
org.joda.time.chrono.BasicChronology.getMaxMonth	(	int	): Gets the maximum month for the specified year. This implementation calls getMaxMonth().
org.joda.time.chrono.BasicChronology.getMaxYear	(	): Gets the maximum supported year.
org.joda.time.chrono.BasicChronology.getMillisOfDay	(	long	): 
org.joda.time.chrono.BasicChronology.getMinYear	(	): Gets the minimum supported year.
org.joda.time.chrono.BasicChronology.getMonthOfYear	(	long	): 
org.joda.time.chrono.BasicChronology.getMonthOfYear	(	long	int	): 
org.joda.time.chrono.BasicChronology.getTotalMillisByYearMonth	(	int	int	): Gets the total number of millis elapsed in this year at the start of the specified month, such as zero for month 1.
org.joda.time.chrono.BasicChronology.getWeekOfWeekyear	(	long	): 
org.joda.time.chrono.BasicChronology.getWeekOfWeekyear	(	long	int	): 
org.joda.time.chrono.BasicChronology.getWeeksInYear	(	int	): Get the number of weeks in the year.
org.joda.time.chrono.BasicChronology.getWeekyear	(	long	): 
org.joda.time.chrono.BasicChronology.getYear	(	long	): 
org.joda.time.chrono.BasicChronology.getYearDifference	(	long	long	): Gets the difference between the two instants in years.
org.joda.time.chrono.BasicChronology.getYearMillis	(	int	): Get the milliseconds for the start of a year.
org.joda.time.chrono.BasicChronology.getYearMonthDayMillis	(	int	int	int	): Get the milliseconds for a particular date.
org.joda.time.chrono.BasicChronology.getYearMonthMillis	(	int	int	): Get the milliseconds for the start of a month.
org.joda.time.chrono.BasicChronology.hashCode	(	): A suitable hash code for the chronology.
org.joda.time.chrono.BasicChronology.isLeapDay	(	long	): Is the specified instant a leap day?
org.joda.time.chrono.BasicChronology.isLeapYear	(	int	): Is the specified year a leap year?
org.joda.time.chrono.BasicChronology.setYear	(	long	int	): Sets the year from an instant and year.
org.joda.time.chrono.BasicChronology.toString	(	): Gets a debugging toString.
org.joda.time.chrono.BasicDayOfMonthDateTimeField: Provides time calculations for the day of the month component of time.
org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField	(	BasicChronology	DurationField	): Restricted constructor.
org.joda.time.chrono.BasicDayOfMonthDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.BasicDayOfYearDateTimeField: Provides time calculations for the day of the year component of time.
org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField	(	BasicChronology	DurationField	): Restricted constructor
org.joda.time.chrono.BasicDayOfYearDateTimeField.get	(	long	): Get the day of the year component of the specified time instant.
org.joda.time.chrono.BasicDayOfYearDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.BasicFixedMonthChronology: Abstract implementation of a calendar system based around fixed length months.  As the month length is fixed various calculations can be optimised. This implementation assumes any additional days after twelve months fall into a thirteenth month.  BasicFixedMonthChronology is thread-safe and immutable, and all subclasses must be as well.
org.joda.time.chrono.BasicFixedMonthChronology.BasicFixedMonthChronology	(	Chronology	Object	int	): Restricted constructor.
org.joda.time.chrono.BasicGJChronology: Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae. Most of the utility methods required by subclasses are package-private, reflecting the intention that they be defined in the same package.  BasicGJChronology is thread-safe and immutable, and all subclasses must be as well.
org.joda.time.chrono.BasicGJChronology.BasicGJChronology	(	Chronology	Object	int	): Constructor.
org.joda.time.chrono.BasicGJChronology.getDaysInYearMonth	(	int	int	): Gets the number of days in the specified month and year.
org.joda.time.chrono.BasicMonthOfYearDateTimeField: Provides time calculations for the month of the year component of time.
org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField	(	BasicChronology	int	): Restricted constructor.
org.joda.time.chrono.BasicMonthOfYearDateTimeField.add	(	long	int	): Add the specified month to the specified time instant. The amount added may be negative. If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g. 07-31 - (1 month) = 06-30 03-31 - (1 month) = 02-28 or 02-29 depending
org.joda.time.chrono.BasicMonthOfYearDateTimeField.addWrapField	(	long	int	): Add to the Month component of the specified time instant wrapping around within that component if necessary.
org.joda.time.chrono.BasicMonthOfYearDateTimeField.get	(	long	): Get the Month component of the specified time instant.
org.joda.time.chrono.BasicMonthOfYearDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.BasicMonthOfYearDateTimeField.set	(	long	int	): Set the Month component of the specified time instant. If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g. 07-31 to month 6 = 06-30 03-31 to month 2 = 02-28 or 02-29 depending
org.joda.time.chrono.BasicSingleEraDateTimeField: Provides time calculations for the coptic era component of time.
org.joda.time.chrono.BasicSingleEraDateTimeField.BasicSingleEraDateTimeField	(	String	): Restricted constructor.
org.joda.time.chrono.BasicSingleEraDateTimeField.get	(	long	): Get the value of this field from the milliseconds.
org.joda.time.chrono.BasicSingleEraDateTimeField.getAsText	(	int	Locale	): Get the human-readable, text value of this field from the field value. If the specified locale is null, the default locale is used.  The default implementation returns Integer.toString(get(instant)).  Note: subclasses that override this method should also override getMaximumTextLength.
org.joda.time.chrono.BasicSingleEraDateTimeField.getDurationField	(	): Returns the duration per unit value of this field. For example, if this field represents "hour of day", then the unit duration is an hour.
org.joda.time.chrono.BasicSingleEraDateTimeField.getMaximumTextLength	(	Locale	): Get the maximum text value for this field. The default implementation returns the equivalent of Integer.toString(getMaximumValue()).length().
org.joda.time.chrono.BasicSingleEraDateTimeField.getMaximumValue	(	): Get the maximum allowable value for this field.
org.joda.time.chrono.BasicSingleEraDateTimeField.getMinimumValue	(	): Get the minimum allowable value for this field.
org.joda.time.chrono.BasicSingleEraDateTimeField.getRangeDurationField	(	): Returns the range duration of this field. For example, if this field represents "hour of day", then the range duration is a day.
org.joda.time.chrono.BasicSingleEraDateTimeField.isLenient	(	): Returns true if the set method is lenient. If so, it accepts values that are out of bounds. For example, a lenient day of month field accepts 32 for January, converting it to February 1.
org.joda.time.chrono.BasicSingleEraDateTimeField.roundCeiling	(	long	): Round to the highest whole unit of this field. The value of this field and all fields of a higher magnitude may be incremented in order to achieve this result. The fractional millis that cannot be expressed in whole increments of this field are set to minimum.  For example, a datetime of 2002-11-02T23:34:56.789, rounded to the highest whole hour is 2002-11-03T00:00:00.000.  The default implementation calls roundFloor, and if the instant is modified as a result, adds one field unit. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.chrono.BasicSingleEraDateTimeField.roundFloor	(	long	): Round to the lowest whole unit of this field. After rounding, the value of this field and all fields of a higher magnitude are retained. The fractional millis that cannot be expressed in whole increments of this field are set to minimum.  For example, a datetime of 2002-11-02T23:34:56.789, rounded to the lowest whole hour is 2002-11-02T23:00:00.000.
org.joda.time.chrono.BasicSingleEraDateTimeField.roundHalfCeiling	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like roundFloor. If the millisecond value is closer to the ceiling or is exactly halfway, this function behaves like roundCeiling.
org.joda.time.chrono.BasicSingleEraDateTimeField.roundHalfEven	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like roundFloor. If the millisecond value is closer to the ceiling, this function behaves like roundCeiling.  If the millisecond value is exactly halfway between the floor and ceiling, the ceiling is chosen over the floor only if it makes this field's value even.
org.joda.time.chrono.BasicSingleEraDateTimeField.roundHalfFloor	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor or is exactly halfway, this function behaves like roundFloor. If the millisecond value is closer to the ceiling, this function behaves like roundCeiling.
org.joda.time.chrono.BasicSingleEraDateTimeField.set	(	long	String	Locale	): Sets a value in the milliseconds supplied from a human-readable, text value. If the specified locale is null, the default locale is used.  This implementation uses convertText(String, Locale) and set().  Note: subclasses that override this method should also override getAsText.
org.joda.time.chrono.BasicSingleEraDateTimeField.set	(	long	int	): Sets a value in the milliseconds supplied.  The value of this field will be set. If the value is invalid, an exception if thrown.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField: Provides time calculations for the week of a week based year component of time.
org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField	(	BasicChronology	DurationField	): Restricted constructor
org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.get	(	long	): Get the week of a week based year component of the specified time instant.
org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.BasicWeekyearDateTimeField: Provides time calculations for the week of the weekyear component of time.
org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField	(	BasicChronology	): Restricted constructor
org.joda.time.chrono.BasicWeekyearDateTimeField.add	(	long	int	): Add the specified years to the specified time instant.
org.joda.time.chrono.BasicWeekyearDateTimeField.addWrapField	(	long	int	): Add to the year component of the specified time instant wrapping around within that component if necessary.
org.joda.time.chrono.BasicWeekyearDateTimeField.get	(	long	): Get the Year of a week based year component of the specified time instant.
org.joda.time.chrono.BasicWeekyearDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.BasicWeekyearDateTimeField.set	(	long	int	): Set the Year of a week based year component of the specified time instant.
org.joda.time.chrono.BasicYearDateTimeField: A year field suitable for many calendars.
org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField	(	BasicChronology	): Restricted constructor.
org.joda.time.chrono.BasicYearDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.BuddhistChronology: A chronology that matches the BuddhistCalendar class supplied by Sun.  The chronology is identical to the Gregorian/Julian, except that the year is offset by +543 and the era is named 'BE' for Buddhist Era.  This class was intended by Sun to model the calendar used in Thailand. However, the actual rules for Thailand are much more involved than this class covers. (This class is accurate after 1941-01-01 ISO).  This chronology is being retained for those who want a same effect replacement for the Sun class. It is hoped that community support will enable a more accurate chronology for Thailand, to be developed.  BuddhistChronology is thread-safe and immutable.
org.joda.time.chrono.BuddhistChronology.BuddhistChronology	(	Chronology	Object	): Restricted constructor.
org.joda.time.chrono.BuddhistChronology.equals	(	Object	): Checks if this chronology instance equals another.
org.joda.time.chrono.BuddhistChronology.getInstance	(	): Standard instance of a Buddhist Chronology, that matches Sun's BuddhistCalendar class. This means that it follows the GregorianJulian calendar rules with a cutover date.
org.joda.time.chrono.BuddhistChronology.getInstance	(	DateTimeZone	): Standard instance of a Buddhist Chronology, that matches Sun's BuddhistCalendar class. This means that it follows the GregorianJulian calendar rules with a cutover date.
org.joda.time.chrono.BuddhistChronology.getInstanceUTC	(	): Standard instance of a Buddhist Chronology, that matches Sun's BuddhistCalendar class. This means that it follows the GregorianJulian calendar rules with a cutover date.  The time zone of the returned instance is UTC.
org.joda.time.chrono.BuddhistChronology.hashCode	(	): A suitable hash code for the chronology.
org.joda.time.chrono.BuddhistChronology.readResolve	(	): Serialization singleton
org.joda.time.chrono.BuddhistChronology.toString	(	): Gets a debugging toString.
org.joda.time.chrono.BuddhistChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.BuddhistChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.CopticChronology: Implements the Coptic calendar system, which defines every fourth year as leap, much like the Julian calendar. The year is broken down into 12 months, each 30 days in length. An extra period at the end of the year is either 5 or 6 days in length. In this implementation, it is considered a 13th month.  Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus Coptic years do not begin at the same time as Julian years. This chronology is not proleptic, as it does not allow dates before the first Coptic year.  This implementation defines a day as midnight to midnight exactly as per the ISO chronology. Some references indicate that a coptic day starts at sunset on the previous ISO day, but this has not been confirmed and is not implemented.  CopticChronology is thread-safe and immutable.
org.joda.time.chrono.CopticChronology.CopticChronology	(	Chronology	Object	int	): Restricted constructor.
org.joda.time.chrono.CopticChronology.getInstance	(	): Gets an instance of the CopticChronology in the default time zone.
org.joda.time.chrono.CopticChronology.getInstance	(	DateTimeZone	): Gets an instance of the CopticChronology in the given time zone.
org.joda.time.chrono.CopticChronology.getInstance	(	DateTimeZone	int	): Gets an instance of the CopticChronology in the given time zone.
org.joda.time.chrono.CopticChronology.getInstanceUTC	(	): Gets an instance of the CopticChronology. The time zone of the returned instance is UTC.
org.joda.time.chrono.CopticChronology.readResolve	(	): Serialization singleton.
org.joda.time.chrono.CopticChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.CopticChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.EthiopicChronology: Implements the Ethiopic calendar system, which defines every fourth year as leap, much like the Julian calendar. The year is broken down into 12 months, each 30 days in length. An extra period at the end of the year is either 5 or 6 days in length. In this implementation, it is considered a 13th month.  Year 1 in the Ethiopic calendar began on August 29, 8 CE (Julian), thus Ethiopic years do not begin at the same time as Julian years. This chronology is not proleptic, as it does not allow dates before the first Ethiopic year.  This implementation defines a day as midnight to midnight exactly as per the ISO chronology. Some references indicate that a coptic day starts at sunset on the previous ISO day, but this has not been confirmed and is not implemented.  EthiopicChronology is thread-safe and immutable.
org.joda.time.chrono.EthiopicChronology.EthiopicChronology	(	Chronology	Object	int	): Restricted constructor.
org.joda.time.chrono.EthiopicChronology.getInstance	(	): Gets an instance of the EthiopicChronology in the default time zone.
org.joda.time.chrono.EthiopicChronology.getInstance	(	DateTimeZone	): Gets an instance of the EthiopicChronology in the given time zone.
org.joda.time.chrono.EthiopicChronology.getInstance	(	DateTimeZone	int	): Gets an instance of the EthiopicChronology in the given time zone.
org.joda.time.chrono.EthiopicChronology.getInstanceUTC	(	): Gets an instance of the EthiopicChronology. The time zone of the returned instance is UTC.
org.joda.time.chrono.EthiopicChronology.readResolve	(	): Serialization singleton.
org.joda.time.chrono.EthiopicChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.EthiopicChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.GJCacheKey: For internal usage in GJChronology only. 
org.joda.time.chrono.GJChronology: Implements the Gregorian/Julian calendar system which is the calendar system used in most of the world. Wherever possible, it is recommended to use the ISOChronology instead.  The Gregorian calendar replaced the Julian calendar, and the point in time when this chronology switches can be controlled using the second parameter of the getInstance method. By default this cutover is set to the date the Gregorian calendar was first instituted, October 15, 1582.  Before this date, this chronology uses the proleptic Julian calendar (proleptic means extending indefinitely). The Julian calendar has leap years every four years, whereas the Gregorian has special rules for 100 and 400 years. A meaningful result will thus be obtained for all input values. However before 8 CE, Julian leap years were irregular, and before 45 BCE there was no Julian calendar.  This chronology differs from java.util.GregorianCalendar GregorianCalendar in that years in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra field produces results compatible with GregorianCalendar.  The Julian calendar does not have a year zero, and so year -1 is followed by year 1. If the Gregorian cutover date is specified at or before year -1 (Julian), year zero is defined. In other words, the proleptic Gregorian chronology used by this class has a year zero.  To create a pure proleptic Julian chronology, use JulianChronology, and to create a pure proleptic Gregorian chronology, use GregorianChronology.  GJChronology is thread-safe and immutable.
org.joda.time.chrono.GJChronology.CutoverField: This basic cutover field adjusts calls to 'get' and 'set' methods, and assumes that calls to add and addWrapField are unaffected by the cutover.
org.joda.time.chrono.GJChronology.CutoverField.CutoverField	(	DateTimeField	DateTimeField	DurationField	long	boolean	): 
org.joda.time.chrono.GJChronology.CutoverField.CutoverField	(	DateTimeField	DateTimeField	long	): 
org.joda.time.chrono.GJChronology.CutoverField.CutoverField	(	DateTimeField	DateTimeField	long	boolean	): 
org.joda.time.chrono.GJChronology.GJChronology	(	Chronology	JulianChronology	GregorianChronology	Instant	): Called when applying a time zone.
org.joda.time.chrono.GJChronology.GJChronology	(	JulianChronology	GregorianChronology	Instant	): 
org.joda.time.chrono.GJChronology.ImpreciseCutoverField: Cutover field for variable length fields. These fields internally call set whenever add is called. As a result, the same correction applied to set must be applied to add and addWrapField. Knowing when to use this field requires specific knowledge of how the GJ fields are implemented.
org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField	(	DateTimeField	DateTimeField	DurationField	DurationField	long	): Uses shared duration fields rather than creating a new one.
org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField	(	DateTimeField	DateTimeField	DurationField	long	): Uses a shared duration field rather than creating a new one.
org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField	(	DateTimeField	DateTimeField	DurationField	long	boolean	): Uses a shared duration field rather than creating a new one.
org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField	(	DateTimeField	DateTimeField	long	): Creates a duration field that links back to this.
org.joda.time.chrono.GJChronology.LinkedDurationField: Links the duration back to a ImpreciseCutoverField.
org.joda.time.chrono.GJChronology.convertByWeekyear	(	long	Chronology	Chronology	): Convert a datetime from one chronology to another.
org.joda.time.chrono.GJChronology.convertByYear	(	long	Chronology	Chronology	): Convert a datetime from one chronology to another.
org.joda.time.chrono.GJChronology.equals	(	Object	): Checks if this chronology instance equals another.
org.joda.time.chrono.GJChronology.getGregorianCutover	(	): Gets the cutover instant between Gregorian and Julian chronologies.
org.joda.time.chrono.GJChronology.getInstance	(	): Factory method returns instances of the default GJ cutover chronology. This uses a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by October 15, 1582 (Gregorian). The first day of the week is designated to be MONDAY Monday, and the minimum days in the first week of the year is 4. The returned chronology is in the default time zone.
org.joda.time.chrono.GJChronology.getInstance	(	DateTimeZone	): Factory method returns instances of the GJ cutover chronology. This uses a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by October 15, 1582 (Gregorian). The first day of the week is designated to be MONDAY Monday, and the minimum days in the first week of the year is 4.
org.joda.time.chrono.GJChronology.getInstance	(	DateTimeZone	ReadableInstant	): Factory method returns instances of the GJ cutover chronology. Any cutover date may be specified. The first day of the week is designated to be MONDAY Monday, and the minimum days in the first week of the year is 4.
org.joda.time.chrono.GJChronology.getInstance	(	DateTimeZone	ReadableInstant	int	): Factory method returns instances of the GJ cutover chronology. Any cutover date may be specified.
org.joda.time.chrono.GJChronology.getInstance	(	DateTimeZone	long	int	): Factory method returns instances of the GJ cutover chronology. Any cutover date may be specified.
org.joda.time.chrono.GJChronology.getInstanceUTC	(	): Factory method returns instances of the default GJ cutover chronology. This uses a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by October 15, 1582 (Gregorian). The first day of the week is designated to be MONDAY Monday, and the minimum days in the first week of the year is 4. The time zone of the returned instance is UTC.
org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek	(	): Gets the minimum days needed for a week to be the first week in a year.
org.joda.time.chrono.GJChronology.hashCode	(	): A suitable hash code for the chronology.
org.joda.time.chrono.GJChronology.readResolve	(	): Serialization singleton
org.joda.time.chrono.GJChronology.toString	(	): Gets a debugging toString.
org.joda.time.chrono.GJChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.GJChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.GJDayOfWeekDateTimeField: GJDayOfWeekDateTimeField provides time calculations for the day of the week component of time.
org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField	(	BasicChronology	DurationField	): Restricted constructor.
org.joda.time.chrono.GJDayOfWeekDateTimeField.convertText	(	String	Locale	): Convert the specified text and locale into a value.
org.joda.time.chrono.GJDayOfWeekDateTimeField.get	(	long	): Get the value of the specified time instant.
org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText	(	int	Locale	): Get the abbreviated textual value of the specified time instant.
org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText	(	int	Locale	): Get the textual value of the specified time instant.
org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength	(	Locale	): Get the maximum length of the abbreviated text returned by this field.
org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumTextLength	(	Locale	): Get the maximum length of the text returned by this field.
org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumValue	(	): Get the maximum value that this field can have.
org.joda.time.chrono.GJDayOfWeekDateTimeField.getMinimumValue	(	): Get the minimum value that this field can have.
org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.GJEraDateTimeField: Provides time calculations for the era component of time.
org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField	(	BasicChronology	): Restricted constructor
org.joda.time.chrono.GJEraDateTimeField.get	(	long	): Get the Era component of the specified time instant.
org.joda.time.chrono.GJEraDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.GJEraDateTimeField.set	(	long	int	): Set the Era component of the specified time instant.
org.joda.time.chrono.GJLocaleSymbols: Utility class used by a few of the GJDateTimeFields.
org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols	(	Locale	): 
org.joda.time.chrono.GJLocaleSymbols.forLocale	(	Locale	): Obtains the symbols for a locale.
org.joda.time.chrono.GJMonthOfYearDateTimeField: Provides time calculations for the month of the year component of time.
org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField	(	BasicChronology	): Restricted constructor
org.joda.time.chrono.GJYearOfEraDateTimeField: Provides time calculations for the year of era component of time.
org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField	(	DateTimeField	BasicChronology	): Restricted constructor.
org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.GJYearOfEraDateTimeField.set	(	long	int	): Set the year component of the specified time instant.
org.joda.time.chrono.GregorianChronology: Implements a pure proleptic Gregorian calendar system, which defines every fourth year as leap, unless the year is divisible by 100 and not by 400. This improves upon the Julian calendar leap year rule.  Although the Gregorian calendar did not exist before 1582 CE, this chronology assumes it did, thus it is proleptic. This implementation also fixes the start of the year at January 1, and defines the year zero.  GregorianChronology is thread-safe and immutable.
org.joda.time.chrono.GregorianChronology.GregorianChronology	(	Chronology	Object	int	): Restricted constructor
org.joda.time.chrono.GregorianChronology.getInstance	(	): Gets an instance of the GregorianChronology in the default time zone.
org.joda.time.chrono.GregorianChronology.getInstance	(	DateTimeZone	): Gets an instance of the GregorianChronology in the given time zone.
org.joda.time.chrono.GregorianChronology.getInstance	(	DateTimeZone	int	): Gets an instance of the GregorianChronology in the given time zone.
org.joda.time.chrono.GregorianChronology.getInstanceUTC	(	): Gets an instance of the GregorianChronology. The time zone of the returned instance is UTC.
org.joda.time.chrono.GregorianChronology.readResolve	(	): Serialization singleton
org.joda.time.chrono.GregorianChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.GregorianChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.ISOChronology: Implements a chronology that follows the rules of the ISO8601 standard, which is compatible with Gregorian for all modern dates. When ISO does not define a field, but it can be determined (such as AM/PM) it is included.  With the exception of century related fields, ISOChronology is exactly the same as GregorianChronology. In this chronology, centuries and year of century are zero based. For all years, the century is determined by dropping the last two digits of the year, ignoring sign. The year of century is the value of the last two year digits.  ISOChronology is thread-safe and immutable.
org.joda.time.chrono.ISOChronology.ISOChronology	(	Chronology	): Restricted constructor
org.joda.time.chrono.ISOChronology.equals	(	Object	): Checks if this chronology instance equals another.
org.joda.time.chrono.ISOChronology.getInstance	(	): Gets an instance of the ISOChronology in the default time zone.
org.joda.time.chrono.ISOChronology.getInstance	(	DateTimeZone	): Gets an instance of the ISOChronology in the given time zone.
org.joda.time.chrono.ISOChronology.getInstanceUTC	(	): Gets an instance of the ISOChronology. The time zone of the returned instance is UTC.
org.joda.time.chrono.ISOChronology.hashCode	(	): A suitable hash code for the chronology.
org.joda.time.chrono.ISOChronology.toString	(	): Gets a debugging toString.
org.joda.time.chrono.ISOChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.ISOChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.ISOChronology.writeReplace	(	): Serialize ISOChronology instances using a small stub. This reduces the serialized size, and deserialized instances come from the cache.
org.joda.time.chrono.ISOYearOfEraDateTimeField: This field is not publicly exposed by ISOChronology, but rather it is used to build the yearOfCentury and centuryOfEra fields. It merely drops the sign of the year.
org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField	(	): Restricted constructor.
org.joda.time.chrono.ISOYearOfEraDateTimeField.readResolve	(	): Serialization singleton
org.joda.time.chrono.IslamicChronology: Implements the Islamic, or Hijri, calendar system using arithmetic rules.  This calendar is a lunar calendar with a shorter year than ISO. Year 1 in the Islamic calendar began on July 16, 622 CE (Julian), thus Islamic years do not begin at the same time as Julian years. This chronology is not proleptic, as it does not allow dates before the first Islamic year.  There are two basic forms of the Islamic calendar, the tabular and the observed. The observed form cannot easily be used by computers as it relies on human observation of the new moon. The tabular calendar, implemented here, is an arithmetical approximation of the observed form that follows relatively simple rules.  The tabular form of the calendar defines 12 months of alternately 30 and 29 days. The last month is extended to 30 days in a leap year. Leap years occur according to a 30 year cycle. There are four recognised patterns of leap years in the 30 year cycle:  Years 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 & 29 - 15-based, used by Microsoft Years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 & 29 - 16-based, most commonly used Years 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 & 29 - Indian Years 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 & 30 - Habash al-Hasib  You can select which pattern to use via the factory methods, or use the default (16-based).  This implementation defines a day as midnight to midnight exactly as per the ISO chronology. This correct start of day is at sunset on the previous day, however this cannot readily be modelled and has been ignored.  IslamicChronology is thread-safe and immutable.
org.joda.time.chrono.IslamicChronology.IslamicChronology	(	Chronology	Object	LeapYearPatternType	): Restricted constructor.
org.joda.time.chrono.IslamicChronology.LeapYearPatternType: Opaque object describing a leap year pattern for the Islamic Chronology.
org.joda.time.chrono.IslamicChronology.LeapYearPatternType.LeapYearPatternType	(	int	int	): Constructor. This constructor takes a bit pattern where bits 0-29 correspond to years 0-29 in the 30 year Islamic cycle of years. This allows a highly efficient lookup by bit-matching.
org.joda.time.chrono.IslamicChronology.LeapYearPatternType.isLeapYear	(	int	): Is the year a leap year.
org.joda.time.chrono.IslamicChronology.LeapYearPatternType.readResolve	(	): Ensure a singleton is returned if possible.
org.joda.time.chrono.IslamicChronology.equals	(	Object	): Checks if this chronology instance equals another.
org.joda.time.chrono.IslamicChronology.getInstance	(	): Gets an instance of the IslamicChronology in the default time zone.
org.joda.time.chrono.IslamicChronology.getInstance	(	DateTimeZone	): Gets an instance of the IslamicChronology in the given time zone.
org.joda.time.chrono.IslamicChronology.getInstance	(	DateTimeZone	LeapYearPatternType	): Gets an instance of the IslamicChronology in the given time zone.
org.joda.time.chrono.IslamicChronology.getInstanceUTC	(	): Gets an instance of the IslamicChronology. The time zone of the returned instance is UTC.
org.joda.time.chrono.IslamicChronology.getLeapYearPatternType	(	): Gets the leap year pattern type.
org.joda.time.chrono.IslamicChronology.hashCode	(	): A suitable hash code for the chronology.
org.joda.time.chrono.IslamicChronology.readResolve	(	): Serialization singleton.
org.joda.time.chrono.IslamicChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.IslamicChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.JulianChronology: Implements a pure proleptic Julian calendar system, which defines every fourth year as leap. This implementation follows the leap year rule strictly, even for dates before 8 CE, where leap years were actually irregular. In the Julian calendar, year zero does not exist: 1 BCE is followed by 1 CE.  Although the Julian calendar did not exist before 45 BCE, this chronology assumes it did, thus it is proleptic. This implementation also fixes the start of the year at January 1.  JulianChronology is thread-safe and immutable.
org.joda.time.chrono.JulianChronology.JulianChronology	(	Chronology	Object	int	): Restricted constructor
org.joda.time.chrono.JulianChronology.getInstance	(	): Gets an instance of the JulianChronology in the default time zone.
org.joda.time.chrono.JulianChronology.getInstance	(	DateTimeZone	): Gets an instance of the JulianChronology in the given time zone.
org.joda.time.chrono.JulianChronology.getInstance	(	DateTimeZone	int	): Gets an instance of the JulianChronology in the given time zone.
org.joda.time.chrono.JulianChronology.getInstanceUTC	(	): Gets an instance of the JulianChronology. The time zone of the returned instance is UTC.
org.joda.time.chrono.JulianChronology.readResolve	(	): Serialization singleton
org.joda.time.chrono.JulianChronology.withUTC	(	): Gets the Chronology in the UTC time zone.
org.joda.time.chrono.JulianChronology.withZone	(	DateTimeZone	): Gets the Chronology in a specific time zone.
org.joda.time.chrono.LenientChronology: Wraps another Chronology, ensuring all the fields are lenient.  LenientChronology is thread-safe and immutable.
org.joda.time.chrono.LenientChronology.LenientChronology	(	Chronology	): Create a LenientChronology for any chronology.
org.joda.time.chrono.LenientChronology.equals	(	Object	): A lenient chronology is only equal to a lenient chronology with the same base chronology.
org.joda.time.chrono.LenientChronology.getInstance	(	Chronology	): Create a LenientChronology for any chronology.
org.joda.time.chrono.LenientChronology.hashCode	(	): A suitable hashcode for the chronology.
org.joda.time.chrono.LenientChronology.toString	(	): A debugging string for the chronology.
org.joda.time.chrono.LimitChronology: Wraps another Chronology to impose limits on the range of instants that the fields within a Chronology may support. The limits are applied to both DateTimeFields and DurationFields.  Methods in DateTimeField and DurationField throw an IllegalArgumentException whenever given an input instant that is outside the limits or when an attempt is made to move an instant outside the limits.  LimitChronology is thread-safe and immutable.
org.joda.time.chrono.LimitChronology.LimitChronology	(	Chronology	DateTime	DateTime	): Wraps another chronology, with datetime limits. When withUTC or withZone is called, the returned LimitChronology instance has the same limits, except they are time zone adjusted.
org.joda.time.chrono.LimitChronology.LimitException: Extends IllegalArgumentException such that the exception message is not generated unless it is actually requested.
org.joda.time.chrono.LimitChronology.equals	(	Object	): A limit chronology is only equal to a limit chronology with the same base chronology and limits.
org.joda.time.chrono.LimitChronology.getInstance	(	Chronology	ReadableDateTime	ReadableDateTime	): Wraps another chronology, with datetime limits. When withUTC or withZone is called, the returned LimitChronology instance has the same limits, except they are time zone adjusted.
org.joda.time.chrono.LimitChronology.getLowerLimit	(	): Returns the inclusive lower limit instant.
org.joda.time.chrono.LimitChronology.getUpperLimit	(	): Returns the inclusive upper limit instant.
org.joda.time.chrono.LimitChronology.hashCode	(	): A suitable hashcode for the chronology.
org.joda.time.chrono.LimitChronology.toString	(	): A debugging string for the chronology.
org.joda.time.chrono.LimitChronology.withUTC	(	): If this LimitChronology is already UTC, then this is returned. Otherwise, a new instance is returned, with the limits adjusted to the new time zone.
org.joda.time.chrono.LimitChronology.withZone	(	DateTimeZone	): If this LimitChronology has the same time zone as the one given, then this is returned. Otherwise, a new instance is returned, with the limits adjusted to the new time zone.
org.joda.time.chrono.StrictChronology: Wraps another Chronology, ensuring all the fields are strict.  StrictChronology is thread-safe and immutable.
org.joda.time.chrono.StrictChronology.StrictChronology	(	Chronology	): Create a StrictChronology for any chronology.
org.joda.time.chrono.StrictChronology.equals	(	Object	): A strict chronology is only equal to a strict chronology with the same base chronology.
org.joda.time.chrono.StrictChronology.getInstance	(	Chronology	): Create a StrictChronology for any chronology.
org.joda.time.chrono.StrictChronology.hashCode	(	): A suitable hashcode for the chronology.
org.joda.time.chrono.StrictChronology.toString	(	): A debugging string for the chronology.
org.joda.time.chrono.TestAll: Entry point for all tests in this package.
org.joda.time.chrono.TestBuddhistChronology: This class is a Junit unit test for BuddhistChronology.
org.joda.time.chrono.TestCopticChronology: This class is a Junit unit test for CopticChronology.
org.joda.time.chrono.TestCopticChronology.testCalendar	(	): Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.
org.joda.time.chrono.TestEthiopicChronology: This class is a Junit unit test for EthiopicChronology.
org.joda.time.chrono.TestEthiopicChronology.testCalendar	(	): Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.
org.joda.time.chrono.TestGJChronology: This class is a Junit unit test for GJChronology.
org.joda.time.chrono.TestGJDate: Test.
org.joda.time.chrono.TestGregorianChronology: This class is a Junit unit test for GregorianChronology.
org.joda.time.chrono.TestISOChronology: This class is a Junit unit test for ISOChronology.
org.joda.time.chrono.TestIslamicChronology: This class is a Junit unit test for IslamicChronology.
org.joda.time.chrono.TestIslamicChronology.testCalendar	(	): Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.
org.joda.time.chrono.TestJulianChronology: This class is a Junit unit test for JulianChronology.
org.joda.time.chrono.ThreadContention: This class is a testing class for threading.
org.joda.time.chrono.ZonedChronology: Wraps another Chronology to add support for time zones.  ZonedChronology is thread-safe and immutable.
org.joda.time.chrono.ZonedChronology.ZonedChronology	(	Chronology	DateTimeZone	): Restricted constructor
org.joda.time.chrono.ZonedChronology.ZonedDateTimeField: A DateTimeField that decorates another to add timezone behaviour.  This class converts passed in instants to local wall time, and vice versa on output.
org.joda.time.chrono.ZonedChronology.equals	(	Object	): A zoned chronology is only equal to a zoned chronology with the same base chronology and zone.
org.joda.time.chrono.ZonedChronology.getInstance	(	Chronology	DateTimeZone	): Create a ZonedChronology for any chronology, overriding any time zone it may already have.
org.joda.time.chrono.ZonedChronology.hashCode	(	): A suitable hashcode for the chronology.
org.joda.time.chrono.ZonedChronology.localToUTC	(	long	): 
org.joda.time.chrono.ZonedChronology.toString	(	): A debugging string for the chronology.
org.joda.time.chrono.gj.MainTest: Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj against the implementations in this package. It tests all the date fields against their principal methods.  Randomly generated values are fed into the DateTimeField methods and the results are compared between the two chronologies. If any result doesn't match, an error report is generated and the program exits. Each time this test program is run, the pseudo random number generator is seeded with the same value. This ensures consistent results between test runs.  The main method accepts three optional arguments: iterations, mode, seed. By default, iterations is set to 1,000,000. The test will take several minutes to run, depending on the computer's performance. Every 5 seconds a progress message is printed.  The mode can be either 'g' for proleptic gregorian (the default) or 'j' for proleptic julian. To override the default random number generator seed, pass in a third argument which accepts a long signed integer.
org.joda.time.chrono.gj.MainTest.MainTest	(	int	int	long	): 
org.joda.time.chrono.gj.MainTest.main	(	String[]	): Arguments: iterations [mode [seed]]
org.joda.time.chrono.gj.MainTest.testChronology	(	): Main junit test
org.joda.time.chrono.gj.TestAll: Entry point for all tests in this package.
org.joda.time.chrono.gj.TestGJChronology: A reference Gregorian/Julian chronology implementation, intended for testing purposes only. Correctness is favored over performance. The key functions for date calculations are based on ones provided in "Calendrical Calculations", ISBN 0-521-77752-6. In theory, this class can be used to test any other Gregorian/Julian chronology as long as almost all datetime fields are implemented differently between the two. Fields that would most likely be implemented the same are not supported by this class. Unsupported features  time zones time of day year of era year of century century of era era 
org.joda.time.chrono.gj.TestGJChronology.div	(	long	long	): Divide with round-negative behavior.
org.joda.time.chrono.gj.TestGJChronology.fixedFromGJ	(	int	int	int	): 
org.joda.time.chrono.gj.TestGJChronology.fixedFromMillis	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.gjFromFixed	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.gjFromMillis	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.gjYearFromFixed	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.gjYearFromMillis	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.isoFromFixed	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.isoFromMillis	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.millisFromFixed	(	long	): 
org.joda.time.chrono.gj.TestGJChronology.millisFromGJ	(	int	int	int	): 
org.joda.time.chrono.gj.TestGJChronology.millisFromISO	(	int	int	int	): 
org.joda.time.chrono.gj.TestGJChronology.mod	(	long	long	): Modulus with round-negative behavior, result is always positive.
org.joda.time.chrono.gj.TestGJChronology.weekdayOnOrBefore	(	long	int	): 
org.joda.time.chrono.gj.TestGJChronology.withZone	(	DateTimeZone	): Unsupported.
org.joda.time.chrono.gj.TestGregorianChronology: A reference Gregorian chronology implementation, intended for testing purposes only. Correctness is favored over performance. The key functions for date calculations are based on ones provided in "Calendrical Calculations", ISBN 0-521-77752-6.
org.joda.time.chrono.gj.TestGregorianChronology.TestGregorianChronology	(	): Constructs with an epoch of 1970-01-01.
org.joda.time.chrono.gj.TestGregorianChronology.fixedFromGJ	(	int	int	int	): 
org.joda.time.chrono.gj.TestGregorianChronology.gjFromFixed	(	long	): 
org.joda.time.chrono.gj.TestGregorianChronology.gjYearFromFixed	(	long	): 
org.joda.time.chrono.gj.TestGregorianChronology.isoFromFixed	(	long	): 
org.joda.time.chrono.gj.TestJulianChronology: A reference Julian chronology implementation, intended for testing purposes only. Correctness is favored over performance. The key functions for date calculations are based on ones provided in "Calendrical Calculations", ISBN 0-521-77752-6.
org.joda.time.chrono.gj.TestJulianChronology.TestJulianChronology	(	): Constructs with an epoch of 1969-12-19.
org.joda.time.chrono.gj.TestJulianChronology.fixedFromGJ	(	int	int	int	): 
org.joda.time.chrono.gj.TestJulianChronology.gjFromFixed	(	long	): 
org.joda.time.chrono.gj.TestJulianChronology.gjYearFromFixed	(	long	): 
org.joda.time.chrono.gj.TestJulianChronology.isoFromFixed	(	long	): 
org.joda.time.convert.AbstractConverter: AbstractConverter simplifies the process of implementing a converter.
org.joda.time.convert.AbstractConverter.AbstractConverter	(	): Restricted constructor.
org.joda.time.convert.AbstractConverter.getChronology	(	Object	Chronology	): Extracts the chronology from an object of this converter's type where the chronology is specified.  This implementation returns the chronology specified, or the ISO chronology in the default zone if null passed in.
org.joda.time.convert.AbstractConverter.getChronology	(	Object	DateTimeZone	): Extracts the chronology from an object of this converter's type where the time zone is specified.  This implementation returns the ISO chronology.
org.joda.time.convert.AbstractConverter.getInstantMillis	(	Object	Chronology	): Extracts the millis from an object of this converter's type.  This implementation returns the current time.
org.joda.time.convert.AbstractConverter.getPartialValues	(	ReadablePartial	Object	Chronology	): Extracts the values of the partial from an object of this converter's type. The chrono parameter is a hint to the converter, should it require a chronology to aid in conversion.  This implementation calls getInstantMillis().
org.joda.time.convert.AbstractConverter.getPartialValues	(	ReadablePartial	Object	Chronology	DateTimeFormatter	): Extracts the values of the partial from an object of this converter's type. The chrono parameter is a hint to the converter, should it require a chronology to aid in conversion.  This implementation calls getPartialValues().
org.joda.time.convert.AbstractConverter.getPeriodType	(	Object	): Selects a suitable period type for the given object.
org.joda.time.convert.AbstractConverter.isReadableInterval	(	Object	Chronology	): Checks if the input is a ReadableInterval.  If it is, then the calling code should cast and copy the fields directly.
org.joda.time.convert.AbstractConverter.toString	(	): Gets a debugging string version of this converter.
org.joda.time.convert.CalendarConverter: CalendarConverter converts a java util Calendar to an instant or partial. The Calendar is converted to milliseconds and the chronology that best matches the calendar.
org.joda.time.convert.CalendarConverter.CalendarConverter	(	): Restricted constructor.
org.joda.time.convert.CalendarConverter.getChronology	(	Object	Chronology	): Gets the chronology.  If a chronology is specified then it is used. Otherwise, it is the GJChronology if a GregorianCalendar is used, BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise. The time zone is extracted from the calendar if possible, default used if not.
org.joda.time.convert.CalendarConverter.getChronology	(	Object	DateTimeZone	): Gets the chronology, which is the GJChronology if a GregorianCalendar is used, BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise. The time zone specified is used in preference to that on the calendar.
org.joda.time.convert.CalendarConverter.getInstantMillis	(	Object	Chronology	): Gets the millis, which is the Calendar millis value.
org.joda.time.convert.CalendarConverter.getSupportedType	(	): Returns Calendar.class.
org.joda.time.convert.Converter: Basic converter interface for specifying what object type can be converted.
org.joda.time.convert.Converter.getSupportedType	(	): Returns the object type that this converter supports, which may specified by a class, superclass, abstract class, interface, or null.
org.joda.time.convert.ConverterManager: ConverterManager controls the date and time converters.  This class enables additional conversion classes to be added via addInstantConverter(), which may replace an existing converter. Similar methods exist for duration, time period and interval converters.  This class is threadsafe, so adding/removing converters can be done at any time. Updating the set of converters is relatively expensive, and so should not be performed often.  The default instant converters are:  ReadableInstant String Calendar Date (includes sql package subclasses) Long (milliseconds) null (now)  The default partial converters are:  ReadablePartial ReadableInstant String Calendar Date (includes sql package subclasses) Long (milliseconds) null (now)  The default duration converters are:  ReadableDuration ReadableInterval String Long (milliseconds) null (zero ms)  The default time period converters are:  ReadablePeriod ReadableInterval String null (zero)  The default interval converters are:  ReadableInterval String null (zero-length from now to now) 
org.joda.time.convert.ConverterManager.ConverterManager	(	): Restricted constructor.
org.joda.time.convert.ConverterManager.addDurationConverter	(	DurationConverter	): Adds a converter to the set of converters. If a matching converter is already in the set, the given converter replaces it. If the converter is exactly the same as one already in the set, no changes are made.  The order in which converters are added is not relevant. The best converter is selected by examining the object hierarchy.
org.joda.time.convert.ConverterManager.addInstantConverter	(	InstantConverter	): Adds a converter to the set of converters. If a matching converter is already in the set, the given converter replaces it. If the converter is exactly the same as one already in the set, no changes are made.  The order in which converters are added is not relevant. The best converter is selected by examining the object hierarchy.
org.joda.time.convert.ConverterManager.addIntervalConverter	(	IntervalConverter	): Adds a converter to the set of converters. If a matching converter is already in the set, the given converter replaces it. If the converter is exactly the same as one already in the set, no changes are made.  The order in which converters are added is not relevant. The best converter is selected by examining the object hierarchy.
org.joda.time.convert.ConverterManager.addPartialConverter	(	PartialConverter	): Adds a converter to the set of converters. If a matching converter is already in the set, the given converter replaces it. If the converter is exactly the same as one already in the set, no changes are made.  The order in which converters are added is not relevant. The best converter is selected by examining the object hierarchy.
org.joda.time.convert.ConverterManager.addPeriodConverter	(	PeriodConverter	): Adds a converter to the set of converters. If a matching converter is already in the set, the given converter replaces it. If the converter is exactly the same as one already in the set, no changes are made.  The order in which converters are added is not relevant. The best converter is selected by examining the object hierarchy.
org.joda.time.convert.ConverterManager.checkAlterDurationConverters	(	): Checks whether the user has permission 'ConverterManager.alterDurationConverters'.
org.joda.time.convert.ConverterManager.checkAlterInstantConverters	(	): Checks whether the user has permission 'ConverterManager.alterInstantConverters'.
org.joda.time.convert.ConverterManager.checkAlterIntervalConverters	(	): Checks whether the user has permission 'ConverterManager.alterIntervalConverters'.
org.joda.time.convert.ConverterManager.checkAlterPartialConverters	(	): Checks whether the user has permission 'ConverterManager.alterPartialConverters'.
org.joda.time.convert.ConverterManager.checkAlterPeriodConverters	(	): Checks whether the user has permission 'ConverterManager.alterPeriodConverters'.
org.joda.time.convert.ConverterManager.getDurationConverter	(	Object	): Gets the best converter for the object specified.
org.joda.time.convert.ConverterManager.getDurationConverters	(	): Gets a copy of the list of converters.
org.joda.time.convert.ConverterManager.getInstantConverter	(	Object	): Gets the best converter for the object specified.
org.joda.time.convert.ConverterManager.getInstantConverters	(	): Gets a copy of the set of converters.
org.joda.time.convert.ConverterManager.getIntervalConverter	(	Object	): Gets the best converter for the object specified.
org.joda.time.convert.ConverterManager.getIntervalConverters	(	): Gets a copy of the list of converters.
org.joda.time.convert.ConverterManager.getPartialConverter	(	Object	): Gets the best converter for the object specified.
org.joda.time.convert.ConverterManager.getPartialConverters	(	): Gets a copy of the set of converters.
org.joda.time.convert.ConverterManager.getPeriodConverter	(	Object	): Gets the best converter for the object specified.
org.joda.time.convert.ConverterManager.getPeriodConverters	(	): Gets a copy of the list of converters.
org.joda.time.convert.ConverterManager.removeDurationConverter	(	DurationConverter	): Removes a converter from the set of converters. If the converter was not in the set, no changes are made.
org.joda.time.convert.ConverterManager.removeInstantConverter	(	InstantConverter	): Removes a converter from the set of converters. If the converter was not in the set, no changes are made.
org.joda.time.convert.ConverterManager.removeIntervalConverter	(	IntervalConverter	): Removes a converter from the set of converters. If the converter was not in the set, no changes are made.
org.joda.time.convert.ConverterManager.removePartialConverter	(	PartialConverter	): Removes a converter from the set of converters. If the converter was not in the set, no changes are made.
org.joda.time.convert.ConverterManager.removePeriodConverter	(	PeriodConverter	): Removes a converter from the set of converters. If the converter was not in the set, no changes are made.
org.joda.time.convert.ConverterManager.toString	(	): Gets a debug representation of the object.
org.joda.time.convert.ConverterSet: A set of converters, which allows exact converters to be quickly selected. This class is threadsafe because it is (essentially) immutable.
org.joda.time.convert.ConverterSet.add	(	Converter	Converter[]	): Returns a copy of this set, with the given converter added. If a matching converter is already in the set, the given converter replaces it. If the converter is exactly the same as one already in the set, the original set is returned.
org.joda.time.convert.ConverterSet.copyInto	(	Converter[]	): Copies all the converters in the set to the given array.
org.joda.time.convert.ConverterSet.remove	(	Converter	Converter[]	): Returns a copy of this set, with the given converter removed. If the converter was not in the set, the original set is returned.
org.joda.time.convert.ConverterSet.remove	(	int	Converter[]	): Returns a copy of this set, with the converter at the given index removed.
org.joda.time.convert.ConverterSet.select	(	Class	): Returns the closest matching converter for the given type, or null if none found.
org.joda.time.convert.ConverterSet.selectSlow	(	ConverterSet	Class	): Returns the closest matching converter for the given type, but not very efficiently.
org.joda.time.convert.ConverterSet.size	(	): Returns the amount of converters in the set.
org.joda.time.convert.DateConverter: DateConverter converts a java util Date to an instant or partial. The Date is converted to milliseconds in the ISO chronology.
org.joda.time.convert.DateConverter.DateConverter	(	): Restricted constructor.
org.joda.time.convert.DateConverter.getInstantMillis	(	Object	Chronology	): Gets the millis, which is the Date millis value.
org.joda.time.convert.DateConverter.getSupportedType	(	): Returns Date.class.
org.joda.time.convert.DurationConverter: DurationConverter defines how an object is converted to a millisecond duration.
org.joda.time.convert.DurationConverter.getDurationMillis	(	Object	): Extracts the millis from an object of this converter's type.
org.joda.time.convert.InstantConverter: InstantConverter defines how an object is converted to milliseconds/chronology.  The two methods in this interface must be called in order, as the getInstantMillis method relies on the result of the getChronology method being passed in.
org.joda.time.convert.InstantConverter.getChronology	(	Object	Chronology	): Extracts the chronology from an object of this converter's type where the chronology may be specified.  If the chronology is non-null it should be used. If it is null, then the object should be queried, and if it has no chronology then ISO default is used.
org.joda.time.convert.InstantConverter.getChronology	(	Object	DateTimeZone	): Extracts the chronology from an object of this converter's type where the time zone is specified.
org.joda.time.convert.InstantConverter.getInstantMillis	(	Object	Chronology	): Extracts the millis from an object of this converter's type.  The chronology passed in is the result of the call to getChronology.
org.joda.time.convert.IntervalConverter: IntervalConverter defines how an object is converted to an interval.
org.joda.time.convert.IntervalConverter.isReadableInterval	(	Object	Chronology	): Checks if the input is a ReadableInterval.  If it is, then the calling code should cast and copy the fields directly.
org.joda.time.convert.IntervalConverter.setInto	(	ReadWritableInterval	Object	Chronology	): Extracts interval endpoint values from an object of this converter's type, and sets them into the given ReadWritableInterval.
org.joda.time.convert.LongConverter: LongConverter converts a Long to an instant, partial or duration. The Long value represents milliseconds in the ISO chronology.
org.joda.time.convert.LongConverter.LongConverter	(	): Restricted constructor.
org.joda.time.convert.LongConverter.getDurationMillis	(	Object	): Gets the millisecond duration, which is the Long value.
org.joda.time.convert.LongConverter.getInstantMillis	(	Object	Chronology	): Gets the millisecond instant, which is the Long value.
org.joda.time.convert.LongConverter.getSupportedType	(	): Returns Long.class.
org.joda.time.convert.MockBadChronology: A basic mock testing class for an unknown calendar.
org.joda.time.convert.MockUnknownCalendar: A basic mock testing class for an unknown calendar.
org.joda.time.convert.MockUnknownTimeZone: A basic mock testing class for an unknown time zone.
org.joda.time.convert.MockZeroNullIntegerConverter: A basic mock testing class for a converter. This converter returns zero and null for an Integer input.
org.joda.time.convert.NullConverter: NullConverter converts null to an instant, partial, duration, period or interval. Null means now for instant/partial, zero for duration/period and from now to now for interval.
org.joda.time.convert.NullConverter.NullConverter	(	): Restricted constructor.
org.joda.time.convert.NullConverter.getDurationMillis	(	Object	): Gets the millisecond duration, which is zero.
org.joda.time.convert.NullConverter.getSupportedType	(	): Returns null.
org.joda.time.convert.NullConverter.setInto	(	ReadWritableInterval	Object	Chronology	): Extracts interval endpoint values from an object of this converter's type, and sets them into the given ReadWritableInterval.
org.joda.time.convert.NullConverter.setInto	(	ReadWritablePeriod	Object	Chronology	): Sets the given ReadWritableDuration to zero milliseconds.
org.joda.time.convert.PartialConverter: PartialConverter defines how an object is converted to a ReadablePartial.  The two methods in this interface must be called in order, as the getPartialValues method relies on the result of the getChronology method being passed in.
org.joda.time.convert.PartialConverter.getChronology	(	Object	Chronology	): Extracts the chronology from an object of this converter's type where the chronology is specified.
org.joda.time.convert.PartialConverter.getChronology	(	Object	DateTimeZone	): Extracts the chronology from an object of this converter's type where the time zone is specified.
org.joda.time.convert.PartialConverter.getPartialValues	(	ReadablePartial	Object	Chronology	): Extracts the values of the partial from an object of this converter's type. The chrono parameter is a hint to the converter, should it require a chronology to aid in conversion.
org.joda.time.convert.PartialConverter.getPartialValues	(	ReadablePartial	Object	Chronology	DateTimeFormatter	): Extracts the values of the partial from an object of this converter's type. The chrono parameter is a hint to the converter, should it require a chronology to aid in conversion.
org.joda.time.convert.PeriodConverter: PeriodConverter defines how an object is converted to a time period.
org.joda.time.convert.PeriodConverter.getPeriodType	(	Object	): Selects a suitable period type for the given object.
org.joda.time.convert.PeriodConverter.setInto	(	ReadWritablePeriod	Object	Chronology	): Extracts duration values from an object of this converter's type, and sets them into the given ReadWritableDuration.
org.joda.time.convert.ReadableDurationConverter: ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.
org.joda.time.convert.ReadableDurationConverter.ReadableDurationConverter	(	): Restricted constructor.
org.joda.time.convert.ReadableDurationConverter.getDurationMillis	(	Object	): Extracts the millis from an object of this converter's type.
org.joda.time.convert.ReadableDurationConverter.getSupportedType	(	): Returns ReadableDuration.class.
org.joda.time.convert.ReadableDurationConverter.setInto	(	ReadWritablePeriod	Object	Chronology	): Extracts duration values from an object of this converter's type, and sets them into the given ReadWritableDuration.
org.joda.time.convert.ReadableInstantConverter: ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.
org.joda.time.convert.ReadableInstantConverter.ReadableInstantConverter	(	): Restricted constructor.
org.joda.time.convert.ReadableInstantConverter.getChronology	(	Object	Chronology	): Gets the chronology, which is taken from the ReadableInstant.  If the passed in chronology is non-null, it is used. Otherwise the chronology from the instant is used.
org.joda.time.convert.ReadableInstantConverter.getChronology	(	Object	DateTimeZone	): Gets the chronology, which is taken from the ReadableInstant. If the chronology on the instant is null, the ISOChronology in the specified time zone is used. If the chronology on the instant is not in the specified zone, it is adapted.
org.joda.time.convert.ReadableInstantConverter.getInstantMillis	(	Object	Chronology	): Extracts the millis from an object of this converter's type.
org.joda.time.convert.ReadableInstantConverter.getSupportedType	(	): Returns ReadableInstant.class.
org.joda.time.convert.ReadableIntervalConverter: Converts intervals into durations of any requested period type.
org.joda.time.convert.ReadableIntervalConverter.ReadableIntervalConverter	(	): Restricted constructor.
org.joda.time.convert.ReadableIntervalConverter.getDurationMillis	(	Object	): Gets the millisecond length of the interval.
org.joda.time.convert.ReadableIntervalConverter.getSupportedType	(	): Returns ReadableInterval.class.
org.joda.time.convert.ReadableIntervalConverter.isReadableInterval	(	Object	Chronology	): Checks if the input is a ReadableInterval.  If it is, then the calling code should cast and copy the fields directly.
org.joda.time.convert.ReadableIntervalConverter.setInto	(	ReadWritableInterval	Object	Chronology	): Extracts interval endpoint values from an object of this converter's type, and sets them into the given ReadWritableInterval.
org.joda.time.convert.ReadableIntervalConverter.setInto	(	ReadWritablePeriod	Object	Chronology	): Sets the values of the mutable duration from the specified interval.
org.joda.time.convert.ReadablePartialConverter: ReadablePartialConverter extracts partial fields and chronology from a ReadablePartial.
org.joda.time.convert.ReadablePartialConverter.ReadablePartialConverter	(	): Restricted constructor.
org.joda.time.convert.ReadablePartialConverter.getChronology	(	Object	Chronology	): Gets the chronology, which is taken from the ReadableInstant.  If the passed in chronology is non-null, it is used. Otherwise the chronology from the instant is used.
org.joda.time.convert.ReadablePartialConverter.getChronology	(	Object	DateTimeZone	): Gets the chronology, which is taken from the ReadablePartial.
org.joda.time.convert.ReadablePartialConverter.getPartialValues	(	ReadablePartial	Object	Chronology	): Extracts the values of the partial from an object of this converter's type. The chrono parameter is a hint to the converter, should it require a chronology to aid in conversion.
org.joda.time.convert.ReadablePartialConverter.getSupportedType	(	): Returns ReadableInstant.class.
org.joda.time.convert.ReadablePeriodConverter: ReadablePeriodConverter extracts milliseconds and chronology from a ReadablePeriod.
org.joda.time.convert.ReadablePeriodConverter.ReadablePeriodConverter	(	): Restricted constructor.
org.joda.time.convert.ReadablePeriodConverter.getPeriodType	(	Object	): Selects a suitable period type for the given object.
org.joda.time.convert.ReadablePeriodConverter.getSupportedType	(	): Returns ReadablePeriod class.
org.joda.time.convert.ReadablePeriodConverter.setInto	(	ReadWritablePeriod	Object	Chronology	): Extracts duration values from an object of this converter's type, and sets them into the given ReadWritablePeriod.
org.joda.time.convert.StringConverter: StringConverter converts from a String to an instant, partial, duration, period or interval..
org.joda.time.convert.StringConverter.StringConverter	(	): Restricted constructor.
org.joda.time.convert.StringConverter.getDurationMillis	(	Object	): Gets the duration of the string using the standard type. This matches the toString() method of ReadableDuration.
org.joda.time.convert.StringConverter.getInstantMillis	(	Object	Chronology	): Gets the millis, which is the ISO parsed string value.
org.joda.time.convert.StringConverter.getPartialValues	(	ReadablePartial	Object	Chronology	DateTimeFormatter	): Extracts the values of the partial from an object of this converter's type. This method checks if the parser has a zone, and uses it if present. This is most useful for parsing local times with UTC.
org.joda.time.convert.StringConverter.getSupportedType	(	): Returns String.class.
org.joda.time.convert.StringConverter.setInto	(	ReadWritableInterval	Object	Chronology	): Sets the value of the mutable interval from the string.
org.joda.time.convert.StringConverter.setInto	(	ReadWritablePeriod	Object	Chronology	): Extracts duration values from an object of this converter's type, and sets them into the given ReadWritableDuration.
org.joda.time.convert.TestAll: Entry point for all tests in this package.
org.joda.time.convert.TestCalendarConverter: This class is a Junit unit test for CalendarConverter.
org.joda.time.convert.TestConverterManager: This class is a JUnit test for ConverterManager.
org.joda.time.convert.TestConverterSet: This class is a JUnit test for ConverterSet. Mostly for coverage.
org.joda.time.convert.TestDateConverter: This class is a Junit unit test for DateConverter.
org.joda.time.convert.TestLongConverter: This class is a Junit unit test for LongConverter.
org.joda.time.convert.TestNullConverter: This class is a Junit unit test for NullConverter.
org.joda.time.convert.TestReadableDurationConverter: This class is a Junit unit test for ReadableDurationConverter.
org.joda.time.convert.TestReadableInstantConverter: This class is a Junit unit test for ReadableInstantConverter.
org.joda.time.convert.TestReadableIntervalConverter: This class is a JUnit test for ReadableIntervalConverter.
org.joda.time.convert.TestReadablePartialConverter: This class is a Junit unit test for ReadablePartialConverter.
org.joda.time.convert.TestReadablePeriodConverter: This class is a Junit unit test for ReadablePeriodConverter.
org.joda.time.convert.TestStringConverter: This class is a Junit unit test for StringConverter.
org.joda.time.field.AbstractPartialFieldProperty: AbstractPartialFieldProperty is a base class for binding a ReadablePartial to a DateTimeField.  It allows the date and time manipulation code to be field based yet still easy to use.
org.joda.time.field.AbstractPartialFieldProperty.AbstractPartialFieldProperty	(	): Constructor.
org.joda.time.field.AbstractPartialFieldProperty.compareTo	(	ReadableInstant	): Compare this field to the same field on another instant.  The comparison is based on the value of the same field type, irrespective of any difference in chronology. Thus, if this property represents the hourOfDay field, then the hourOfDay field of the other instant will be queried whether in the same chronology or not.
org.joda.time.field.AbstractPartialFieldProperty.compareTo	(	ReadablePartial	): Compare this field to the same field on another partial instant.  The comparison is based on the value of the same field type, irrespective of any difference in chronology. Thus, if this property represents the hourOfDay field, then the hourOfDay field of the other partial will be queried whether in the same chronology or not.
org.joda.time.field.AbstractPartialFieldProperty.equals	(	Object	): Compares this property to another.
org.joda.time.field.AbstractPartialFieldProperty.get	(	): Gets the value of this property from the instant.  For example, the following two lines of code are equivalent:  partial.getDayOfMonth(); partial.dayOfMonth().get(); 
org.joda.time.field.AbstractPartialFieldProperty.getAsShortText	(	): Gets the short textual value of this property from the instant as a string in the default locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Mon' in English.
org.joda.time.field.AbstractPartialFieldProperty.getAsShortText	(	Locale	): Gets the short textual value of this property from the instant as a string in the specified locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Mon' in English.
org.joda.time.field.AbstractPartialFieldProperty.getAsString	(	): Gets the value of this property from the instant as a string.  This method returns the value converted to a String using Integer.toString. This method does NOT return textual descriptions such as 'Monday' or 'January'. See getAsText() and getAsShortText() for those.
org.joda.time.field.AbstractPartialFieldProperty.getAsText	(	): Gets the textual value of this property from the instant as a string in the default locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Monday' in English.
org.joda.time.field.AbstractPartialFieldProperty.getAsText	(	Locale	): Gets the textual value of this property from the instant as a string in the specified locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Monday' in English.
org.joda.time.field.AbstractPartialFieldProperty.getDurationField	(	): Returns the duration per unit value of this field. For example, if this field represents "hour of day", then the duration is an hour.
org.joda.time.field.AbstractPartialFieldProperty.getField	(	): Gets the field being used.
org.joda.time.field.AbstractPartialFieldProperty.getFieldType	(	): Gets the field type being used.
org.joda.time.field.AbstractPartialFieldProperty.getMaximumShortTextLength	(	Locale	): Gets the maximum short text length for the field.
org.joda.time.field.AbstractPartialFieldProperty.getMaximumTextLength	(	Locale	): Gets the maximum text length for the field.
org.joda.time.field.AbstractPartialFieldProperty.getMaximumValue	(	): Gets the maximum value for this field given the current field values.
org.joda.time.field.AbstractPartialFieldProperty.getMaximumValueOverall	(	): Gets the maximum value for the field ignoring the current time.
org.joda.time.field.AbstractPartialFieldProperty.getMinimumValue	(	): Gets the minimum value for this field given the current field values.
org.joda.time.field.AbstractPartialFieldProperty.getMinimumValueOverall	(	): Gets the minimum value for the field ignoring the current time.
org.joda.time.field.AbstractPartialFieldProperty.getName	(	): Gets the name of the field.
org.joda.time.field.AbstractPartialFieldProperty.getRangeDurationField	(	): Returns the range duration of this field. For example, if this field represents "hour of day", then the range duration is a day.
org.joda.time.field.AbstractPartialFieldProperty.getReadablePartial	(	): Gets the partial instant being used.
org.joda.time.field.AbstractPartialFieldProperty.hashCode	(	): Gets a suitable hashcode for the object.
org.joda.time.field.AbstractPartialFieldProperty.toString	(	): Output a debugging string.
org.joda.time.field.AbstractReadableInstantFieldProperty: AbstractReadableInstantFieldProperty is a base class for binding a ReadableInstant to a DateTimeField.  It allows the date and time manipulation code to be field based yet still easy to use.  AbstractReadableInstantFieldProperty itself is thread-safe and immutable, but the ReadableInstant being operated on may be mutable and not thread-safe.
org.joda.time.field.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty	(	): Constructor.
org.joda.time.field.AbstractReadableInstantFieldProperty.compareTo	(	ReadableInstant	): Compare this field to the same field on another instant.  The comparison is based on the value of the same field type, irrespective of any difference in chronology. Thus, if this property represents the hourOfDay field, then the hourOfDay field of the other instant will be queried whether in the same chronology or not.
org.joda.time.field.AbstractReadableInstantFieldProperty.compareTo	(	ReadablePartial	): Compare this field to the same field on another partial instant.  The comparison is based on the value of the same field type, irrespective of any difference in chronology. Thus, if this property represents the hourOfDay field, then the hourOfDay field of the other partial will be queried whether in the same chronology or not.
org.joda.time.field.AbstractReadableInstantFieldProperty.equals	(	Object	): Compares this property to another.
org.joda.time.field.AbstractReadableInstantFieldProperty.get	(	): Gets the value of this property from the instant.  For example, the following two lines of code are equivalent:  datetime.getDayOfMonth(); datetime.dayOfMonth().get(); 
org.joda.time.field.AbstractReadableInstantFieldProperty.getAsShortText	(	): Gets the short textual value of this property from the instant as a string in the default locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Mon' in English.
org.joda.time.field.AbstractReadableInstantFieldProperty.getAsShortText	(	Locale	): Gets the short textual value of this property from the instant as a string in the specified locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Mon' in English.
org.joda.time.field.AbstractReadableInstantFieldProperty.getAsString	(	): Gets the value of this property from the instant as a string.  This method returns the value converted to a String using Integer.toString. This method does NOT return textual descriptions such as 'Monday' or 'January'. See getAsText() and getAsShortText() for those.
org.joda.time.field.AbstractReadableInstantFieldProperty.getAsText	(	): Gets the textual value of this property from the instant as a string in the default locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Monday' in English.
org.joda.time.field.AbstractReadableInstantFieldProperty.getAsText	(	Locale	): Gets the textual value of this property from the instant as a string in the specified locale.  This method returns the value converted to a String returning the appropriate textual description wherever possible. Thus, a day of week of 1 would return 'Monday' in English.
org.joda.time.field.AbstractReadableInstantFieldProperty.getChronology	(	): Gets the chronology of the datetime that this property is linked to.  This implementation throws UnsupportedOperationException, and must be implemented by subclasses to enable the equals() and hashCode() methods.
org.joda.time.field.AbstractReadableInstantFieldProperty.getDifference	(	ReadableInstant	): Returns the difference between this field property instant and the one passed in, in the units of this field. The sign of the difference matches that of compareTo. In other words, this field property's instant is the minuend.
org.joda.time.field.AbstractReadableInstantFieldProperty.getDifferenceAsLong	(	ReadableInstant	): Returns the difference between this field property instant and the one passed in, in the units of this field. The sign of the difference matches that of compareTo. In other words, this field property's instant is the minuend.
org.joda.time.field.AbstractReadableInstantFieldProperty.getDurationField	(	): Returns the duration per unit value of this field. For example, if this field represents "hour of day", then the duration is an hour.
org.joda.time.field.AbstractReadableInstantFieldProperty.getField	(	): Gets the field being used.
org.joda.time.field.AbstractReadableInstantFieldProperty.getFieldType	(	): Gets the field type being used.
org.joda.time.field.AbstractReadableInstantFieldProperty.getLeapAmount	(	): Gets the amount by which this field is leap.
org.joda.time.field.AbstractReadableInstantFieldProperty.getLeapDurationField	(	): If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMaximumShortTextLength	(	Locale	): Gets the maximum short text length for the field.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMaximumTextLength	(	Locale	): Gets the maximum text length for the field.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMaximumValue	(	): Gets the maximum value for the field.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMaximumValueOverall	(	): Gets the maximum value for the field ignoring the current time.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMillis	(	): Gets the milliseconds of the datetime that this property is linked to.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMinimumValue	(	): Gets the minimum value for the field.
org.joda.time.field.AbstractReadableInstantFieldProperty.getMinimumValueOverall	(	): Gets the minimum value for the field ignoring the current time.
org.joda.time.field.AbstractReadableInstantFieldProperty.getName	(	): Gets the name of the field.
org.joda.time.field.AbstractReadableInstantFieldProperty.getRangeDurationField	(	): Returns the range duration of this field. For example, if this field represents "hour of day", then the range duration is a day.
org.joda.time.field.AbstractReadableInstantFieldProperty.hashCode	(	): Returns a hashcode compatible with the equals method.
org.joda.time.field.AbstractReadableInstantFieldProperty.isLeap	(	): Gets whether this field is leap.
org.joda.time.field.AbstractReadableInstantFieldProperty.remainder	(	): Returns the fractional duration milliseconds of this field.
org.joda.time.field.AbstractReadableInstantFieldProperty.toInterval	(	): Returns the interval that represents the range of the minimum and maximum values of this field.  For example, datetime.monthOfYear().toInterval() will return an interval over the whole month.
org.joda.time.field.AbstractReadableInstantFieldProperty.toString	(	): Output a debugging string.
org.joda.time.field.BaseDateTimeField: BaseDateTimeField provides the common behaviour for DateTimeField implementations.  This class should generally not be used directly by API users. The DateTimeField class should be used when different kinds of DateTimeField objects are to be referenced.  BaseDateTimeField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.BaseDateTimeField.BaseDateTimeField	(	DateTimeFieldType	): Constructor.
org.joda.time.field.BaseDateTimeField.add	(	ReadablePartial	int	int[]	int	): Adds a value (which may be negative) to the partial instant, throwing an exception if the maximum size of the instant is reached.  The value will be added to this field, overflowing into larger fields if necessary. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  Partial instants only contain some fields. This may result in a maximum possible value, such as TimeOfDay being limited to 23:59:59:999. If this limit is breached by the add an exception is thrown.  For example, in the ISO chronology: 2000-08-20 add six months is 2000-02-20 2000-08-20 add twenty months is 2000-04-20 2000-08-20 add minus nine months is 2000-11-20 2001-01-31 add one month is 2001-02-28 2001-01-31 add two months is 2001-03-31
org.joda.time.field.BaseDateTimeField.add	(	long	int	): Adds a value (which may be negative) to the instant value, overflowing into larger fields if necessary.  The value will be added to this field. If the value is too large to be added solely to this field, larger fields will increase as required. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  For example, in the ISO chronology: 2000-08-20 add six months is 2001-02-20 2000-08-20 add twenty months is 2002-04-20 2000-08-20 add minus nine months is 1999-11-20 2001-01-31 add one month is 2001-02-28 2001-01-31 add two months is 2001-03-31
org.joda.time.field.BaseDateTimeField.add	(	long	long	): Adds a value (which may be negative) to the instant value, overflowing into larger fields if necessary.
org.joda.time.field.BaseDateTimeField.addWrapField	(	ReadablePartial	int	int[]	int	): Adds a value (which may be negative) to the partial instant, wrapping within this field.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps. Larger fields are always unaffected. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  For example, in the ISO chronology: 2000-08-20 addWrapField six months is 2000-02-20 2000-08-20 addWrapField twenty months is 2000-04-20 2000-08-20 addWrapField minus nine months is 2000-11-20 2001-01-31 addWrapField one month is 2001-02-28 2001-01-31 addWrapField two months is 2001-03-31  The default implementation internally calls set. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.field.BaseDateTimeField.addWrapField	(	long	int	): Adds a value (which may be negative) to the instant value, wrapping within this field.  The value will be added to this field. If the value is too large to be added solely to this field then it wraps. Larger fields are always unaffected. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  For example, in the ISO chronology: 2000-08-20 addWrapField six months is 2000-02-20 2000-08-20 addWrapField twenty months is 2000-04-20 2000-08-20 addWrapField minus nine months is 2000-11-20 2001-01-31 addWrapField one month is 2001-02-28 2001-01-31 addWrapField two months is 2001-03-31  The default implementation internally calls set. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.field.BaseDateTimeField.addWrapPartial	(	ReadablePartial	int	int[]	int	): Adds a value (which may be negative) to the partial instant, wrapping the whole partial if the maximum size of the partial is reached.  The value will be added to this field, overflowing into larger fields if necessary. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range.  Partial instants only contain some fields. This may result in a maximum possible value, such as TimeOfDay normally being limited to 23:59:59:999. If this limit is reached by the addition, this method will wrap back to 00:00:00.000. In fact, you would generally only use this method for classes that have a limitation such as this.  For example, in the ISO chronology: 10:20:30 add 20 minutes is 10:40:30 10:20:30 add 45 minutes is 11:05:30 10:20:30 add 16 hours is 02:20:30
org.joda.time.field.BaseDateTimeField.convertText	(	String	Locale	): Convert the specified text and locale into a value.
org.joda.time.field.BaseDateTimeField.get	(	long	): Get the value of this field from the milliseconds.
org.joda.time.field.BaseDateTimeField.getAsShortText	(	ReadablePartial	Locale	): Get the human-readable, short text value of this field from a partial instant. If the specified locale is null, the default locale is used.  The default implementation calls get() and getAsText().
org.joda.time.field.BaseDateTimeField.getAsShortText	(	ReadablePartial	int	Locale	): Get the human-readable, short text value of this field from a partial instant. If the specified locale is null, the default locale is used.  The default implementation returns getAsShortText(fieldValue, locale).
org.joda.time.field.BaseDateTimeField.getAsShortText	(	int	Locale	): Get the human-readable, short text value of this field from the field value. If the specified locale is null, the default locale is used.  The default implementation returns getAsText(fieldValue, locale).  Note: subclasses that override this method should also override getMaximumShortTextLength.
org.joda.time.field.BaseDateTimeField.getAsShortText	(	long	): Get the human-readable, short text value of this field from the milliseconds.  The default implementation calls getAsShortText().
org.joda.time.field.BaseDateTimeField.getAsShortText	(	long	Locale	): Get the human-readable, short text value of this field from the milliseconds. If the specified locale is null, the default locale is used.  The default implementation returns getAsShortText(get(instant), locale).
org.joda.time.field.BaseDateTimeField.getAsText	(	ReadablePartial	Locale	): Get the human-readable, text value of this field from a partial instant. If the specified locale is null, the default locale is used.  The default implementation calls get() and getAsText().
org.joda.time.field.BaseDateTimeField.getAsText	(	ReadablePartial	int	Locale	): Get the human-readable, text value of this field from a partial instant. If the specified locale is null, the default locale is used.  The default implementation returns getAsText(fieldValue, locale).
org.joda.time.field.BaseDateTimeField.getAsText	(	int	Locale	): Get the human-readable, text value of this field from the field value. If the specified locale is null, the default locale is used.  The default implementation returns Integer.toString(get(instant)).  Note: subclasses that override this method should also override getMaximumTextLength.
org.joda.time.field.BaseDateTimeField.getAsText	(	long	): Get the human-readable, text value of this field from the milliseconds.  The default implementation calls getAsText().
org.joda.time.field.BaseDateTimeField.getAsText	(	long	Locale	): Get the human-readable, text value of this field from the milliseconds. If the specified locale is null, the default locale is used.  The default implementation returns getAsText(get(instant), locale).
org.joda.time.field.BaseDateTimeField.getDifference	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... int v = ... int age = getDifference(add(instant, v), instant);  The value 'age' is the same as the value 'v'.
org.joda.time.field.BaseDateTimeField.getDifferenceAsLong	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... long v = ... long age = getDifferenceAsLong(add(instant, v), instant);  The value 'age' is the same as the value 'v'.
org.joda.time.field.BaseDateTimeField.getDurationField	(	): Returns the duration per unit value of this field. For example, if this field represents "hour of day", then the unit duration is an hour.
org.joda.time.field.BaseDateTimeField.getLeapAmount	(	long	): Gets the amount by which this field is 'leap' for the specified instant.  For example, a leap year would return one, a non leap year would return zero.  This implementation returns zero.
org.joda.time.field.BaseDateTimeField.getLeapDurationField	(	): If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned.  This implementation returns null.
org.joda.time.field.BaseDateTimeField.getMaximumShortTextLength	(	Locale	): Get the maximum short text value for this field. The default implementation returns getMaximumTextLength().
org.joda.time.field.BaseDateTimeField.getMaximumTextLength	(	Locale	): Get the maximum text value for this field. The default implementation returns the equivalent of Integer.toString(getMaximumValue()).length().
org.joda.time.field.BaseDateTimeField.getMaximumValue	(	): Get the maximum allowable value for this field.
org.joda.time.field.BaseDateTimeField.getMaximumValue	(	ReadablePartial	): Get the maximum value for this field evaluated at the specified instant.  This implementation returns the same as getMaximumValue().
org.joda.time.field.BaseDateTimeField.getMaximumValue	(	ReadablePartial	int[]	): Get the maximum value for this field using the partial instant and the specified values.  This implementation returns the same as getMaximumValue().
org.joda.time.field.BaseDateTimeField.getMaximumValue	(	long	): Get the maximum value for this field evaluated at the specified time.  This implementation returns the same as getMaximumValue().
org.joda.time.field.BaseDateTimeField.getMinimumValue	(	): Get the minimum allowable value for this field.
org.joda.time.field.BaseDateTimeField.getMinimumValue	(	ReadablePartial	): Get the minimum value for this field evaluated at the specified instant.  This implementation returns the same as getMinimumValue().
org.joda.time.field.BaseDateTimeField.getMinimumValue	(	ReadablePartial	int[]	): Get the minimum value for this field using the partial instant and the specified values.  This implementation returns the same as getMinimumValue().
org.joda.time.field.BaseDateTimeField.getMinimumValue	(	long	): Get the minimum value for this field evaluated at the specified time.  This implementation returns the same as getMinimumValue().
org.joda.time.field.BaseDateTimeField.getRangeDurationField	(	): Returns the range duration of this field. For example, if this field represents "hour of day", then the range duration is a day.
org.joda.time.field.BaseDateTimeField.isLeap	(	long	): Returns whether this field is 'leap' for the specified instant.  For example, a leap year would return true, a non leap year would return false.  This implementation returns false.
org.joda.time.field.BaseDateTimeField.isSupported	(	): Returns true if this field is supported.
org.joda.time.field.BaseDateTimeField.remainder	(	long	): Returns the fractional duration milliseconds of this field. In other words, calling remainder returns the duration that roundFloor would subtract.  For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by hour is 34 minutes and 56.789 seconds.  The default implementation computes instant - roundFloor(instant). Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.field.BaseDateTimeField.roundCeiling	(	long	): Round to the highest whole unit of this field. The value of this field and all fields of a higher magnitude may be incremented in order to achieve this result. The fractional millis that cannot be expressed in whole increments of this field are set to minimum.  For example, a datetime of 2002-11-02T23:34:56.789, rounded to the highest whole hour is 2002-11-03T00:00:00.000.  The default implementation calls roundFloor, and if the instant is modified as a result, adds one field unit. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.field.BaseDateTimeField.roundFloor	(	long	): Round to the lowest whole unit of this field. After rounding, the value of this field and all fields of a higher magnitude are retained. The fractional millis that cannot be expressed in whole increments of this field are set to minimum.  For example, a datetime of 2002-11-02T23:34:56.789, rounded to the lowest whole hour is 2002-11-02T23:00:00.000.
org.joda.time.field.BaseDateTimeField.roundHalfCeiling	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like roundFloor. If the millisecond value is closer to the ceiling or is exactly halfway, this function behaves like roundCeiling.
org.joda.time.field.BaseDateTimeField.roundHalfEven	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like roundFloor. If the millisecond value is closer to the ceiling, this function behaves like roundCeiling.  If the millisecond value is exactly halfway between the floor and ceiling, the ceiling is chosen over the floor only if it makes this field's value even.
org.joda.time.field.BaseDateTimeField.roundHalfFloor	(	long	): Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor or is exactly halfway, this function behaves like roundFloor. If the millisecond value is closer to the ceiling, this function behaves like roundCeiling.
org.joda.time.field.BaseDateTimeField.set	(	ReadablePartial	int	int[]	String	Locale	): Sets a value in the milliseconds supplied from a human-readable, text value. If the specified locale is null, the default locale is used.  This implementation uses convertText(String, Locale) and set().
org.joda.time.field.BaseDateTimeField.set	(	ReadablePartial	int	int[]	int	): Sets a value using the specified partial instant.  The value of this field (specified by the index) will be set. If the value is invalid, an exception if thrown.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.field.BaseDateTimeField.set	(	long	String	): Sets a value in the milliseconds supplied from a human-readable, text value.  This implementation uses set().  Note: subclasses that override this method should also override getAsText.
org.joda.time.field.BaseDateTimeField.set	(	long	String	Locale	): Sets a value in the milliseconds supplied from a human-readable, text value. If the specified locale is null, the default locale is used.  This implementation uses convertText(String, Locale) and set().  Note: subclasses that override this method should also override getAsText.
org.joda.time.field.BaseDateTimeField.set	(	long	int	): Sets a value in the milliseconds supplied.  The value of this field will be set. If the value is invalid, an exception if thrown.  If setting this field would make other fields invalid, then those fields may be changed. For example if the current date is the 31st January, and the month is set to February, the day would be invalid. Instead, the day would be changed to the closest value - the 28th/29th February as appropriate.
org.joda.time.field.BaseDateTimeField.toString	(	): Get a suitable debug string.
org.joda.time.field.BaseDurationField: BaseDurationField provides the common behaviour for DurationField implementations.  This class should generally not be used directly by API users. The DurationField class should be used when different kinds of DurationField objects are to be referenced.  BaseDurationField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.BaseDurationField.getMillis	(	int	): Get the millisecond duration of this field from its value, which is approximate if this field is imprecise.
org.joda.time.field.BaseDurationField.getMillis	(	long	): Get the millisecond duration of this field from its value, which is approximate if this field is imprecise.
org.joda.time.field.BaseDurationField.getValue	(	long	): Get the value of this field from the milliseconds, which is approximate if this field is imprecise.
org.joda.time.field.BaseDurationField.getValue	(	long	long	): Get the value of this field from the milliseconds relative to an instant. If the milliseconds is positive, then the instant is treated as a "start instant". If negative, the instant is treated as an "end instant". The default implementation returns Utils.safeToInt(getAsLong(millisDuration, instant)).
org.joda.time.field.BaseDurationField.getValueAsLong	(	long	): Get the value of this field from the milliseconds, which is approximate if this field is imprecise.
org.joda.time.field.BaseDurationField.isSupported	(	): Returns true if this field is supported.
org.joda.time.field.BaseDurationField.toString	(	): Get a suitable debug string.
org.joda.time.field.DecoratedDateTimeField: DecoratedDateTimeField extends BaseDateTimeField, implementing only the minimum required set of methods. These implemented methods delegate to a wrapped field.  This design allows new DateTimeField types to be defined that piggyback on top of another, inheriting all the safe method implementations from BaseDateTimeField. Should any method require pure delegation to the wrapped field, simply override and use the provided getWrappedField method.  DecoratedDateTimeField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField	(	DateTimeField	DateTimeFieldType	): Constructor.
org.joda.time.field.DecoratedDateTimeField.getWrappedField	(	): Gets the wrapped date time field.
org.joda.time.field.DecoratedDurationField: DecoratedDurationField extends BaseDurationField, implementing only the minimum required set of methods. These implemented methods delegate to a wrapped field.  This design allows new DurationField types to be defined that piggyback on top of another, inheriting all the safe method implementations from BaseDurationField. Should any method require pure delegation to the wrapped field, simply override and use the provided getWrappedField method.  DecoratedDurationField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.DecoratedDurationField.DecoratedDurationField	(	DurationField	DurationFieldType	): Constructor.
org.joda.time.field.DecoratedDurationField.getWrappedField	(	): Gets the wrapped duration field.
org.joda.time.field.DelegatedDateTimeField: DelegatedDateTimeField delegates each method call to the date time field it wraps.  DelegatedDateTimeField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField	(	DateTimeField	): Constructor.
org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField	(	DateTimeField	DateTimeFieldType	): Constructor.
org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField	(	DateTimeField	DurationField	DateTimeFieldType	): Constructor.
org.joda.time.field.DelegatedDateTimeField.getWrappedField	(	): Gets the wrapped date time field.
org.joda.time.field.DelegatedDurationField: DelegatedDurationField delegates each method call to the duration field it wraps.  DelegatedDurationField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.DelegatedDurationField.DelegatedDurationField	(	DurationField	): Constructor.
org.joda.time.field.DelegatedDurationField.DelegatedDurationField	(	DurationField	DurationFieldType	): Constructor.
org.joda.time.field.DelegatedDurationField.getWrappedField	(	): Gets the wrapped duration field.
org.joda.time.field.DelegatedDurationField.isSupported	(	): Returns true if this field is supported.
org.joda.time.field.DividedDateTimeField: Divides a DateTimeField such that the retrieved values are reduced by a fixed divisor. The field's unit duration is scaled accordingly, but the range duration is unchanged.  DividedDateTimeField is thread-safe and immutable.
org.joda.time.field.DividedDateTimeField.DividedDateTimeField	(	DateTimeField	DateTimeFieldType	int	): Constructor.
org.joda.time.field.DividedDateTimeField.DividedDateTimeField	(	DateTimeField	DurationField	DateTimeFieldType	int	): Constructor.
org.joda.time.field.DividedDateTimeField.DividedDateTimeField	(	RemainderDateTimeField	DateTimeFieldType	): Construct a DividedDateTimeField that compliments the given RemainderDateTimeField.
org.joda.time.field.DividedDateTimeField.DividedDateTimeField	(	RemainderDateTimeField	DurationField	DateTimeFieldType	): Construct a DividedDateTimeField that compliments the given RemainderDateTimeField.
org.joda.time.field.DividedDateTimeField.add	(	long	int	): Add the specified amount of scaled units to the specified time instant. The amount added may be negative.
org.joda.time.field.DividedDateTimeField.add	(	long	long	): Add the specified amount of scaled units to the specified time instant. The amount added may be negative.
org.joda.time.field.DividedDateTimeField.addWrapField	(	long	int	): Add to the scaled component of the specified time instant, wrapping around within that component if necessary.
org.joda.time.field.DividedDateTimeField.get	(	long	): Get the amount of scaled units from the specified time instant.
org.joda.time.field.DividedDateTimeField.getDivisor	(	): Returns the divisor applied, in the field's units.
org.joda.time.field.DividedDateTimeField.getDurationField	(	): Returns a scaled version of the wrapped field's unit duration field.
org.joda.time.field.DividedDateTimeField.getMaximumValue	(	): Get the maximum value for the field.
org.joda.time.field.DividedDateTimeField.getMinimumValue	(	): Get the minimum value for the field.
org.joda.time.field.DividedDateTimeField.set	(	long	int	): Set the specified amount of scaled units to the specified time instant.
org.joda.time.field.FieldUtils: General utilities that don't fit elsewhere.  FieldUtils is thread-safe and immutable.
org.joda.time.field.FieldUtils.FieldUtils	(	): Restricted constructor.
org.joda.time.field.FieldUtils.equals	(	Object	Object	): Compares two objects as equals handling null.
org.joda.time.field.FieldUtils.getWrappedValue	(	int	int	int	): Utility method that ensures the given value lies within the field's legal value range.
org.joda.time.field.FieldUtils.getWrappedValue	(	int	int	int	int	): Utility method used by addWrapField implementations to ensure the new value lies within the field's legal value range.
org.joda.time.field.FieldUtils.safeAdd	(	int	int	): Add two values throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeAdd	(	long	long	): Add two values throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeDivide	(	long	long	): Divides the dividend by the divisor throwing an exception if overflow occurs or the divisor is zero.
org.joda.time.field.FieldUtils.safeDivide	(	long	long	RoundingMode	): Divides the dividend by divisor. Rounding of result occurs as per the roundingMode.
org.joda.time.field.FieldUtils.safeMultiply	(	int	int	): Multiply two values throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeMultiply	(	long	int	): Multiply two values throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeMultiply	(	long	long	): Multiply two values throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeMultiplyToInt	(	long	long	): Multiply two values to return an int throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeNegate	(	int	): Negates the input throwing an exception if it can't negate it.
org.joda.time.field.FieldUtils.safeSubtract	(	long	long	): Subtracts two values throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.safeToInt	(	long	): Casts to an int throwing an exception if overflow occurs.
org.joda.time.field.FieldUtils.verifyValueBounds	(	DateTimeField	int	int	int	): Verify that input values are within specified bounds.
org.joda.time.field.FieldUtils.verifyValueBounds	(	DateTimeFieldType	int	int	int	): Verify that input values are within specified bounds.
org.joda.time.field.FieldUtils.verifyValueBounds	(	String	int	int	int	): Verify that input values are within specified bounds.
org.joda.time.field.ImpreciseDateTimeField: Abstract datetime field class that defines its own DurationField, which delegates back into this ImpreciseDateTimeField.  This DateTimeField is useful for defining DateTimeFields that are composed of imprecise durations. If both duration fields are precise, then a PreciseDateTimeField should be used instead.  When defining imprecise DateTimeFields where a matching DurationField is already available, just extend BaseDateTimeField directly so as not to create redundant DurationField instances.  ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField	(	DateTimeFieldType	long	): Constructor.
org.joda.time.field.ImpreciseDateTimeField.getDifference	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... int v = ... int age = getDifference(add(instant, v), instant);  The value 'age' is the same as the value 'v'.  The default implementation call getDifferenceAsLong and converts the return value to an int.
org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong	(	long	long	): Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  long instant = ... long v = ... long age = getDifferenceAsLong(add(instant, v), instant);  The value 'age' is the same as the value 'v'.  The default implementation performs a guess-and-check algorithm using getDurationField().getUnitMillis() and the add() method. Subclasses are encouraged to provide a more efficient implementation.
org.joda.time.field.LenientDateTimeField: Converts a strict DateTimeField into a lenient one. By being lenient, the set method accepts out of bounds values, performing an addition instead.  LenientDateTimeField is thread-safe and immutable.
org.joda.time.field.LenientDateTimeField.getInstance	(	DateTimeField	Chronology	): Returns a lenient version of the given field. If it is already lenient, then it is returned as-is. Otherwise, a new LenientDateTimeField is returned.
org.joda.time.field.LenientDateTimeField.set	(	long	int	): Set values which may be out of bounds by adding the difference between the new value and the current value.
org.joda.time.field.MillisDurationField: Duration field class representing a field with a fixed unit length of one millisecond.  MillisDurationField is thread-safe and immutable.
org.joda.time.field.MillisDurationField.MillisDurationField	(	): Restricted constructor.
org.joda.time.field.MillisDurationField.getUnitMillis	(	): Returns the amount of milliseconds per unit value of this field.
org.joda.time.field.MillisDurationField.isPrecise	(	): Returns true as this field is precise.
org.joda.time.field.MillisDurationField.isSupported	(	): Returns true as this field is supported.
org.joda.time.field.MillisDurationField.readResolve	(	): Deserialize to the singleton.
org.joda.time.field.MillisDurationField.toString	(	): Get a suitable debug string.
org.joda.time.field.OffsetDateTimeField: Generic offset adjusting datetime field.  OffsetDateTimeField is thread-safe and immutable.
org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField	(	DateTimeField	DateTimeFieldType	int	): Constructor.
org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField	(	DateTimeField	DateTimeFieldType	int	int	int	): Constructor.
org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField	(	DateTimeField	int	): Constructor.
org.joda.time.field.OffsetDateTimeField.add	(	long	int	): Add the specified amount of offset units to the specified time instant. The amount added may be negative.
org.joda.time.field.OffsetDateTimeField.add	(	long	long	): Add the specified amount of offset units to the specified time instant. The amount added may be negative.
org.joda.time.field.OffsetDateTimeField.addWrapField	(	long	int	): Add to the offset component of the specified time instant, wrapping around within that component if necessary.
org.joda.time.field.OffsetDateTimeField.get	(	long	): Get the amount of offset units from the specified time instant.
org.joda.time.field.OffsetDateTimeField.getMaximumValue	(	): Get the maximum value for the field.
org.joda.time.field.OffsetDateTimeField.getMinimumValue	(	): Get the minimum value for the field.
org.joda.time.field.OffsetDateTimeField.getOffset	(	): Returns the offset added to the field values.
org.joda.time.field.OffsetDateTimeField.set	(	long	int	): Set the specified amount of offset units to the specified time instant.
org.joda.time.field.PreciseDateTimeField: Precise datetime field, composed of two precise duration fields.  This DateTimeField is useful for defining DateTimeFields that are composed of precise durations, like time of day fields. If either duration field is imprecise, then an ImpreciseDateTimeField may be used instead.  PreciseDateTimeField is thread-safe and immutable.
org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField	(	DateTimeFieldType	DurationField	DurationField	): Constructor.
org.joda.time.field.PreciseDateTimeField.addWrapField	(	long	int	): Add to the component of the specified time instant, wrapping around within that component if necessary.
org.joda.time.field.PreciseDateTimeField.get	(	long	): Get the amount of fractional units from the specified time instant.
org.joda.time.field.PreciseDateTimeField.getMaximumValue	(	): Get the maximum value for the field.
org.joda.time.field.PreciseDateTimeField.getRange	(	): Returns the range of the field in the field's units.  For example, 60 for seconds per minute. The field is allowed values from 0 to range - 1.
org.joda.time.field.PreciseDateTimeField.getRangeDurationField	(	): Returns the range duration of this field. For example, if this field represents "minute of hour", then the range duration field is an hours.
org.joda.time.field.PreciseDateTimeField.set	(	long	int	): Set the specified amount of units to the specified time instant.
org.joda.time.field.PreciseDurationDateTimeField: Precise datetime field, which has a precise unit duration field.  PreciseDurationDateTimeField is thread-safe and immutable, and its subclasses must be as well.
org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField	(	DateTimeFieldType	DurationField	): Constructor.
org.joda.time.field.PreciseDurationDateTimeField.getDurationField	(	): Returns the duration per unit value of this field. For example, if this field represents "minute of hour", then the duration field is minutes.
org.joda.time.field.PreciseDurationDateTimeField.getMaximumValueForSet	(	long	int	): Called by the set method to get the maximum allowed value. By default, returns getMaximumValue(instant). Override to provide a faster implementation.
org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue	(	): Get the minimum value for the field.
org.joda.time.field.PreciseDurationDateTimeField.isLenient	(	): Returns false by default.
org.joda.time.field.PreciseDurationDateTimeField.remainder	(	long	): This method assumes that this field is properly rounded on 1970-01-01T00:00:00. If the rounding alignment differs, override this method as follows:  return super.remainder(instant + ALIGNMENT_MILLIS); 
org.joda.time.field.PreciseDurationDateTimeField.roundCeiling	(	long	): This method assumes that this field is properly rounded on 1970-01-01T00:00:00. If the rounding alignment differs, override this method as follows:  return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS; 
org.joda.time.field.PreciseDurationDateTimeField.roundFloor	(	long	): This method assumes that this field is properly rounded on 1970-01-01T00:00:00. If the rounding alignment differs, override this method as follows:  return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS; 
org.joda.time.field.PreciseDurationDateTimeField.set	(	long	int	): Set the specified amount of units to the specified time instant.
org.joda.time.field.PreciseDurationField: Duration field class representing a field with a fixed unit length.  PreciseDurationField is thread-safe and immutable.
org.joda.time.field.PreciseDurationField.PreciseDurationField	(	DurationFieldType	long	): Constructor.
org.joda.time.field.PreciseDurationField.equals	(	Object	): Compares this duration field to another. Two fields are equal if of the same type and duration.
org.joda.time.field.PreciseDurationField.getMillis	(	int	long	): Get the millisecond duration of this field from its value.
org.joda.time.field.PreciseDurationField.getMillis	(	long	long	): Get the millisecond duration of this field from its value.
org.joda.time.field.PreciseDurationField.getUnitMillis	(	): Returns the amount of milliseconds per unit value of this field.
org.joda.time.field.PreciseDurationField.getValueAsLong	(	long	long	): Get the value of this field from the milliseconds.
org.joda.time.field.PreciseDurationField.hashCode	(	): Gets a hash code for this instance.
org.joda.time.field.PreciseDurationField.isPrecise	(	): This field is precise.
org.joda.time.field.RemainderDateTimeField: Counterpart remainder datetime field to DividedDateTimeField. The field's unit duration is unchanged, but the range duration is scaled accordingly.  RemainderDateTimeField is thread-safe and immutable.
org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField	(	DateTimeField	DateTimeFieldType	int	): Constructor.
org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField	(	DateTimeField	DurationField	DateTimeFieldType	int	): Constructor.
org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField	(	DividedDateTimeField	): Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.
org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField	(	DividedDateTimeField	DateTimeFieldType	): Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.
org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField	(	DividedDateTimeField	DurationField	DateTimeFieldType	): Construct a RemainderDateTimeField that compliments the given DividedDateTimeField. This constructor allows the duration field to be set.
org.joda.time.field.RemainderDateTimeField.addWrapField	(	long	int	): Add the specified amount to the specified time instant, wrapping around within the remainder range if necessary. The amount added may be negative.
org.joda.time.field.RemainderDateTimeField.get	(	long	): Get the remainder from the specified time instant.
org.joda.time.field.RemainderDateTimeField.getDivisor	(	): Returns the divisor applied, in the field's units.
org.joda.time.field.RemainderDateTimeField.getMaximumValue	(	): Get the maximum value for the field, which is always one less than the divisor.
org.joda.time.field.RemainderDateTimeField.getMinimumValue	(	): Get the minimum value for the field, which is always zero.
org.joda.time.field.RemainderDateTimeField.getRangeDurationField	(	): Returns a scaled version of the wrapped field's unit duration field.
org.joda.time.field.RemainderDateTimeField.set	(	long	int	): Set the specified amount of remainder units to the specified time instant.
org.joda.time.field.ScaledDurationField: Scales a DurationField such that it's unit millis becomes larger in magnitude.  ScaledDurationField is thread-safe and immutable.
org.joda.time.field.ScaledDurationField.ScaledDurationField	(	DurationField	DurationFieldType	int	): Constructor
org.joda.time.field.ScaledDurationField.equals	(	Object	): Compares this duration field to another. Two fields are equal if of the same type and duration.
org.joda.time.field.ScaledDurationField.getScalar	(	): Returns the scalar applied, in the field's units.
org.joda.time.field.ScaledDurationField.hashCode	(	): Gets a hash code for this instance.
org.joda.time.field.SkipDateTimeField: Wraps another field such that a certain value is skipped.  This is most useful for years where you want to skip zero, so the sequence runs ...,2,1,-1,-2,...  SkipDateTimeField is thread-safe and immutable.
org.joda.time.field.SkipDateTimeField.SkipDateTimeField	(	Chronology	DateTimeField	): Constructor that skips zero.
org.joda.time.field.SkipDateTimeField.SkipDateTimeField	(	Chronology	DateTimeField	int	): Constructor.
org.joda.time.field.SkipUndoDateTimeField: Wraps another field such that a certain value is added back into the sequence of numbers.  This reverses the effect of SkipDateTimeField. This isn't very elegant.  SkipUndoDateTimeField is thread-safe and immutable.
org.joda.time.field.SkipUndoDateTimeField.SkipUndoDateTimeField	(	Chronology	DateTimeField	): Constructor that reinserts zero.
org.joda.time.field.SkipUndoDateTimeField.SkipUndoDateTimeField	(	Chronology	DateTimeField	int	): Constructor.
org.joda.time.field.StrictDateTimeField: Converts a lenient DateTimeField into a strict one. By being strict, the set throws an IllegalArgumentException if the value is out of bounds.  StrictDateTimeField is thread-safe and immutable.
org.joda.time.field.StrictDateTimeField.getInstance	(	DateTimeField	): Returns a strict version of the given field. If it is already strict, then it is returned as-is. Otherwise, a new StrictDateTimeField is returned.
org.joda.time.field.StrictDateTimeField.set	(	long	int	): Does a bounds check before setting the value.
org.joda.time.field.TestAll: Entry point for all tests in this package.
org.joda.time.field.TestBaseDateTimeField: This class is a Junit unit test for BaseDateTimeField.
org.joda.time.field.TestMillisDurationField: This class is a Junit unit test for PeriodFormatterBuilder.
org.joda.time.field.TestOffsetDateTimeField: This class is a Junit unit test for PreciseDateTimeField.
org.joda.time.field.TestPreciseDateTimeField: This class is a Junit unit test for PreciseDateTimeField.
org.joda.time.field.TestPreciseDurationDateTimeField: This class is a Junit unit test for PreciseDurationDateTimeField.
org.joda.time.field.TestPreciseDurationField: This class is a Junit unit test for PreciseDurationField.
org.joda.time.field.TestScaledDurationField: This class is a Junit unit test for PreciseDurationField.
org.joda.time.field.TestUnsupportedDateTimeField: This class is a JUnit test to test only the UnsupportedDateTimeField class. This set of test cases exercises everything described in the Javadoc for this class.
org.joda.time.field.TestUnsupportedDateTimeField.testAlwaysFalseReturnTypes	(	): As this is an unsupported date/time field, some normal methods will always return false, as they are not supported. Verify that each method correctly returns null.
org.joda.time.field.TestUnsupportedDateTimeField.testDelegatedMethods	(	): As this is an unsupported date/time field, many normal methods are unsupported. Some delegate and can possibly throw an UnsupportedOperationException or have a valid return. Verify that each method correctly throws this exception when appropriate and delegates correctly based on the Duration used to get the instance.
org.joda.time.field.TestUnsupportedDateTimeField.testDifferentDurationReturnDifferentObjects	(	): This test exercises the logic in UnsupportedDateTimeField.getInstance. If getInstance() is invoked twice with: - the same DateTimeFieldType - different duration fields Then the field returned in the first invocation should not be equal to the field returned by the second invocation. In other words, the generated instance should be the same for a unique pairing of DateTimeFieldType/DurationField
org.joda.time.field.TestUnsupportedDateTimeField.testMethodsThatShouldAlwaysReturnNull	(	): According to the JavaDocs, there are two methods that should always return null. * getRangeDurationField() * getLeapDurationField() Ensure that these are in fact null.
org.joda.time.field.TestUnsupportedDateTimeField.testNullValuesToGetInstanceThrowsException	(	): Passing null values into UnsupportedDateTimeField.getInstance() should throw an IllegalArguementsException
org.joda.time.field.TestUnsupportedDateTimeField.testPublicGetNameMethod	(	): The getName() method should return the same value as the getName() method of the DateTimeFieldType that was used to create the instance.
org.joda.time.field.TestUnsupportedDateTimeField.testToString	(	): The toString method should return a suitable debug message (not null). Ensure that the toString method returns a string with length greater than 0 (and not null)
org.joda.time.field.TestUnsupportedDateTimeField.testUnsupportedMethods	(	): As this is an unsupported date/time field, many normal methods are unsupported and throw an UnsupportedOperationException. Verify that each method correctly throws this exception. * add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) * addWrapField(long instant, int value) * addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) * get(long instant) * getAsShortText(int fieldValue, Locale locale) * getAsShortText(long instant) * getAsShortText(long instant, Locale locale) * getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) * getAsShortText(ReadablePartial partial, Locale locale) getAsText(int fieldValue, Locale locale) * getAsText(long instant) getAsText(long instant, Locale locale) * getAsText(ReadablePartial partial, int fieldValue, Locale locale) * getAsText(ReadablePartial partial, Locale locale) * getLeapAmount(long instant) getMaximumShortTextLength(Locale locale) * getMaximumTextLength(Locale locale) * getMaximumValue() * getMaximumValue(long instant) getMaximumValue(ReadablePartial instant) getMaximumValue(ReadablePartial instant, int[] values) getMinimumValue() * getMinimumValue(long instant) getMinimumValue(ReadablePartial instant) getMinimumValue(ReadablePartial instant, int[] values) * isLeap(long instant) * remainder(long instant) * roundCeiling(long instant) roundFloor(long instant) * roundHalfCeiling(long instant) roundHalfEven(long instant) * roundHalfFloor(long instant) * set(long instant, int value) * set(long instant, String text) * set(long instant, String text, Locale locale) * set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) * set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale)
org.joda.time.field.UnsupportedDateTimeField: A placeholder implementation to use when a datetime field is not supported.  UnsupportedDateTimeField is thread-safe and immutable.
org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField	(	DateTimeFieldType	DurationField	): Constructor.
org.joda.time.field.UnsupportedDateTimeField.add	(	ReadablePartial	int	int[]	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.add	(	long	int	): Delegates to the duration field.
org.joda.time.field.UnsupportedDateTimeField.add	(	long	long	): Delegates to the duration field.
org.joda.time.field.UnsupportedDateTimeField.addWrapField	(	ReadablePartial	int	int[]	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.addWrapField	(	long	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.addWrapPartial	(	ReadablePartial	int	int[]	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.get	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsShortText	(	ReadablePartial	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsShortText	(	ReadablePartial	int	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsShortText	(	int	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsShortText	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsShortText	(	long	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsText	(	ReadablePartial	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsText	(	ReadablePartial	int	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsText	(	int	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsText	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getAsText	(	long	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getDifference	(	long	long	): Delegates to the duration field.
org.joda.time.field.UnsupportedDateTimeField.getDifferenceAsLong	(	long	long	): Delegates to the duration field.
org.joda.time.field.UnsupportedDateTimeField.getDurationField	(	): Even though this DateTimeField is unsupported, the duration field might be supported.
org.joda.time.field.UnsupportedDateTimeField.getInstance	(	DateTimeFieldType	DurationField	): Gets an instance of UnsupportedDateTimeField for a specific named field. Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'. The returned instance is cached.
org.joda.time.field.UnsupportedDateTimeField.getLeapAmount	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getLeapDurationField	(	): Always returns null.
org.joda.time.field.UnsupportedDateTimeField.getMaximumShortTextLength	(	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMaximumTextLength	(	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMaximumValue	(	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMaximumValue	(	ReadablePartial	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMaximumValue	(	ReadablePartial	int[]	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMaximumValue	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMinimumValue	(	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMinimumValue	(	ReadablePartial	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMinimumValue	(	ReadablePartial	int[]	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getMinimumValue	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.getRangeDurationField	(	): Always returns null.
org.joda.time.field.UnsupportedDateTimeField.isLeap	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.isLenient	(	): This field is not lenient.
org.joda.time.field.UnsupportedDateTimeField.isSupported	(	): This field is not supported.
org.joda.time.field.UnsupportedDateTimeField.readResolve	(	): Ensure proper singleton serialization
org.joda.time.field.UnsupportedDateTimeField.remainder	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.roundCeiling	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.roundFloor	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.roundHalfCeiling	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.roundHalfEven	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.roundHalfFloor	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.set	(	ReadablePartial	int	int[]	String	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.set	(	ReadablePartial	int	int[]	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.set	(	long	String	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.set	(	long	String	Locale	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.set	(	long	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDateTimeField.toString	(	): Get a suitable debug string.
org.joda.time.field.UnsupportedDurationField: A placeholder implementation to use when a duration field is not supported.  UnsupportedDurationField is thread-safe and immutable.
org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField	(	DurationFieldType	): Constructor.
org.joda.time.field.UnsupportedDurationField.add	(	long	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.add	(	long	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.compareTo	(	DurationField	): Always returns zero, indicating that sort order is not relevant.
org.joda.time.field.UnsupportedDurationField.equals	(	Object	): Compares this duration field to another.
org.joda.time.field.UnsupportedDurationField.getDifference	(	long	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getDifferenceAsLong	(	long	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getInstance	(	DurationFieldType	): Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.
org.joda.time.field.UnsupportedDurationField.getMillis	(	int	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getMillis	(	int	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getMillis	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getMillis	(	long	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getUnitMillis	(	): Always returns zero.
org.joda.time.field.UnsupportedDurationField.getValue	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getValue	(	long	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getValueAsLong	(	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.getValueAsLong	(	long	long	): Always throws UnsupportedOperationException
org.joda.time.field.UnsupportedDurationField.hashCode	(	): Gets a suitable hashcode.
org.joda.time.field.UnsupportedDurationField.isPrecise	(	): This field is precise.
org.joda.time.field.UnsupportedDurationField.isSupported	(	): This field is not supported.
org.joda.time.field.UnsupportedDurationField.readResolve	(	): Ensure proper singleton serialization
org.joda.time.field.UnsupportedDurationField.toString	(	): Get a suitable debug string.
org.joda.time.field.ZeroIsMaxDateTimeField: Wraps another field such that zero values are replaced with one more than it's maximum. This is particularly useful for implementing an clockhourOfDay field, where the midnight value of 0 is replaced with 24.  ZeroIsMaxDateTimeField is thread-safe and immutable.
org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField	(	DateTimeField	DateTimeFieldType	): Constructor.
org.joda.time.field.ZeroIsMaxDateTimeField.getMaximumValue	(	): Get the maximum value for the field, which is one more than the wrapped field's maximum value.
org.joda.time.field.ZeroIsMaxDateTimeField.getMaximumValue	(	ReadablePartial	): Get the maximum value for the field, which is one more than the wrapped field's maximum value.
org.joda.time.field.ZeroIsMaxDateTimeField.getMaximumValue	(	ReadablePartial	int[]	): Get the maximum value for the field, which is one more than the wrapped field's maximum value.
org.joda.time.field.ZeroIsMaxDateTimeField.getMaximumValue	(	long	): Get the maximum value for the field, which is one more than the wrapped field's maximum value.
org.joda.time.field.ZeroIsMaxDateTimeField.getMinimumValue	(	): Always returns 1.
org.joda.time.field.ZeroIsMaxDateTimeField.getMinimumValue	(	ReadablePartial	): Always returns 1.
org.joda.time.field.ZeroIsMaxDateTimeField.getMinimumValue	(	ReadablePartial	int[]	): Always returns 1.
org.joda.time.field.ZeroIsMaxDateTimeField.getMinimumValue	(	long	): Always returns 1.
org.joda.time.format.DateTimeFormat: Factory that creates instances of DateTimeFormatter from patterns and styles.  Datetime formatting is performed by the DateTimeFormatter class. Three classes provide factory methods to create formatters, and this is one. The others are ISODateTimeFormat and DateTimeFormatterBuilder.  This class provides two types of factory:  forPattern() Pattern provides a DateTimeFormatter based on a pattern string that is mostly compatible with the JDK date patterns. forStyle() Style provides a DateTimeFormatter based on a two character style, representing short, medium, long and full.   For example, to use a pattern:  DateTime dt = new DateTime(); DateTimeFormatter fmt = DateTimeFormat.forPattern("MMMM, yyyy"); String str = fmt.print(dt);  The pattern syntax is mostly compatible with java.text.SimpleDateFormat - time zone names cannot be parsed and a few more symbols are supported. All ASCII letters are reserved as pattern letters, which are defined as follows:   Symbol Meaning Presentation Examples ------ ------- ------------ ------- G era text AD C century of era (>=0) number 20 Y year of era (>=0) year 1996 x weekyear year 1996 w week of weekyear number 27 e day of week number 2 E day of week text Tuesday; Tue y year year 1996 D day of year number 189 M month of year month July; Jul; 07 d day of month number 10 a halfday of day text PM K hour of halfday (0~11) number 0 h clockhour of halfday (1~12) number 12 H hour of day (0~23) number 0 k clockhour of day (1~24) number 24 m minute of hour number 30 s second of minute number 55 S fraction of second millis 978 z time zone text Pacific Standard Time; PST Z time zone offset/id zone -0800; -08:00; America/Los_Angeles ' escape for text delimiter '' single quote literal '   The count of pattern letters determine the format.  Text: If the number of pattern letters is 4 or more, the full form is used; otherwise a short or abbreviated form is used if available.  Number: The minimum number of digits. Shorter numbers are zero-padded to this amount. When parsing, any number of digits are accepted.  Year: Numeric presentation for year and weekyear fields are handled specially. For example, if the count of 'y' is 2, the year will be displayed as the zero-based year of the century, which is two digits.  Month: 3 or over, use text, otherwise use number.  Millis: The exact number of fractional digits. If more millisecond digits are available then specified the number will be truncated, if there are fewer than specified then the number will be zero-padded to the right. When parsing, only the exact number of digits are accepted.  Zone: 'Z' outputs offset without a colon, 'ZZ' outputs the offset with a colon, 'ZZZ' or more outputs the zone id.  Zone names: Time zone names ('z') cannot be parsed.  Any characters in the pattern that are not in the ranges of ['a'..'z'] and ['A'..'Z'] will be treated as quoted text. For instance, characters like ':', '.', ' ', '#' and '?' will appear in the resulting time text even they are not embraced within single quotes.  DateTimeFormat is thread-safe and immutable, and the formatters it returns are as well.
org.joda.time.format.DateTimeFormat.DateTimeFormat	(	): Constructor.
org.joda.time.format.DateTimeFormat.appendPatternTo	(	DateTimeFormatterBuilder	String	): Parses the given pattern and appends the rules to the given DateTimeFormatterBuilder.
org.joda.time.format.DateTimeFormat.createDateTimeFormatter	(	int	int	): Creates a formatter for the specified style.
org.joda.time.format.DateTimeFormat.createFormatterForPattern	(	String	): Select a format from a custom pattern.
org.joda.time.format.DateTimeFormat.createFormatterForStyle	(	String	): Select a format from a two character style pattern. The first character is the date style, and the second character is the time style. Specify a character of 'S' for short style, 'M' for medium, 'L' for long, and 'F' for full. A date or time may be omitted by specifying a style character '-'.
org.joda.time.format.DateTimeFormat.createFormatterForStyleIndex	(	int	int	): Gets the formatter for the specified style.
org.joda.time.format.DateTimeFormat.forPattern	(	String	): Factory to create a formatter from a pattern string. The pattern string is described above in the class level javadoc. It is very similar to SimpleDateFormat patterns.  The format may contain locale specific output, and this will change as you change the locale of the formatter. Call withLocale() to switch the locale. For example:  DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt); 
org.joda.time.format.DateTimeFormat.forStyle	(	String	): Factory to create a format from a two character style pattern.  The first character is the date style, and the second character is the time style. Specify a character of 'S' for short style, 'M' for medium, 'L' for long, and 'F' for full. A date or time may be omitted by specifying a style character '-'.  The returned formatter will dynamically adjust to the locale that the print/parse takes place in. Thus you just call withLocale() and the Short/Medium/Long/Full style for that locale will be output. For example:  DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt); 
org.joda.time.format.DateTimeFormat.fullDate	(	): Creates a format that outputs a full date format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.fullDateTime	(	): Creates a format that outputs a full datetime format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.fullTime	(	): Creates a format that outputs a full time format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.isNumericToken	(	String	): Returns true if token should be parsed as a numeric field.
org.joda.time.format.DateTimeFormat.longDate	(	): Creates a format that outputs a long date format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.longDateTime	(	): Creates a format that outputs a long datetime format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.longTime	(	): Creates a format that outputs a long time format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.mediumDate	(	): Creates a format that outputs a medium date format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.mediumDateTime	(	): Creates a format that outputs a medium datetime format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.mediumTime	(	): Creates a format that outputs a medium time format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.parsePatternTo	(	DateTimeFormatterBuilder	String	): Parses the given pattern and appends the rules to the given DateTimeFormatterBuilder.
org.joda.time.format.DateTimeFormat.parseToken	(	String	int[]	): Parses an individual token.
org.joda.time.format.DateTimeFormat.patternForStyle	(	String	Locale	): Returns the pattern used by a particular style and locale.  The first character is the date style, and the second character is the time style. Specify a character of 'S' for short style, 'M' for medium, 'L' for long, and 'F' for full. A date or time may be omitted by specifying a style character '-'.
org.joda.time.format.DateTimeFormat.selectStyle	(	char	): Gets the JDK style code from the Joda code.
org.joda.time.format.DateTimeFormat.shortDate	(	): Creates a format that outputs a short date format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.shortDateTime	(	): Creates a format that outputs a short datetime format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormat.shortTime	(	): Creates a format that outputs a short time format.  The format will change as you change the locale of the formatter. Call withLocale() to switch the locale.
org.joda.time.format.DateTimeFormatter: Controls the printing and parsing of a datetime to and from a string.  This class is the main API for printing and parsing used by most applications. Instances of this class are created via one of three factory classes:  DateTimeFormat - formats by pattern and style ISODateTimeFormat - ISO8601 formats DateTimeFormatterBuilder - complex formats created via method calls   An instance of this class holds a reference internally to one printer and one parser. It is possible that one of these may be null, in which case the formatter cannot print/parse. This can be checked via the isPrinter() and isParser() methods.  The underlying printer/parser can be altered to behave exactly as required by using one of the decorator modifiers:  withLocale() - returns a new formatter that uses the specified locale withZone() - returns a new formatter that uses the specified time zone withChronology() - returns a new formatter that uses the specified chronology withOffsetParsed() - returns a new formatter that returns the parsed time zone offset withPivotYear() - returns a new formatter with the specified pivot year withDefaultYear() - returns a new formatter with the specified default year  Each of these returns a new formatter (instances of this class are immutable).  The main methods of the class are the printXxx and parseXxx methods. These are used as follows:  // print using the defaults (default locale, chronology/zone of the datetime) String dateStr = formatter.print(dt); // print using the French locale String dateStr = formatter.withLocale(Locale.FRENCH).print(dt); // print using the UTC zone String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt); // parse using the Paris zone DateTime date = formatter.withZone(DateTimeZone.forID("Europe/Paris")).parseDateTime(str);   Parsing builds up the resultant instant by 'setting' the value of each parsed field from largest to smallest onto an initial instant, typically 1970-01-01T00:00Z. This design means that day-of-month is set before day-of-week. As such, if both the day-of-month and day-of-week are parsed, and the day-of-week is incorrect, then the day-of-week overrides the day-of-month. This has a side effect if the input is not consistent.
org.joda.time.format.DateTimeFormatter.DateTimeFormatter	(	DateTimePrinter	DateTimeParser	): Creates a new formatter, however you will normally use the factory or the builder.
org.joda.time.format.DateTimeFormatter.DateTimeFormatter	(	InternalPrinter	InternalParser	): Creates a new formatter, however you will normally use the factory or the builder.
org.joda.time.format.DateTimeFormatter.DateTimeFormatter	(	InternalPrinter	InternalParser	Locale	boolean	Chronology	DateTimeZone	Integer	int	): Constructor.
org.joda.time.format.DateTimeFormatter.getChronolgy	(	): Gets the chronology to use as an override.
org.joda.time.format.DateTimeFormatter.getChronology	(	): Gets the chronology to use as an override.
org.joda.time.format.DateTimeFormatter.getDefaultYear	(	): Gets the default year for parsing months and days.
org.joda.time.format.DateTimeFormatter.getLocale	(	): Gets the locale that will be used for printing and parsing.
org.joda.time.format.DateTimeFormatter.getParser	(	): Gets the internal parser object that performs the real parsing work.
org.joda.time.format.DateTimeFormatter.getPivotYear	(	): Gets the pivot year to use as an override.
org.joda.time.format.DateTimeFormatter.getPrinter	(	): Gets the internal printer object that performs the real printing work.
org.joda.time.format.DateTimeFormatter.getPrinter0	(	): Gets the internal printer object that performs the real printing work.
org.joda.time.format.DateTimeFormatter.getZone	(	): Gets the zone to use as an override.
org.joda.time.format.DateTimeFormatter.isOffsetParsed	(	): Checks whether the offset from the string is used as the zone of the parsed datetime.
org.joda.time.format.DateTimeFormatter.isParser	(	): Is this formatter capable of parsing.
org.joda.time.format.DateTimeFormatter.isPrinter	(	): Is this formatter capable of printing.
org.joda.time.format.DateTimeFormatter.parseDateTime	(	String	): Parses a date-time from the given text, returning a new DateTime.  The parse will use the zone and chronology specified on this formatter.  If the text contains a time zone string then that will be taken into account in adjusting the time of day as follows. If the withOffsetParsed() has been called, then the resulting DateTime will have a fixed offset based on the parsed time zone. Otherwise the resulting DateTime will have the zone of this formatter, but the parsed zone may have caused the time to be adjusted.
org.joda.time.format.DateTimeFormatter.parseInto	(	ReadWritableInstant	String	int	): Parses a datetime from the given text, at the given position, saving the result into the fields of the given ReadWritableInstant. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text and in this case those fields that were read will be set.  Only those fields present in the string will be changed in the specified instant. All other fields will remain unaltered. Thus if the string only contains a year and a month, then the day and time will be retained from the input instant. If this is not the behaviour you want, then reset the fields before calling this method, or use parseDateTime() or parseMutableDateTime().  If it fails, the return value is negative, but the instant may still be modified. To determine the position where the parse failed, apply the one's complement operator (~) on the return value.  This parse method ignores the getDefaultYear() default year and parses using the year from the supplied instant based on the chronology and time-zone of the supplied instant.  The parse will use the chronology of the instant.
org.joda.time.format.DateTimeFormatter.parseLocalDate	(	String	): Parses only the local date from the given text, returning a new LocalDate.  This will parse the text fully according to the formatter, using the UTC zone. Once parsed, only the local date will be used. This means that any parsed time, time-zone or offset field is completely ignored. It also means that the zone and offset-parsed settings are ignored.
org.joda.time.format.DateTimeFormatter.parseLocalDateTime	(	String	): Parses only the local date-time from the given text, returning a new LocalDateTime.  This will parse the text fully according to the formatter, using the UTC zone. Once parsed, only the local date-time will be used. This means that any parsed time-zone or offset field is completely ignored. It also means that the zone and offset-parsed settings are ignored.
org.joda.time.format.DateTimeFormatter.parseLocalTime	(	String	): Parses only the local time from the given text, returning a new LocalTime.  This will parse the text fully according to the formatter, using the UTC zone. Once parsed, only the local time will be used. This means that any parsed date, time-zone or offset field is completely ignored. It also means that the zone and offset-parsed settings are ignored.
org.joda.time.format.DateTimeFormatter.parseMillis	(	String	): Parses a datetime from the given text, returning the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.  The parse will use the ISO chronology, and the default time zone. If the text contains a time zone string then that will be taken into account.
org.joda.time.format.DateTimeFormatter.parseMutableDateTime	(	String	): Parses a date-time from the given text, returning a new MutableDateTime.  The parse will use the zone and chronology specified on this formatter.  If the text contains a time zone string then that will be taken into account in adjusting the time of day as follows. If the withOffsetParsed() has been called, then the resulting DateTime will have a fixed offset based on the parsed time zone. Otherwise the resulting DateTime will have the zone of this formatter, but the parsed zone may have caused the time to be adjusted.
org.joda.time.format.DateTimeFormatter.print	(	ReadableInstant	): Prints a ReadableInstant to a String.  This method will use the override zone and the override chronology if they are set. Otherwise it will use the chronology and zone of the instant.
org.joda.time.format.DateTimeFormatter.print	(	ReadablePartial	): Prints a ReadablePartial to a new String.  Neither the override chronology nor the override zone are used by this method.
org.joda.time.format.DateTimeFormatter.print	(	long	): Prints a millisecond instant to a String.  This method will use the override zone and the override chronology if they are set. Otherwise it will use the ISO chronology and default zone.
org.joda.time.format.DateTimeFormatter.printTo	(	Appendable	ReadableInstant	): Prints a ReadableInstant, using the chronology supplied by the instant.
org.joda.time.format.DateTimeFormatter.printTo	(	Appendable	ReadablePartial	): Prints a ReadablePartial.  Neither the override chronology nor the override zone are used by this method.
org.joda.time.format.DateTimeFormatter.printTo	(	Appendable	long	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using ISO chronology in the default DateTimeZone.
org.joda.time.format.DateTimeFormatter.printTo	(	StringBuffer	ReadableInstant	): Prints a ReadableInstant, using the chronology supplied by the instant.
org.joda.time.format.DateTimeFormatter.printTo	(	StringBuffer	ReadablePartial	): Prints a ReadablePartial.  Neither the override chronology nor the override zone are used by this method.
org.joda.time.format.DateTimeFormatter.printTo	(	StringBuffer	long	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using ISO chronology in the default DateTimeZone.
org.joda.time.format.DateTimeFormatter.printTo	(	StringBuilder	ReadableInstant	): Prints a ReadableInstant, using the chronology supplied by the instant.
org.joda.time.format.DateTimeFormatter.printTo	(	StringBuilder	ReadablePartial	): Prints a ReadablePartial.  Neither the override chronology nor the override zone are used by this method.
org.joda.time.format.DateTimeFormatter.printTo	(	StringBuilder	long	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using ISO chronology in the default DateTimeZone.
org.joda.time.format.DateTimeFormatter.printTo	(	Writer	ReadableInstant	): Prints a ReadableInstant, using the chronology supplied by the instant.
org.joda.time.format.DateTimeFormatter.printTo	(	Writer	ReadablePartial	): Prints a ReadablePartial.  Neither the override chronology nor the override zone are used by this method.
org.joda.time.format.DateTimeFormatter.printTo	(	Writer	long	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using ISO chronology in the default DateTimeZone.
org.joda.time.format.DateTimeFormatter.requireParser	(	): Checks whether parsing is supported.
org.joda.time.format.DateTimeFormatter.requirePrinter	(	): Checks whether printing is supported.
org.joda.time.format.DateTimeFormatter.selectChronology	(	Chronology	): Determines the correct chronology to use.
org.joda.time.format.DateTimeFormatter.withChronology	(	Chronology	): Returns a new formatter that will use the specified chronology in preference to that of the printed object, or ISO on a parse.  When printing, this chronology will be used in preference to the chronology from the datetime that would otherwise be used.  When parsing, this chronology will be set on the parsed datetime.  A null chronology means no-override. If both an override chronology and an override zone are set, the override zone will take precedence over the zone in the chronology.
org.joda.time.format.DateTimeFormatter.withDefaultYear	(	int	): Returns a new formatter that will use the specified default year.  The default year is used when parsing in the case where there is a month or a day but not a year. Specifically, it is used if there is a field parsed with a duration between the length of a month and the length of a day inclusive.  This value is typically used to move the year from 1970 to a leap year to enable February 29th to be parsed. Unless customised, the year 2000 is used.  This setting has no effect when printing.
org.joda.time.format.DateTimeFormatter.withLocale	(	Locale	): Returns a new formatter with a different locale that will be used for printing and parsing.  A DateTimeFormatter is immutable, so a new instance is returned, and the original is unaltered and still usable.
org.joda.time.format.DateTimeFormatter.withOffsetParsed	(	): Returns a new formatter that will create a datetime with a time zone equal to that of the offset of the parsed string.  After calling this method, a string '2004-06-09T10:20:30-08:00' will create a datetime with a zone of -08:00 (a fixed zone, with no daylight savings rules). If the parsed string represents a local time (no zone offset) the parsed datetime will be in the default zone.  Calling this method sets the override zone to null. Calling the override zone method sets this flag off.
org.joda.time.format.DateTimeFormatter.withPivotYear	(	Integer	): Returns a new formatter that will use the specified pivot year for two digit year parsing in preference to that stored in the parser.  This setting is useful for changing the pivot year of formats built using a pattern - forPattern().  When parsing, this pivot year is used. Null means no-override. There is no effect when printing.  The pivot year enables a two digit year to be converted to a four digit year. The pivot represents the year in the middle of the supported range of years. Thus the full range of years that will be built is (pivot - 50) .. (pivot + 49).  pivot supported range 00 is 20 is 40 is 60 is 80 is --------------------------------------------------------------- 1950 1900..1999 1900 1920 1940 1960 1980 1975 1925..2024 2000 2020 1940 1960 1980 2000 1950..2049 2000 2020 2040 1960 1980 2025 1975..2074 2000 2020 2040 2060 1980 2050 2000..2099 2000 2020 2040 2060 2080 
org.joda.time.format.DateTimeFormatter.withPivotYear	(	int	): Returns a new formatter that will use the specified pivot year for two digit year parsing in preference to that stored in the parser.  This setting is useful for changing the pivot year of formats built using a pattern - forPattern().  When parsing, this pivot year is used. There is no effect when printing.  The pivot year enables a two digit year to be converted to a four digit year. The pivot represents the year in the middle of the supported range of years. Thus the full range of years that will be built is (pivot - 50) .. (pivot + 49).  pivot supported range 00 is 20 is 40 is 60 is 80 is --------------------------------------------------------------- 1950 1900..1999 1900 1920 1940 1960 1980 1975 1925..2024 2000 2020 1940 1960 1980 2000 1950..2049 2000 2020 2040 1960 1980 2025 1975..2074 2000 2020 2040 2060 1980 2050 2000..2099 2000 2020 2040 2060 2080 
org.joda.time.format.DateTimeFormatter.withZone	(	DateTimeZone	): Returns a new formatter that will use the specified zone in preference to the zone of the printed object, or default zone on a parse.  When printing, this zone will be used in preference to the zone from the datetime that would otherwise be used.  When parsing, this zone will be set on the parsed datetime.  A null zone means of no-override. If both an override chronology and an override zone are set, the override zone will take precedence over the zone in the chronology.
org.joda.time.format.DateTimeFormatter.withZoneUTC	(	): Returns a new formatter that will use the UTC zone in preference to the zone of the printed object, or default zone on a parse.  When printing, UTC will be used in preference to the zone from the datetime that would otherwise be used.  When parsing, UTC will be set on the parsed datetime.  If both an override chronology and an override zone are set, the override zone will take precedence over the zone in the chronology.
org.joda.time.format.DateTimeFormatterBuilder: Factory that creates complex instances of DateTimeFormatter via method calls.  Datetime formatting is performed by the DateTimeFormatter class. Three classes provide factory methods to create formatters, and this is one. The others are DateTimeFormat and ISODateTimeFormat.  DateTimeFormatterBuilder is used for constructing formatters which are then used to print or parse. The formatters are built by appending specific fields or other formatters to an instance of this builder.  For example, a formatter that prints month and year, like "January 1970", can be constructed as follows:   DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder() .appendMonthOfYearText() .appendLiteral(' ') .appendYear(4, 4) .toFormatter();   DateTimeFormatterBuilder itself is mutable and not thread-safe, but the formatters that it builds are thread-safe and immutable.
org.joda.time.format.DateTimeFormatterBuilder.Composite.decompose	(	List	List	List	): Processes the element pairs, putting results into the given printer and parser lists.
org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder	(	): Creates a DateTimeFormatterBuilder.
org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.digitCount	(	CharSequence	int	int	): Returns actual amount of digits to parse, but no more than original 'amount' parameter.
org.joda.time.format.DateTimeFormatterBuilder.append	(	DateTimeFormatter	): Appends another formatter.  This extracts the underlying printer and parser and appends them The printer and parser interfaces are the low-level part of the formatting API. Normally, instances are extracted from another formatter. Note however that any formatter specific information, such as the locale, time-zone, chronology, offset parsing or pivot/default year, will not be extracted by this method.
org.joda.time.format.DateTimeFormatterBuilder.append	(	DateTimeParser	): Appends just a parser. With no matching printer, a printer cannot be built from this builder.  The parser interface is part of the low-level part of the formatting API. Normally, instances are extracted from another formatter. Note however that any formatter specific information, such as the locale, time-zone, chronology, offset parsing or pivot/default year, will not be extracted by this method.
org.joda.time.format.DateTimeFormatterBuilder.append	(	DateTimePrinter	): Appends just a printer. With no matching parser, a parser cannot be built from this DateTimeFormatterBuilder.  The printer interface is part of the low-level part of the formatting API. Normally, instances are extracted from another formatter. Note however that any formatter specific information, such as the locale, time-zone, chronology, offset parsing or pivot/default year, will not be extracted by this method.
org.joda.time.format.DateTimeFormatterBuilder.append	(	DateTimePrinter	DateTimeParser	): Appends a printer/parser pair.  The printer and parser interfaces are the low-level part of the formatting API. Normally, instances are extracted from another formatter. Note however that any formatter specific information, such as the locale, time-zone, chronology, offset parsing or pivot/default year, will not be extracted by this method.
org.joda.time.format.DateTimeFormatterBuilder.append	(	DateTimePrinter	DateTimeParser[]	): Appends a printer and a set of matching parsers. When parsing, the first parser in the list is selected for parsing. If it fails, the next is chosen, and so on. If none of these parsers succeeds, then the failed position of the parser that made the greatest progress is returned.  Only the printer is optional. In addition, it is illegal for any but the last of the parser array elements to be null. If the last element is null, this represents the empty parser. The presence of an empty parser indicates that the entire array of parse formats is optional.  The printer and parser interfaces are the low-level part of the formatting API. Normally, instances are extracted from another formatter. Note however that any formatter specific information, such as the locale, time-zone, chronology, offset parsing or pivot/default year, will not be extracted by this method.
org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra	(	int	int	): Instructs the printer to emit a numeric century of era field.
org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay	(	int	): Instructs the printer to emit a numeric clockhourOfDay field.
org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday	(	int	): Instructs the printer to emit a numeric clockhourOfHalfday field.
org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth	(	int	): Instructs the printer to emit a numeric dayOfMonth field.
org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek	(	int	): Instructs the printer to emit a numeric dayOfWeek field.
org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText	(	): Instructs the printer to emit a short locale-specific dayOfWeek text. The parser will accept a long or short dayOfWeek text, case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText	(	): Instructs the printer to emit a locale-specific dayOfWeek text. The parser will accept a long or short dayOfWeek text, case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear	(	int	): Instructs the printer to emit a numeric dayOfYear field.
org.joda.time.format.DateTimeFormatterBuilder.appendDecimal	(	DateTimeFieldType	int	int	): Instructs the printer to emit a field value as a decimal number, and the parser to expect an unsigned decimal number.
org.joda.time.format.DateTimeFormatterBuilder.appendEraText	(	): Instructs the printer to emit a locale-specific era text (BC/AD), and the parser to expect it. The parser is case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendFixedDecimal	(	DateTimeFieldType	int	): Instructs the printer to emit a field value as a fixed-width decimal number (smaller numbers will be left-padded with zeros), and the parser to expect an unsigned decimal number with the same fixed width.
org.joda.time.format.DateTimeFormatterBuilder.appendFixedSignedDecimal	(	DateTimeFieldType	int	): Instructs the printer to emit a field value as a fixed-width decimal number (smaller numbers will be left-padded with zeros), and the parser to expect an signed decimal number with the same fixed width.
org.joda.time.format.DateTimeFormatterBuilder.appendFraction	(	DateTimeFieldType	int	int	): Instructs the printer to emit a remainder of time as a decimal fraction, without decimal point. For example, if the field is specified as minuteOfHour and the time is 12:30:45, the value printed is 75. A decimal point is implied, so the fraction is 0.75, or three-quarters of a minute.
org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay	(	int	int	): Appends the print/parse of a fractional day.  This reliably handles the case where fractional digits are being handled beyond a visible decimal point. The digits parsed will always be treated as the most significant (numerically largest) digits. Thus '23' will be parsed as 0.23 days (converted to milliseconds). This method does not print or parse the decimal point itself.
org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour	(	int	int	): Appends the print/parse of a fractional hour.  This reliably handles the case where fractional digits are being handled beyond a visible decimal point. The digits parsed will always be treated as the most significant (numerically largest) digits. Thus '23' will be parsed as 0.23 hours (converted to milliseconds). This method does not print or parse the decimal point itself.
org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute	(	int	int	): Appends the print/parse of a fractional minute.  This reliably handles the case where fractional digits are being handled beyond a visible decimal point. The digits parsed will always be treated as the most significant (numerically largest) digits. Thus '23' will be parsed as 0.23 minutes (converted to milliseconds). This method does not print or parse the decimal point itself.
org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond	(	int	int	): Appends the print/parse of a fractional second.  This reliably handles the case where fractional digits are being handled beyond a visible decimal point. The digits parsed will always be treated as the most significant (numerically largest) digits. Thus '23' will be parsed as 230 milliseconds. Contrast this behaviour to appendMillisOfSecond. This method does not print or parse the decimal point itself.
org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText	(	): Instructs the printer to emit a locale-specific AM/PM text, and the parser to expect it. The parser is case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay	(	int	): Instructs the printer to emit a numeric hourOfDay field.
org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday	(	int	): Instructs the printer to emit a numeric hourOfHalfday field.
org.joda.time.format.DateTimeFormatterBuilder.appendLiteral	(	String	): Instructs the printer to emit specific text, and the parser to expect it. The parser is case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendLiteral	(	char	): Instructs the printer to emit a specific character, and the parser to expect it. The parser is case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay	(	int	): Instructs the printer to emit a numeric millisOfDay field.
org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond	(	int	): Instructs the printer to emit a numeric millisOfSecond field.  This method will append a field that prints a three digit value. During parsing the value that is parsed is assumed to be three digits. If less than three digits are present then they will be counted as the smallest parts of the millisecond. This is probably not what you want if you are using the field as a fraction. Instead, a fractional millisecond should be produced using appendFractionOfSecond.
org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay	(	int	): Instructs the printer to emit a numeric minuteOfDay field.
org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour	(	int	): Instructs the printer to emit a numeric minuteOfHour field.
org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear	(	int	): Instructs the printer to emit a numeric monthOfYear field.
org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText	(	): Instructs the printer to emit a locale-specific monthOfYear text. The parser will accept a long or short monthOfYear text, case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText	(	): Instructs the printer to emit a short locale-specific monthOfYear text. The parser will accept a long or short monthOfYear text, case-insensitive.
org.joda.time.format.DateTimeFormatterBuilder.appendOptional	(	DateTimeParser	): Appends just a parser element which is optional. With no matching printer, a printer cannot be built from this DateTimeFormatterBuilder.  The parser interface is part of the low-level part of the formatting API. Normally, instances are extracted from another formatter. Note however that any formatter specific information, such as the locale, time-zone, chronology, offset parsing or pivot/default year, will not be extracted by this method.
org.joda.time.format.DateTimeFormatterBuilder.appendPattern	(	String	): Calls upon DateTimeFormat to parse the pattern and append the results into this builder.
org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay	(	int	): Instructs the printer to emit a numeric secondOfDay field.
org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute	(	int	): Instructs the printer to emit a numeric secondOfMinute field.
org.joda.time.format.DateTimeFormatterBuilder.appendShortText	(	DateTimeFieldType	): Instructs the printer to emit a field value as short text, and the parser to expect text.
org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal	(	DateTimeFieldType	int	int	): Instructs the printer to emit a field value as a decimal number, and the parser to expect a signed decimal number.
org.joda.time.format.DateTimeFormatterBuilder.appendText	(	DateTimeFieldType	): Instructs the printer to emit a field value as text, and the parser to expect text.
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneId	(	): Instructs the printer to emit the identifier of the time zone. From version 2.0, this field can be parsed.
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName	(	): Instructs the printer to emit a locale-specific time zone name. Using this method prevents parsing, because time zone names are not unique. See appendTimeZoneName().
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName	(	Map	): Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing. Time zone names are not unique, thus the API forces you to supply the lookup. The names are searched in the order of the map, thus it is strongly recommended to use a LinkedHashMap or similar.
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset	(	String	String	boolean	int	int	): Instructs the printer to emit text and numbers to display time zone offset from UTC. A parser will use the parsed time zone offset to adjust the datetime.  If zero offset print text is supplied, then it will be printed when the zone is zero. If zero offset parse text is supplied, then either it or the offset will be parsed.
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset	(	String	boolean	int	int	): Instructs the printer to emit text and numbers to display time zone offset from UTC. A parser will use the parsed time zone offset to adjust the datetime.  If zero offset text is supplied, then it will be printed when the zone is zero. During parsing, either the zero offset text, or the offset will be parsed.
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName	(	): Instructs the printer to emit a short locale-specific time zone name. Using this method prevents parsing, because time zone names are not unique. See appendTimeZoneShortName().
org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName	(	Map	): Instructs the printer to emit a short locale-specific time zone name, providing a lookup for parsing. Time zone names are not unique, thus the API forces you to supply the lookup. The names are searched in the order of the map, thus it is strongly recommended to use a LinkedHashMap or similar.
org.joda.time.format.DateTimeFormatterBuilder.appendTwoDigitWeekyear	(	int	): Instructs the printer to emit a numeric weekyear field which always prints and parses two digits. A pivot year is used during parsing to determine the range of supported years as (pivot - 50) .. (pivot + 49).  pivot supported range 00 is 20 is 40 is 60 is 80 is --------------------------------------------------------------- 1950 1900..1999 1900 1920 1940 1960 1980 1975 1925..2024 2000 2020 1940 1960 1980 2000 1950..2049 2000 2020 2040 1960 1980 2025 1975..2074 2000 2020 2040 2060 1980 2050 2000..2099 2000 2020 2040 2060 2080 
org.joda.time.format.DateTimeFormatterBuilder.appendTwoDigitWeekyear	(	int	boolean	): Instructs the printer to emit a numeric weekyear field which always prints two digits. A pivot year is used during parsing to determine the range of supported years as (pivot - 50) .. (pivot + 49). If parse is instructed to be lenient and the digit count is not two, it is treated as an absolute weekyear. With lenient parsing, specifying a positive or negative sign before the weekyear also makes it absolute.
org.joda.time.format.DateTimeFormatterBuilder.appendTwoDigitYear	(	int	): Instructs the printer to emit a numeric year field which always prints and parses two digits. A pivot year is used during parsing to determine the range of supported years as (pivot - 50) .. (pivot + 49).  pivot supported range 00 is 20 is 40 is 60 is 80 is --------------------------------------------------------------- 1950 1900..1999 1900 1920 1940 1960 1980 1975 1925..2024 2000 2020 1940 1960 1980 2000 1950..2049 2000 2020 2040 1960 1980 2025 1975..2074 2000 2020 2040 2060 1980 2050 2000..2099 2000 2020 2040 2060 2080 
org.joda.time.format.DateTimeFormatterBuilder.appendTwoDigitYear	(	int	boolean	): Instructs the printer to emit a numeric year field which always prints two digits. A pivot year is used during parsing to determine the range of supported years as (pivot - 50) .. (pivot + 49). If parse is instructed to be lenient and the digit count is not two, it is treated as an absolute year. With lenient parsing, specifying a positive or negative sign before the year also makes it absolute.
org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear	(	int	): Instructs the printer to emit a numeric weekOfWeekyear field.
org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear	(	int	int	): Instructs the printer to emit a numeric weekyear field.
org.joda.time.format.DateTimeFormatterBuilder.appendYear	(	int	int	): Instructs the printer to emit a numeric year field.
org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury	(	int	int	): Instructs the printer to emit a numeric year of century field.
org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra	(	int	int	): Instructs the printer to emit a numeric yearOfEra field.
org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter	(	): Returns true if toFormatter can be called without throwing an UnsupportedOperationException.
org.joda.time.format.DateTimeFormatterBuilder.canBuildParser	(	): Returns true if toParser can be called without throwing an UnsupportedOperationException.
org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter	(	): Returns true if toPrinter can be called without throwing an UnsupportedOperationException.
org.joda.time.format.DateTimeFormatterBuilder.checkParser	(	DateTimeParser	): Checks if the parser is non null and a provider.
org.joda.time.format.DateTimeFormatterBuilder.checkPrinter	(	DateTimePrinter	): Checks if the printer is non null and a provider.
org.joda.time.format.DateTimeFormatterBuilder.clear	(	): Clears out all the appended elements, allowing this builder to be reused.
org.joda.time.format.DateTimeFormatterBuilder.toFormatter	(	): Constructs a DateTimeFormatter using all the appended elements.  This is the main method used by applications at the end of the build process to create a usable formatter.  Subsequent changes to this builder do not affect the returned formatter.  The returned formatter may not support both printing and parsing. The methods isPrinter() and isParser() will help you determine the state of the formatter.
org.joda.time.format.DateTimeFormatterBuilder.toParser	(	): Internal method to create a DateTimeParser instance using all the appended elements.  Most applications will not use this method. If you want a parser in an application, call toFormatter() and just use the parsing API.  Subsequent changes to this builder do not affect the returned parser.
org.joda.time.format.DateTimeFormatterBuilder.toPrinter	(	): Internal method to create a DateTimePrinter instance using all the appended elements.  Most applications will not use this method. If you want a printer in an application, call toFormatter() and just use the printing API.  Subsequent changes to this builder do not affect the returned printer.
org.joda.time.format.DateTimeParser: Internal interface for parsing textual representations of datetimes.  Application users will rarely use this class directly. Instead, you will use one of the factory classes to create a DateTimeFormatter.  The factory classes are: - DateTimeFormatterBuilder - DateTimeFormat - ISODateTimeFormat
org.joda.time.format.DateTimeParser.estimateParsedLength	(	): Returns the expected maximum number of characters consumed. The actual amount should rarely exceed this estimate.
org.joda.time.format.DateTimeParser.parseInto	(	DateTimeParserBucket	String	int	): Parse an element from the given text, saving any fields into the given DateTimeParserBucket. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text.  If it fails, the return value is negative. To determine the position where the parse failed, apply the one's complement operator (~) on the return value.
org.joda.time.format.DateTimeParserBucket: DateTimeParserBucket is an advanced class, intended mainly for parser implementations. It can also be used during normal parsing operations to capture more information about the parse.  This class allows fields to be saved in any order, but be physically set in a consistent order. This is useful for parsing against formats that allow field values to contradict each other.  Field values are applied in an order where the "larger" fields are set first, making their value less likely to stick. A field is larger than another when it's range duration is longer. If both ranges are the same, then the larger field has the longer duration. If it cannot be determined which field is larger, then the fields are set in the order they were saved.  For example, these fields were saved in this order: dayOfWeek, monthOfYear, dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.  DateTimeParserBucket is mutable and not thread-safe.
org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket	(	long	Chronology	Locale	): Constructs a bucket.
org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket	(	long	Chronology	Locale	Integer	): Constructs a bucket, with the option of specifying the pivot year for two-digit year parsing.
org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket	(	long	Chronology	Locale	Integer	int	): Constructs a bucket, with the option of specifying the pivot year for two-digit year parsing.
org.joda.time.format.DateTimeParserBucket.SavedField.compareTo	(	SavedField	): The field with the longer range duration is ordered first, where null is considered infinite. If the ranges match, then the field with the longer duration is ordered first.
org.joda.time.format.DateTimeParserBucket.computeMillis	(	): Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.
org.joda.time.format.DateTimeParserBucket.computeMillis	(	boolean	): Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.
org.joda.time.format.DateTimeParserBucket.computeMillis	(	boolean	CharSequence	): Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.
org.joda.time.format.DateTimeParserBucket.computeMillis	(	boolean	String	): Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.
org.joda.time.format.DateTimeParserBucket.getChronology	(	): Gets the chronology of the bucket, which will be a local (UTC) chronology.
org.joda.time.format.DateTimeParserBucket.getLocale	(	): Returns the locale to be used during parsing.
org.joda.time.format.DateTimeParserBucket.getOffset	(	): Returns the time zone offset in milliseconds used by computeMillis.
org.joda.time.format.DateTimeParserBucket.getOffsetInteger	(	): Returns the time zone offset in milliseconds used by computeMillis.
org.joda.time.format.DateTimeParserBucket.getPivotYear	(	): Returns the default year used when information is incomplete.  This is used for two-digit years and when the largest parsed field is months or days.  A null value for two-digit years means to use the value from DateTimeFormatterBuilder. A null value for month/day only parsing will cause the default of 2000 to be used.
org.joda.time.format.DateTimeParserBucket.getZone	(	): Returns the time zone used by computeMillis.
org.joda.time.format.DateTimeParserBucket.parseMillis	(	DateTimeParser	CharSequence	): Parses a datetime from the given text, returning the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.  This parses the text using the parser into this bucket. The bucket is reset before parsing begins, allowing the bucket to be re-used. The bucket must not be shared between threads.
org.joda.time.format.DateTimeParserBucket.reset	(	): Resets the state back to that when the object was constructed.  This resets the state of the bucket, allowing a single bucket to be re-used for many parses. The bucket must not be shared between threads.
org.joda.time.format.DateTimeParserBucket.restoreState	(	Object	): Restores the state of this bucket from a previously saved state. The state object passed into this method is not consumed, and it can be used later to restore to that state again.
org.joda.time.format.DateTimeParserBucket.saveField	(	DateTimeField	int	): Saves a datetime field value.
org.joda.time.format.DateTimeParserBucket.saveField	(	DateTimeFieldType	String	Locale	): Saves a datetime field text value.
org.joda.time.format.DateTimeParserBucket.saveField	(	DateTimeFieldType	int	): Saves a datetime field value.
org.joda.time.format.DateTimeParserBucket.saveState	(	): Saves the state of this bucket, returning it in an opaque object. Call restoreState to undo any changes that were made since the state was saved. Calls to saveState may be nested.
org.joda.time.format.DateTimeParserBucket.setOffset	(	Integer	): Set a time zone offset to be used when computeMillis is called.
org.joda.time.format.DateTimeParserBucket.setOffset	(	int	): Set a time zone offset to be used when computeMillis is called.
org.joda.time.format.DateTimeParserBucket.setPivotYear	(	Integer	): Sets the pivot year to use when parsing two digit years.  If the value is set to null, this will indicate that default behaviour should be used.
org.joda.time.format.DateTimeParserBucket.setZone	(	DateTimeZone	): Set a time zone to be used when computeMillis is called.
org.joda.time.format.DateTimeParserBucket.sort	(	SavedField[]	int	): Sorts elements [0,high). Calling java.util.Arrays isn't always the right choice since it always creates an internal copy of the array, even if it doesn't need to. If the array slice is small enough, an insertion sort is chosen instead, but it doesn't need a copy!  This method has a modified version of that insertion sort, except it doesn't create an unnecessary array copy. If high is over 10, then java.util.Arrays is called, which will perform a merge sort, which is faster than insertion sort on large lists.  The end result is much greater performance when computeMillis is called. Since the amount of saved fields is small, the insertion sort is a better choice. Additional performance is gained since there is no extra array allocation and copying. Also, the insertion sort here does not perform any casting operations. The version in java.util.Arrays performs casts within the insertion sort loop.
org.joda.time.format.DateTimeParserInternalParser: Adapter between old and new parser interface.
org.joda.time.format.DateTimePrinter: Internal interface for creating textual representations of datetimes.  Application users will rarely use this class directly. Instead, you will use one of the factory classes to create a DateTimeFormatter.  The factory classes are: - DateTimeFormatterBuilder - DateTimeFormat - ISODateTimeFormat
org.joda.time.format.DateTimePrinter.estimatePrintedLength	(	): Returns the expected maximum number of characters produced. The actual amount should rarely exceed this estimate.
org.joda.time.format.DateTimePrinter.printTo	(	StringBuffer	ReadablePartial	Locale	): Prints a ReadablePartial.
org.joda.time.format.DateTimePrinter.printTo	(	StringBuffer	long	Chronology	int	DateTimeZone	Locale	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using the given Chronology.
org.joda.time.format.DateTimePrinter.printTo	(	Writer	ReadablePartial	Locale	): Prints a ReadablePartial.
org.joda.time.format.DateTimePrinter.printTo	(	Writer	long	Chronology	int	DateTimeZone	Locale	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using the given Chronology.
org.joda.time.format.DateTimePrinterInternalPrinter: Adapter between old and new printer interface.
org.joda.time.format.FormatUtils: Utility methods used by formatters.  FormatUtils is thread-safe and immutable.
org.joda.time.format.FormatUtils.FormatUtils	(	): Restricted constructor.
org.joda.time.format.FormatUtils.appendPaddedInteger	(	Appendable	int	int	): Converts an integer to a string, prepended with a variable amount of '0' pad characters, and appends it to the given appendable. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendPaddedInteger	(	Appendable	long	int	): Converts an integer to a string, prepended with a variable amount of '0' pad characters, and appends it to the given buffer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendPaddedInteger	(	StringBuffer	int	int	): Converts an integer to a string, prepended with a variable amount of '0' pad characters, and appends it to the given buffer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendPaddedInteger	(	StringBuffer	long	int	): Converts an integer to a string, prepended with a variable amount of '0' pad characters, and appends it to the given buffer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendUnpaddedInteger	(	Appendable	int	): Converts an integer to a string, and appends it to the given appendable. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendUnpaddedInteger	(	Appendable	long	): Converts an integer to a string, and appends it to the given appendable. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendUnpaddedInteger	(	StringBuffer	int	): Converts an integer to a string, and appends it to the given buffer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.appendUnpaddedInteger	(	StringBuffer	long	): Converts an integer to a string, and appends it to the given buffer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.calculateDigitCount	(	long	): Calculates the number of decimal digits for the given value, including the sign.
org.joda.time.format.FormatUtils.writePaddedInteger	(	Writer	int	int	): Converts an integer to a string, prepended with a variable amount of '0' pad characters, and writes it to the given writer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.writePaddedInteger	(	Writer	long	int	): Converts an integer to a string, prepended with a variable amount of '0' pad characters, and writes it to the given writer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.writeUnpaddedInteger	(	Writer	int	): Converts an integer to a string, and writes it to the given writer. This method is optimized for converting small values to strings.
org.joda.time.format.FormatUtils.writeUnpaddedInteger	(	Writer	long	): Converts an integer to a string, and writes it to the given writer. This method is optimized for converting small values to strings.
org.joda.time.format.ISODateTimeFormat: Factory that creates instances of DateTimeFormatter based on the ISO8601 standard.  Date-time formatting is performed by the DateTimeFormatter class. Three classes provide factory methods to create formatters, and this is one. The others are DateTimeFormat and DateTimeFormatterBuilder.  ISO8601 is the international standard for data interchange. It defines a framework, rather than an absolute standard. As a result this provider has a number of methods that represent common uses of the framework. The most common formats are date(), time(), and dateTime().  For example, to format a date time in ISO format:  DateTime dt = new DateTime(); DateTimeFormatter fmt = ISODateTimeFormat.dateTime(); String str = fmt.print(dt);   Note that these formatters mostly follow the ISO8601 standard for printing. For parsing, the formatters are more lenient and allow formats that are not in strict compliance with the standard.  It is important to understand that these formatters are not linked to the ISOChronology. These formatters may be used with any chronology, however there may be certain side effects with more unusual chronologies. For example, the ISO formatters rely on dayOfWeek being single digit, dayOfMonth being two digit and dayOfYear being three digit. A chronology with a ten day week would thus cause issues. However, in general, it is safe to use these formatters with other chronologies.  ISODateTimeFormat is thread-safe and immutable, and the formatters it returns are as well.
org.joda.time.format.ISODateTimeFormat.ISODateTimeFormat	(	): Constructor.
org.joda.time.format.ISODateTimeFormat.appendSeparator	(	DateTimeFormatterBuilder	boolean	): Appends the separator if necessary.
org.joda.time.format.ISODateTimeFormat.basicDate	(	): Returns a basic formatter for a full date as four digit year, two digit month of year, and two digit day of month (yyyyMMdd).  The returned formatter prints and parses only this format.
org.joda.time.format.ISODateTimeFormat.basicDateTime	(	): Returns a basic formatter that combines a basic date and time, separated by a 'T' (yyyyMMdd'T'HHmmss.SSSZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicDateTimeNoMillis	(	): Returns a basic formatter that combines a basic date and time without millis, separated by a 'T' (yyyyMMdd'T'HHmmssZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicOrdinalDate	(	): Returns a formatter for a full ordinal date, using a four digit year and three digit dayOfYear (yyyyDDD).  The returned formatter prints and parses only this format.
org.joda.time.format.ISODateTimeFormat.basicOrdinalDateTime	(	): Returns a formatter for a full ordinal date and time, using a four digit year and three digit dayOfYear (yyyyDDD'T'HHmmss.SSSZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicOrdinalDateTimeNoMillis	(	): Returns a formatter for a full ordinal date and time without millis, using a four digit year and three digit dayOfYear (yyyyDDD'T'HHmmssZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicTTime	(	): Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset prefixed by 'T' ('T'HHmmss.SSSZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicTTimeNoMillis	(	): Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by 'T' ('T'HHmmssZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicTime	(	): Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicTimeNoMillis	(	): Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset (HHmmssZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicWeekDate	(	): Returns a basic formatter for a full date as four digit weekyear, two digit week of weekyear, and one digit day of week (xxxx'W'wwe).  The returned formatter prints and parses only this format.
org.joda.time.format.ISODateTimeFormat.basicWeekDateTime	(	): Returns a basic formatter that combines a basic weekyear date and time, separated by a 'T' (xxxx'W'wwe'T'HHmmss.SSSZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds.
org.joda.time.format.ISODateTimeFormat.basicWeekDateTimeNoMillis	(	): Returns a basic formatter that combines a basic weekyear date and time without millis, separated by a 'T' (xxxx'W'wwe'T'HHmmssZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds.
org.joda.time.format.ISODateTimeFormat.checkNotStrictISO	(	Collection	boolean	): Checks that the iso only flag is not set, throwing an exception if it is.
org.joda.time.format.ISODateTimeFormat.date	(	): Returns a formatter for a full date as four digit year, two digit month of year, and two digit day of month (yyyy-MM-dd).  The returned formatter prints and parses only this format. See dateParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.dateByMonth	(	DateTimeFormatterBuilder	Collection	boolean	boolean	): Creates a date using the calendar date format. Specification reference: 5.2.1.
org.joda.time.format.ISODateTimeFormat.dateByOrdinal	(	DateTimeFormatterBuilder	Collection	boolean	boolean	): Creates a date using the ordinal date format. Specification reference: 5.2.2.
org.joda.time.format.ISODateTimeFormat.dateByWeek	(	DateTimeFormatterBuilder	Collection	boolean	boolean	): Creates a date using the calendar date format. Specification reference: 5.2.3.
org.joda.time.format.ISODateTimeFormat.dateElementParser	(	): Returns a generic ISO date parser for parsing dates.  The returned formatter can only be used for parsing, printing is unsupported.  It accepts formats described by the following syntax:  date-element = std-date-element | ord-date-element | week-date-element std-date-element = yyyy ['-' MM ['-' dd]] ord-date-element = yyyy ['-' DDD] week-date-element = xxxx '-W' ww ['-' e] 
org.joda.time.format.ISODateTimeFormat.dateHour	(	): Returns a formatter that combines a full date and two digit hour of day. (yyyy-MM-dd'T'HH)
org.joda.time.format.ISODateTimeFormat.dateHourMinute	(	): Returns a formatter that combines a full date, two digit hour of day, and two digit minute of hour. (yyyy-MM-dd'T'HH:mm)
org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond	(	): Returns a formatter that combines a full date, two digit hour of day, two digit minute of hour, and two digit second of minute. (yyyy-MM-dd'T'HH:mm:ss)
org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction	(	): Returns a formatter that combines a full date, two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (yyyy-MM-dd'T'HH:mm:ss.SSS). Parsing will parse up to 9 fractional second digits, throwing away all except the first three.
org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondMillis	(	): Returns a formatter that combines a full date, two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (yyyy-MM-dd'T'HH:mm:ss.SSS). Parsing will parse up to 3 fractional second digits.
org.joda.time.format.ISODateTimeFormat.dateOptionalTimeParser	(	): Returns a generic ISO datetime parser where the date is mandatory and the time is optional.  The returned formatter can only be used for parsing, printing is unsupported.  This parser can parse zoned datetimes. The parser is strict by default, thus time string 24:00 cannot be parsed.  It accepts formats described by the following syntax:  date-opt-time = date-element ['T' [time-element] [offset]] date-element = std-date-element | ord-date-element | week-date-element std-date-element = yyyy ['-' MM ['-' dd]] ord-date-element = yyyy ['-' DDD] week-date-element = xxxx '-W' ww ['-' e] time-element = HH [minute-element] | [fraction] minute-element = ':' mm [second-element] | [fraction] second-element = ':' ss [fraction] fraction = ('.' | ',') digit+ 
org.joda.time.format.ISODateTimeFormat.dateParser	(	): Returns a generic ISO date parser for parsing dates with a possible zone.  The returned formatter can only be used for parsing, printing is unsupported.  It accepts formats described by the following syntax:  date = date-element ['T' offset] date-element = std-date-element | ord-date-element | week-date-element std-date-element = yyyy ['-' MM ['-' dd]] ord-date-element = yyyy ['-' DDD] week-date-element = xxxx '-W' ww ['-' e] offset = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]]) 
org.joda.time.format.ISODateTimeFormat.dateTime	(	): Returns a formatter that combines a full date and time, separated by a 'T' (yyyy-MM-dd'T'HH:mm:ss.SSSZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds. See dateTimeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.dateTimeNoMillis	(	): Returns a formatter that combines a full date and time without millis, separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds. See dateTimeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.dateTimeParser	(	): Returns a generic ISO datetime parser which parses either a date or a time or both.  The returned formatter can only be used for parsing, printing is unsupported.  The parser is strict by default, thus time string 24:00 cannot be parsed.  It accepts formats described by the following syntax:  datetime = time | date-opt-time time = 'T' time-element [offset] date-opt-time = date-element ['T' [time-element] [offset]] date-element = std-date-element | ord-date-element | week-date-element std-date-element = yyyy ['-' MM ['-' dd]] ord-date-element = yyyy ['-' DDD] week-date-element = xxxx '-W' ww ['-' e] time-element = HH [minute-element] | [fraction] minute-element = ':' mm [second-element] | [fraction] second-element = ':' ss [fraction] fraction = ('.' | ',') digit+ offset = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]]) 
org.joda.time.format.ISODateTimeFormat.forFields	(	Collection	boolean	boolean	): Returns a formatter that outputs only those fields specified.  This method examines the fields provided and returns an ISO-style formatter that best fits. This can be useful for outputting less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).  The list provided may have overlapping fields, such as dayOfWeek and dayOfMonth. In this case, the style is chosen based on the following list, thus in the example, the calendar style is chosen as dayOfMonth is higher in priority than dayOfWeek:  monthOfYear - calendar date style dayOfYear - ordinal date style weekOfWeekYear - week date style dayOfMonth - calendar date style dayOfWeek - week date style year weekyear  The supported formats are:  Extended Basic Fields 2005-03-25 20050325 year/monthOfYear/dayOfMonth 2005-03 2005-03 year/monthOfYear 2005--25 2005--25 year/dayOfMonth 2005 2005 year --03-25 --0325 monthOfYear/dayOfMonth --03 --03 monthOfYear ---03 ---03 dayOfMonth 2005-084 2005084 year/dayOfYear -084 -084 dayOfYear 2005-W12-5 2005W125 weekyear/weekOfWeekyear/dayOfWeek 2005-W-5 2005W-5 weekyear/dayOfWeek 2005-W12 2005W12 weekyear/weekOfWeekyear -W12-5 -W125 weekOfWeekyear/dayOfWeek -W12 -W12 weekOfWeekyear -W-5 -W-5 dayOfWeek 10:20:30.040 102030.040 hour/minute/second/milli 10:20:30 102030 hour/minute/second 10:20 1020 hour/minute 10 10 hour -20:30.040 -2030.040 minute/second/milli -20:30 -2030 minute/second -20 -20 minute --30.040 --30.040 second/milli --30 --30 second ---.040 ---.040 milli 10-30.040 10-30.040 hour/second/milli 10:20-.040 1020-.040 hour/minute/milli 10-30 10-30 hour/second 10--.040 10--.040 hour/milli -20-.040 -20-.040 minute/milli plus datetime formats like {date}T{time}  * indicates that this is not an official ISO format and can be excluded by passing in strictISO as true.  This method can side effect the input collection of fields. If the input collection is modifiable, then each field that was added to the formatter will be removed from the collection, including any duplicates. If the input collection is unmodifiable then no side effect occurs.  This side effect processing is useful if you need to know whether all the fields were converted into the formatter or not. To achieve this, pass in a modifiable list, and check that it is empty on exit.
org.joda.time.format.ISODateTimeFormat.hour	(	): Returns a formatter for a two digit hour of day. (HH)
org.joda.time.format.ISODateTimeFormat.hourMinute	(	): Returns a formatter for a two digit hour of day and two digit minute of hour. (HH:mm)
org.joda.time.format.ISODateTimeFormat.hourMinuteSecond	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, and two digit second of minute. (HH:mm:ss)
org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS). Parsing will parse up to 9 fractional second digits, throwing away all except the first three.
org.joda.time.format.ISODateTimeFormat.hourMinuteSecondMillis	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS). Parsing will parse up to 3 fractional second digits.
org.joda.time.format.ISODateTimeFormat.localDateOptionalTimeParser	(	): Returns a generic ISO datetime parser where the date is mandatory and the time is optional.  The returned formatter can only be used for parsing, printing is unsupported.  This parser only parses local datetimes. This parser is initialised with the local (UTC) time zone. The parser is strict by default, thus time string 24:00 cannot be parsed.  It accepts formats described by the following syntax:  datetime = date-element ['T' time-element] date-element = std-date-element | ord-date-element | week-date-element std-date-element = yyyy ['-' MM ['-' dd]] ord-date-element = yyyy ['-' DDD] week-date-element = xxxx '-W' ww ['-' e] time-element = HH [minute-element] | [fraction] minute-element = ':' mm [second-element] | [fraction] second-element = ':' ss [fraction] fraction = ('.' | ',') digit+ 
org.joda.time.format.ISODateTimeFormat.localDateParser	(	): Returns a generic ISO date parser for parsing local dates.  The returned formatter can only be used for parsing, printing is unsupported.  This parser is initialised with the local (UTC) time zone.  It accepts formats described by the following syntax:  date-element = std-date-element | ord-date-element | week-date-element std-date-element = yyyy ['-' MM ['-' dd]] ord-date-element = yyyy ['-' DDD] week-date-element = xxxx '-W' ww ['-' e] 
org.joda.time.format.ISODateTimeFormat.localTimeParser	(	): Returns a generic ISO time parser for parsing local times.  The returned formatter can only be used for parsing, printing is unsupported.  This parser is initialised with the local (UTC) time zone. The parser is strict by default, thus time string 24:00 cannot be parsed.  It accepts formats described by the following syntax:  time = ['T'] time-element time-element = HH [minute-element] | [fraction] minute-element = ':' mm [second-element] | [fraction] second-element = ':' ss [fraction] fraction = ('.' | ',') digit+ 
org.joda.time.format.ISODateTimeFormat.ordinalDate	(	): Returns a formatter for a full ordinal date, using a four digit year and three digit dayOfYear (yyyy-DDD).  The returned formatter prints and parses only this format. See dateParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.ordinalDateTime	(	): Returns a formatter for a full ordinal date and time, using a four digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ss.SSSZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds. See dateTimeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.ordinalDateTimeNoMillis	(	): Returns a formatter for a full ordinal date and time without millis, using a four digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ssZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds. See dateTimeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.tTime	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset prefixed by 'T' ('T'HH:mm:ss.SSSZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds. See timeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.tTimeNoMillis	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by 'T' ('T'HH:mm:ssZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds. See timeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.time	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset (HH:mm:ss.SSSZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds. See timeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.time	(	DateTimeFormatterBuilder	Collection	boolean	boolean	boolean	boolean	): Adds the time fields to the builder. Specification reference: 5.3.1.
org.joda.time.format.ISODateTimeFormat.timeElementParser	(	): Returns a generic ISO time parser.  The returned formatter can only be used for parsing, printing is unsupported.  The parser is strict by default, thus time string 24:00 cannot be parsed.  It accepts formats described by the following syntax:  time-element = HH [minute-element] | [fraction] minute-element = ':' mm [second-element] | [fraction] second-element = ':' ss [fraction] fraction = ('.' | ',') digit+ 
org.joda.time.format.ISODateTimeFormat.timeNoMillis	(	): Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset (HH:mm:ssZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds. See timeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.timeParser	(	): Returns a generic ISO time parser for parsing times with a possible zone.  The returned formatter can only be used for parsing, printing is unsupported.  The parser is strict by default, thus time string 24:00 cannot be parsed.  It accepts formats described by the following syntax:  time = ['T'] time-element [offset] time-element = HH [minute-element] | [fraction] minute-element = ':' mm [second-element] | [fraction] second-element = ':' ss [fraction] fraction = ('.' | ',') digit+ offset = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]]) 
org.joda.time.format.ISODateTimeFormat.weekDate	(	): Returns a formatter for a full date as four digit weekyear, two digit week of weekyear, and one digit day of week (xxxx-'W'ww-e).  The returned formatter prints and parses only this format. See dateParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.weekDateTime	(	): Returns a formatter that combines a full weekyear date and time, separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which includes milliseconds. See dateTimeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.weekDateTimeNoMillis	(	): Returns a formatter that combines a full weekyear date and time without millis, separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ssZZ).  The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero. The parser is strict by default, thus time string 24:00 cannot be parsed.  The returned formatter prints and parses only this format, which excludes milliseconds. See dateTimeParser() for a more flexible parser that accepts different formats.
org.joda.time.format.ISODateTimeFormat.weekyear	(	): Returns a formatter for a four digit weekyear. (xxxx)
org.joda.time.format.ISODateTimeFormat.weekyearWeek	(	): Returns a formatter for a four digit weekyear and two digit week of weekyear. (xxxx-'W'ww)
org.joda.time.format.ISODateTimeFormat.weekyearWeekDay	(	): Returns a formatter for a four digit weekyear, two digit week of weekyear, and one digit day of week. (xxxx-'W'ww-e)
org.joda.time.format.ISODateTimeFormat.year	(	): Returns a formatter for a four digit year. (yyyy)
org.joda.time.format.ISODateTimeFormat.yearMonth	(	): Returns a formatter for a four digit year and two digit month of year. (yyyy-MM)
org.joda.time.format.ISODateTimeFormat.yearMonthDay	(	): Returns a formatter for a four digit year, two digit month of year, and two digit day of month. (yyyy-MM-dd)
org.joda.time.format.ISOPeriodFormat: Factory that creates instances of PeriodFormatter for the ISO8601 standard.  Period formatting is performed by the PeriodFormatter class. Three classes provide factory methods to create formatters, and this is one. The others are PeriodFormat and PeriodFormatterBuilder.  ISOPeriodFormat is thread-safe and immutable, and the formatters it returns are as well.
org.joda.time.format.ISOPeriodFormat.ISOPeriodFormat	(	): Constructor.
org.joda.time.format.ISOPeriodFormat.alternate	(	): The alternate ISO format, PyyyymmddThhmmss, which excludes weeks.  Even if weeks are present in the period, they are not output. Fractional seconds (milliseconds) will appear if required.
org.joda.time.format.ISOPeriodFormat.alternateExtended	(	): The alternate ISO format, Pyyyy-mm-ddThh:mm:ss, which excludes weeks.  Even if weeks are present in the period, they are not output. Fractional seconds (milliseconds) will appear if required.
org.joda.time.format.ISOPeriodFormat.alternateExtendedWithWeeks	(	): The alternate ISO format, Pyyyy-Www-ddThh:mm:ss, which excludes months.  Even if months are present in the period, they are not output. Fractional seconds (milliseconds) will appear if required.
org.joda.time.format.ISOPeriodFormat.alternateWithWeeks	(	): The alternate ISO format, PyyyyWwwddThhmmss, which excludes months.  Even if months are present in the period, they are not output. Fractional seconds (milliseconds) will appear if required.
org.joda.time.format.ISOPeriodFormat.standard	(	): The standard ISO format - PyYmMwWdDThHmMsS. Milliseconds are not output. Note that the ISO8601 standard actually indicates weeks should not be shown if any other field is present and vice versa.
org.joda.time.format.InternalParser: Internal interface for parsing textual representations of datetimes.  This has been separated from DateTimeParser to change to using CharSequence.
org.joda.time.format.InternalParser.estimateParsedLength	(	): Returns the expected maximum number of characters consumed. The actual amount should rarely exceed this estimate.
org.joda.time.format.InternalParser.parseInto	(	DateTimeParserBucket	CharSequence	int	): Parse an element from the given text, saving any fields into the given DateTimeParserBucket. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text.  If it fails, the return value is negative. To determine the position where the parse failed, apply the one's complement operator (~) on the return value.
org.joda.time.format.InternalParserDateTimeParser: Adapter between old and new printer interface.
org.joda.time.format.InternalPrinter: Internal interface for creating textual representations of datetimes.  This has been separated from DateTimePrinter to avoid code duplication.
org.joda.time.format.InternalPrinter.estimatePrintedLength	(	): Returns the expected maximum number of characters produced. The actual amount should rarely exceed this estimate.
org.joda.time.format.InternalPrinter.printTo	(	Appendable	ReadablePartial	Locale	): Prints a ReadablePartial.
org.joda.time.format.InternalPrinter.printTo	(	Appendable	long	Chronology	int	DateTimeZone	Locale	): Prints an instant from milliseconds since 1970-01-01T00:00:00Z, using the given Chronology.
org.joda.time.format.InternalPrinterDateTimePrinter: Adapter between old and new printer interface.
org.joda.time.format.PeriodFormat: Factory that creates instances of PeriodFormatter.  Period formatting is performed by the PeriodFormatter class. Three classes provide factory methods to create formatters, and this is one. The others are ISOPeriodFormat and PeriodFormatterBuilder.  PeriodFormat is thread-safe and immutable, and the formatters it returns are as well.
org.joda.time.format.PeriodFormat.DynamicWordBased: Printer/parser that reacts to the locale and changes the word-based pattern if necessary.
org.joda.time.format.PeriodFormat.PeriodFormat	(	): Constructor.
org.joda.time.format.PeriodFormat.getDefault	(	): Gets the default formatter that outputs words in English.  This calls wordBased() using a locale of ENGLISH.
org.joda.time.format.PeriodFormat.wordBased	(	): Returns a word based formatter for the JDK default locale.  This calls wordBased() using the getDefault() default locale.
org.joda.time.format.PeriodFormat.wordBased	(	Locale	): Returns a word based formatter for the specified locale.  The words are configured in a resource bundle text file - org.joda.time.format.messages. This can be added to via the normal classpath resource bundle mechanisms.  You can add your own translation by creating messages_.properties file and adding it to the org.joda.time.format.messages path.  Simple example (1 -> singular suffix, not 1 -> plural suffix):  PeriodFormat.space=\ PeriodFormat.comma=, PeriodFormat.commandand=,and PeriodFormat.commaspaceand=, and PeriodFormat.commaspace=, PeriodFormat.spaceandspace=\ and PeriodFormat.year=\ year PeriodFormat.years=\ years PeriodFormat.month=\ month PeriodFormat.months=\ months PeriodFormat.week=\ week PeriodFormat.weeks=\ weeks PeriodFormat.day=\ day PeriodFormat.days=\ days PeriodFormat.hour=\ hour PeriodFormat.hours=\ hours PeriodFormat.minute=\ minute PeriodFormat.minutes=\ minutes PeriodFormat.second=\ second PeriodFormat.seconds=\ seconds PeriodFormat.millisecond=\ millisecond PeriodFormat.milliseconds=\ milliseconds   Some languages contain more than two suffixes. You can use regular expressions for them. Here's an example using regular expression for English:  PeriodFormat.space=\ PeriodFormat.comma=, PeriodFormat.commandand=,and PeriodFormat.commaspaceand=, and PeriodFormat.commaspace=, PeriodFormat.spaceandspace=\ and PeriodFormat.regex.separator=% PeriodFormat.years.regex=1$%. PeriodFormat.years.list=\ year%\ years PeriodFormat.months.regex=1$%. PeriodFormat.months.list=\ month%\ months PeriodFormat.weeks.regex=1$%. PeriodFormat.weeks.list=\ week%\ weeks PeriodFormat.days.regex=1$%. PeriodFormat.days.list=\ day%\ days PeriodFormat.hours.regex=1$%. PeriodFormat.hours.list=\ hour%\ hours PeriodFormat.minutes.regex=1$%. PeriodFormat.minutes.list=\ minute%\ minutes PeriodFormat.seconds.regex=1$%. PeriodFormat.seconds.list=\ second%\ seconds PeriodFormat.milliseconds.regex=1$%. PeriodFormat.milliseconds.list=\ millisecond%\ milliseconds   You can mix both approaches. Here's example for Polish ( "1 year, 2 years, 5 years, 12 years, 15 years, 21 years, 22 years, 25 years" translates to "1 rok, 2 lata, 5 lat, 12 lat, 15 lat, 21 lat, 22 lata, 25 lat"). Notice that PeriodFormat.day and PeriodFormat.days is used for day suffixes as there is no need for regular expressions:  PeriodFormat.space=\ PeriodFormat.comma=, PeriodFormat.commandand=,i PeriodFormat.commaspaceand=, i PeriodFormat.commaspace=, PeriodFormat.spaceandspace=\ i PeriodFormat.regex.separator=% PeriodFormat.years.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.years.list=\ rok%\ lata%\ lat PeriodFormat.months.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.months.list=\ miesi\u0105c%\ miesi\u0105ce%\ miesi\u0119cy PeriodFormat.weeks.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.weeks.list=\ tydzie\u0144%\ tygodnie%\ tygodni PeriodFormat.day=\ dzie\u0144 PeriodFormat.days=\ dni PeriodFormat.hours.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.hours.list=\ godzina%\ godziny%\ godzin PeriodFormat.minutes.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.minutes.list=\ minuta%\ minuty%\ minut PeriodFormat.seconds.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.seconds.list=\ sekunda%\ sekundy%\ sekund PeriodFormat.milliseconds.regex=^1$%[0-9]*(?<!1)[2-4]$%[0-9] PeriodFormat.milliseconds.list=\ milisekunda%\ milisekundy%\ milisekund   Each PeriodFormat.<duration_field_type>.regex property stands for an array of regular expressions and is followed by a property PeriodFormat.<duration_field_type>.list holding an array of suffixes. PeriodFormat.regex.separator is used for splitting. See appendSuffix() for details.  Available languages are English, Danish, Dutch, French, German, Japanese, Polish, Portuguese and Spanish.
org.joda.time.format.PeriodFormatter: Controls the printing and parsing of a time period to and from a string.  This class is the main API for printing and parsing used by most applications. Instances of this class are created via one of three factory classes:  PeriodFormat - formats by pattern and style ISOPeriodFormat - ISO8601 formats PeriodFormatterBuilder - complex formats created via method calls   An instance of this class holds a reference internally to one printer and one parser. It is possible that one of these may be null, in which case the formatter cannot print/parse. This can be checked via the isPrinter() and isParser() methods.  The underlying printer/parser can be altered to behave exactly as required by using a decorator modifier:  withLocale() - returns a new formatter that uses the specified locale  This returns a new formatter (instances of this class are immutable).  The main methods of the class are the printXxx and parseXxx methods. These are used as follows:  // print using the default locale String periodStr = formatter.print(period); // print using the French locale String periodStr = formatter.withLocale(Locale.FRENCH).print(period); // parse using the French locale Period date = formatter.withLocale(Locale.FRENCH).parsePeriod(str); 
org.joda.time.format.PeriodFormatter.PeriodFormatter	(	PeriodPrinter	PeriodParser	): Creates a new formatter, however you will normally use the factory or the builder.
org.joda.time.format.PeriodFormatter.PeriodFormatter	(	PeriodPrinter	PeriodParser	Locale	PeriodType	): Constructor.
org.joda.time.format.PeriodFormatter.checkParser	(	): Checks whether parsing is supported.
org.joda.time.format.PeriodFormatter.checkPeriod	(	ReadablePeriod	): Checks whether the period is non-null.
org.joda.time.format.PeriodFormatter.checkPrinter	(	): Checks whether printing is supported.
org.joda.time.format.PeriodFormatter.getLocale	(	): Gets the locale that will be used for printing and parsing.  A null locale indicates that no specific locale override is in use.
org.joda.time.format.PeriodFormatter.getParseType	(	): Gets the PeriodType that will be used for parsing.
org.joda.time.format.PeriodFormatter.getParser	(	): Gets the internal parser object that performs the real parsing work.
org.joda.time.format.PeriodFormatter.getPrinter	(	): Gets the internal printer object that performs the real printing work.
org.joda.time.format.PeriodFormatter.isParser	(	): Is this formatter capable of parsing.
org.joda.time.format.PeriodFormatter.isPrinter	(	): Is this formatter capable of printing.
org.joda.time.format.PeriodFormatter.parseInto	(	ReadWritablePeriod	String	int	): Parses a period from the given text, at the given position, saving the result into the fields of the given ReadWritablePeriod. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text.  The parse type of the formatter is not used by this method.  If it fails, the return value is negative, but the period may still be modified. To determine the position where the parse failed, apply the one's complement operator (~) on the return value.
org.joda.time.format.PeriodFormatter.parseMutablePeriod	(	String	): Parses a period from the given text, returning a new MutablePeriod.
org.joda.time.format.PeriodFormatter.parsePeriod	(	String	): Parses a period from the given text, returning a new Period.
org.joda.time.format.PeriodFormatter.print	(	ReadablePeriod	): Prints a ReadablePeriod to a new String.
org.joda.time.format.PeriodFormatter.printTo	(	StringBuffer	ReadablePeriod	): Prints a ReadablePeriod to a StringBuffer.
org.joda.time.format.PeriodFormatter.printTo	(	Writer	ReadablePeriod	): Prints a ReadablePeriod to a Writer.
org.joda.time.format.PeriodFormatter.withLocale	(	Locale	): Returns a new formatter with a different locale that will be used for printing and parsing.  A PeriodFormatter is immutable, so a new instance is returned, and the original is unaltered and still usable.  A null locale indicates that no specific locale override is in use.
org.joda.time.format.PeriodFormatter.withParseType	(	PeriodType	): Returns a new formatter with a different PeriodType for parsing.  A PeriodFormatter is immutable, so a new instance is returned, and the original is unaltered and still usable.
org.joda.time.format.PeriodFormatterBuilder: Factory that creates complex instances of PeriodFormatter via method calls.  Period formatting is performed by the PeriodFormatter class. Three classes provide factory methods to create formatters, and this is one. The others are PeriodFormat and ISOPeriodFormat.  PeriodFormatterBuilder is used for constructing formatters which are then used to print or parse. The formatters are built by appending specific fields or other formatters to an instance of this builder.  For example, a formatter that prints years and months, like "15 years and 8 months", can be constructed as follows:   PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder() .printZeroAlways() .appendYears() .appendSuffix(" year", " years") .appendSeparator(" and ") .printZeroRarelyLast() .appendMonths() .appendSuffix(" month", " months") .toFormatter();   PeriodFormatterBuilder itself is mutable and not thread-safe, but the formatters that it builds are thread-safe and immutable.
org.joda.time.format.PeriodFormatterBuilder.Composite: Composite implementation that merges other fields to create a full pattern.
org.joda.time.format.PeriodFormatterBuilder.CompositeAffix: Builds a composite affix by merging two other affix implementations.
org.joda.time.format.PeriodFormatterBuilder.FieldFormatter: Formats the numeric value of a field, potentially with prefix/suffix.
org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.getFieldValue	(	ReadablePeriod	): 
org.joda.time.format.PeriodFormatterBuilder.FieldFormatter.parseInt	(	String	int	int	): 
org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix: An affix that can be ignored.
org.joda.time.format.PeriodFormatterBuilder.IgnorableAffix.matchesOtherAffix	(	int	String	int	): Checks if there is a match among the other affixes (stored internally) that is longer than the passed value (textLength).
org.joda.time.format.PeriodFormatterBuilder.Literal: Handles a simple literal piece of text.
org.joda.time.format.PeriodFormatterBuilder.PeriodFieldAffix: Defines a formatted field's prefix or suffix text. This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.
org.joda.time.format.PeriodFormatterBuilder.PeriodFieldAffix.finish	(	Set	): This method should be called only once. After first call consecutive calls to this methods will have no effect. Causes this affix to ignore a match (parse and scan methods) if there is an affix in the passed list that holds affix text which satisfy both following conditions: - the affix text is also a match - the affix text is longer than the match from this object
org.joda.time.format.PeriodFormatterBuilder.PeriodFieldAffix.getAffixes	(	): 
org.joda.time.format.PeriodFormatterBuilder.PeriodFieldAffix.parse	(	String	int	): 
org.joda.time.format.PeriodFormatterBuilder.PeriodFieldAffix.scan	(	String	int	): 
org.joda.time.format.PeriodFormatterBuilder.PluralAffix: Implements an affix where the text varies by the amount of the field. Only singular (1) and plural (not 1) are supported.
org.joda.time.format.PeriodFormatterBuilder.RegExAffix: Implements an affix where the text varies by the amount of the field. Different amounts are supported based on the provided parameters.
org.joda.time.format.PeriodFormatterBuilder.Separator: Handles a separator, that splits the fields into multiple parts. For example, the 'T' in the ISO8601 standard.
org.joda.time.format.PeriodFormatterBuilder.SimpleAffix: Implements an affix where the text does not vary by the amount.
org.joda.time.format.PeriodFormatterBuilder.append	(	PeriodFormatter	): Appends another formatter.
org.joda.time.format.PeriodFormatterBuilder.append	(	PeriodPrinter	PeriodParser	): Appends a printer parser pair.  Either the printer or the parser may be null, in which case the builder will be unable to produce a parser or printer respectively.
org.joda.time.format.PeriodFormatterBuilder.appendDays	(	): Instruct the printer to emit an integer days field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendHours	(	): Instruct the printer to emit an integer hours field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendLiteral	(	String	): Instructs the printer to emit specific text, and the parser to expect it. The parser is case-insensitive.
org.joda.time.format.PeriodFormatterBuilder.appendMillis	(	): Instruct the printer to emit an integer millis field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendMillis3Digit	(	): Instruct the printer to emit an integer millis field, if supported.  The number of parsed digits can be controlled using maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendMinutes	(	): Instruct the printer to emit an integer minutes field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendMonths	(	): Instruct the printer to emit an integer months field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendPrefix	(	PeriodFieldAffix	): Append a field prefix which applies only to the next appended field. If the field is not printed, neither is the prefix.
org.joda.time.format.PeriodFormatterBuilder.appendPrefix	(	String	): Append a field prefix which applies only to the next appended field. If the field is not printed, neither is the prefix.
org.joda.time.format.PeriodFormatterBuilder.appendPrefix	(	String	String	): Append a field prefix which applies only to the next appended field. If the field is not printed, neither is the prefix.  During parsing, the singular and plural versions are accepted whether or not the actual value matches plurality.
org.joda.time.format.PeriodFormatterBuilder.appendPrefix	(	String[]	String[]	): Append a field prefix which applies only to the next appended field. If the field is not printed, neither is the prefix.  The value is converted to String. During parsing, the prefix is selected based on the match with the regular expression. The index of the first regular expression that matches value converted to String nominates the prefix. If none of the regular expressions match the value converted to String then the last prefix is selected.  An example usage for English might look like this:  appendPrefix(new String[] { "ˆ1$", ".*" }, new String[] { " year", " years" })   Please note that for languages with simple mapping (singular and plural prefix only - like the one above) the appendPrefix() method will produce in a slightly faster formatter and that appendPrefix() method should be only used when the mapping between values and prefixes is more complicated than the difference between singular and plural.
org.joda.time.format.PeriodFormatterBuilder.appendSeconds	(	): Instruct the printer to emit an integer seconds field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendSecondsWithMillis	(	): Instruct the printer to emit a combined seconds and millis field, if supported. The millis will overflow into the seconds if necessary. The millis are always output.
org.joda.time.format.PeriodFormatterBuilder.appendSecondsWithOptionalMillis	(	): Instruct the printer to emit a combined seconds and millis field, if supported. The millis will overflow into the seconds if necessary. The millis are only output if non-zero.
org.joda.time.format.PeriodFormatterBuilder.appendSeparator	(	String	): Append a separator, which is output if fields are printed both before and after the separator.  For example, builder.appendDays().appendSeparator(",").appendHours() will only output the comma if both the days and hours fields are output.  The text will be parsed case-insensitively.  Note: appending a separator discontinues any further work on the latest appended field.
org.joda.time.format.PeriodFormatterBuilder.appendSeparator	(	String	String	): Append a separator, which is output if fields are printed both before and after the separator.  This method changes the separator depending on whether it is the last separator to be output.  For example, builder.appendDays().appendSeparator(",", "&").appendHours().appendSeparator(",", "&").appendMinutes() will output '1,2&3' if all three fields are output, '1&2' if two fields are output and '1' if just one field is output.  The text will be parsed case-insensitively.  Note: appending a separator discontinues any further work on the latest appended field.
org.joda.time.format.PeriodFormatterBuilder.appendSeparator	(	String	String	String[]	): Append a separator, which is output if fields are printed both before and after the separator.  This method changes the separator depending on whether it is the last separator to be output.  For example, builder.appendDays().appendSeparator(",", "&").appendHours().appendSeparator(",", "&").appendMinutes() will output '1,2&3' if all three fields are output, '1&2' if two fields are output and '1' if just one field is output.  The text will be parsed case-insensitively.  Note: appending a separator discontinues any further work on the latest appended field.
org.joda.time.format.PeriodFormatterBuilder.appendSeparatorIfFieldsAfter	(	String	): Append a separator, which is output only if fields are printed after the separator.  For example, builder.appendDays().appendSeparatorIfFieldsAfter(",").appendHours() will only output the comma if the hours fields is output.  The text will be parsed case-insensitively.  Note: appending a separator discontinues any further work on the latest appended field.
org.joda.time.format.PeriodFormatterBuilder.appendSeparatorIfFieldsBefore	(	String	): Append a separator, which is output only if fields are printed before the separator.  For example, builder.appendDays().appendSeparatorIfFieldsBefore(",").appendHours() will only output the comma if the days fields is output.  The text will be parsed case-insensitively.  Note: appending a separator discontinues any further work on the latest appended field.
org.joda.time.format.PeriodFormatterBuilder.appendSuffix	(	PeriodFieldAffix	): Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.
org.joda.time.format.PeriodFormatterBuilder.appendSuffix	(	String	): Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.
org.joda.time.format.PeriodFormatterBuilder.appendSuffix	(	String	String	): Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.  During parsing, the singular and plural versions are accepted whether or not the actual value matches plurality.
org.joda.time.format.PeriodFormatterBuilder.appendSuffix	(	String[]	String[]	): Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.  The value is converted to String. During parsing, the suffix is selected based on the match with the regular expression. The index of the first regular expression that matches value converted to String nominates the suffix. If none of the regular expressions match the value converted to String then the last suffix is selected.  An example usage for English might look like this:  appendSuffix(new String[] { "ˆ1$", ".*" }, new String[] { " year", " years" })   Please note that for languages with simple mapping (singular and plural suffix only - like the one above) the appendSuffix() method will result in a slightly faster formatter and that appendSuffix() method should be only used when the mapping between values and prefixes is more complicated than the difference between singular and plural.
org.joda.time.format.PeriodFormatterBuilder.appendWeeks	(	): Instruct the printer to emit an integer weeks field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.appendYears	(	): Instruct the printer to emit an integer years field, if supported.  The number of printed and parsed digits can be controlled using minimumPrintedDigits() and maximumParsedDigits().
org.joda.time.format.PeriodFormatterBuilder.clear	(	): Clears out all the appended elements, allowing this builder to be reused.
org.joda.time.format.PeriodFormatterBuilder.maximumParsedDigits	(	int	): Set the maximum digits parsed for the next and following appended fields. By default, the maximum digits parsed is ten.
org.joda.time.format.PeriodFormatterBuilder.minimumPrintedDigits	(	int	): Set the minimum digits printed for the next and following appended fields. By default, the minimum digits printed is one. If the field value is zero, it is not printed unless a printZero rule is applied.
org.joda.time.format.PeriodFormatterBuilder.printZeroAlways	(	): Always print zero values for the next and following appended fields, even if the period doesn't support it. The parser requires values for fields that always print zero.
org.joda.time.format.PeriodFormatterBuilder.printZeroIfSupported	(	): Print zero values for the next and following appended fields only if the period supports it.
org.joda.time.format.PeriodFormatterBuilder.printZeroNever	(	): Never print zero values for the next and following appended fields, unless no fields would be printed. If no fields are printed, the printer forces the last "printZeroRarely" field to print a zero.  This field setting is the default.
org.joda.time.format.PeriodFormatterBuilder.printZeroRarelyFirst	(	): Never print zero values for the next and following appended fields, unless no fields would be printed. If no fields are printed, the printer forces the first "printZeroRarely" field to print a zero.
org.joda.time.format.PeriodFormatterBuilder.printZeroRarelyLast	(	): Never print zero values for the next and following appended fields, unless no fields would be printed. If no fields are printed, the printer forces the last "printZeroRarely" field to print a zero.  This field setting is the default.
org.joda.time.format.PeriodFormatterBuilder.rejectSignedValues	(	boolean	): Reject signed values when parsing the next and following appended fields.
org.joda.time.format.PeriodFormatterBuilder.toFormatter	(	): Constructs a PeriodFormatter using all the appended elements.  This is the main method used by applications at the end of the build process to create a usable formatter.  Once this method has been called, the builder is in an invalid state.  The returned formatter may not support both printing and parsing. The methods isPrinter() and isParser() will help you determine the state of the formatter.
org.joda.time.format.PeriodFormatterBuilder.toParser	(	): Internal method to create a PeriodParser instance using all the appended elements.  Most applications will not use this method. If you want a printer in an application, call toFormatter() and just use the printing API.  Subsequent changes to this builder do not affect the returned parser.
org.joda.time.format.PeriodFormatterBuilder.toPrinter	(	): Internal method to create a PeriodPrinter instance using all the appended elements.  Most applications will not use this method. If you want a printer in an application, call toFormatter() and just use the printing API.  Subsequent changes to this builder do not affect the returned printer.
org.joda.time.format.PeriodParser: Internal interface for parsing textual representations of time periods.  Application users will rarely use this class directly. Instead, you will use one of the factory classes to create a PeriodFormatter.  The factory classes are: - PeriodFormatterBuilder - PeriodFormat - ISOPeriodFormat
org.joda.time.format.PeriodParser.parseInto	(	ReadWritablePeriod	String	int	Locale	): Parses a period from the given text, at the given position, saving the result into the fields of the given ReadWritablePeriod. If the parse succeeds, the return value is the new text position. Note that the parse may succeed without fully reading the text.  If it fails, the return value is negative, but the period may still be modified. To determine the position where the parse failed, apply the one's complement operator (~) on the return value.
org.joda.time.format.PeriodPrinter: Internal interface for printing textual representations of time periods.  Application users will rarely use this class directly. Instead, you will use one of the factory classes to create a PeriodFormatter.  The factory classes are: - PeriodFormatterBuilder - PeriodFormat - ISOPeriodFormat
org.joda.time.format.PeriodPrinter.calculatePrintedLength	(	ReadablePeriod	Locale	): Returns the exact number of characters produced for the given period.
org.joda.time.format.PeriodPrinter.countFieldsToPrint	(	ReadablePeriod	int	Locale	): Returns the amount of fields from the given period that this printer will print.
org.joda.time.format.PeriodPrinter.printTo	(	StringBuffer	ReadablePeriod	Locale	): Prints a ReadablePeriod to a StringBuffer.
org.joda.time.format.PeriodPrinter.printTo	(	Writer	ReadablePeriod	Locale	): Prints a ReadablePeriod to a Writer.
org.joda.time.format.TestAll: Entry point for all tests in this package.
org.joda.time.format.TestDateTimeFormat: This class is a Junit unit test for DateTime Formating.
org.joda.time.format.TestDateTimeFormatStyle: This class is a Junit unit test for DateTimeFormat styles.
org.joda.time.format.TestDateTimeFormatter: This class is a Junit unit test for DateTime Formating.
org.joda.time.format.TestDateTimeFormatterBuilder: This class is a Junit unit test for DateTimeFormatterBuilder.
org.joda.time.format.TestDateTimeParserBucket: Test.
org.joda.time.format.TestISODateTimeFormat: This class is a Junit unit test for ISODateTimeFormat.
org.joda.time.format.TestISODateTimeFormatParsing: This class is a Junit unit test for ISODateTimeFormat parsing.
org.joda.time.format.TestISODateTimeFormat_Fields: This class is a Junit unit test for ISODateTimeFormat.
org.joda.time.format.TestISOPeriodFormat: This class is a Junit unit test for ISOPeriodFormat.
org.joda.time.format.TestISOPeriodFormatParsing: This class is a Junit unit test for ISOPeriodFormat.
org.joda.time.format.TestPeriodFormat: This class is a Junit unit test for PeriodFormat.
org.joda.time.format.TestPeriodFormatParsing: This class is a Junit unit test for PeriodFormat.
org.joda.time.format.TestPeriodFormatter: This class is a Junit unit test for Period Formating.
org.joda.time.format.TestPeriodFormatterBuilder: This class is a Junit unit test for PeriodFormatterBuilder.
org.joda.time.format.TestTextFields: Makes sure that text fields are correct for English.
org.joda.time.tz.CachedDateTimeZone: Improves the performance of requesting time zone offsets and name keys by caching the results. Time zones that have simple rules or are fixed should not be cached, as it is unlikely to improve performance.  CachedDateTimeZone is thread-safe and immutable.
org.joda.time.tz.CachedDateTimeZone.forZone	(	DateTimeZone	): Returns a new CachedDateTimeZone unless given zone is already cached.
org.joda.time.tz.CachedDateTimeZone.getUncachedZone	(	): Returns the DateTimeZone being wrapped.
org.joda.time.tz.DateTimeZoneBuilder: DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since creating a new DateTimeZone this way is a relatively expensive operation, built zones can be written to a file. Reading back the encoded data is a quick operation.  DateTimeZoneBuilder itself is mutable and not thread-safe, but the DateTimeZone objects that it builds are thread-safe and immutable.  It is intended that ZoneInfoCompiler be used to read time zone data files, indirectly calling DateTimeZoneBuilder. The following complex example defines the America/Los_Angeles time zone, with all historical transitions:  DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder() .addCutover(-2147483648, 'w', 1, 1, 0, false, 0) .setStandardOffset(-28378000) .setFixedSavings("LMT", 0) .addCutover(1883, 'w', 11, 18, 0, false, 43200000) .setStandardOffset(-28800000) .addRecurringSavings("PDT", 3600000, 1918, 1919, 'w', 3, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1918, 1919, 'w', 10, -1, 7, false, 7200000) .addRecurringSavings("PWT", 3600000, 1942, 1942, 'w', 2, 9, 0, false, 7200000) .addRecurringSavings("PPT", 3600000, 1945, 1945, 'u', 8, 14, 0, false, 82800000) .addRecurringSavings("PST", 0, 1945, 1945, 'w', 9, 30, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1948, 1948, 'w', 3, 14, 0, false, 7200000) .addRecurringSavings("PST", 0, 1949, 1949, 'w', 1, 1, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1950, 1966, 'w', 4, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1950, 1961, 'w', 9, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1962, 1966, 'w', 10, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000) .addRecurringSavings("PDT", 3600000, 1967, 1973, 'w', 4, -1, 7, false, 7200000) .addRecurringSavings("PDT", 3600000, 1974, 1974, 'w', 1, 6, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1975, 1975, 'w', 2, 23, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1976, 1986, 'w', 4, -1, 7, false, 7200000) .addRecurringSavings("PDT", 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000) .toDateTimeZone("America/Los_Angeles", true); 
org.joda.time.tz.DateTimeZoneBuilder.OfYear: Supports setting fields of year and moving between transitions.
org.joda.time.tz.DateTimeZoneBuilder.OfYear.next	(	long	int	int	): 
org.joda.time.tz.DateTimeZoneBuilder.OfYear.previous	(	long	int	int	): 
org.joda.time.tz.DateTimeZoneBuilder.OfYear.setDayOfMonthNext	(	Chronology	long	): If month-day is 02-29 and year isn't leap, advances to next leap year.
org.joda.time.tz.DateTimeZoneBuilder.OfYear.setDayOfMonthPrevious	(	Chronology	long	): If month-day is 02-29 and year isn't leap, retreats to previous leap year.
org.joda.time.tz.DateTimeZoneBuilder.OfYear.setInstant	(	int	int	int	): 
org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.PrecalculatedZone	(	String	long[]	int[]	int[]	String[]	DSTZone	): Constructor used ONLY for valid input, loaded via static methods.
org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.create	(	String	boolean	ArrayList	DSTZone	): Factory to create instance from builder.
org.joda.time.tz.DateTimeZoneBuilder.Recurrence: Extends OfYear with a nameKey and savings.
org.joda.time.tz.DateTimeZoneBuilder.Recurrence.next	(	long	int	int	): 
org.joda.time.tz.DateTimeZoneBuilder.Recurrence.previous	(	long	int	int	): 
org.joda.time.tz.DateTimeZoneBuilder.Rule: Extends Recurrence with inclusive year limits.
org.joda.time.tz.DateTimeZoneBuilder.RuleSet.RuleSet	(	RuleSet	): Copy constructor.
org.joda.time.tz.DateTimeZoneBuilder.RuleSet.buildTailZone	(	String	): Returns null if none can be built.
org.joda.time.tz.DateTimeZoneBuilder.RuleSet.firstTransition	(	long	): Returns a transition at firstMillis with the first name key and offsets for this rule set. This method may return null.
org.joda.time.tz.DateTimeZoneBuilder.RuleSet.getUpperLimit	(	int	): 
org.joda.time.tz.DateTimeZoneBuilder.RuleSet.nextTransition	(	long	int	): Returns null if RuleSet is exhausted or upper limit reached. Calling this method will throw away rules as they each become exhausted. Copy the RuleSet before using it to compute transitions. Returned transition may be a duplicate from previous transition. Caller must call isTransitionFrom to filter out duplicates.
org.joda.time.tz.DateTimeZoneBuilder.Transition.isTransitionFrom	(	Transition	): There must be a change in the millis, wall offsets or name keys.
org.joda.time.tz.DateTimeZoneBuilder.addCutover	(	int	char	int	int	int	boolean	int	): Adds a cutover for added rules. The standard offset at the cutover defaults to 0. Call setStandardOffset afterwards to change it.
org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings	(	String	int	int	int	char	int	int	int	boolean	int	): Add a recurring daylight saving time rule.
org.joda.time.tz.DateTimeZoneBuilder.readFrom	(	DataInput	String	): Decodes a built DateTimeZone from the given stream, as encoded by writeTo.
org.joda.time.tz.DateTimeZoneBuilder.readFrom	(	InputStream	String	): Decodes a built DateTimeZone from the given stream, as encoded by writeTo.
org.joda.time.tz.DateTimeZoneBuilder.readMillis	(	DataInput	): Reads encoding generated by writeMillis.
org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings	(	String	int	): Set a fixed savings rule at the cutover.
org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset	(	int	): Sets the standard offset to use for newly added rules until the next cutover is added.
org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone	(	String	boolean	): Processes all the rules and builds a DateTimeZone.
org.joda.time.tz.DateTimeZoneBuilder.writeMillis	(	DataOutput	long	): Millisecond encoding formats: upper two bits units field length approximate range --------------------------------------------------------------- 00 30 minutes 1 byte +/- 16 hours 01 minutes 4 bytes +/- 1020 years 10 seconds 5 bytes +/- 4355 years 11 millis 9 bytes +/- 292,000,000 years Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.
org.joda.time.tz.DateTimeZoneBuilder.writeTo	(	String	DataOutput	): Encodes a built DateTimeZone to the given stream. Call readFrom to decode the data into a DateTimeZone object.
org.joda.time.tz.DateTimeZoneBuilder.writeTo	(	String	OutputStream	): Encodes a built DateTimeZone to the given stream. Call readFrom to decode the data into a DateTimeZone object.
org.joda.time.tz.DefaultNameProvider: The default name provider acquires localized names from DateFormatSymbols java.text.DateFormatSymbols.  DefaultNameProvider is thread-safe and immutable.
org.joda.time.tz.FixedDateTimeZone: Basic DateTimeZone implementation that has a fixed name key and offsets.  FixedDateTimeZone is thread-safe and immutable.
org.joda.time.tz.FixedDateTimeZone.toTimeZone	(	): Override to return the correct timezone instance.
org.joda.time.tz.NameProvider: Service provider factory for localized time zone names.
org.joda.time.tz.NameProvider.getName	(	Locale	String	String	): Returns a localized name, or null if not found.
org.joda.time.tz.NameProvider.getShortName	(	Locale	String	String	): Returns a localized short name, or null if not found.
org.joda.time.tz.Provider: Service provider factory for time zones.
org.joda.time.tz.Provider.getAvailableIDs	(	): Returns an unmodifiable set of ids. All providers must at least support id "UTC".
org.joda.time.tz.Provider.getZone	(	String	): Retrieves a DateTimeZone for the given id. All providers must at least support id "UTC".
org.joda.time.tz.TestAll: Entry point for all tests in this package.
org.joda.time.tz.TestBuilder: Test cases for DateTimeZoneBuilder.
org.joda.time.tz.TestCachedDateTimeZone: Test cases for FixedDateTimeZone.
org.joda.time.tz.TestCompiler: Test cases for ZoneInfoCompiler.
org.joda.time.tz.TestFixedDateTimeZone: Test cases for FixedDateTimeZone.
org.joda.time.tz.TestFixedDateTimeZone.getOffset	(	TimeZone	long	): Make test compile on JDK 1.3. 
org.joda.time.tz.TestUTCProvider: This class is a JUnit test for UTCProvider.
org.joda.time.tz.UTCProvider: Simple time zone provider that supports only UTC.  UTCProvider is thread-safe and immutable.
org.joda.time.tz.UTCProvider.UTCProvider	(	): Constructor.
org.joda.time.tz.UTCProvider.getAvailableIDs	(	): Returns a singleton collection containing only "UTC".
org.joda.time.tz.UTCProvider.getZone	(	String	): Returns UTC for "UTC", null otherwise.
org.joda.time.tz.ZoneInfoCompiler: Compiles IANA ZoneInfo database files into binary files for each time zone in the database. DateTimeZoneBuilder is used to construct and encode compiled data files. ZoneInfoProvider loads the encoded files and converts them back into DateTimeZone objects.  Although this tool is similar to zic, the binary formats are not compatible. The latest IANA time zone database files may be obtained here.  ZoneInfoCompiler is mutable and not thread-safe, although the main method may be safely invoked by multiple threads.
org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear.addCutover	(	DateTimeZoneBuilder	int	): Adds a cutover to the builder.
org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear.addRecurring	(	DateTimeZoneBuilder	String	int	int	int	): Adds a recurring savings rule to the builder.
org.joda.time.tz.ZoneInfoCompiler.Rule.addRecurring	(	DateTimeZoneBuilder	String	): Adds a recurring savings rule to the builder.
org.joda.time.tz.ZoneInfoCompiler.RuleSet.addRecurring	(	DateTimeZoneBuilder	String	): Adds recurring savings rules to the builder.
org.joda.time.tz.ZoneInfoCompiler.Zone.addToBuilder	(	DateTimeZoneBuilder	Map	): Adds zone info to the builder.
org.joda.time.tz.ZoneInfoCompiler.compile	(	File	File[]	): Returns a map of ids to DateTimeZones.
org.joda.time.tz.ZoneInfoCompiler.main	(	String[]	): Launches the ZoneInfoCompiler tool.  Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files> where possible options include: -src <directory> Specify where to read source files -dst <directory> Specify where to write generated files -verbose Output verbosely (default false) 
org.joda.time.tz.ZoneInfoCompiler.test	(	String	DateTimeZone	): 
org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap	(	DataOutputStream	Map	): 
org.joda.time.tz.ZoneInfoLogger: Logger for the compiler.
org.joda.time.tz.ZoneInfoLogger.verbose	(	): Gets a flag indicating that verbose logging is required.
org.joda.time.tz.ZoneInfoProvider: ZoneInfoProvider loads compiled data files as generated by ZoneInfoCompiler.  ZoneInfoProvider is thread-safe and publicly immutable.
org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider	(	): Search the default classloader resource path for compiled data files.
org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider	(	File	): ZoneInfoProvider searches the given directory for compiled data files.
org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider	(	String	): ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.
org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider	(	String	ClassLoader	): ZoneInfoProvider searches the given ClassLoader resource path for compiled data files.
org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider	(	String	ClassLoader	boolean	): 
org.joda.time.tz.ZoneInfoProvider.getAvailableIDs	(	): Gets a list of all the available zone ids.
org.joda.time.tz.ZoneInfoProvider.getZone	(	String	): If an error is thrown while loading zone data, the exception is logged to system error and null is returned for this and all future requests.
org.joda.time.tz.ZoneInfoProvider.loadZoneData	(	String	): Loads the time zone data for one id.
org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap	(	InputStream	): Loads the zone info map.
org.joda.time.tz.ZoneInfoProvider.openResource	(	String	): Opens a resource from file or classpath.
org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap	(	DataInputStream	Map	): Reads the zone info map from file.
org.joda.time.tz.ZoneInfoProvider.uncaughtException	(	Exception	): Called if an exception is thrown from getZone while loading zone data.
